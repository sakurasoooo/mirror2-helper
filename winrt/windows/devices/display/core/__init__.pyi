# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

import enum
import typing
import uuid

import winrt._winrt as _winrt
try:
    import winrt.windows.devices.display
except Exception:
    pass

try:
    import winrt.windows.foundation
except Exception:
    pass

try:
    import winrt.windows.foundation.collections
except Exception:
    pass

try:
    import winrt.windows.foundation.numerics
except Exception:
    pass

try:
    import winrt.windows.graphics
except Exception:
    pass

try:
    import winrt.windows.graphics.directx
except Exception:
    pass

try:
    import winrt.windows.graphics.directx.direct3d11
except Exception:
    pass

try:
    import winrt.windows.storage.streams
except Exception:
    pass

class DisplayBitsPerChannel(enum.IntFlag):
    NONE = 0
    BPC6 = 0x1
    BPC8 = 0x2
    BPC10 = 0x4
    BPC12 = 0x8
    BPC14 = 0x10
    BPC16 = 0x20

class DisplayDeviceCapability(enum.IntEnum):
    FLIP_OVERRIDE = 0

class DisplayManagerOptions(enum.IntFlag):
    NONE = 0
    ENFORCE_SOURCE_OWNERSHIP = 0x1
    VIRTUAL_REFRESH_RATE_AWARE = 0x2

class DisplayManagerResult(enum.IntEnum):
    SUCCESS = 0
    UNKNOWN_FAILURE = 1
    TARGET_ACCESS_DENIED = 2
    TARGET_STALE = 3
    REMOTE_SESSION_NOT_SUPPORTED = 4

class DisplayModeQueryOptions(enum.IntFlag):
    NONE = 0
    ONLY_PREFERRED_RESOLUTION = 0x1

class DisplayPathScaling(enum.IntEnum):
    IDENTITY = 0
    CENTERED = 1
    STRETCHED = 2
    ASPECT_RATIO_STRETCHED = 3
    CUSTOM = 4
    DRIVER_PREFERRED = 5

class DisplayPathStatus(enum.IntEnum):
    UNKNOWN = 0
    SUCCEEDED = 1
    PENDING = 2
    FAILED = 3
    FAILED_ASYNC = 4
    INVALIDATED_ASYNC = 5

class DisplayPresentStatus(enum.IntEnum):
    SUCCESS = 0
    SOURCE_STATUS_PREVENTED_PRESENT = 1
    SCANOUT_INVALID = 2
    SOURCE_INVALID = 3
    DEVICE_INVALID = 4
    UNKNOWN_FAILURE = 5

class DisplayRotation(enum.IntEnum):
    NONE = 0
    CLOCKWISE90_DEGREES = 1
    CLOCKWISE180_DEGREES = 2
    CLOCKWISE270_DEGREES = 3

class DisplayScanoutOptions(enum.IntFlag):
    NONE = 0
    ALLOW_TEARING = 0x2

class DisplaySourceStatus(enum.IntEnum):
    ACTIVE = 0
    POWERED_OFF = 1
    INVALID = 2
    OWNED_BY_ANOTHER_DEVICE = 3
    UNOWNED = 4

class DisplayStateApplyOptions(enum.IntFlag):
    NONE = 0
    FAIL_IF_STATE_CHANGED = 0x1
    FORCE_REAPPLY = 0x2
    FORCE_MODE_ENUMERATION = 0x4

class DisplayStateFunctionalizeOptions(enum.IntFlag):
    NONE = 0
    FAIL_IF_STATE_CHANGED = 0x1
    VALIDATE_TOPOLOGY_ONLY = 0x2

class DisplayStateOperationStatus(enum.IntEnum):
    SUCCESS = 0
    PARTIAL_FAILURE = 1
    UNKNOWN_FAILURE = 2
    TARGET_OWNERSHIP_LOST = 3
    SYSTEM_STATE_CHANGED = 4
    TOO_MANY_PATHS_FOR_ADAPTER = 5
    MODES_NOT_SUPPORTED = 6
    REMOTE_SESSION_NOT_SUPPORTED = 7

class DisplayTargetPersistence(enum.IntEnum):
    NONE = 0
    BOOT_PERSISTED = 1
    TEMPORARY_PERSISTED = 2
    PATH_PERSISTED = 3

class DisplayTaskSignalKind(enum.IntEnum):
    ON_PRESENT_FLIP_AWAY = 0
    ON_PRESENT_FLIP_TO = 1

class DisplayWireFormatColorSpace(enum.IntEnum):
    B_T709 = 0
    B_T2020 = 1
    PROFILE_DEFINED_WIDE_COLOR_GAMUT = 2

class DisplayWireFormatEotf(enum.IntEnum):
    SDR = 0
    HDR_SMPTE2084 = 1

class DisplayWireFormatHdrMetadata(enum.IntEnum):
    NONE = 0
    HDR10 = 1
    HDR10_PLUS = 2
    DOLBY_VISION_LOW_LATENCY = 3

class DisplayWireFormatPixelEncoding(enum.IntEnum):
    RGB444 = 0
    YCC444 = 1
    YCC422 = 2
    YCC420 = 3
    INTENSITY = 4

class DisplayPresentationRate(_winrt.winrt_base):
    ...

class DisplayAdapter(_winrt.winrt_base):
    ...
    device_interface_path: str
    id: winrt.windows.graphics.DisplayAdapterId
    pci_device_id: int
    pci_revision: int
    pci_sub_system_id: int
    pci_vendor_id: int
    properties: winrt.windows.foundation.collections.IMapView[uuid.UUID, _winrt.winrt_base]
    source_count: int
    def from_id(id: winrt.windows.graphics.DisplayAdapterId) -> DisplayAdapter:
        ...

class DisplayDevice(_winrt.winrt_base):
    ...
    def create_periodic_fence(target: DisplayTarget, offset_from_v_blank: winrt.windows.foundation.TimeSpan) -> DisplayFence:
        ...
    def create_primary(target: DisplayTarget, desc: DisplayPrimaryDescription) -> DisplaySurface:
        ...
    def create_scanout_source(target: DisplayTarget) -> DisplaySource:
        ...
    def create_simple_scanout(p_source: DisplaySource, p_surface: DisplaySurface, sub_resource_index: int, sync_interval: int) -> DisplayScanout:
        ...
    def create_simple_scanout_with_dirty_rects_and_options(source: DisplaySource, surface: DisplaySurface, subresource_index: int, sync_interval: int, dirty_rects: typing.Iterable[winrt.windows.graphics.RectInt32], options: DisplayScanoutOptions) -> DisplayScanout:
        ...
    def create_task_pool() -> DisplayTaskPool:
        ...
    def is_capability_supported(capability: DisplayDeviceCapability) -> bool:
        ...
    def wait_for_v_blank(source: DisplaySource) -> None:
        ...

class DisplayFence(_winrt.winrt_base):
    ...

class DisplayManager(winrt.windows.foundation.IClosable, _winrt.winrt_base):
    ...
    def close() -> None:
        ...
    def create(options: DisplayManagerOptions) -> DisplayManager:
        ...
    def create_display_device(adapter: DisplayAdapter) -> DisplayDevice:
        ...
    def get_current_adapters() -> winrt.windows.foundation.collections.IVectorView[DisplayAdapter]:
        ...
    def get_current_targets() -> winrt.windows.foundation.collections.IVectorView[DisplayTarget]:
        ...
    def release_target(target: DisplayTarget) -> None:
        ...
    def start() -> None:
        ...
    def stop() -> None:
        ...
    def try_acquire_target(target: DisplayTarget) -> DisplayManagerResult:
        ...
    def try_acquire_targets_and_create_empty_state(targets: typing.Iterable[DisplayTarget]) -> DisplayManagerResultWithState:
        ...
    def try_acquire_targets_and_create_substate(existing_state: DisplayState, targets: typing.Iterable[DisplayTarget]) -> DisplayManagerResultWithState:
        ...
    def try_acquire_targets_and_read_current_state(targets: typing.Iterable[DisplayTarget]) -> DisplayManagerResultWithState:
        ...
    def try_read_current_state_for_all_targets() -> DisplayManagerResultWithState:
        ...
    def add_changed(handler: winrt.windows.foundation.TypedEventHandler[DisplayManager, DisplayManagerChangedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_changed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_disabled(handler: winrt.windows.foundation.TypedEventHandler[DisplayManager, DisplayManagerDisabledEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_disabled(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_enabled(handler: winrt.windows.foundation.TypedEventHandler[DisplayManager, DisplayManagerEnabledEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_enabled(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_paths_failed_or_invalidated(handler: winrt.windows.foundation.TypedEventHandler[DisplayManager, DisplayManagerPathsFailedOrInvalidatedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_paths_failed_or_invalidated(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class DisplayManagerChangedEventArgs(_winrt.winrt_base):
    ...
    handled: bool
    def get_deferral() -> winrt.windows.foundation.Deferral:
        ...

class DisplayManagerDisabledEventArgs(_winrt.winrt_base):
    ...
    handled: bool
    def get_deferral() -> winrt.windows.foundation.Deferral:
        ...

class DisplayManagerEnabledEventArgs(_winrt.winrt_base):
    ...
    handled: bool
    def get_deferral() -> winrt.windows.foundation.Deferral:
        ...

class DisplayManagerPathsFailedOrInvalidatedEventArgs(_winrt.winrt_base):
    ...
    handled: bool
    def get_deferral() -> winrt.windows.foundation.Deferral:
        ...

class DisplayManagerResultWithState(_winrt.winrt_base):
    ...
    error_code: DisplayManagerResult
    extended_error_code: winrt.windows.foundation.HResult
    state: DisplayState

class DisplayModeInfo(_winrt.winrt_base):
    ...
    is_interlaced: bool
    is_stereo: bool
    presentation_rate: DisplayPresentationRate
    properties: winrt.windows.foundation.collections.IMapView[uuid.UUID, _winrt.winrt_base]
    source_pixel_format: winrt.windows.graphics.directx.DirectXPixelFormat
    source_resolution: winrt.windows.graphics.SizeInt32
    target_resolution: winrt.windows.graphics.SizeInt32
    physical_presentation_rate: DisplayPresentationRate
    def get_wire_format_supported_bits_per_channel(encoding: DisplayWireFormatPixelEncoding) -> DisplayBitsPerChannel:
        ...
    def is_wire_format_supported(wire_format: DisplayWireFormat) -> bool:
        ...

class DisplayPath(_winrt.winrt_base):
    ...
    wire_format: DisplayWireFormat
    target_resolution: typing.Optional[winrt.windows.graphics.SizeInt32]
    source_resolution: typing.Optional[winrt.windows.graphics.SizeInt32]
    source_pixel_format: winrt.windows.graphics.directx.DirectXPixelFormat
    scaling: DisplayPathScaling
    rotation: DisplayRotation
    presentation_rate: typing.Optional[DisplayPresentationRate]
    is_stereo: bool
    is_interlaced: typing.Optional[bool]
    properties: winrt.windows.foundation.collections.IMap[uuid.UUID, _winrt.winrt_base]
    status: DisplayPathStatus
    target: DisplayTarget
    view: DisplayView
    physical_presentation_rate: typing.Optional[DisplayPresentationRate]
    def apply_properties_from_mode(mode_result: DisplayModeInfo) -> None:
        ...
    def find_modes(flags: DisplayModeQueryOptions) -> winrt.windows.foundation.collections.IVectorView[DisplayModeInfo]:
        ...

class DisplayPrimaryDescription(_winrt.winrt_base):
    ...
    color_space: winrt.windows.graphics.directx.DirectXColorSpace
    format: winrt.windows.graphics.directx.DirectXPixelFormat
    height: int
    is_stereo: bool
    multisample_description: winrt.windows.graphics.directx.direct3d11.Direct3DMultisampleDescription
    properties: winrt.windows.foundation.collections.IMapView[uuid.UUID, _winrt.winrt_base]
    width: int
    def create_with_properties(extra_properties: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[uuid.UUID, _winrt.winrt_base]], width: int, height: int, pixel_format: winrt.windows.graphics.directx.DirectXPixelFormat, color_space: winrt.windows.graphics.directx.DirectXColorSpace, is_stereo: bool, multisample_description: winrt.windows.graphics.directx.direct3d11.Direct3DMultisampleDescription) -> DisplayPrimaryDescription:
        ...

class DisplayScanout(_winrt.winrt_base):
    ...

class DisplaySource(_winrt.winrt_base):
    ...
    adapter_id: winrt.windows.graphics.DisplayAdapterId
    source_id: int
    status: DisplaySourceStatus
    def get_metadata(key: uuid.UUID) -> winrt.windows.storage.streams.IBuffer:
        ...
    def add_status_changed(handler: winrt.windows.foundation.TypedEventHandler[DisplaySource, _winrt.winrt_base]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_status_changed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class DisplayState(_winrt.winrt_base):
    ...
    is_read_only: bool
    is_stale: bool
    properties: winrt.windows.foundation.collections.IMap[uuid.UUID, _winrt.winrt_base]
    targets: winrt.windows.foundation.collections.IVectorView[DisplayTarget]
    views: winrt.windows.foundation.collections.IVectorView[DisplayView]
    def can_connect_target_to_view(target: DisplayTarget, view: DisplayView) -> bool:
        ...
    def clone() -> DisplayState:
        ...
    def connect_target(target: DisplayTarget) -> DisplayPath:
        ...
    def connect_target(target: DisplayTarget, view: DisplayView) -> DisplayPath:
        ...
    def disconnect_target(target: DisplayTarget) -> None:
        ...
    def get_path_for_target(target: DisplayTarget) -> DisplayPath:
        ...
    def get_view_for_target(target: DisplayTarget) -> DisplayView:
        ...
    def try_apply(options: DisplayStateApplyOptions) -> DisplayStateOperationResult:
        ...
    def try_functionalize(options: DisplayStateFunctionalizeOptions) -> DisplayStateOperationResult:
        ...

class DisplayStateOperationResult(_winrt.winrt_base):
    ...
    extended_error_code: winrt.windows.foundation.HResult
    status: DisplayStateOperationStatus

class DisplaySurface(_winrt.winrt_base):
    ...

class DisplayTarget(_winrt.winrt_base):
    ...
    adapter: DisplayAdapter
    adapter_relative_id: int
    device_interface_path: str
    is_connected: bool
    is_stale: bool
    is_virtual_mode_enabled: bool
    is_virtual_topology_enabled: bool
    monitor_persistence: DisplayTargetPersistence
    properties: winrt.windows.foundation.collections.IMapView[uuid.UUID, _winrt.winrt_base]
    stable_monitor_id: str
    usage_kind: winrt.windows.devices.display.DisplayMonitorUsageKind
    def is_equal(other_target: DisplayTarget) -> bool:
        ...
    def is_same(other_target: DisplayTarget) -> bool:
        ...
    def try_get_monitor() -> winrt.windows.devices.display.DisplayMonitor:
        ...

class DisplayTask(_winrt.winrt_base):
    ...
    def set_scanout(scanout: DisplayScanout) -> None:
        ...
    def set_signal(signal_kind: DisplayTaskSignalKind, fence: DisplayFence) -> None:
        ...
    def set_wait(ready_fence: DisplayFence, ready_fence_value: int) -> None:
        ...

class DisplayTaskPool(_winrt.winrt_base):
    ...
    def create_task() -> DisplayTask:
        ...
    def execute_task(task: DisplayTask) -> None:
        ...
    def try_execute_task(task: DisplayTask) -> DisplayTaskResult:
        ...

class DisplayTaskResult(_winrt.winrt_base):
    ...
    present_id: int
    present_status: DisplayPresentStatus
    source_status: DisplaySourceStatus

class DisplayView(_winrt.winrt_base):
    ...
    content_resolution: typing.Optional[winrt.windows.graphics.SizeInt32]
    paths: winrt.windows.foundation.collections.IVectorView[DisplayPath]
    properties: winrt.windows.foundation.collections.IMap[uuid.UUID, _winrt.winrt_base]
    def set_primary_path(path: DisplayPath) -> None:
        ...

class DisplayWireFormat(_winrt.winrt_base):
    ...
    bits_per_channel: int
    color_space: DisplayWireFormatColorSpace
    eotf: DisplayWireFormatEotf
    hdr_metadata: DisplayWireFormatHdrMetadata
    pixel_encoding: DisplayWireFormatPixelEncoding
    properties: winrt.windows.foundation.collections.IMapView[uuid.UUID, _winrt.winrt_base]
    def create_with_properties(extra_properties: typing.Iterable[winrt.windows.foundation.collections.IKeyValuePair[uuid.UUID, _winrt.winrt_base]], pixel_encoding: DisplayWireFormatPixelEncoding, bits_per_channel: int, color_space: DisplayWireFormatColorSpace, eotf: DisplayWireFormatEotf, hdr_metadata: DisplayWireFormatHdrMetadata) -> DisplayWireFormat:
        ...

