# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

import enum
import typing
import uuid

import winrt._winrt as _winrt
try:
    import winrt.windows.foundation
except Exception:
    pass

try:
    import winrt.windows.storage.streams
except Exception:
    pass

class DeviceAccessMode(enum.IntEnum):
    READ = 0
    WRITE = 1
    READ_WRITE = 2

class DeviceSharingMode(enum.IntEnum):
    SHARED = 0
    EXCLUSIVE = 1

class IOControlAccessMode(enum.IntEnum):
    ANY = 0
    READ = 1
    WRITE = 2
    READ_WRITE = 3

class IOControlBufferingMethod(enum.IntEnum):
    BUFFERED = 0
    DIRECT_INPUT = 1
    DIRECT_OUTPUT = 2
    NEITHER = 3

class CustomDevice(_winrt.winrt_base):
    ...
    input_stream: winrt.windows.storage.streams.IInputStream
    output_stream: winrt.windows.storage.streams.IOutputStream
    def from_id_async(device_id: str, desired_access: DeviceAccessMode, sharing_mode: DeviceSharingMode) -> winrt.windows.foundation.IAsyncOperation[CustomDevice]:
        ...
    def get_device_selector(class_guid: uuid.UUID) -> str:
        ...
    def send_i_o_control_async(io_control_code: IIOControlCode, input_buffer: winrt.windows.storage.streams.IBuffer, output_buffer: winrt.windows.storage.streams.IBuffer) -> winrt.windows.foundation.IAsyncOperation[int]:
        ...
    def try_send_i_o_control_async(io_control_code: IIOControlCode, input_buffer: winrt.windows.storage.streams.IBuffer, output_buffer: winrt.windows.storage.streams.IBuffer) -> winrt.windows.foundation.IAsyncOperation[bool]:
        ...

class IOControlCode(IIOControlCode, _winrt.winrt_base):
    ...
    access_mode: IOControlAccessMode
    buffering_method: IOControlBufferingMethod
    control_code: int
    device_type: int
    function: int

class KnownDeviceTypes(_winrt.winrt_base):
    ...
    unknown: int

class IIOControlCode(_winrt.winrt_base):
    ...
    access_mode: IOControlAccessMode
    buffering_method: IOControlBufferingMethod
    control_code: int
    device_type: int
    function: int

