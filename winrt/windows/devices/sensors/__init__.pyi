# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

import enum
import typing
import uuid

import winrt._winrt as _winrt
try:
    import winrt.windows.foundation
except Exception:
    pass

try:
    import winrt.windows.foundation.collections
except Exception:
    pass

try:
    import winrt.windows.graphics.display
except Exception:
    pass

class AccelerometerReadingType(enum.IntEnum):
    STANDARD = 0
    LINEAR = 1
    GRAVITY = 2

class ActivitySensorReadingConfidence(enum.IntEnum):
    HIGH = 0
    LOW = 1

class ActivityType(enum.IntEnum):
    UNKNOWN = 0
    IDLE = 1
    STATIONARY = 2
    FIDGETING = 3
    WALKING = 4
    RUNNING = 5
    IN_VEHICLE = 6
    BIKING = 7

class MagnetometerAccuracy(enum.IntEnum):
    UNKNOWN = 0
    UNRELIABLE = 1
    APPROXIMATE = 2
    HIGH = 3

class PedometerStepKind(enum.IntEnum):
    UNKNOWN = 0
    WALKING = 1
    RUNNING = 2

class SensorOptimizationGoal(enum.IntEnum):
    PRECISION = 0
    POWER_EFFICIENCY = 1

class SensorReadingType(enum.IntEnum):
    ABSOLUTE = 0
    RELATIVE = 1

class SensorType(enum.IntEnum):
    ACCELEROMETER = 0
    ACTIVITY_SENSOR = 1
    BAROMETER = 2
    COMPASS = 3
    CUSTOM_SENSOR = 4
    GYROSCOPE = 5
    PROXIMITY_SENSOR = 6
    INCLINOMETER = 7
    LIGHT_SENSOR = 8
    ORIENTATION_SENSOR = 9
    PEDOMETER = 10
    RELATIVE_INCLINOMETER = 11
    RELATIVE_ORIENTATION_SENSOR = 12
    SIMPLE_ORIENTATION_SENSOR = 13

class SimpleOrientation(enum.IntEnum):
    NOT_ROTATED = 0
    ROTATED90_DEGREES_COUNTERCLOCKWISE = 1
    ROTATED180_DEGREES_COUNTERCLOCKWISE = 2
    ROTATED270_DEGREES_COUNTERCLOCKWISE = 3
    FACEUP = 4
    FACEDOWN = 5

class Accelerometer(_winrt.winrt_base):
    ...
    report_interval: int
    minimum_report_interval: int
    reading_transform: winrt.windows.graphics.display.DisplayOrientations
    report_latency: int
    max_batch_size: int
    reading_type: AccelerometerReadingType
    report_threshold: AccelerometerDataThreshold
    device_id: str
    def from_id_async(device_id: str) -> winrt.windows.foundation.IAsyncOperation[Accelerometer]:
        ...
    def get_current_reading() -> AccelerometerReading:
        ...
    def get_default() -> Accelerometer:
        ...
    def get_default(reading_type: AccelerometerReadingType) -> Accelerometer:
        ...
    def get_device_selector(reading_type: AccelerometerReadingType) -> str:
        ...
    def add_reading_changed(handler: winrt.windows.foundation.TypedEventHandler[Accelerometer, AccelerometerReadingChangedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_reading_changed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_shaken(handler: winrt.windows.foundation.TypedEventHandler[Accelerometer, AccelerometerShakenEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_shaken(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class AccelerometerDataThreshold(_winrt.winrt_base):
    ...
    z_axis_in_g_force: float
    y_axis_in_g_force: float
    x_axis_in_g_force: float

class AccelerometerReading(_winrt.winrt_base):
    ...
    acceleration_x: float
    acceleration_y: float
    acceleration_z: float
    timestamp: winrt.windows.foundation.DateTime
    performance_count: typing.Optional[winrt.windows.foundation.TimeSpan]
    properties: winrt.windows.foundation.collections.IMapView[str, _winrt.winrt_base]

class AccelerometerReadingChangedEventArgs(_winrt.winrt_base):
    ...
    reading: AccelerometerReading

class AccelerometerShakenEventArgs(_winrt.winrt_base):
    ...
    timestamp: winrt.windows.foundation.DateTime

class ActivitySensor(_winrt.winrt_base):
    ...
    device_id: str
    minimum_report_interval: int
    power_in_milliwatts: float
    subscribed_activities: winrt.windows.foundation.collections.IVector[ActivityType]
    supported_activities: winrt.windows.foundation.collections.IVectorView[ActivityType]
    def from_id_async(device_id: str) -> winrt.windows.foundation.IAsyncOperation[ActivitySensor]:
        ...
    def get_current_reading_async() -> winrt.windows.foundation.IAsyncOperation[ActivitySensorReading]:
        ...
    def get_default_async() -> winrt.windows.foundation.IAsyncOperation[ActivitySensor]:
        ...
    def get_device_selector() -> str:
        ...
    def get_system_history_async(from_time: winrt.windows.foundation.DateTime) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ActivitySensorReading]]:
        ...
    def get_system_history_async(from_time: winrt.windows.foundation.DateTime, duration: winrt.windows.foundation.TimeSpan) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ActivitySensorReading]]:
        ...
    def add_reading_changed(handler: winrt.windows.foundation.TypedEventHandler[ActivitySensor, ActivitySensorReadingChangedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_reading_changed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class ActivitySensorReading(_winrt.winrt_base):
    ...
    activity: ActivityType
    confidence: ActivitySensorReadingConfidence
    timestamp: winrt.windows.foundation.DateTime

class ActivitySensorReadingChangeReport(_winrt.winrt_base):
    ...
    reading: ActivitySensorReading

class ActivitySensorReadingChangedEventArgs(_winrt.winrt_base):
    ...
    reading: ActivitySensorReading

class ActivitySensorTriggerDetails(_winrt.winrt_base):
    ...
    def read_reports() -> winrt.windows.foundation.collections.IVectorView[ActivitySensorReadingChangeReport]:
        ...

class Altimeter(_winrt.winrt_base):
    ...
    report_interval: int
    device_id: str
    minimum_report_interval: int
    report_latency: int
    max_batch_size: int
    def get_current_reading() -> AltimeterReading:
        ...
    def get_default() -> Altimeter:
        ...
    def add_reading_changed(handler: winrt.windows.foundation.TypedEventHandler[Altimeter, AltimeterReadingChangedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_reading_changed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class AltimeterReading(_winrt.winrt_base):
    ...
    altitude_change_in_meters: float
    timestamp: winrt.windows.foundation.DateTime
    performance_count: typing.Optional[winrt.windows.foundation.TimeSpan]
    properties: winrt.windows.foundation.collections.IMapView[str, _winrt.winrt_base]

class AltimeterReadingChangedEventArgs(_winrt.winrt_base):
    ...
    reading: AltimeterReading

class Barometer(_winrt.winrt_base):
    ...
    report_interval: int
    device_id: str
    minimum_report_interval: int
    report_latency: int
    max_batch_size: int
    report_threshold: BarometerDataThreshold
    def from_id_async(device_id: str) -> winrt.windows.foundation.IAsyncOperation[Barometer]:
        ...
    def get_current_reading() -> BarometerReading:
        ...
    def get_default() -> Barometer:
        ...
    def get_device_selector() -> str:
        ...
    def add_reading_changed(handler: winrt.windows.foundation.TypedEventHandler[Barometer, BarometerReadingChangedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_reading_changed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class BarometerDataThreshold(_winrt.winrt_base):
    ...
    hectopascals: float

class BarometerReading(_winrt.winrt_base):
    ...
    station_pressure_in_hectopascals: float
    timestamp: winrt.windows.foundation.DateTime
    performance_count: typing.Optional[winrt.windows.foundation.TimeSpan]
    properties: winrt.windows.foundation.collections.IMapView[str, _winrt.winrt_base]

class BarometerReadingChangedEventArgs(_winrt.winrt_base):
    ...
    reading: BarometerReading

class Compass(_winrt.winrt_base):
    ...
    report_interval: int
    minimum_report_interval: int
    reading_transform: winrt.windows.graphics.display.DisplayOrientations
    report_latency: int
    max_batch_size: int
    report_threshold: CompassDataThreshold
    device_id: str
    def from_id_async(device_id: str) -> winrt.windows.foundation.IAsyncOperation[Compass]:
        ...
    def get_current_reading() -> CompassReading:
        ...
    def get_default() -> Compass:
        ...
    def get_device_selector() -> str:
        ...
    def add_reading_changed(handler: winrt.windows.foundation.TypedEventHandler[Compass, CompassReadingChangedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_reading_changed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class CompassDataThreshold(_winrt.winrt_base):
    ...
    degrees: float

class CompassReading(_winrt.winrt_base):
    ...
    heading_magnetic_north: float
    heading_true_north: typing.Optional[float]
    timestamp: winrt.windows.foundation.DateTime
    performance_count: typing.Optional[winrt.windows.foundation.TimeSpan]
    properties: winrt.windows.foundation.collections.IMapView[str, _winrt.winrt_base]
    heading_accuracy: MagnetometerAccuracy

class CompassReadingChangedEventArgs(_winrt.winrt_base):
    ...
    reading: CompassReading

class Gyrometer(_winrt.winrt_base):
    ...
    report_interval: int
    minimum_report_interval: int
    reading_transform: winrt.windows.graphics.display.DisplayOrientations
    report_latency: int
    max_batch_size: int
    report_threshold: GyrometerDataThreshold
    device_id: str
    def from_id_async(device_id: str) -> winrt.windows.foundation.IAsyncOperation[Gyrometer]:
        ...
    def get_current_reading() -> GyrometerReading:
        ...
    def get_default() -> Gyrometer:
        ...
    def get_device_selector() -> str:
        ...
    def add_reading_changed(handler: winrt.windows.foundation.TypedEventHandler[Gyrometer, GyrometerReadingChangedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_reading_changed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class GyrometerDataThreshold(_winrt.winrt_base):
    ...
    z_axis_in_degrees_per_second: float
    y_axis_in_degrees_per_second: float
    x_axis_in_degrees_per_second: float

class GyrometerReading(_winrt.winrt_base):
    ...
    angular_velocity_x: float
    angular_velocity_y: float
    angular_velocity_z: float
    timestamp: winrt.windows.foundation.DateTime
    performance_count: typing.Optional[winrt.windows.foundation.TimeSpan]
    properties: winrt.windows.foundation.collections.IMapView[str, _winrt.winrt_base]

class GyrometerReadingChangedEventArgs(_winrt.winrt_base):
    ...
    reading: GyrometerReading

class HingeAngleReading(_winrt.winrt_base):
    ...
    angle_in_degrees: float
    properties: winrt.windows.foundation.collections.IMapView[str, _winrt.winrt_base]
    timestamp: winrt.windows.foundation.DateTime

class HingeAngleSensor(_winrt.winrt_base):
    ...
    report_threshold_in_degrees: float
    device_id: str
    min_report_threshold_in_degrees: float
    def from_id_async(device_id: str) -> winrt.windows.foundation.IAsyncOperation[HingeAngleSensor]:
        ...
    def get_current_reading_async() -> winrt.windows.foundation.IAsyncOperation[HingeAngleReading]:
        ...
    def get_default_async() -> winrt.windows.foundation.IAsyncOperation[HingeAngleSensor]:
        ...
    def get_device_selector() -> str:
        ...
    def get_related_to_adjacent_panels_async(first_panel_id: str, second_panel_id: str) -> winrt.windows.foundation.IAsyncOperation[HingeAngleSensor]:
        ...
    def add_reading_changed(handler: winrt.windows.foundation.TypedEventHandler[HingeAngleSensor, HingeAngleSensorReadingChangedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_reading_changed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class HingeAngleSensorReadingChangedEventArgs(_winrt.winrt_base):
    ...
    reading: HingeAngleReading

class Inclinometer(_winrt.winrt_base):
    ...
    report_interval: int
    minimum_report_interval: int
    reading_transform: winrt.windows.graphics.display.DisplayOrientations
    reading_type: SensorReadingType
    report_latency: int
    max_batch_size: int
    report_threshold: InclinometerDataThreshold
    device_id: str
    def from_id_async(device_id: str) -> winrt.windows.foundation.IAsyncOperation[Inclinometer]:
        ...
    def get_current_reading() -> InclinometerReading:
        ...
    def get_default() -> Inclinometer:
        ...
    def get_default(sensor_readingtype: SensorReadingType) -> Inclinometer:
        ...
    def get_default_for_relative_readings() -> Inclinometer:
        ...
    def get_device_selector(reading_type: SensorReadingType) -> str:
        ...
    def add_reading_changed(handler: winrt.windows.foundation.TypedEventHandler[Inclinometer, InclinometerReadingChangedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_reading_changed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class InclinometerDataThreshold(_winrt.winrt_base):
    ...
    yaw_in_degrees: float
    roll_in_degrees: float
    pitch_in_degrees: float

class InclinometerReading(_winrt.winrt_base):
    ...
    pitch_degrees: float
    roll_degrees: float
    timestamp: winrt.windows.foundation.DateTime
    yaw_degrees: float
    performance_count: typing.Optional[winrt.windows.foundation.TimeSpan]
    properties: winrt.windows.foundation.collections.IMapView[str, _winrt.winrt_base]
    yaw_accuracy: MagnetometerAccuracy

class InclinometerReadingChangedEventArgs(_winrt.winrt_base):
    ...
    reading: InclinometerReading

class LightSensor(_winrt.winrt_base):
    ...
    report_interval: int
    minimum_report_interval: int
    report_latency: int
    max_batch_size: int
    report_threshold: LightSensorDataThreshold
    device_id: str
    def from_id_async(device_id: str) -> winrt.windows.foundation.IAsyncOperation[LightSensor]:
        ...
    def get_current_reading() -> LightSensorReading:
        ...
    def get_default() -> LightSensor:
        ...
    def get_device_selector() -> str:
        ...
    def add_reading_changed(handler: winrt.windows.foundation.TypedEventHandler[LightSensor, LightSensorReadingChangedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_reading_changed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class LightSensorDataThreshold(_winrt.winrt_base):
    ...
    lux_percentage: float
    absolute_lux: float

class LightSensorReading(_winrt.winrt_base):
    ...
    illuminance_in_lux: float
    timestamp: winrt.windows.foundation.DateTime
    performance_count: typing.Optional[winrt.windows.foundation.TimeSpan]
    properties: winrt.windows.foundation.collections.IMapView[str, _winrt.winrt_base]

class LightSensorReadingChangedEventArgs(_winrt.winrt_base):
    ...
    reading: LightSensorReading

class Magnetometer(_winrt.winrt_base):
    ...
    report_interval: int
    minimum_report_interval: int
    reading_transform: winrt.windows.graphics.display.DisplayOrientations
    report_latency: int
    max_batch_size: int
    report_threshold: MagnetometerDataThreshold
    device_id: str
    def from_id_async(device_id: str) -> winrt.windows.foundation.IAsyncOperation[Magnetometer]:
        ...
    def get_current_reading() -> MagnetometerReading:
        ...
    def get_default() -> Magnetometer:
        ...
    def get_device_selector() -> str:
        ...
    def add_reading_changed(handler: winrt.windows.foundation.TypedEventHandler[Magnetometer, MagnetometerReadingChangedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_reading_changed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class MagnetometerDataThreshold(_winrt.winrt_base):
    ...
    z_axis_microteslas: float
    y_axis_microteslas: float
    x_axis_microteslas: float

class MagnetometerReading(_winrt.winrt_base):
    ...
    directional_accuracy: MagnetometerAccuracy
    magnetic_field_x: float
    magnetic_field_y: float
    magnetic_field_z: float
    timestamp: winrt.windows.foundation.DateTime
    performance_count: typing.Optional[winrt.windows.foundation.TimeSpan]
    properties: winrt.windows.foundation.collections.IMapView[str, _winrt.winrt_base]

class MagnetometerReadingChangedEventArgs(_winrt.winrt_base):
    ...
    reading: MagnetometerReading

class OrientationSensor(_winrt.winrt_base):
    ...
    report_interval: int
    minimum_report_interval: int
    reading_transform: winrt.windows.graphics.display.DisplayOrientations
    reading_type: SensorReadingType
    report_latency: int
    max_batch_size: int
    device_id: str
    def from_id_async(device_id: str) -> winrt.windows.foundation.IAsyncOperation[OrientationSensor]:
        ...
    def get_current_reading() -> OrientationSensorReading:
        ...
    def get_default() -> OrientationSensor:
        ...
    def get_default(sensor_readingtype: SensorReadingType) -> OrientationSensor:
        ...
    def get_default(sensor_reading_type: SensorReadingType, optimization_goal: SensorOptimizationGoal) -> OrientationSensor:
        ...
    def get_default_for_relative_readings() -> OrientationSensor:
        ...
    def get_device_selector(reading_type: SensorReadingType) -> str:
        ...
    def get_device_selector(reading_type: SensorReadingType, optimization_goal: SensorOptimizationGoal) -> str:
        ...
    def add_reading_changed(handler: winrt.windows.foundation.TypedEventHandler[OrientationSensor, OrientationSensorReadingChangedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_reading_changed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class OrientationSensorReading(_winrt.winrt_base):
    ...
    quaternion: SensorQuaternion
    rotation_matrix: SensorRotationMatrix
    timestamp: winrt.windows.foundation.DateTime
    performance_count: typing.Optional[winrt.windows.foundation.TimeSpan]
    properties: winrt.windows.foundation.collections.IMapView[str, _winrt.winrt_base]
    yaw_accuracy: MagnetometerAccuracy

class OrientationSensorReadingChangedEventArgs(_winrt.winrt_base):
    ...
    reading: OrientationSensorReading

class Pedometer(_winrt.winrt_base):
    ...
    report_interval: int
    device_id: str
    minimum_report_interval: int
    power_in_milliwatts: float
    def from_id_async(device_id: str) -> winrt.windows.foundation.IAsyncOperation[Pedometer]:
        ...
    def get_current_readings() -> winrt.windows.foundation.collections.IMapView[PedometerStepKind, PedometerReading]:
        ...
    def get_default_async() -> winrt.windows.foundation.IAsyncOperation[Pedometer]:
        ...
    def get_device_selector() -> str:
        ...
    def get_readings_from_trigger_details(trigger_details: SensorDataThresholdTriggerDetails) -> winrt.windows.foundation.collections.IVectorView[PedometerReading]:
        ...
    def get_system_history_async(from_time: winrt.windows.foundation.DateTime) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[PedometerReading]]:
        ...
    def get_system_history_async(from_time: winrt.windows.foundation.DateTime, duration: winrt.windows.foundation.TimeSpan) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[PedometerReading]]:
        ...
    def add_reading_changed(handler: winrt.windows.foundation.TypedEventHandler[Pedometer, PedometerReadingChangedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_reading_changed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class PedometerDataThreshold(ISensorDataThreshold, _winrt.winrt_base):
    ...

class PedometerReading(_winrt.winrt_base):
    ...
    cumulative_steps: int
    cumulative_steps_duration: winrt.windows.foundation.TimeSpan
    step_kind: PedometerStepKind
    timestamp: winrt.windows.foundation.DateTime

class PedometerReadingChangedEventArgs(_winrt.winrt_base):
    ...
    reading: PedometerReading

class ProximitySensor(_winrt.winrt_base):
    ...
    device_id: str
    max_distance_in_millimeters: typing.Optional[int]
    min_distance_in_millimeters: typing.Optional[int]
    def create_display_on_off_controller() -> ProximitySensorDisplayOnOffController:
        ...
    def from_id(sensor_id: str) -> ProximitySensor:
        ...
    def get_current_reading() -> ProximitySensorReading:
        ...
    def get_device_selector() -> str:
        ...
    def get_readings_from_trigger_details(trigger_details: SensorDataThresholdTriggerDetails) -> winrt.windows.foundation.collections.IVectorView[ProximitySensorReading]:
        ...
    def add_reading_changed(handler: winrt.windows.foundation.TypedEventHandler[ProximitySensor, ProximitySensorReadingChangedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_reading_changed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class ProximitySensorDataThreshold(ISensorDataThreshold, _winrt.winrt_base):
    ...

class ProximitySensorDisplayOnOffController(winrt.windows.foundation.IClosable, _winrt.winrt_base):
    ...
    def close() -> None:
        ...

class ProximitySensorReading(_winrt.winrt_base):
    ...
    distance_in_millimeters: typing.Optional[int]
    is_detected: bool
    timestamp: winrt.windows.foundation.DateTime

class ProximitySensorReadingChangedEventArgs(_winrt.winrt_base):
    ...
    reading: ProximitySensorReading

class SensorDataThresholdTriggerDetails(_winrt.winrt_base):
    ...
    device_id: str
    sensor_type: SensorType

class SensorQuaternion(_winrt.winrt_base):
    ...
    w: float
    x: float
    y: float
    z: float

class SensorRotationMatrix(_winrt.winrt_base):
    ...
    m11: float
    m12: float
    m13: float
    m21: float
    m22: float
    m23: float
    m31: float
    m32: float
    m33: float

class SimpleOrientationSensor(_winrt.winrt_base):
    ...
    reading_transform: winrt.windows.graphics.display.DisplayOrientations
    device_id: str
    def from_id_async(device_id: str) -> winrt.windows.foundation.IAsyncOperation[SimpleOrientationSensor]:
        ...
    def get_current_orientation() -> SimpleOrientation:
        ...
    def get_default() -> SimpleOrientationSensor:
        ...
    def get_device_selector() -> str:
        ...
    def add_orientation_changed(handler: winrt.windows.foundation.TypedEventHandler[SimpleOrientationSensor, SimpleOrientationSensorOrientationChangedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_orientation_changed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class SimpleOrientationSensorOrientationChangedEventArgs(_winrt.winrt_base):
    ...
    orientation: SimpleOrientation
    timestamp: winrt.windows.foundation.DateTime

class ISensorDataThreshold(_winrt.winrt_base):
    ...

