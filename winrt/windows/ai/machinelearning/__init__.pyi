# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

import enum
import typing
import uuid

import winrt._winrt as _winrt
try:
    import winrt.windows.foundation
except Exception:
    pass

try:
    import winrt.windows.foundation.collections
except Exception:
    pass

try:
    import winrt.windows.graphics
except Exception:
    pass

try:
    import winrt.windows.graphics.directx.direct3d11
except Exception:
    pass

try:
    import winrt.windows.graphics.imaging
except Exception:
    pass

try:
    import winrt.windows.media
except Exception:
    pass

try:
    import winrt.windows.storage
except Exception:
    pass

try:
    import winrt.windows.storage.streams
except Exception:
    pass

class LearningModelDeviceKind(enum.IntEnum):
    DEFAULT = 0
    CPU = 1
    DIRECT_X = 2
    DIRECT_X_HIGH_PERFORMANCE = 3
    DIRECT_X_MIN_POWER = 4

class LearningModelFeatureKind(enum.IntEnum):
    TENSOR = 0
    SEQUENCE = 1
    MAP = 2
    IMAGE = 3

class LearningModelPixelRange(enum.IntEnum):
    ZERO_TO255 = 0
    ZERO_TO_ONE = 1
    MINUS_ONE_TO_ONE = 2

class TensorKind(enum.IntEnum):
    UNDEFINED = 0
    FLOAT = 1
    UINT8 = 2
    INT8 = 3
    UINT16 = 4
    INT16 = 5
    INT32 = 6
    INT64 = 7
    STRING = 8
    BOOLEAN = 9
    FLOAT16 = 10
    DOUBLE = 11
    UINT32 = 12
    UINT64 = 13
    COMPLEX64 = 14
    COMPLEX128 = 15

class ImageFeatureDescriptor(ILearningModelFeatureDescriptor, _winrt.winrt_base):
    ...
    bitmap_alpha_mode: winrt.windows.graphics.imaging.BitmapAlphaMode
    bitmap_pixel_format: winrt.windows.graphics.imaging.BitmapPixelFormat
    height: int
    width: int
    pixel_range: LearningModelPixelRange
    description: str
    is_required: bool
    kind: LearningModelFeatureKind
    name: str

class ImageFeatureValue(ILearningModelFeatureValue, _winrt.winrt_base):
    ...
    video_frame: winrt.windows.media.VideoFrame
    kind: LearningModelFeatureKind
    def create_from_video_frame(image: winrt.windows.media.VideoFrame) -> ImageFeatureValue:
        ...

class LearningModel(winrt.windows.foundation.IClosable, _winrt.winrt_base):
    ...
    author: str
    description: str
    domain: str
    input_features: winrt.windows.foundation.collections.IVectorView[ILearningModelFeatureDescriptor]
    metadata: winrt.windows.foundation.collections.IMapView[str, str]
    name: str
    output_features: winrt.windows.foundation.collections.IVectorView[ILearningModelFeatureDescriptor]
    version: int
    def close() -> None:
        ...
    def load_from_file_path(file_path: str) -> LearningModel:
        ...
    def load_from_file_path(file_path: str, operator_provider: ILearningModelOperatorProvider) -> LearningModel:
        ...
    def load_from_storage_file_async(model_file: winrt.windows.storage.IStorageFile) -> winrt.windows.foundation.IAsyncOperation[LearningModel]:
        ...
    def load_from_storage_file_async(model_file: winrt.windows.storage.IStorageFile, operator_provider: ILearningModelOperatorProvider) -> winrt.windows.foundation.IAsyncOperation[LearningModel]:
        ...
    def load_from_stream(model_stream: winrt.windows.storage.streams.IRandomAccessStreamReference) -> LearningModel:
        ...
    def load_from_stream(model_stream: winrt.windows.storage.streams.IRandomAccessStreamReference, operator_provider: ILearningModelOperatorProvider) -> LearningModel:
        ...
    def load_from_stream_async(model_stream: winrt.windows.storage.streams.IRandomAccessStreamReference) -> winrt.windows.foundation.IAsyncOperation[LearningModel]:
        ...
    def load_from_stream_async(model_stream: winrt.windows.storage.streams.IRandomAccessStreamReference, operator_provider: ILearningModelOperatorProvider) -> winrt.windows.foundation.IAsyncOperation[LearningModel]:
        ...

class LearningModelBinding(winrt.windows.foundation.collections.IMapView[str, _winrt.winrt_base], winrt.windows.foundation.collections.IIterable[winrt.windows.foundation.collections.IKeyValuePair[str, _winrt.winrt_base]], _winrt.winrt_base):
    ...
    size: int
    def bind(name: str, value: _winrt.winrt_base) -> None:
        ...
    def bind(name: str, value: _winrt.winrt_base, props: winrt.windows.foundation.collections.IPropertySet) -> None:
        ...
    def clear() -> None:
        ...
    def first() -> winrt.windows.foundation.collections.IIterator[winrt.windows.foundation.collections.IKeyValuePair[str, _winrt.winrt_base]]:
        ...
    def has_key(key: str) -> bool:
        ...
    def lookup(key: str) -> _winrt.winrt_base:
        ...
    def split() -> typing.Tuple[winrt.windows.foundation.collections.IMapView[str, _winrt.winrt_base], winrt.windows.foundation.collections.IMapView[str, _winrt.winrt_base]]:
        ...

class LearningModelDevice(_winrt.winrt_base):
    ...
    adapter_id: winrt.windows.graphics.DisplayAdapterId
    direct3_d11_device: winrt.windows.graphics.directx.direct3d11.IDirect3DDevice
    def create_from_direct3_d11_device(device: winrt.windows.graphics.directx.direct3d11.IDirect3DDevice) -> LearningModelDevice:
        ...

class LearningModelEvaluationResult(_winrt.winrt_base):
    ...
    correlation_id: str
    error_status: int
    outputs: winrt.windows.foundation.collections.IMapView[str, _winrt.winrt_base]
    succeeded: bool

class LearningModelSession(winrt.windows.foundation.IClosable, _winrt.winrt_base):
    ...
    device: LearningModelDevice
    evaluation_properties: winrt.windows.foundation.collections.IPropertySet
    model: LearningModel
    def close() -> None:
        ...
    def evaluate(bindings: LearningModelBinding, correlation_id: str) -> LearningModelEvaluationResult:
        ...
    def evaluate_async(bindings: LearningModelBinding, correlation_id: str) -> winrt.windows.foundation.IAsyncOperation[LearningModelEvaluationResult]:
        ...
    def evaluate_features(features: winrt.windows.foundation.collections.IMap[str, _winrt.winrt_base], correlation_id: str) -> LearningModelEvaluationResult:
        ...
    def evaluate_features_async(features: winrt.windows.foundation.collections.IMap[str, _winrt.winrt_base], correlation_id: str) -> winrt.windows.foundation.IAsyncOperation[LearningModelEvaluationResult]:
        ...

class LearningModelSessionOptions(_winrt.winrt_base):
    ...
    batch_size_override: int
    close_model_on_session_creation: bool
    def override_named_dimension(name: str, dimension: int) -> None:
        ...

class MapFeatureDescriptor(ILearningModelFeatureDescriptor, _winrt.winrt_base):
    ...
    description: str
    is_required: bool
    kind: LearningModelFeatureKind
    name: str
    key_kind: TensorKind
    value_descriptor: ILearningModelFeatureDescriptor

class SequenceFeatureDescriptor(ILearningModelFeatureDescriptor, _winrt.winrt_base):
    ...
    description: str
    is_required: bool
    kind: LearningModelFeatureKind
    name: str
    element_descriptor: ILearningModelFeatureDescriptor

class TensorBoolean(ITensor, ILearningModelFeatureValue, winrt.windows.foundation.IMemoryBuffer, winrt.windows.foundation.IClosable, _winrt.winrt_base):
    ...
    kind: LearningModelFeatureKind
    shape: winrt.windows.foundation.collections.IVectorView[int]
    tensor_kind: TensorKind
    def close() -> None:
        ...
    def create() -> TensorBoolean:
        ...
    def create(shape: typing.Iterable[int]) -> TensorBoolean:
        ...
    def create_from_array(shape: typing.Iterable[int], data: typing.Sequence[bool]) -> TensorBoolean:
        ...
    def create_from_buffer(shape: typing.Sequence[int], buffer: winrt.windows.storage.streams.IBuffer) -> TensorBoolean:
        ...
    def create_from_iterable(shape: typing.Iterable[int], data: typing.Iterable[bool]) -> TensorBoolean:
        ...
    def create_from_shape_array_and_data_array(shape: typing.Sequence[int], data: typing.Sequence[bool]) -> TensorBoolean:
        ...
    def create_reference() -> winrt.windows.foundation.IMemoryBufferReference:
        ...
    def get_as_vector_view() -> winrt.windows.foundation.collections.IVectorView[bool]:
        ...

class TensorDouble(ITensor, ILearningModelFeatureValue, winrt.windows.foundation.IMemoryBuffer, winrt.windows.foundation.IClosable, _winrt.winrt_base):
    ...
    kind: LearningModelFeatureKind
    shape: winrt.windows.foundation.collections.IVectorView[int]
    tensor_kind: TensorKind
    def close() -> None:
        ...
    def create() -> TensorDouble:
        ...
    def create(shape: typing.Iterable[int]) -> TensorDouble:
        ...
    def create_from_array(shape: typing.Iterable[int], data: typing.Sequence[float]) -> TensorDouble:
        ...
    def create_from_buffer(shape: typing.Sequence[int], buffer: winrt.windows.storage.streams.IBuffer) -> TensorDouble:
        ...
    def create_from_iterable(shape: typing.Iterable[int], data: typing.Iterable[float]) -> TensorDouble:
        ...
    def create_from_shape_array_and_data_array(shape: typing.Sequence[int], data: typing.Sequence[float]) -> TensorDouble:
        ...
    def create_reference() -> winrt.windows.foundation.IMemoryBufferReference:
        ...
    def get_as_vector_view() -> winrt.windows.foundation.collections.IVectorView[float]:
        ...

class TensorFeatureDescriptor(ILearningModelFeatureDescriptor, _winrt.winrt_base):
    ...
    description: str
    is_required: bool
    kind: LearningModelFeatureKind
    name: str
    shape: winrt.windows.foundation.collections.IVectorView[int]
    tensor_kind: TensorKind

class TensorFloat(ITensor, ILearningModelFeatureValue, winrt.windows.foundation.IMemoryBuffer, winrt.windows.foundation.IClosable, _winrt.winrt_base):
    ...
    kind: LearningModelFeatureKind
    shape: winrt.windows.foundation.collections.IVectorView[int]
    tensor_kind: TensorKind
    def close() -> None:
        ...
    def create() -> TensorFloat:
        ...
    def create(shape: typing.Iterable[int]) -> TensorFloat:
        ...
    def create_from_array(shape: typing.Iterable[int], data: typing.Sequence[float]) -> TensorFloat:
        ...
    def create_from_buffer(shape: typing.Sequence[int], buffer: winrt.windows.storage.streams.IBuffer) -> TensorFloat:
        ...
    def create_from_iterable(shape: typing.Iterable[int], data: typing.Iterable[float]) -> TensorFloat:
        ...
    def create_from_shape_array_and_data_array(shape: typing.Sequence[int], data: typing.Sequence[float]) -> TensorFloat:
        ...
    def create_reference() -> winrt.windows.foundation.IMemoryBufferReference:
        ...
    def get_as_vector_view() -> winrt.windows.foundation.collections.IVectorView[float]:
        ...

class TensorFloat16Bit(ITensor, ILearningModelFeatureValue, winrt.windows.foundation.IMemoryBuffer, winrt.windows.foundation.IClosable, _winrt.winrt_base):
    ...
    kind: LearningModelFeatureKind
    shape: winrt.windows.foundation.collections.IVectorView[int]
    tensor_kind: TensorKind
    def close() -> None:
        ...
    def create() -> TensorFloat16Bit:
        ...
    def create(shape: typing.Iterable[int]) -> TensorFloat16Bit:
        ...
    def create_from_array(shape: typing.Iterable[int], data: typing.Sequence[float]) -> TensorFloat16Bit:
        ...
    def create_from_buffer(shape: typing.Sequence[int], buffer: winrt.windows.storage.streams.IBuffer) -> TensorFloat16Bit:
        ...
    def create_from_iterable(shape: typing.Iterable[int], data: typing.Iterable[float]) -> TensorFloat16Bit:
        ...
    def create_from_shape_array_and_data_array(shape: typing.Sequence[int], data: typing.Sequence[float]) -> TensorFloat16Bit:
        ...
    def create_reference() -> winrt.windows.foundation.IMemoryBufferReference:
        ...
    def get_as_vector_view() -> winrt.windows.foundation.collections.IVectorView[float]:
        ...

class TensorInt16Bit(ITensor, ILearningModelFeatureValue, winrt.windows.foundation.IMemoryBuffer, winrt.windows.foundation.IClosable, _winrt.winrt_base):
    ...
    kind: LearningModelFeatureKind
    shape: winrt.windows.foundation.collections.IVectorView[int]
    tensor_kind: TensorKind
    def close() -> None:
        ...
    def create() -> TensorInt16Bit:
        ...
    def create(shape: typing.Iterable[int]) -> TensorInt16Bit:
        ...
    def create_from_array(shape: typing.Iterable[int], data: typing.Sequence[int]) -> TensorInt16Bit:
        ...
    def create_from_buffer(shape: typing.Sequence[int], buffer: winrt.windows.storage.streams.IBuffer) -> TensorInt16Bit:
        ...
    def create_from_iterable(shape: typing.Iterable[int], data: typing.Iterable[int]) -> TensorInt16Bit:
        ...
    def create_from_shape_array_and_data_array(shape: typing.Sequence[int], data: typing.Sequence[int]) -> TensorInt16Bit:
        ...
    def create_reference() -> winrt.windows.foundation.IMemoryBufferReference:
        ...
    def get_as_vector_view() -> winrt.windows.foundation.collections.IVectorView[int]:
        ...

class TensorInt32Bit(ITensor, ILearningModelFeatureValue, winrt.windows.foundation.IMemoryBuffer, winrt.windows.foundation.IClosable, _winrt.winrt_base):
    ...
    kind: LearningModelFeatureKind
    shape: winrt.windows.foundation.collections.IVectorView[int]
    tensor_kind: TensorKind
    def close() -> None:
        ...
    def create() -> TensorInt32Bit:
        ...
    def create(shape: typing.Iterable[int]) -> TensorInt32Bit:
        ...
    def create_from_array(shape: typing.Iterable[int], data: typing.Sequence[int]) -> TensorInt32Bit:
        ...
    def create_from_buffer(shape: typing.Sequence[int], buffer: winrt.windows.storage.streams.IBuffer) -> TensorInt32Bit:
        ...
    def create_from_iterable(shape: typing.Iterable[int], data: typing.Iterable[int]) -> TensorInt32Bit:
        ...
    def create_from_shape_array_and_data_array(shape: typing.Sequence[int], data: typing.Sequence[int]) -> TensorInt32Bit:
        ...
    def create_reference() -> winrt.windows.foundation.IMemoryBufferReference:
        ...
    def get_as_vector_view() -> winrt.windows.foundation.collections.IVectorView[int]:
        ...

class TensorInt64Bit(ITensor, ILearningModelFeatureValue, winrt.windows.foundation.IMemoryBuffer, winrt.windows.foundation.IClosable, _winrt.winrt_base):
    ...
    kind: LearningModelFeatureKind
    shape: winrt.windows.foundation.collections.IVectorView[int]
    tensor_kind: TensorKind
    def close() -> None:
        ...
    def create() -> TensorInt64Bit:
        ...
    def create(shape: typing.Iterable[int]) -> TensorInt64Bit:
        ...
    def create_from_array(shape: typing.Iterable[int], data: typing.Sequence[int]) -> TensorInt64Bit:
        ...
    def create_from_buffer(shape: typing.Sequence[int], buffer: winrt.windows.storage.streams.IBuffer) -> TensorInt64Bit:
        ...
    def create_from_iterable(shape: typing.Iterable[int], data: typing.Iterable[int]) -> TensorInt64Bit:
        ...
    def create_from_shape_array_and_data_array(shape: typing.Sequence[int], data: typing.Sequence[int]) -> TensorInt64Bit:
        ...
    def create_reference() -> winrt.windows.foundation.IMemoryBufferReference:
        ...
    def get_as_vector_view() -> winrt.windows.foundation.collections.IVectorView[int]:
        ...

class TensorInt8Bit(ITensor, ILearningModelFeatureValue, winrt.windows.foundation.IMemoryBuffer, winrt.windows.foundation.IClosable, _winrt.winrt_base):
    ...
    kind: LearningModelFeatureKind
    shape: winrt.windows.foundation.collections.IVectorView[int]
    tensor_kind: TensorKind
    def close() -> None:
        ...
    def create() -> TensorInt8Bit:
        ...
    def create(shape: typing.Iterable[int]) -> TensorInt8Bit:
        ...
    def create_from_array(shape: typing.Iterable[int], data: typing.Sequence[int]) -> TensorInt8Bit:
        ...
    def create_from_buffer(shape: typing.Sequence[int], buffer: winrt.windows.storage.streams.IBuffer) -> TensorInt8Bit:
        ...
    def create_from_iterable(shape: typing.Iterable[int], data: typing.Iterable[int]) -> TensorInt8Bit:
        ...
    def create_from_shape_array_and_data_array(shape: typing.Sequence[int], data: typing.Sequence[int]) -> TensorInt8Bit:
        ...
    def create_reference() -> winrt.windows.foundation.IMemoryBufferReference:
        ...
    def get_as_vector_view() -> winrt.windows.foundation.collections.IVectorView[int]:
        ...

class TensorString(ITensor, ILearningModelFeatureValue, winrt.windows.foundation.IMemoryBuffer, winrt.windows.foundation.IClosable, _winrt.winrt_base):
    ...
    kind: LearningModelFeatureKind
    shape: winrt.windows.foundation.collections.IVectorView[int]
    tensor_kind: TensorKind
    def close() -> None:
        ...
    def create() -> TensorString:
        ...
    def create(shape: typing.Iterable[int]) -> TensorString:
        ...
    def create_from_array(shape: typing.Iterable[int], data: typing.Sequence[str]) -> TensorString:
        ...
    def create_from_iterable(shape: typing.Iterable[int], data: typing.Iterable[str]) -> TensorString:
        ...
    def create_from_shape_array_and_data_array(shape: typing.Sequence[int], data: typing.Sequence[str]) -> TensorString:
        ...
    def create_reference() -> winrt.windows.foundation.IMemoryBufferReference:
        ...
    def get_as_vector_view() -> winrt.windows.foundation.collections.IVectorView[str]:
        ...

class TensorUInt16Bit(ITensor, ILearningModelFeatureValue, winrt.windows.foundation.IMemoryBuffer, winrt.windows.foundation.IClosable, _winrt.winrt_base):
    ...
    kind: LearningModelFeatureKind
    shape: winrt.windows.foundation.collections.IVectorView[int]
    tensor_kind: TensorKind
    def close() -> None:
        ...
    def create() -> TensorUInt16Bit:
        ...
    def create(shape: typing.Iterable[int]) -> TensorUInt16Bit:
        ...
    def create_from_array(shape: typing.Iterable[int], data: typing.Sequence[int]) -> TensorUInt16Bit:
        ...
    def create_from_buffer(shape: typing.Sequence[int], buffer: winrt.windows.storage.streams.IBuffer) -> TensorUInt16Bit:
        ...
    def create_from_iterable(shape: typing.Iterable[int], data: typing.Iterable[int]) -> TensorUInt16Bit:
        ...
    def create_from_shape_array_and_data_array(shape: typing.Sequence[int], data: typing.Sequence[int]) -> TensorUInt16Bit:
        ...
    def create_reference() -> winrt.windows.foundation.IMemoryBufferReference:
        ...
    def get_as_vector_view() -> winrt.windows.foundation.collections.IVectorView[int]:
        ...

class TensorUInt32Bit(ITensor, ILearningModelFeatureValue, winrt.windows.foundation.IMemoryBuffer, winrt.windows.foundation.IClosable, _winrt.winrt_base):
    ...
    kind: LearningModelFeatureKind
    shape: winrt.windows.foundation.collections.IVectorView[int]
    tensor_kind: TensorKind
    def close() -> None:
        ...
    def create() -> TensorUInt32Bit:
        ...
    def create(shape: typing.Iterable[int]) -> TensorUInt32Bit:
        ...
    def create_from_array(shape: typing.Iterable[int], data: typing.Sequence[int]) -> TensorUInt32Bit:
        ...
    def create_from_buffer(shape: typing.Sequence[int], buffer: winrt.windows.storage.streams.IBuffer) -> TensorUInt32Bit:
        ...
    def create_from_iterable(shape: typing.Iterable[int], data: typing.Iterable[int]) -> TensorUInt32Bit:
        ...
    def create_from_shape_array_and_data_array(shape: typing.Sequence[int], data: typing.Sequence[int]) -> TensorUInt32Bit:
        ...
    def create_reference() -> winrt.windows.foundation.IMemoryBufferReference:
        ...
    def get_as_vector_view() -> winrt.windows.foundation.collections.IVectorView[int]:
        ...

class TensorUInt64Bit(ITensor, ILearningModelFeatureValue, winrt.windows.foundation.IMemoryBuffer, winrt.windows.foundation.IClosable, _winrt.winrt_base):
    ...
    kind: LearningModelFeatureKind
    shape: winrt.windows.foundation.collections.IVectorView[int]
    tensor_kind: TensorKind
    def close() -> None:
        ...
    def create() -> TensorUInt64Bit:
        ...
    def create(shape: typing.Iterable[int]) -> TensorUInt64Bit:
        ...
    def create_from_array(shape: typing.Iterable[int], data: typing.Sequence[int]) -> TensorUInt64Bit:
        ...
    def create_from_buffer(shape: typing.Sequence[int], buffer: winrt.windows.storage.streams.IBuffer) -> TensorUInt64Bit:
        ...
    def create_from_iterable(shape: typing.Iterable[int], data: typing.Iterable[int]) -> TensorUInt64Bit:
        ...
    def create_from_shape_array_and_data_array(shape: typing.Sequence[int], data: typing.Sequence[int]) -> TensorUInt64Bit:
        ...
    def create_reference() -> winrt.windows.foundation.IMemoryBufferReference:
        ...
    def get_as_vector_view() -> winrt.windows.foundation.collections.IVectorView[int]:
        ...

class TensorUInt8Bit(ITensor, ILearningModelFeatureValue, winrt.windows.foundation.IMemoryBuffer, winrt.windows.foundation.IClosable, _winrt.winrt_base):
    ...
    kind: LearningModelFeatureKind
    shape: winrt.windows.foundation.collections.IVectorView[int]
    tensor_kind: TensorKind
    def close() -> None:
        ...
    def create() -> TensorUInt8Bit:
        ...
    def create(shape: typing.Iterable[int]) -> TensorUInt8Bit:
        ...
    def create_from_array(shape: typing.Iterable[int], data: typing.Sequence[int]) -> TensorUInt8Bit:
        ...
    def create_from_buffer(shape: typing.Sequence[int], buffer: winrt.windows.storage.streams.IBuffer) -> TensorUInt8Bit:
        ...
    def create_from_iterable(shape: typing.Iterable[int], data: typing.Iterable[int]) -> TensorUInt8Bit:
        ...
    def create_from_shape_array_and_data_array(shape: typing.Sequence[int], data: typing.Sequence[int]) -> TensorUInt8Bit:
        ...
    def create_reference() -> winrt.windows.foundation.IMemoryBufferReference:
        ...
    def get_as_vector_view() -> winrt.windows.foundation.collections.IVectorView[int]:
        ...

class ILearningModelFeatureDescriptor(_winrt.winrt_base):
    ...
    description: str
    is_required: bool
    kind: LearningModelFeatureKind
    name: str

class ILearningModelFeatureValue(_winrt.winrt_base):
    ...
    kind: LearningModelFeatureKind

class ILearningModelOperatorProvider(_winrt.winrt_base):
    ...

class ITensor(ILearningModelFeatureValue, _winrt.winrt_base):
    ...
    shape: winrt.windows.foundation.collections.IVectorView[int]
    tensor_kind: TensorKind
    kind: LearningModelFeatureKind

