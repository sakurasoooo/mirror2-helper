# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

import enum
import typing
import uuid

import winrt._winrt as _winrt
try:
    import winrt.windows.foundation
except Exception:
    pass

try:
    import winrt.windows.foundation.collections
except Exception:
    pass

try:
    import winrt.windows.foundation.numerics
except Exception:
    pass

try:
    import winrt.windows.storage.streams
except Exception:
    pass

try:
    import winrt.windows.ui
except Exception:
    pass

try:
    import winrt.windows.ui.core
except Exception:
    pass

try:
    import winrt.windows.ui.input
except Exception:
    pass

class HandwritingLineHeight(enum.IntEnum):
    SMALL = 0
    MEDIUM = 1
    LARGE = 2

class InkDrawingAttributesKind(enum.IntEnum):
    DEFAULT = 0
    PENCIL = 1

class InkHighContrastAdjustment(enum.IntEnum):
    USE_SYSTEM_COLORS_WHEN_NECESSARY = 0
    USE_SYSTEM_COLORS = 1
    USE_ORIGINAL_COLORS = 2

class InkInputProcessingMode(enum.IntEnum):
    NONE = 0
    INKING = 1
    ERASING = 2

class InkInputRightDragAction(enum.IntEnum):
    LEAVE_UNPROCESSED = 0
    ALLOW_PROCESSING = 1

class InkManipulationMode(enum.IntEnum):
    INKING = 0
    ERASING = 1
    SELECTING = 2

class InkPersistenceFormat(enum.IntEnum):
    GIF_WITH_EMBEDDED_ISF = 0
    ISF = 1

class InkPresenterPredefinedConfiguration(enum.IntEnum):
    SIMPLE_SINGLE_POINTER = 0
    SIMPLE_MULTIPLE_POINTER = 1

class InkPresenterStencilKind(enum.IntEnum):
    OTHER = 0
    RULER = 1
    PROTRACTOR = 2

class InkRecognitionTarget(enum.IntEnum):
    ALL = 0
    SELECTED = 1
    RECENT = 2

class PenHandedness(enum.IntEnum):
    RIGHT = 0
    LEFT = 1

class PenTipShape(enum.IntEnum):
    CIRCLE = 0
    RECTANGLE = 1

class InkDrawingAttributes(_winrt.winrt_base):
    ...
    size: winrt.windows.foundation.Size
    pen_tip: PenTipShape
    ignore_pressure: bool
    fit_to_curve: bool
    color: winrt.windows.ui.Color
    pen_tip_transform: winrt.windows.foundation.numerics.Matrix3x2
    draw_as_highlighter: bool
    kind: InkDrawingAttributesKind
    pencil_properties: InkDrawingAttributesPencilProperties
    ignore_tilt: bool
    modeler_attributes: InkModelerAttributes
    def create_for_pencil() -> InkDrawingAttributes:
        ...

class InkDrawingAttributesPencilProperties(_winrt.winrt_base):
    ...
    opacity: float

class InkInputConfiguration(_winrt.winrt_base):
    ...
    is_primary_barrel_button_input_enabled: bool
    is_eraser_input_enabled: bool
    is_pen_haptic_feedback_enabled: bool

class InkInputProcessingConfiguration(_winrt.winrt_base):
    ...
    right_drag_action: InkInputRightDragAction
    mode: InkInputProcessingMode

class InkManager(IInkRecognizerContainer, IInkStrokeContainer, _winrt.winrt_base):
    ...
    mode: InkManipulationMode
    bounding_rect: winrt.windows.foundation.Rect
    def add_stroke(stroke: InkStroke) -> None:
        ...
    def can_paste_from_clipboard() -> bool:
        ...
    def copy_selected_to_clipboard() -> None:
        ...
    def delete_selected() -> winrt.windows.foundation.Rect:
        ...
    def get_recognition_results() -> winrt.windows.foundation.collections.IVectorView[InkRecognitionResult]:
        ...
    def get_recognizers() -> winrt.windows.foundation.collections.IVectorView[InkRecognizer]:
        ...
    def get_strokes() -> winrt.windows.foundation.collections.IVectorView[InkStroke]:
        ...
    def load_async(input_stream: winrt.windows.storage.streams.IInputStream) -> winrt.windows.foundation.IAsyncActionWithProgress[int]:
        ...
    def move_selected(translation: winrt.windows.foundation.Point) -> winrt.windows.foundation.Rect:
        ...
    def paste_from_clipboard(position: winrt.windows.foundation.Point) -> winrt.windows.foundation.Rect:
        ...
    def process_pointer_down(pointer_point: winrt.windows.ui.input.PointerPoint) -> None:
        ...
    def process_pointer_up(pointer_point: winrt.windows.ui.input.PointerPoint) -> winrt.windows.foundation.Rect:
        ...
    def process_pointer_update(pointer_point: winrt.windows.ui.input.PointerPoint) -> _winrt.winrt_base:
        ...
    def recognize_async(recognition_target: InkRecognitionTarget) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[InkRecognitionResult]]:
        ...
    def recognize_async(stroke_collection: InkStrokeContainer, recognition_target: InkRecognitionTarget) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[InkRecognitionResult]]:
        ...
    def save_async(output_stream: winrt.windows.storage.streams.IOutputStream) -> winrt.windows.foundation.IAsyncOperationWithProgress[int, int]:
        ...
    def select_with_line(from: winrt.windows.foundation.Point, to: winrt.windows.foundation.Point) -> winrt.windows.foundation.Rect:
        ...
    def select_with_poly_line(polyline: typing.Iterable[winrt.windows.foundation.Point]) -> winrt.windows.foundation.Rect:
        ...
    def set_default_drawing_attributes(drawing_attributes: InkDrawingAttributes) -> None:
        ...
    def set_default_recognizer(recognizer: InkRecognizer) -> None:
        ...
    def update_recognition_results(recognition_results: winrt.windows.foundation.collections.IVectorView[InkRecognitionResult]) -> None:
        ...

class InkModelerAttributes(_winrt.winrt_base):
    ...
    scaling_factor: float
    prediction_time: winrt.windows.foundation.TimeSpan
    use_velocity_based_pressure: bool

class InkPoint(_winrt.winrt_base):
    ...
    position: winrt.windows.foundation.Point
    pressure: float
    tilt_x: float
    tilt_y: float
    timestamp: int

class InkPresenter(_winrt.winrt_base):
    ...
    stroke_container: InkStrokeContainer
    is_input_enabled: bool
    input_device_types: winrt.windows.ui.core.CoreInputDeviceTypes
    input_processing_configuration: InkInputProcessingConfiguration
    stroke_input: InkStrokeInput
    unprocessed_input: InkUnprocessedInput
    high_contrast_adjustment: InkHighContrastAdjustment
    input_configuration: InkInputConfiguration
    def activate_custom_drying() -> InkSynchronizer:
        ...
    def copy_default_drawing_attributes() -> InkDrawingAttributes:
        ...
    def set_predefined_configuration(value: InkPresenterPredefinedConfiguration) -> None:
        ...
    def update_default_drawing_attributes(value: InkDrawingAttributes) -> None:
        ...
    def add_strokes_collected(handler: winrt.windows.foundation.TypedEventHandler[InkPresenter, InkStrokesCollectedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_strokes_collected(cookie: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_strokes_erased(handler: winrt.windows.foundation.TypedEventHandler[InkPresenter, InkStrokesErasedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_strokes_erased(cookie: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class InkPresenterProtractor(IInkPresenterStencil, _winrt.winrt_base):
    ...
    radius: float
    is_resizable: bool
    is_center_marker_visible: bool
    is_angle_readout_visible: bool
    are_tick_marks_visible: bool
    are_rays_visible: bool
    accent_color: winrt.windows.ui.Color
    transform: winrt.windows.foundation.numerics.Matrix3x2
    is_visible: bool
    foreground_color: winrt.windows.ui.Color
    background_color: winrt.windows.ui.Color
    kind: InkPresenterStencilKind

class InkPresenterRuler(IInkPresenterStencil, _winrt.winrt_base):
    ...
    width: float
    length: float
    is_compass_visible: bool
    are_tick_marks_visible: bool
    transform: winrt.windows.foundation.numerics.Matrix3x2
    is_visible: bool
    foreground_color: winrt.windows.ui.Color
    background_color: winrt.windows.ui.Color
    kind: InkPresenterStencilKind

class InkRecognitionResult(_winrt.winrt_base):
    ...
    bounding_rect: winrt.windows.foundation.Rect
    def get_strokes() -> winrt.windows.foundation.collections.IVectorView[InkStroke]:
        ...
    def get_text_candidates() -> winrt.windows.foundation.collections.IVectorView[str]:
        ...

class InkRecognizer(_winrt.winrt_base):
    ...
    name: str

class InkRecognizerContainer(IInkRecognizerContainer, _winrt.winrt_base):
    ...
    def get_recognizers() -> winrt.windows.foundation.collections.IVectorView[InkRecognizer]:
        ...
    def recognize_async(stroke_collection: InkStrokeContainer, recognition_target: InkRecognitionTarget) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[InkRecognitionResult]]:
        ...
    def set_default_recognizer(recognizer: InkRecognizer) -> None:
        ...

class InkStroke(_winrt.winrt_base):
    ...
    selected: bool
    drawing_attributes: InkDrawingAttributes
    bounding_rect: winrt.windows.foundation.Rect
    recognized: bool
    point_transform: winrt.windows.foundation.numerics.Matrix3x2
    stroke_started_time: typing.Optional[winrt.windows.foundation.DateTime]
    stroke_duration: typing.Optional[winrt.windows.foundation.TimeSpan]
    id: int
    pointer_id: int
    def clone() -> InkStroke:
        ...
    def get_ink_points() -> winrt.windows.foundation.collections.IVectorView[InkPoint]:
        ...
    def get_rendering_segments() -> winrt.windows.foundation.collections.IVectorView[InkStrokeRenderingSegment]:
        ...

class InkStrokeBuilder(_winrt.winrt_base):
    ...
    def append_to_stroke(pointer_point: winrt.windows.ui.input.PointerPoint) -> winrt.windows.ui.input.PointerPoint:
        ...
    def begin_stroke(pointer_point: winrt.windows.ui.input.PointerPoint) -> None:
        ...
    def create_stroke(points: typing.Iterable[winrt.windows.foundation.Point]) -> InkStroke:
        ...
    def create_stroke_from_ink_points(ink_points: typing.Iterable[InkPoint], transform: winrt.windows.foundation.numerics.Matrix3x2) -> InkStroke:
        ...
    def create_stroke_from_ink_points(ink_points: typing.Iterable[InkPoint], transform: winrt.windows.foundation.numerics.Matrix3x2, stroke_started_time: typing.Optional[winrt.windows.foundation.DateTime], stroke_duration: typing.Optional[winrt.windows.foundation.TimeSpan]) -> InkStroke:
        ...
    def end_stroke(pointer_point: winrt.windows.ui.input.PointerPoint) -> InkStroke:
        ...
    def set_default_drawing_attributes(drawing_attributes: InkDrawingAttributes) -> None:
        ...

class InkStrokeContainer(IInkStrokeContainer, _winrt.winrt_base):
    ...
    bounding_rect: winrt.windows.foundation.Rect
    def add_stroke(stroke: InkStroke) -> None:
        ...
    def add_strokes(strokes: typing.Iterable[InkStroke]) -> None:
        ...
    def can_paste_from_clipboard() -> bool:
        ...
    def clear() -> None:
        ...
    def copy_selected_to_clipboard() -> None:
        ...
    def delete_selected() -> winrt.windows.foundation.Rect:
        ...
    def get_recognition_results() -> winrt.windows.foundation.collections.IVectorView[InkRecognitionResult]:
        ...
    def get_stroke_by_id(id: int) -> InkStroke:
        ...
    def get_strokes() -> winrt.windows.foundation.collections.IVectorView[InkStroke]:
        ...
    def load_async(input_stream: winrt.windows.storage.streams.IInputStream) -> winrt.windows.foundation.IAsyncActionWithProgress[int]:
        ...
    def move_selected(translation: winrt.windows.foundation.Point) -> winrt.windows.foundation.Rect:
        ...
    def paste_from_clipboard(position: winrt.windows.foundation.Point) -> winrt.windows.foundation.Rect:
        ...
    def save_async(output_stream: winrt.windows.storage.streams.IOutputStream) -> winrt.windows.foundation.IAsyncOperationWithProgress[int, int]:
        ...
    def save_async(output_stream: winrt.windows.storage.streams.IOutputStream, ink_persistence_format: InkPersistenceFormat) -> winrt.windows.foundation.IAsyncOperationWithProgress[int, int]:
        ...
    def select_with_line(from: winrt.windows.foundation.Point, to: winrt.windows.foundation.Point) -> winrt.windows.foundation.Rect:
        ...
    def select_with_poly_line(polyline: typing.Iterable[winrt.windows.foundation.Point]) -> winrt.windows.foundation.Rect:
        ...
    def update_recognition_results(recognition_results: winrt.windows.foundation.collections.IVectorView[InkRecognitionResult]) -> None:
        ...

class InkStrokeInput(_winrt.winrt_base):
    ...
    ink_presenter: InkPresenter
    def add_stroke_canceled(handler: winrt.windows.foundation.TypedEventHandler[InkStrokeInput, winrt.windows.ui.core.PointerEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_stroke_canceled(cookie: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_stroke_continued(handler: winrt.windows.foundation.TypedEventHandler[InkStrokeInput, winrt.windows.ui.core.PointerEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_stroke_continued(cookie: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_stroke_ended(handler: winrt.windows.foundation.TypedEventHandler[InkStrokeInput, winrt.windows.ui.core.PointerEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_stroke_ended(cookie: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_stroke_started(handler: winrt.windows.foundation.TypedEventHandler[InkStrokeInput, winrt.windows.ui.core.PointerEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_stroke_started(cookie: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class InkStrokeRenderingSegment(_winrt.winrt_base):
    ...
    bezier_control_point1: winrt.windows.foundation.Point
    bezier_control_point2: winrt.windows.foundation.Point
    position: winrt.windows.foundation.Point
    pressure: float
    tilt_x: float
    tilt_y: float
    twist: float

class InkStrokesCollectedEventArgs(_winrt.winrt_base):
    ...
    strokes: winrt.windows.foundation.collections.IVectorView[InkStroke]

class InkStrokesErasedEventArgs(_winrt.winrt_base):
    ...
    strokes: winrt.windows.foundation.collections.IVectorView[InkStroke]

class InkSynchronizer(_winrt.winrt_base):
    ...
    def begin_dry() -> winrt.windows.foundation.collections.IVectorView[InkStroke]:
        ...
    def end_dry() -> None:
        ...

class InkUnprocessedInput(_winrt.winrt_base):
    ...
    ink_presenter: InkPresenter
    def add_pointer_entered(handler: winrt.windows.foundation.TypedEventHandler[InkUnprocessedInput, winrt.windows.ui.core.PointerEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_pointer_entered(cookie: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_pointer_exited(handler: winrt.windows.foundation.TypedEventHandler[InkUnprocessedInput, winrt.windows.ui.core.PointerEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_pointer_exited(cookie: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_pointer_hovered(handler: winrt.windows.foundation.TypedEventHandler[InkUnprocessedInput, winrt.windows.ui.core.PointerEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_pointer_hovered(cookie: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_pointer_lost(handler: winrt.windows.foundation.TypedEventHandler[InkUnprocessedInput, winrt.windows.ui.core.PointerEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_pointer_lost(cookie: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_pointer_moved(handler: winrt.windows.foundation.TypedEventHandler[InkUnprocessedInput, winrt.windows.ui.core.PointerEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_pointer_moved(cookie: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_pointer_pressed(handler: winrt.windows.foundation.TypedEventHandler[InkUnprocessedInput, winrt.windows.ui.core.PointerEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_pointer_pressed(cookie: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_pointer_released(handler: winrt.windows.foundation.TypedEventHandler[InkUnprocessedInput, winrt.windows.ui.core.PointerEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_pointer_released(cookie: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class PenAndInkSettings(_winrt.winrt_base):
    ...
    font_family_name: str
    handwriting_line_height: HandwritingLineHeight
    is_handwriting_directly_into_text_field_enabled: bool
    is_touch_handwriting_enabled: bool
    pen_handedness: PenHandedness
    user_consents_to_handwriting_telemetry_collection: bool
    def get_default() -> PenAndInkSettings:
        ...
    def set_pen_handedness(value: PenHandedness) -> None:
        ...

class IInkPointFactory(_winrt.winrt_base):
    ...
    def create_ink_point(position: winrt.windows.foundation.Point, pressure: float) -> InkPoint:
        ...

class IInkPresenterRulerFactory(_winrt.winrt_base):
    ...
    def create(ink_presenter: InkPresenter) -> InkPresenterRuler:
        ...

class IInkPresenterStencil(_winrt.winrt_base):
    ...
    background_color: winrt.windows.ui.Color
    foreground_color: winrt.windows.ui.Color
    is_visible: bool
    kind: InkPresenterStencilKind
    transform: winrt.windows.foundation.numerics.Matrix3x2

class IInkRecognizerContainer(_winrt.winrt_base):
    ...
    def get_recognizers() -> winrt.windows.foundation.collections.IVectorView[InkRecognizer]:
        ...
    def recognize_async(stroke_collection: InkStrokeContainer, recognition_target: InkRecognitionTarget) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[InkRecognitionResult]]:
        ...
    def set_default_recognizer(recognizer: InkRecognizer) -> None:
        ...

class IInkStrokeContainer(_winrt.winrt_base):
    ...
    bounding_rect: winrt.windows.foundation.Rect
    def add_stroke(stroke: InkStroke) -> None:
        ...
    def can_paste_from_clipboard() -> bool:
        ...
    def copy_selected_to_clipboard() -> None:
        ...
    def delete_selected() -> winrt.windows.foundation.Rect:
        ...
    def get_recognition_results() -> winrt.windows.foundation.collections.IVectorView[InkRecognitionResult]:
        ...
    def get_strokes() -> winrt.windows.foundation.collections.IVectorView[InkStroke]:
        ...
    def load_async(input_stream: winrt.windows.storage.streams.IInputStream) -> winrt.windows.foundation.IAsyncActionWithProgress[int]:
        ...
    def move_selected(translation: winrt.windows.foundation.Point) -> winrt.windows.foundation.Rect:
        ...
    def paste_from_clipboard(position: winrt.windows.foundation.Point) -> winrt.windows.foundation.Rect:
        ...
    def save_async(output_stream: winrt.windows.storage.streams.IOutputStream) -> winrt.windows.foundation.IAsyncOperationWithProgress[int, int]:
        ...
    def select_with_line(from: winrt.windows.foundation.Point, to: winrt.windows.foundation.Point) -> winrt.windows.foundation.Rect:
        ...
    def select_with_poly_line(polyline: typing.Iterable[winrt.windows.foundation.Point]) -> winrt.windows.foundation.Rect:
        ...
    def update_recognition_results(recognition_results: winrt.windows.foundation.collections.IVectorView[InkRecognitionResult]) -> None:
        ...

