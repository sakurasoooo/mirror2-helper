# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

import enum
import typing
import uuid

import winrt._winrt as _winrt
try:
    import winrt.windows.foundation
except Exception:
    pass

try:
    import winrt.windows.foundation.collections
except Exception:
    pass

try:
    import winrt.windows.storage.streams
except Exception:
    pass

try:
    import winrt.windows.web.http
except Exception:
    pass

class AdaptiveMediaSourceCreationStatus(enum.IntEnum):
    SUCCESS = 0
    MANIFEST_DOWNLOAD_FAILURE = 1
    MANIFEST_PARSE_FAILURE = 2
    UNSUPPORTED_MANIFEST_CONTENT_TYPE = 3
    UNSUPPORTED_MANIFEST_VERSION = 4
    UNSUPPORTED_MANIFEST_PROFILE = 5
    UNKNOWN_FAILURE = 6

class AdaptiveMediaSourceDiagnosticType(enum.IntEnum):
    MANIFEST_UNCHANGED_UPON_RELOAD = 0
    MANIFEST_MISMATCH_UPON_RELOAD = 1
    MANIFEST_SIGNALED_END_OF_LIVE_EVENT_UPON_RELOAD = 2
    MEDIA_SEGMENT_SKIPPED = 3
    RESOURCE_NOT_FOUND = 4
    RESOURCE_TIMED_OUT = 5
    RESOURCE_PARSING_ERROR = 6
    BITRATE_DISABLED = 7
    FATAL_MEDIA_SOURCE_ERROR = 8

class AdaptiveMediaSourceDownloadBitrateChangedReason(enum.IntEnum):
    SUFFICIENT_INBOUND_BITS_PER_SECOND = 0
    INSUFFICIENT_INBOUND_BITS_PER_SECOND = 1
    LOW_BUFFER_LEVEL = 2
    POSITION_CHANGED = 3
    TRACK_SELECTION_CHANGED = 4
    DESIRED_BITRATES_CHANGED = 5
    ERROR_IN_PREVIOUS_BITRATE = 6

class AdaptiveMediaSourceResourceType(enum.IntEnum):
    MANIFEST = 0
    INITIALIZATION_SEGMENT = 1
    MEDIA_SEGMENT = 2
    KEY = 3
    INITIALIZATION_VECTOR = 4
    MEDIA_SEGMENT_INDEX = 5

class AdaptiveMediaSource(winrt.windows.media.core.IMediaSource, winrt.windows.foundation.IClosable, _winrt.winrt_base):
    ...
    initial_bitrate: int
    inbound_bits_per_second_window: winrt.windows.foundation.TimeSpan
    desired_max_bitrate: typing.Optional[int]
    desired_live_offset: winrt.windows.foundation.TimeSpan
    desired_min_bitrate: typing.Optional[int]
    current_playback_bitrate: int
    audio_only_playback: bool
    inbound_bits_per_second: int
    available_bitrates: winrt.windows.foundation.collections.IVectorView[int]
    current_download_bitrate: int
    is_live: bool
    advanced_settings: AdaptiveMediaSourceAdvancedSettings
    desired_seekable_window_size: typing.Optional[winrt.windows.foundation.TimeSpan]
    diagnostics: AdaptiveMediaSourceDiagnostics
    max_seekable_window_size: typing.Optional[winrt.windows.foundation.TimeSpan]
    min_live_offset: typing.Optional[winrt.windows.foundation.TimeSpan]
    def close() -> None:
        ...
    def create_from_stream_async(stream: winrt.windows.storage.streams.IInputStream, uri: winrt.windows.foundation.Uri, content_type: str) -> winrt.windows.foundation.IAsyncOperation[AdaptiveMediaSourceCreationResult]:
        ...
    def create_from_stream_async(stream: winrt.windows.storage.streams.IInputStream, uri: winrt.windows.foundation.Uri, content_type: str, http_client: winrt.windows.web.http.HttpClient) -> winrt.windows.foundation.IAsyncOperation[AdaptiveMediaSourceCreationResult]:
        ...
    def create_from_uri_async(uri: winrt.windows.foundation.Uri) -> winrt.windows.foundation.IAsyncOperation[AdaptiveMediaSourceCreationResult]:
        ...
    def create_from_uri_async(uri: winrt.windows.foundation.Uri, http_client: winrt.windows.web.http.HttpClient) -> winrt.windows.foundation.IAsyncOperation[AdaptiveMediaSourceCreationResult]:
        ...
    def get_correlated_times() -> AdaptiveMediaSourceCorrelatedTimes:
        ...
    def is_content_type_supported(content_type: str) -> bool:
        ...
    def add_download_bitrate_changed(handler: winrt.windows.foundation.TypedEventHandler[AdaptiveMediaSource, AdaptiveMediaSourceDownloadBitrateChangedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_download_bitrate_changed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_download_completed(handler: winrt.windows.foundation.TypedEventHandler[AdaptiveMediaSource, AdaptiveMediaSourceDownloadCompletedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_download_completed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_download_failed(handler: winrt.windows.foundation.TypedEventHandler[AdaptiveMediaSource, AdaptiveMediaSourceDownloadFailedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_download_failed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_download_requested(handler: winrt.windows.foundation.TypedEventHandler[AdaptiveMediaSource, AdaptiveMediaSourceDownloadRequestedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_download_requested(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_playback_bitrate_changed(handler: winrt.windows.foundation.TypedEventHandler[AdaptiveMediaSource, AdaptiveMediaSourcePlaybackBitrateChangedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_playback_bitrate_changed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class AdaptiveMediaSourceAdvancedSettings(_winrt.winrt_base):
    ...
    desired_bitrate_headroom_ratio: typing.Optional[float]
    bitrate_downgrade_trigger_ratio: typing.Optional[float]
    all_segments_independent: bool

class AdaptiveMediaSourceCorrelatedTimes(_winrt.winrt_base):
    ...
    position: typing.Optional[winrt.windows.foundation.TimeSpan]
    presentation_time_stamp: typing.Optional[winrt.windows.foundation.TimeSpan]
    program_date_time: typing.Optional[winrt.windows.foundation.DateTime]

class AdaptiveMediaSourceCreationResult(_winrt.winrt_base):
    ...
    http_response_message: winrt.windows.web.http.HttpResponseMessage
    media_source: AdaptiveMediaSource
    status: AdaptiveMediaSourceCreationStatus
    extended_error: winrt.windows.foundation.HResult

class AdaptiveMediaSourceDiagnosticAvailableEventArgs(_winrt.winrt_base):
    ...
    bitrate: typing.Optional[int]
    diagnostic_type: AdaptiveMediaSourceDiagnosticType
    position: typing.Optional[winrt.windows.foundation.TimeSpan]
    request_id: typing.Optional[int]
    resource_byte_range_length: typing.Optional[int]
    resource_byte_range_offset: typing.Optional[int]
    resource_type: typing.Optional[AdaptiveMediaSourceResourceType]
    resource_uri: winrt.windows.foundation.Uri
    segment_id: typing.Optional[int]
    extended_error: winrt.windows.foundation.HResult
    resource_content_type: str
    resource_duration: typing.Optional[winrt.windows.foundation.TimeSpan]

class AdaptiveMediaSourceDiagnostics(_winrt.winrt_base):
    ...
    def add_diagnostic_available(handler: winrt.windows.foundation.TypedEventHandler[AdaptiveMediaSourceDiagnostics, AdaptiveMediaSourceDiagnosticAvailableEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_diagnostic_available(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class AdaptiveMediaSourceDownloadBitrateChangedEventArgs(_winrt.winrt_base):
    ...
    new_value: int
    old_value: int
    reason: AdaptiveMediaSourceDownloadBitrateChangedReason

class AdaptiveMediaSourceDownloadCompletedEventArgs(_winrt.winrt_base):
    ...
    http_response_message: winrt.windows.web.http.HttpResponseMessage
    resource_byte_range_length: typing.Optional[int]
    resource_byte_range_offset: typing.Optional[int]
    resource_type: AdaptiveMediaSourceResourceType
    resource_uri: winrt.windows.foundation.Uri
    position: typing.Optional[winrt.windows.foundation.TimeSpan]
    request_id: int
    statistics: AdaptiveMediaSourceDownloadStatistics
    resource_content_type: str
    resource_duration: typing.Optional[winrt.windows.foundation.TimeSpan]

class AdaptiveMediaSourceDownloadFailedEventArgs(_winrt.winrt_base):
    ...
    http_response_message: winrt.windows.web.http.HttpResponseMessage
    resource_byte_range_length: typing.Optional[int]
    resource_byte_range_offset: typing.Optional[int]
    resource_type: AdaptiveMediaSourceResourceType
    resource_uri: winrt.windows.foundation.Uri
    extended_error: winrt.windows.foundation.HResult
    position: typing.Optional[winrt.windows.foundation.TimeSpan]
    request_id: int
    statistics: AdaptiveMediaSourceDownloadStatistics
    resource_content_type: str
    resource_duration: typing.Optional[winrt.windows.foundation.TimeSpan]

class AdaptiveMediaSourceDownloadRequestedDeferral(_winrt.winrt_base):
    ...
    def complete() -> None:
        ...

class AdaptiveMediaSourceDownloadRequestedEventArgs(_winrt.winrt_base):
    ...
    resource_byte_range_length: typing.Optional[int]
    resource_byte_range_offset: typing.Optional[int]
    resource_type: AdaptiveMediaSourceResourceType
    resource_uri: winrt.windows.foundation.Uri
    result: AdaptiveMediaSourceDownloadResult
    position: typing.Optional[winrt.windows.foundation.TimeSpan]
    request_id: int
    resource_content_type: str
    resource_duration: typing.Optional[winrt.windows.foundation.TimeSpan]
    def get_deferral() -> AdaptiveMediaSourceDownloadRequestedDeferral:
        ...

class AdaptiveMediaSourceDownloadResult(_winrt.winrt_base):
    ...
    resource_uri: winrt.windows.foundation.Uri
    input_stream: winrt.windows.storage.streams.IInputStream
    extended_status: int
    content_type: str
    buffer: winrt.windows.storage.streams.IBuffer
    resource_byte_range_offset: typing.Optional[int]
    resource_byte_range_length: typing.Optional[int]

class AdaptiveMediaSourceDownloadStatistics(_winrt.winrt_base):
    ...
    content_bytes_received_count: int
    time_to_first_byte_received: typing.Optional[winrt.windows.foundation.TimeSpan]
    time_to_headers_received: typing.Optional[winrt.windows.foundation.TimeSpan]
    time_to_last_byte_received: typing.Optional[winrt.windows.foundation.TimeSpan]

class AdaptiveMediaSourcePlaybackBitrateChangedEventArgs(_winrt.winrt_base):
    ...
    audio_only: bool
    new_value: int
    old_value: int

