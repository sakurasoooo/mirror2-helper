# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

import enum
import typing
import uuid

import winrt._winrt as _winrt
try:
    import winrt.windows.foundation
except Exception:
    pass

try:
    import winrt.windows.foundation.collections
except Exception:
    pass

try:
    import winrt.windows.media.core
except Exception:
    pass

try:
    import winrt.windows.media.protection
except Exception:
    pass

try:
    import winrt.windows.storage
except Exception:
    pass

class NDCertificateFeature(enum.IntEnum):
    TRANSMITTER = 1
    RECEIVER = 2
    SHARED_CERTIFICATE = 3
    SECURE_CLOCK = 4
    ANTI_ROLL_BACK_CLOCK = 5
    C_R_L_S = 9
    PLAY_READY3_FEATURES = 13

class NDCertificatePlatformID(enum.IntEnum):
    WINDOWS = 0
    O_S_X = 1
    WINDOWS_ON_A_R_M = 2
    WINDOWS_MOBILE7 = 5
    I_O_S_ON_A_R_M = 6
    X_BOX_ON_P_P_C = 7
    WINDOWS_PHONE8_ON_A_R_M = 8
    WINDOWS_PHONE8_ON_X86 = 9
    XBOX_ONE = 10
    ANDROID_ON_A_R_M = 11
    WINDOWS_PHONE81_ON_A_R_M = 12
    WINDOWS_PHONE81_ON_X86 = 13

class NDCertificateType(enum.IntEnum):
    UNKNOWN = 0
    P_C = 1
    DEVICE = 2
    DOMAIN = 3
    ISSUER = 4
    CRL_SIGNER = 5
    SERVICE = 6
    SILVERLIGHT = 7
    APPLICATION = 8
    METERING = 9
    KEY_FILE_SIGNER = 10
    SERVER = 11
    LICENSE_SIGNER = 12

class NDClosedCaptionFormat(enum.IntEnum):
    A_T_S_C = 0
    S_C_T_E20 = 1
    UNKNOWN = 2

class NDContentIDType(enum.IntEnum):
    KEY_I_D = 1
    PLAY_READY_OBJECT = 2
    CUSTOM = 3

class NDMediaStreamType(enum.IntEnum):
    AUDIO = 1
    VIDEO = 2

class NDProximityDetectionType(enum.IntEnum):
    U_D_P = 1
    T_C_P = 2
    TRANSPORT_AGNOSTIC = 4

class NDStartAsyncOptions(enum.IntEnum):
    MUTUAL_AUTHENTICATION = 1
    WAIT_FOR_LICENSE_DESCRIPTOR = 2

class PlayReadyDecryptorSetup(enum.IntEnum):
    UNINITIALIZED = 0
    ON_DEMAND = 1

class PlayReadyEncryptionAlgorithm(enum.IntEnum):
    UNPROTECTED = 0
    AES128_CTR = 1
    COCKTAIL = 4
    AES128_CBC = 5
    UNSPECIFIED = 65535
    UNINITIALIZED = 2147483647

class PlayReadyHardwareDRMFeatures(enum.IntEnum):
    HARDWARE_D_R_M = 1
    H_E_V_C = 2
    AES128_CBC = 3

class PlayReadyITADataFormat(enum.IntEnum):
    SERIALIZED_PROPERTIES = 0
    SERIALIZED_PROPERTIES_WITH_CONTENT_PROTECTION_WRAPPER = 1

class NDClient(_winrt.winrt_base):
    ...
    def close() -> None:
        ...
    def license_fetch_async(license_fetch_descriptor: INDLicenseFetchDescriptor) -> winrt.windows.foundation.IAsyncOperation[INDLicenseFetchResult]:
        ...
    def re_registration_async(registration_custom_data: INDCustomData) -> winrt.windows.foundation.IAsyncAction:
        ...
    def start_async(content_url: winrt.windows.foundation.Uri, start_async_options: int, registration_custom_data: INDCustomData, license_fetch_descriptor: INDLicenseFetchDescriptor) -> winrt.windows.foundation.IAsyncOperation[INDStartResult]:
        ...
    def add_closed_caption_data_received(handler: winrt.windows.foundation.TypedEventHandler[NDClient, INDClosedCaptionDataReceivedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_closed_caption_data_received(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_license_fetch_completed(handler: winrt.windows.foundation.TypedEventHandler[NDClient, INDLicenseFetchCompletedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_license_fetch_completed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_proximity_detection_completed(handler: winrt.windows.foundation.TypedEventHandler[NDClient, INDProximityDetectionCompletedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_proximity_detection_completed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_re_registration_needed(handler: winrt.windows.foundation.TypedEventHandler[NDClient, _winrt.winrt_base]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_re_registration_needed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_registration_completed(handler: winrt.windows.foundation.TypedEventHandler[NDClient, INDRegistrationCompletedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_registration_completed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class NDCustomData(INDCustomData, _winrt.winrt_base):
    ...
    custom_data: int
    custom_data_type_i_d: int

class NDDownloadEngineNotifier(INDDownloadEngineNotifier, _winrt.winrt_base):
    ...
    def on_content_i_d_received(license_fetch_descriptor: INDLicenseFetchDescriptor) -> None:
        ...
    def on_data_received(data_bytes: typing.Sequence[int], bytes_received: int) -> None:
        ...
    def on_end_of_stream() -> None:
        ...
    def on_network_error() -> None:
        ...
    def on_play_ready_object_received(data_bytes: typing.Sequence[int]) -> None:
        ...
    def on_stream_opened() -> None:
        ...

class NDLicenseFetchDescriptor(INDLicenseFetchDescriptor, _winrt.winrt_base):
    ...
    license_fetch_challenge_custom_data: INDCustomData
    content_i_d: int
    content_i_d_type: NDContentIDType

class NDStorageFileHelper(INDStorageFileHelper, _winrt.winrt_base):
    ...
    def get_file_u_r_ls(file: winrt.windows.storage.IStorageFile) -> winrt.windows.foundation.collections.IVector[str]:
        ...

class NDStreamParserNotifier(INDStreamParserNotifier, _winrt.winrt_base):
    ...
    def on_begin_setup_decryptor(descriptor: winrt.windows.media.core.IMediaStreamDescriptor, key_i_d: uuid.UUID, pro_bytes: typing.Sequence[int]) -> None:
        ...
    def on_content_i_d_received(license_fetch_descriptor: INDLicenseFetchDescriptor) -> None:
        ...
    def on_media_stream_descriptor_created(audio_stream_descriptors: winrt.windows.foundation.collections.IVector[winrt.windows.media.core.AudioStreamDescriptor], video_stream_descriptors: winrt.windows.foundation.collections.IVector[winrt.windows.media.core.VideoStreamDescriptor]) -> None:
        ...
    def on_sample_parsed(stream_i_d: int, stream_type: NDMediaStreamType, stream_sample: winrt.windows.media.core.MediaStreamSample, pts: int, cc_format: NDClosedCaptionFormat, cc_data_bytes: typing.Sequence[int]) -> None:
        ...

class NDTCPMessenger(INDMessenger, _winrt.winrt_base):
    ...
    def send_license_fetch_request_async(session_i_d_bytes: typing.Sequence[int], challenge_data_bytes: typing.Sequence[int]) -> winrt.windows.foundation.IAsyncOperation[INDSendResult]:
        ...
    def send_proximity_detection_response_async(pd_type: NDProximityDetectionType, transmitter_channel_bytes: typing.Sequence[int], session_i_d_bytes: typing.Sequence[int], response_data_bytes: typing.Sequence[int]) -> winrt.windows.foundation.IAsyncOperation[INDSendResult]:
        ...
    def send_proximity_detection_start_async(pd_type: NDProximityDetectionType, transmitter_channel_bytes: typing.Sequence[int], session_i_d_bytes: typing.Sequence[int], challenge_data_bytes: typing.Sequence[int]) -> winrt.windows.foundation.IAsyncOperation[INDSendResult]:
        ...
    def send_registration_request_async(session_i_d_bytes: typing.Sequence[int], challenge_data_bytes: typing.Sequence[int]) -> winrt.windows.foundation.IAsyncOperation[INDSendResult]:
        ...

class PlayReadyContentHeader(_winrt.winrt_base):
    ...
    custom_attributes: str
    decryptor_setup: PlayReadyDecryptorSetup
    domain_service_id: uuid.UUID
    encryption_type: PlayReadyEncryptionAlgorithm
    header_with_embedded_updates: PlayReadyContentHeader
    key_id: uuid.UUID
    key_id_string: str
    license_acquisition_url: winrt.windows.foundation.Uri
    license_acquisition_user_interface_url: winrt.windows.foundation.Uri
    key_id_strings: str
    key_ids: uuid.UUID
    def get_serialized_header() -> int:
        ...

class PlayReadyContentResolver(_winrt.winrt_base):
    ...
    def service_request(content_header: PlayReadyContentHeader) -> IPlayReadyServiceRequest:
        ...

class PlayReadyDomain(IPlayReadyDomain, _winrt.winrt_base):
    ...
    account_id: uuid.UUID
    domain_join_url: winrt.windows.foundation.Uri
    friendly_name: str
    revision: int
    service_id: uuid.UUID

class PlayReadyDomainIterable(winrt.windows.foundation.collections.IIterable[IPlayReadyDomain], _winrt.winrt_base):
    ...
    def first() -> winrt.windows.foundation.collections.IIterator[IPlayReadyDomain]:
        ...

class PlayReadyDomainIterator(winrt.windows.foundation.collections.IIterator[IPlayReadyDomain], _winrt.winrt_base):
    ...
    current: IPlayReadyDomain
    has_current: bool
    def get_many(items_size: int) -> typing.Tuple[int, typing.List[IPlayReadyDomain]]:
        ...
    def move_next() -> bool:
        ...

class PlayReadyDomainJoinServiceRequest(IPlayReadyServiceRequest, winrt.windows.media.protection.IMediaProtectionServiceRequest, _winrt.winrt_base):
    ...
    protection_system: uuid.UUID
    type: uuid.UUID
    domain_service_id: uuid.UUID
    domain_friendly_name: str
    domain_account_id: uuid.UUID
    uri: winrt.windows.foundation.Uri
    challenge_custom_data: str
    response_custom_data: str
    def begin_service_request() -> winrt.windows.foundation.IAsyncAction:
        ...
    def generate_manual_enabling_challenge() -> PlayReadySoapMessage:
        ...
    def next_service_request() -> IPlayReadyServiceRequest:
        ...
    def process_manual_enabling_response(response_bytes: typing.Sequence[int]) -> winrt.windows.foundation.HResult:
        ...

class PlayReadyDomainLeaveServiceRequest(IPlayReadyServiceRequest, winrt.windows.media.protection.IMediaProtectionServiceRequest, _winrt.winrt_base):
    ...
    protection_system: uuid.UUID
    type: uuid.UUID
    domain_service_id: uuid.UUID
    domain_account_id: uuid.UUID
    uri: winrt.windows.foundation.Uri
    challenge_custom_data: str
    response_custom_data: str
    def begin_service_request() -> winrt.windows.foundation.IAsyncAction:
        ...
    def generate_manual_enabling_challenge() -> PlayReadySoapMessage:
        ...
    def next_service_request() -> IPlayReadyServiceRequest:
        ...
    def process_manual_enabling_response(response_bytes: typing.Sequence[int]) -> winrt.windows.foundation.HResult:
        ...

class PlayReadyITADataGenerator(_winrt.winrt_base):
    ...
    def generate_data(guid_c_p_system_id: uuid.UUID, count_of_streams: int, configuration: winrt.windows.foundation.collections.IPropertySet, format: PlayReadyITADataFormat) -> int:
        ...

class PlayReadyIndividualizationServiceRequest(IPlayReadyServiceRequest, winrt.windows.media.protection.IMediaProtectionServiceRequest, _winrt.winrt_base):
    ...
    protection_system: uuid.UUID
    type: uuid.UUID
    uri: winrt.windows.foundation.Uri
    challenge_custom_data: str
    response_custom_data: str
    def begin_service_request() -> winrt.windows.foundation.IAsyncAction:
        ...
    def generate_manual_enabling_challenge() -> PlayReadySoapMessage:
        ...
    def next_service_request() -> IPlayReadyServiceRequest:
        ...
    def process_manual_enabling_response(response_bytes: typing.Sequence[int]) -> winrt.windows.foundation.HResult:
        ...

class PlayReadyLicense(IPlayReadyLicense, _winrt.winrt_base):
    ...
    chain_depth: int
    domain_account_i_d: uuid.UUID
    expiration_date: typing.Optional[winrt.windows.foundation.DateTime]
    expire_after_first_play: int
    fully_evaluated: bool
    usable_for_play: bool
    expires_in_real_time: bool
    in_memory_only: bool
    secure_stop_id: uuid.UUID
    security_level: int
    def get_k_i_d_at_chain_depth(chain_depth: int) -> uuid.UUID:
        ...

class PlayReadyLicenseAcquisitionServiceRequest(IPlayReadyLicenseAcquisitionServiceRequest, IPlayReadyServiceRequest, winrt.windows.media.protection.IMediaProtectionServiceRequest, _winrt.winrt_base):
    ...
    protection_system: uuid.UUID
    type: uuid.UUID
    domain_service_id: uuid.UUID
    content_header: PlayReadyContentHeader
    session_id: uuid.UUID
    uri: winrt.windows.foundation.Uri
    challenge_custom_data: str
    response_custom_data: str
    def begin_service_request() -> winrt.windows.foundation.IAsyncAction:
        ...
    def create_license_iterable(content_header: PlayReadyContentHeader, fully_evaluated: bool) -> PlayReadyLicenseIterable:
        ...
    def generate_manual_enabling_challenge() -> PlayReadySoapMessage:
        ...
    def next_service_request() -> IPlayReadyServiceRequest:
        ...
    def process_manual_enabling_response(response_bytes: typing.Sequence[int]) -> winrt.windows.foundation.HResult:
        ...

class PlayReadyLicenseIterable(winrt.windows.foundation.collections.IIterable[IPlayReadyLicense], _winrt.winrt_base):
    ...
    def first() -> winrt.windows.foundation.collections.IIterator[IPlayReadyLicense]:
        ...

class PlayReadyLicenseIterator(winrt.windows.foundation.collections.IIterator[IPlayReadyLicense], _winrt.winrt_base):
    ...
    current: IPlayReadyLicense
    has_current: bool
    def get_many(items_size: int) -> typing.Tuple[int, typing.List[IPlayReadyLicense]]:
        ...
    def move_next() -> bool:
        ...

class PlayReadyLicenseManagement(_winrt.winrt_base):
    ...
    def delete_licenses(content_header: PlayReadyContentHeader) -> winrt.windows.foundation.IAsyncAction:
        ...

class PlayReadyLicenseSession(IPlayReadyLicenseSession, IPlayReadyLicenseSession2, _winrt.winrt_base):
    ...
    def configure_media_protection_manager(mpm: winrt.windows.media.protection.MediaProtectionManager) -> None:
        ...
    def create_l_a_service_request() -> IPlayReadyLicenseAcquisitionServiceRequest:
        ...
    def create_license_iterable(content_header: PlayReadyContentHeader, fully_evaluated: bool) -> PlayReadyLicenseIterable:
        ...

class PlayReadyMeteringReportServiceRequest(IPlayReadyServiceRequest, winrt.windows.media.protection.IMediaProtectionServiceRequest, _winrt.winrt_base):
    ...
    protection_system: uuid.UUID
    type: uuid.UUID
    metering_certificate: int
    uri: winrt.windows.foundation.Uri
    challenge_custom_data: str
    response_custom_data: str
    def begin_service_request() -> winrt.windows.foundation.IAsyncAction:
        ...
    def generate_manual_enabling_challenge() -> PlayReadySoapMessage:
        ...
    def next_service_request() -> IPlayReadyServiceRequest:
        ...
    def process_manual_enabling_response(response_bytes: typing.Sequence[int]) -> winrt.windows.foundation.HResult:
        ...

class PlayReadyRevocationServiceRequest(IPlayReadyServiceRequest, winrt.windows.media.protection.IMediaProtectionServiceRequest, _winrt.winrt_base):
    ...
    protection_system: uuid.UUID
    type: uuid.UUID
    uri: winrt.windows.foundation.Uri
    challenge_custom_data: str
    response_custom_data: str
    def begin_service_request() -> winrt.windows.foundation.IAsyncAction:
        ...
    def generate_manual_enabling_challenge() -> PlayReadySoapMessage:
        ...
    def next_service_request() -> IPlayReadyServiceRequest:
        ...
    def process_manual_enabling_response(response_bytes: typing.Sequence[int]) -> winrt.windows.foundation.HResult:
        ...

class PlayReadySecureStopIterable(winrt.windows.foundation.collections.IIterable[IPlayReadySecureStopServiceRequest], _winrt.winrt_base):
    ...
    def first() -> winrt.windows.foundation.collections.IIterator[IPlayReadySecureStopServiceRequest]:
        ...

class PlayReadySecureStopIterator(winrt.windows.foundation.collections.IIterator[IPlayReadySecureStopServiceRequest], _winrt.winrt_base):
    ...
    current: IPlayReadySecureStopServiceRequest
    has_current: bool
    def get_many(items_size: int) -> typing.Tuple[int, typing.List[IPlayReadySecureStopServiceRequest]]:
        ...
    def move_next() -> bool:
        ...

class PlayReadySecureStopServiceRequest(IPlayReadySecureStopServiceRequest, IPlayReadyServiceRequest, winrt.windows.media.protection.IMediaProtectionServiceRequest, _winrt.winrt_base):
    ...
    protection_system: uuid.UUID
    type: uuid.UUID
    publisher_certificate: int
    session_i_d: uuid.UUID
    start_time: winrt.windows.foundation.DateTime
    stopped: bool
    update_time: winrt.windows.foundation.DateTime
    uri: winrt.windows.foundation.Uri
    challenge_custom_data: str
    response_custom_data: str
    def begin_service_request() -> winrt.windows.foundation.IAsyncAction:
        ...
    def generate_manual_enabling_challenge() -> PlayReadySoapMessage:
        ...
    def next_service_request() -> IPlayReadyServiceRequest:
        ...
    def process_manual_enabling_response(response_bytes: typing.Sequence[int]) -> winrt.windows.foundation.HResult:
        ...

class PlayReadySoapMessage(_winrt.winrt_base):
    ...
    message_headers: winrt.windows.foundation.collections.IPropertySet
    uri: winrt.windows.foundation.Uri
    def get_message_body() -> int:
        ...

class PlayReadyStatics(_winrt.winrt_base):
    ...
    domain_join_service_request_type: uuid.UUID
    domain_leave_service_request_type: uuid.UUID
    individualization_service_request_type: uuid.UUID
    license_acquirer_service_request_type: uuid.UUID
    media_protection_system_id: uuid.UUID
    metering_report_service_request_type: uuid.UUID
    play_ready_security_version: int
    revocation_service_request_type: uuid.UUID
    play_ready_certificate_security_level: int
    secure_stop_service_request_type: uuid.UUID
    protection_system_id: uuid.UUID
    input_trust_authority_to_create: str
    hardware_d_r_m_disabled_until_time: typing.Optional[winrt.windows.foundation.DateTime]
    hardware_d_r_m_disabled_at_time: typing.Optional[winrt.windows.foundation.DateTime]
    def check_supported_hardware(hwdrm_feature: PlayReadyHardwareDRMFeatures) -> bool:
        ...
    def reset_hardware_d_r_m_disabled() -> None:
        ...

class INDClosedCaptionDataReceivedEventArgs(_winrt.winrt_base):
    ...
    closed_caption_data: int
    closed_caption_data_format: NDClosedCaptionFormat
    presentation_timestamp: int

class INDCustomData(_winrt.winrt_base):
    ...
    custom_data: int
    custom_data_type_i_d: int

class INDDownloadEngine(_winrt.winrt_base):
    ...
    buffer_full_max_threshold_in_samples: int
    buffer_full_min_threshold_in_samples: int
    can_seek: bool
    notifier: NDDownloadEngineNotifier
    def close() -> None:
        ...
    def open(uri: winrt.windows.foundation.Uri, session_i_d_bytes: typing.Sequence[int]) -> None:
        ...
    def pause() -> None:
        ...
    def resume() -> None:
        ...
    def seek(start_position: winrt.windows.foundation.TimeSpan) -> None:
        ...

class INDDownloadEngineNotifier(_winrt.winrt_base):
    ...
    def on_content_i_d_received(license_fetch_descriptor: INDLicenseFetchDescriptor) -> None:
        ...
    def on_data_received(data_bytes: typing.Sequence[int], bytes_received: int) -> None:
        ...
    def on_end_of_stream() -> None:
        ...
    def on_network_error() -> None:
        ...
    def on_play_ready_object_received(data_bytes: typing.Sequence[int]) -> None:
        ...
    def on_stream_opened() -> None:
        ...

class INDLicenseFetchCompletedEventArgs(_winrt.winrt_base):
    ...
    response_custom_data: INDCustomData

class INDLicenseFetchDescriptor(_winrt.winrt_base):
    ...
    content_i_d: int
    content_i_d_type: NDContentIDType
    license_fetch_challenge_custom_data: INDCustomData

class INDLicenseFetchResult(_winrt.winrt_base):
    ...
    response_custom_data: INDCustomData

class INDMessenger(_winrt.winrt_base):
    ...
    def send_license_fetch_request_async(session_i_d_bytes: typing.Sequence[int], challenge_data_bytes: typing.Sequence[int]) -> winrt.windows.foundation.IAsyncOperation[INDSendResult]:
        ...
    def send_proximity_detection_response_async(pd_type: NDProximityDetectionType, transmitter_channel_bytes: typing.Sequence[int], session_i_d_bytes: typing.Sequence[int], response_data_bytes: typing.Sequence[int]) -> winrt.windows.foundation.IAsyncOperation[INDSendResult]:
        ...
    def send_proximity_detection_start_async(pd_type: NDProximityDetectionType, transmitter_channel_bytes: typing.Sequence[int], session_i_d_bytes: typing.Sequence[int], challenge_data_bytes: typing.Sequence[int]) -> winrt.windows.foundation.IAsyncOperation[INDSendResult]:
        ...
    def send_registration_request_async(session_i_d_bytes: typing.Sequence[int], challenge_data_bytes: typing.Sequence[int]) -> winrt.windows.foundation.IAsyncOperation[INDSendResult]:
        ...

class INDProximityDetectionCompletedEventArgs(_winrt.winrt_base):
    ...
    proximity_detection_retry_count: int

class INDRegistrationCompletedEventArgs(_winrt.winrt_base):
    ...
    response_custom_data: INDCustomData
    transmitter_certificate_accepted: bool
    transmitter_properties: INDTransmitterProperties

class INDSendResult(_winrt.winrt_base):
    ...
    response: int

class INDStartResult(_winrt.winrt_base):
    ...
    media_stream_source: winrt.windows.media.core.MediaStreamSource

class INDStorageFileHelper(_winrt.winrt_base):
    ...
    def get_file_u_r_ls(file: winrt.windows.storage.IStorageFile) -> winrt.windows.foundation.collections.IVector[str]:
        ...

class INDStreamParser(_winrt.winrt_base):
    ...
    notifier: NDStreamParserNotifier
    def begin_of_stream() -> None:
        ...
    def end_of_stream() -> None:
        ...
    def get_stream_information(descriptor: winrt.windows.media.core.IMediaStreamDescriptor) -> typing.Tuple[int, NDMediaStreamType]:
        ...
    def parse_data(data_bytes: typing.Sequence[int]) -> None:
        ...

class INDStreamParserNotifier(_winrt.winrt_base):
    ...
    def on_begin_setup_decryptor(descriptor: winrt.windows.media.core.IMediaStreamDescriptor, key_i_d: uuid.UUID, pro_bytes: typing.Sequence[int]) -> None:
        ...
    def on_content_i_d_received(license_fetch_descriptor: INDLicenseFetchDescriptor) -> None:
        ...
    def on_media_stream_descriptor_created(audio_stream_descriptors: winrt.windows.foundation.collections.IVector[winrt.windows.media.core.AudioStreamDescriptor], video_stream_descriptors: winrt.windows.foundation.collections.IVector[winrt.windows.media.core.VideoStreamDescriptor]) -> None:
        ...
    def on_sample_parsed(stream_i_d: int, stream_type: NDMediaStreamType, stream_sample: winrt.windows.media.core.MediaStreamSample, pts: int, cc_format: NDClosedCaptionFormat, cc_data_bytes: typing.Sequence[int]) -> None:
        ...

class INDTransmitterProperties(_winrt.winrt_base):
    ...
    certificate_type: NDCertificateType
    client_i_d: int
    expiration_date: winrt.windows.foundation.DateTime
    model_digest: int
    model_manufacturer_name: str
    model_name: str
    model_number: str
    platform_identifier: NDCertificatePlatformID
    security_level: int
    security_version: int
    supported_features: NDCertificateFeature

class IPlayReadyDomain(_winrt.winrt_base):
    ...
    account_id: uuid.UUID
    domain_join_url: winrt.windows.foundation.Uri
    friendly_name: str
    revision: int
    service_id: uuid.UUID

class IPlayReadyLicense(_winrt.winrt_base):
    ...
    chain_depth: int
    domain_account_i_d: uuid.UUID
    expiration_date: typing.Optional[winrt.windows.foundation.DateTime]
    expire_after_first_play: int
    fully_evaluated: bool
    usable_for_play: bool
    def get_k_i_d_at_chain_depth(chain_depth: int) -> uuid.UUID:
        ...

class IPlayReadyLicenseAcquisitionServiceRequest(IPlayReadyServiceRequest, winrt.windows.media.protection.IMediaProtectionServiceRequest, _winrt.winrt_base):
    ...
    content_header: PlayReadyContentHeader
    domain_service_id: uuid.UUID
    challenge_custom_data: str
    response_custom_data: str
    uri: winrt.windows.foundation.Uri
    protection_system: uuid.UUID
    type: uuid.UUID
    def begin_service_request() -> winrt.windows.foundation.IAsyncAction:
        ...
    def generate_manual_enabling_challenge() -> PlayReadySoapMessage:
        ...
    def next_service_request() -> IPlayReadyServiceRequest:
        ...
    def process_manual_enabling_response(response_bytes: typing.Sequence[int]) -> winrt.windows.foundation.HResult:
        ...

class IPlayReadyLicenseSession(_winrt.winrt_base):
    ...
    def configure_media_protection_manager(mpm: winrt.windows.media.protection.MediaProtectionManager) -> None:
        ...
    def create_l_a_service_request() -> IPlayReadyLicenseAcquisitionServiceRequest:
        ...

class IPlayReadyLicenseSession2(IPlayReadyLicenseSession, _winrt.winrt_base):
    ...
    def create_license_iterable(content_header: PlayReadyContentHeader, fully_evaluated: bool) -> PlayReadyLicenseIterable:
        ...
    def configure_media_protection_manager(mpm: winrt.windows.media.protection.MediaProtectionManager) -> None:
        ...
    def create_l_a_service_request() -> IPlayReadyLicenseAcquisitionServiceRequest:
        ...

class IPlayReadySecureStopServiceRequest(IPlayReadyServiceRequest, winrt.windows.media.protection.IMediaProtectionServiceRequest, _winrt.winrt_base):
    ...
    publisher_certificate: int
    session_i_d: uuid.UUID
    start_time: winrt.windows.foundation.DateTime
    stopped: bool
    update_time: winrt.windows.foundation.DateTime
    challenge_custom_data: str
    response_custom_data: str
    uri: winrt.windows.foundation.Uri
    protection_system: uuid.UUID
    type: uuid.UUID
    def begin_service_request() -> winrt.windows.foundation.IAsyncAction:
        ...
    def generate_manual_enabling_challenge() -> PlayReadySoapMessage:
        ...
    def next_service_request() -> IPlayReadyServiceRequest:
        ...
    def process_manual_enabling_response(response_bytes: typing.Sequence[int]) -> winrt.windows.foundation.HResult:
        ...

class IPlayReadyServiceRequest(winrt.windows.media.protection.IMediaProtectionServiceRequest, _winrt.winrt_base):
    ...
    challenge_custom_data: str
    response_custom_data: str
    uri: winrt.windows.foundation.Uri
    protection_system: uuid.UUID
    type: uuid.UUID
    def begin_service_request() -> winrt.windows.foundation.IAsyncAction:
        ...
    def generate_manual_enabling_challenge() -> PlayReadySoapMessage:
        ...
    def next_service_request() -> IPlayReadyServiceRequest:
        ...
    def process_manual_enabling_response(response_bytes: typing.Sequence[int]) -> winrt.windows.foundation.HResult:
        ...

