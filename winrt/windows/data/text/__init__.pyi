# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

import enum
import typing
import uuid

import winrt._winrt as _winrt
try:
    import winrt.windows.foundation
except Exception:
    pass

try:
    import winrt.windows.foundation.collections
except Exception:
    pass

try:
    import winrt.windows.ui.text.core
except Exception:
    pass

class AlternateNormalizationFormat(enum.IntEnum):
    NOT_NORMALIZED = 0
    NUMBER = 1
    CURRENCY = 3
    DATE = 4
    TIME = 5

class TextPredictionOptions(enum.IntFlag):
    NONE = 0
    PREDICTIONS = 0x1
    CORRECTIONS = 0x2

class UnicodeGeneralCategory(enum.IntEnum):
    UPPERCASE_LETTER = 0
    LOWERCASE_LETTER = 1
    TITLECASE_LETTER = 2
    MODIFIER_LETTER = 3
    OTHER_LETTER = 4
    NONSPACING_MARK = 5
    SPACING_COMBINING_MARK = 6
    ENCLOSING_MARK = 7
    DECIMAL_DIGIT_NUMBER = 8
    LETTER_NUMBER = 9
    OTHER_NUMBER = 10
    SPACE_SEPARATOR = 11
    LINE_SEPARATOR = 12
    PARAGRAPH_SEPARATOR = 13
    CONTROL = 14
    FORMAT = 15
    SURROGATE = 16
    PRIVATE_USE = 17
    CONNECTOR_PUNCTUATION = 18
    DASH_PUNCTUATION = 19
    OPEN_PUNCTUATION = 20
    CLOSE_PUNCTUATION = 21
    INITIAL_QUOTE_PUNCTUATION = 22
    FINAL_QUOTE_PUNCTUATION = 23
    OTHER_PUNCTUATION = 24
    MATH_SYMBOL = 25
    CURRENCY_SYMBOL = 26
    MODIFIER_SYMBOL = 27
    OTHER_SYMBOL = 28
    NOT_ASSIGNED = 29

class UnicodeNumericType(enum.IntEnum):
    NONE = 0
    DECIMAL = 1
    DIGIT = 2
    NUMERIC = 3

class TextSegment(_winrt.winrt_base):
    ...

class AlternateWordForm(_winrt.winrt_base):
    ...
    alternate_text: str
    normalization_format: AlternateNormalizationFormat
    source_text_segment: TextSegment

class SelectableWordSegment(_winrt.winrt_base):
    ...
    source_text_segment: TextSegment
    text: str

class SelectableWordsSegmenter(_winrt.winrt_base):
    ...
    resolved_language: str
    def get_token_at(text: str, start_index: int) -> SelectableWordSegment:
        ...
    def get_tokens(text: str) -> winrt.windows.foundation.collections.IVectorView[SelectableWordSegment]:
        ...
    def tokenize(text: str, start_index: int, handler: SelectableWordSegmentsTokenizingHandler) -> None:
        ...

class SemanticTextQuery(_winrt.winrt_base):
    ...
    def find(content: str) -> winrt.windows.foundation.collections.IVectorView[TextSegment]:
        ...
    def find_in_property(property_content: str, property_name: str) -> winrt.windows.foundation.collections.IVectorView[TextSegment]:
        ...

class TextConversionGenerator(_winrt.winrt_base):
    ...
    language_available_but_not_installed: bool
    resolved_language: str
    def get_candidates_async(input: str) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]:
        ...
    def get_candidates_async(input: str, max_candidates: int) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]:
        ...

class TextPhoneme(_winrt.winrt_base):
    ...
    display_text: str
    reading_text: str

class TextPredictionGenerator(_winrt.winrt_base):
    ...
    language_available_but_not_installed: bool
    resolved_language: str
    input_scope: winrt.windows.ui.text.core.CoreTextInputScope
    def get_candidates_async(input: str) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]:
        ...
    def get_candidates_async(input: str, max_candidates: int) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]:
        ...
    def get_candidates_async(input: str, max_candidates: int, prediction_options: TextPredictionOptions, previous_strings: typing.Iterable[str]) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]:
        ...
    def get_next_word_candidates_async(max_candidates: int, previous_strings: typing.Iterable[str]) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[str]]:
        ...

class TextReverseConversionGenerator(_winrt.winrt_base):
    ...
    language_available_but_not_installed: bool
    resolved_language: str
    def convert_back_async(input: str) -> winrt.windows.foundation.IAsyncOperation[str]:
        ...
    def get_phonemes_async(input: str) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[TextPhoneme]]:
        ...

class UnicodeCharacters(_winrt.winrt_base):
    ...
    def get_codepoint_from_surrogate_pair(high_surrogate: int, low_surrogate: int) -> int:
        ...
    def get_general_category(codepoint: int) -> UnicodeGeneralCategory:
        ...
    def get_numeric_type(codepoint: int) -> UnicodeNumericType:
        ...
    def get_surrogate_pair_from_codepoint(codepoint: int) -> typing.Tuple[int, int]:
        ...
    def is_alphabetic(codepoint: int) -> bool:
        ...
    def is_cased(codepoint: int) -> bool:
        ...
    def is_grapheme_base(codepoint: int) -> bool:
        ...
    def is_grapheme_extend(codepoint: int) -> bool:
        ...
    def is_high_surrogate(codepoint: int) -> bool:
        ...
    def is_id_continue(codepoint: int) -> bool:
        ...
    def is_id_start(codepoint: int) -> bool:
        ...
    def is_low_surrogate(codepoint: int) -> bool:
        ...
    def is_lowercase(codepoint: int) -> bool:
        ...
    def is_noncharacter(codepoint: int) -> bool:
        ...
    def is_supplementary(codepoint: int) -> bool:
        ...
    def is_uppercase(codepoint: int) -> bool:
        ...
    def is_whitespace(codepoint: int) -> bool:
        ...

class WordSegment(_winrt.winrt_base):
    ...
    alternate_forms: winrt.windows.foundation.collections.IVectorView[AlternateWordForm]
    source_text_segment: TextSegment
    text: str

class WordsSegmenter(_winrt.winrt_base):
    ...
    resolved_language: str
    def get_token_at(text: str, start_index: int) -> WordSegment:
        ...
    def get_tokens(text: str) -> winrt.windows.foundation.collections.IVectorView[WordSegment]:
        ...
    def tokenize(text: str, start_index: int, handler: WordSegmentsTokenizingHandler) -> None:
        ...

SelectableWordSegmentsTokenizingHandler = typing.Callable[[typing.Iterable[SelectableWordSegment], typing.Iterable[SelectableWordSegment]], None]

WordSegmentsTokenizingHandler = typing.Callable[[typing.Iterable[WordSegment], typing.Iterable[WordSegment]], None]

