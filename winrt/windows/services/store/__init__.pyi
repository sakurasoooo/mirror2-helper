# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

import enum
import typing
import uuid

import winrt._winrt as _winrt
try:
    import winrt.windows.applicationmodel
except Exception:
    pass

try:
    import winrt.windows.foundation
except Exception:
    pass

try:
    import winrt.windows.foundation.collections
except Exception:
    pass

try:
    import winrt.windows.system
except Exception:
    pass

try:
    import winrt.windows.web.http
except Exception:
    pass

class StoreCanLicenseStatus(enum.IntEnum):
    NOT_LICENSABLE_TO_USER = 0
    LICENSABLE = 1
    LICENSE_ACTION_NOT_APPLICABLE_TO_PRODUCT = 2
    NETWORK_ERROR = 3
    SERVER_ERROR = 4

class StoreConsumableStatus(enum.IntEnum):
    SUCCEEDED = 0
    INSUFFICENT_QUANTITY = 1
    NETWORK_ERROR = 2
    SERVER_ERROR = 3

class StoreDurationUnit(enum.IntEnum):
    MINUTE = 0
    HOUR = 1
    DAY = 2
    WEEK = 3
    MONTH = 4
    YEAR = 5

class StorePackageUpdateState(enum.IntEnum):
    PENDING = 0
    DOWNLOADING = 1
    DEPLOYING = 2
    COMPLETED = 3
    CANCELED = 4
    OTHER_ERROR = 5
    ERROR_LOW_BATTERY = 6
    ERROR_WI_FI_RECOMMENDED = 7
    ERROR_WI_FI_REQUIRED = 8

class StorePurchaseStatus(enum.IntEnum):
    SUCCEEDED = 0
    ALREADY_PURCHASED = 1
    NOT_PURCHASED = 2
    NETWORK_ERROR = 3
    SERVER_ERROR = 4

class StoreQueueItemExtendedState(enum.IntEnum):
    ACTIVE_PENDING = 0
    ACTIVE_STARTING = 1
    ACTIVE_ACQUIRING_LICENSE = 2
    ACTIVE_DOWNLOADING = 3
    ACTIVE_RESTORING_DATA = 4
    ACTIVE_INSTALLING = 5
    COMPLETED = 6
    CANCELED = 7
    PAUSED = 8
    ERROR = 9
    PAUSED_PACKAGES_IN_USE = 10
    PAUSED_LOW_BATTERY = 11
    PAUSED_WI_FI_RECOMMENDED = 12
    PAUSED_WI_FI_REQUIRED = 13
    PAUSED_READY_TO_INSTALL = 14

class StoreQueueItemKind(enum.IntEnum):
    INSTALL = 0
    UPDATE = 1
    REPAIR = 2

class StoreQueueItemState(enum.IntEnum):
    ACTIVE = 0
    COMPLETED = 1
    CANCELED = 2
    ERROR = 3
    PAUSED = 4

class StoreRateAndReviewStatus(enum.IntEnum):
    SUCCEEDED = 0
    CANCELED_BY_USER = 1
    NETWORK_ERROR = 2
    ERROR = 3

class StoreUninstallStorePackageStatus(enum.IntEnum):
    SUCCEEDED = 0
    CANCELED_BY_USER = 1
    NETWORK_ERROR = 2
    UNINSTALL_NOT_APPLICABLE = 3
    ERROR = 4

class StorePackageUpdateStatus(_winrt.winrt_base):
    ...

class StoreAcquireLicenseResult(_winrt.winrt_base):
    ...
    extended_error: winrt.windows.foundation.HResult
    store_package_license: StorePackageLicense

class StoreAppLicense(_winrt.winrt_base):
    ...
    add_on_licenses: winrt.windows.foundation.collections.IMapView[str, StoreLicense]
    expiration_date: winrt.windows.foundation.DateTime
    extended_json_data: str
    is_active: bool
    is_trial: bool
    is_trial_owned_by_this_user: bool
    sku_store_id: str
    trial_time_remaining: winrt.windows.foundation.TimeSpan
    trial_unique_id: str
    is_disc_license: bool

class StoreAvailability(_winrt.winrt_base):
    ...
    end_date: winrt.windows.foundation.DateTime
    extended_json_data: str
    price: StorePrice
    store_id: str
    def request_purchase_async() -> winrt.windows.foundation.IAsyncOperation[StorePurchaseResult]:
        ...
    def request_purchase_async(store_purchase_properties: StorePurchaseProperties) -> winrt.windows.foundation.IAsyncOperation[StorePurchaseResult]:
        ...

class StoreCanAcquireLicenseResult(_winrt.winrt_base):
    ...
    extended_error: winrt.windows.foundation.HResult
    licensable_sku: str
    status: StoreCanLicenseStatus

class StoreCollectionData(_winrt.winrt_base):
    ...
    acquired_date: winrt.windows.foundation.DateTime
    campaign_id: str
    developer_offer_id: str
    end_date: winrt.windows.foundation.DateTime
    extended_json_data: str
    is_trial: bool
    start_date: winrt.windows.foundation.DateTime
    trial_time_remaining: winrt.windows.foundation.TimeSpan

class StoreConsumableResult(_winrt.winrt_base):
    ...
    balance_remaining: int
    extended_error: winrt.windows.foundation.HResult
    status: StoreConsumableStatus
    tracking_id: uuid.UUID

class StoreContext(_winrt.winrt_base):
    ...
    user: winrt.windows.system.User
    can_silently_download_store_package_updates: bool
    def acquire_store_license_for_optional_package_async(optional_package: winrt.windows.applicationmodel.Package) -> winrt.windows.foundation.IAsyncOperation[StoreAcquireLicenseResult]:
        ...
    def can_acquire_store_license_async(product_store_id: str) -> winrt.windows.foundation.IAsyncOperation[StoreCanAcquireLicenseResult]:
        ...
    def can_acquire_store_license_for_optional_package_async(optional_package: winrt.windows.applicationmodel.Package) -> winrt.windows.foundation.IAsyncOperation[StoreCanAcquireLicenseResult]:
        ...
    def download_and_install_store_packages_async(store_ids: typing.Iterable[str]) -> winrt.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]:
        ...
    def find_store_product_for_package_async(product_kinds: typing.Iterable[str], package: winrt.windows.applicationmodel.Package) -> winrt.windows.foundation.IAsyncOperation[StoreProductResult]:
        ...
    def get_app_and_optional_store_package_updates_async() -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StorePackageUpdate]]:
        ...
    def get_app_license_async() -> winrt.windows.foundation.IAsyncOperation[StoreAppLicense]:
        ...
    def get_associated_store_products_async(product_kinds: typing.Iterable[str]) -> winrt.windows.foundation.IAsyncOperation[StoreProductQueryResult]:
        ...
    def get_associated_store_products_with_paging_async(product_kinds: typing.Iterable[str], max_items_to_retrieve_per_page: int) -> winrt.windows.foundation.IAsyncOperation[StoreProductPagedQueryResult]:
        ...
    def get_associated_store_queue_items_async() -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StoreQueueItem]]:
        ...
    def get_consumable_balance_remaining_async(product_store_id: str) -> winrt.windows.foundation.IAsyncOperation[StoreConsumableResult]:
        ...
    def get_customer_collections_id_async(service_ticket: str, publisher_user_id: str) -> winrt.windows.foundation.IAsyncOperation[str]:
        ...
    def get_customer_purchase_id_async(service_ticket: str, publisher_user_id: str) -> winrt.windows.foundation.IAsyncOperation[str]:
        ...
    def get_default() -> StoreContext:
        ...
    def get_for_user(user: winrt.windows.system.User) -> StoreContext:
        ...
    def get_store_product_for_current_app_async() -> winrt.windows.foundation.IAsyncOperation[StoreProductResult]:
        ...
    def get_store_products_async(product_kinds: typing.Iterable[str], store_ids: typing.Iterable[str]) -> winrt.windows.foundation.IAsyncOperation[StoreProductQueryResult]:
        ...
    def get_store_products_async(product_kinds: typing.Iterable[str], store_ids: typing.Iterable[str], store_product_options: StoreProductOptions) -> winrt.windows.foundation.IAsyncOperation[StoreProductQueryResult]:
        ...
    def get_store_queue_items_async(store_ids: typing.Iterable[str]) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StoreQueueItem]]:
        ...
    def get_user_collection_async(product_kinds: typing.Iterable[str]) -> winrt.windows.foundation.IAsyncOperation[StoreProductQueryResult]:
        ...
    def get_user_collection_with_paging_async(product_kinds: typing.Iterable[str], max_items_to_retrieve_per_page: int) -> winrt.windows.foundation.IAsyncOperation[StoreProductPagedQueryResult]:
        ...
    def report_consumable_fulfillment_async(product_store_id: str, quantity: int, tracking_id: uuid.UUID) -> winrt.windows.foundation.IAsyncOperation[StoreConsumableResult]:
        ...
    def request_download_and_install_store_package_updates_async(store_package_updates: typing.Iterable[StorePackageUpdate]) -> winrt.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]:
        ...
    def request_download_and_install_store_packages_async(store_ids: typing.Iterable[str]) -> winrt.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]:
        ...
    def request_download_and_install_store_packages_async(store_ids: typing.Iterable[str], store_package_install_options: StorePackageInstallOptions) -> winrt.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]:
        ...
    def request_download_store_package_updates_async(store_package_updates: typing.Iterable[StorePackageUpdate]) -> winrt.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]:
        ...
    def request_purchase_async(store_id: str) -> winrt.windows.foundation.IAsyncOperation[StorePurchaseResult]:
        ...
    def request_purchase_async(store_id: str, store_purchase_properties: StorePurchaseProperties) -> winrt.windows.foundation.IAsyncOperation[StorePurchaseResult]:
        ...
    def request_rate_and_review_app_async() -> winrt.windows.foundation.IAsyncOperation[StoreRateAndReviewResult]:
        ...
    def request_uninstall_store_package_async(package: winrt.windows.applicationmodel.Package) -> winrt.windows.foundation.IAsyncOperation[StoreUninstallStorePackageResult]:
        ...
    def request_uninstall_store_package_by_store_id_async(store_id: str) -> winrt.windows.foundation.IAsyncOperation[StoreUninstallStorePackageResult]:
        ...
    def set_install_order_for_associated_store_queue_items_async(items: typing.Iterable[StoreQueueItem]) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[StoreQueueItem]]:
        ...
    def try_silent_download_and_install_store_package_updates_async(store_package_updates: typing.Iterable[StorePackageUpdate]) -> winrt.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]:
        ...
    def try_silent_download_store_package_updates_async(store_package_updates: typing.Iterable[StorePackageUpdate]) -> winrt.windows.foundation.IAsyncOperationWithProgress[StorePackageUpdateResult, StorePackageUpdateStatus]:
        ...
    def uninstall_store_package_async(package: winrt.windows.applicationmodel.Package) -> winrt.windows.foundation.IAsyncOperation[StoreUninstallStorePackageResult]:
        ...
    def uninstall_store_package_by_store_id_async(store_id: str) -> winrt.windows.foundation.IAsyncOperation[StoreUninstallStorePackageResult]:
        ...
    def add_offline_licenses_changed(handler: winrt.windows.foundation.TypedEventHandler[StoreContext, _winrt.winrt_base]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_offline_licenses_changed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class StoreImage(_winrt.winrt_base):
    ...
    caption: str
    height: int
    image_purpose_tag: str
    uri: winrt.windows.foundation.Uri
    width: int

class StoreLicense(_winrt.winrt_base):
    ...
    expiration_date: winrt.windows.foundation.DateTime
    extended_json_data: str
    in_app_offer_token: str
    is_active: bool
    sku_store_id: str

class StorePackageInstallOptions(_winrt.winrt_base):
    ...
    allow_forced_app_restart: bool

class StorePackageLicense(winrt.windows.foundation.IClosable, _winrt.winrt_base):
    ...
    is_valid: bool
    package: winrt.windows.applicationmodel.Package
    def close() -> None:
        ...
    def release_license() -> None:
        ...
    def add_license_lost(handler: winrt.windows.foundation.TypedEventHandler[StorePackageLicense, _winrt.winrt_base]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_license_lost(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class StorePackageUpdate(_winrt.winrt_base):
    ...
    mandatory: bool
    package: winrt.windows.applicationmodel.Package

class StorePackageUpdateResult(_winrt.winrt_base):
    ...
    overall_state: StorePackageUpdateState
    store_package_update_statuses: winrt.windows.foundation.collections.IVectorView[StorePackageUpdateStatus]
    store_queue_items: winrt.windows.foundation.collections.IVectorView[StoreQueueItem]

class StorePrice(_winrt.winrt_base):
    ...
    currency_code: str
    formatted_base_price: str
    formatted_price: str
    formatted_recurrence_price: str
    is_on_sale: bool
    sale_end_date: winrt.windows.foundation.DateTime

class StoreProduct(_winrt.winrt_base):
    ...
    description: str
    extended_json_data: str
    has_digital_download: bool
    images: winrt.windows.foundation.collections.IVectorView[StoreImage]
    in_app_offer_token: str
    is_in_user_collection: bool
    keywords: winrt.windows.foundation.collections.IVectorView[str]
    language: str
    link_uri: winrt.windows.foundation.Uri
    price: StorePrice
    product_kind: str
    skus: winrt.windows.foundation.collections.IVectorView[StoreSku]
    store_id: str
    title: str
    videos: winrt.windows.foundation.collections.IVectorView[StoreVideo]
    def get_is_any_sku_installed_async() -> winrt.windows.foundation.IAsyncOperation[bool]:
        ...
    def request_purchase_async() -> winrt.windows.foundation.IAsyncOperation[StorePurchaseResult]:
        ...
    def request_purchase_async(store_purchase_properties: StorePurchaseProperties) -> winrt.windows.foundation.IAsyncOperation[StorePurchaseResult]:
        ...

class StoreProductOptions(_winrt.winrt_base):
    ...
    action_filters: winrt.windows.foundation.collections.IVector[str]

class StoreProductPagedQueryResult(_winrt.winrt_base):
    ...
    extended_error: winrt.windows.foundation.HResult
    has_more_results: bool
    products: winrt.windows.foundation.collections.IMapView[str, StoreProduct]
    def get_next_async() -> winrt.windows.foundation.IAsyncOperation[StoreProductPagedQueryResult]:
        ...

class StoreProductQueryResult(_winrt.winrt_base):
    ...
    extended_error: winrt.windows.foundation.HResult
    products: winrt.windows.foundation.collections.IMapView[str, StoreProduct]

class StoreProductResult(_winrt.winrt_base):
    ...
    extended_error: winrt.windows.foundation.HResult
    product: StoreProduct

class StorePurchaseProperties(_winrt.winrt_base):
    ...
    name: str
    extended_json_data: str

class StorePurchaseResult(_winrt.winrt_base):
    ...
    extended_error: winrt.windows.foundation.HResult
    status: StorePurchaseStatus

class StoreQueueItem(_winrt.winrt_base):
    ...
    install_kind: StoreQueueItemKind
    package_family_name: str
    product_id: str
    def cancel_install_async() -> winrt.windows.foundation.IAsyncAction:
        ...
    def get_current_status() -> StoreQueueItemStatus:
        ...
    def pause_install_async() -> winrt.windows.foundation.IAsyncAction:
        ...
    def resume_install_async() -> winrt.windows.foundation.IAsyncAction:
        ...
    def add_completed(handler: winrt.windows.foundation.TypedEventHandler[StoreQueueItem, StoreQueueItemCompletedEventArgs]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_completed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...
    def add_status_changed(handler: winrt.windows.foundation.TypedEventHandler[StoreQueueItem, _winrt.winrt_base]) -> winrt.windows.foundation.EventRegistrationToken:
        ...
    def remove_status_changed(token: winrt.windows.foundation.EventRegistrationToken) -> None:
        ...

class StoreQueueItemCompletedEventArgs(_winrt.winrt_base):
    ...
    status: StoreQueueItemStatus

class StoreQueueItemStatus(_winrt.winrt_base):
    ...
    extended_error: winrt.windows.foundation.HResult
    package_install_extended_state: StoreQueueItemExtendedState
    package_install_state: StoreQueueItemState
    update_status: StorePackageUpdateStatus

class StoreRateAndReviewResult(_winrt.winrt_base):
    ...
    extended_error: winrt.windows.foundation.HResult
    extended_json_data: str
    status: StoreRateAndReviewStatus
    was_updated: bool

class StoreRequestHelper(_winrt.winrt_base):
    ...
    def send_request_async(context: StoreContext, request_kind: int, parameters_as_json: str) -> winrt.windows.foundation.IAsyncOperation[StoreSendRequestResult]:
        ...

class StoreSendRequestResult(_winrt.winrt_base):
    ...
    extended_error: winrt.windows.foundation.HResult
    response: str
    http_status_code: winrt.windows.web.http.HttpStatusCode

class StoreSku(_winrt.winrt_base):
    ...
    availabilities: winrt.windows.foundation.collections.IVectorView[StoreAvailability]
    bundled_skus: winrt.windows.foundation.collections.IVectorView[str]
    collection_data: StoreCollectionData
    custom_developer_data: str
    description: str
    extended_json_data: str
    images: winrt.windows.foundation.collections.IVectorView[StoreImage]
    is_in_user_collection: bool
    is_subscription: bool
    is_trial: bool
    language: str
    price: StorePrice
    store_id: str
    subscription_info: StoreSubscriptionInfo
    title: str
    videos: winrt.windows.foundation.collections.IVectorView[StoreVideo]
    def get_is_installed_async() -> winrt.windows.foundation.IAsyncOperation[bool]:
        ...
    def request_purchase_async() -> winrt.windows.foundation.IAsyncOperation[StorePurchaseResult]:
        ...
    def request_purchase_async(store_purchase_properties: StorePurchaseProperties) -> winrt.windows.foundation.IAsyncOperation[StorePurchaseResult]:
        ...

class StoreSubscriptionInfo(_winrt.winrt_base):
    ...
    billing_period: int
    billing_period_unit: StoreDurationUnit
    has_trial_period: bool
    trial_period: int
    trial_period_unit: StoreDurationUnit

class StoreUninstallStorePackageResult(_winrt.winrt_base):
    ...
    extended_error: winrt.windows.foundation.HResult
    status: StoreUninstallStorePackageStatus

class StoreVideo(_winrt.winrt_base):
    ...
    caption: str
    height: int
    preview_image: StoreImage
    uri: winrt.windows.foundation.Uri
    video_purpose_tag: str
    width: int

