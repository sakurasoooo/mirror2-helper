# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

import enum
import typing
import uuid

import winrt._winrt as _winrt
try:
    import winrt.windows.foundation
except Exception:
    pass

try:
    import winrt.windows.foundation.collections
except Exception:
    pass

try:
    import winrt.windows.networking
except Exception:
    pass

try:
    import winrt.windows.storage.streams
except Exception:
    pass

class CertificateChainPolicy(enum.IntEnum):
    BASE = 0
    SSL = 1
    N_T_AUTHENTICATION = 2
    MICROSOFT_ROOT = 3

class ChainValidationResult(enum.IntEnum):
    SUCCESS = 0
    UNTRUSTED = 1
    REVOKED = 2
    EXPIRED = 3
    INCOMPLETE_CHAIN = 4
    INVALID_SIGNATURE = 5
    WRONG_USAGE = 6
    INVALID_NAME = 7
    INVALID_CERTIFICATE_AUTHORITY_POLICY = 8
    BASIC_CONSTRAINTS_ERROR = 9
    UNKNOWN_CRITICAL_EXTENSION = 10
    REVOCATION_INFORMATION_MISSING = 11
    REVOCATION_FAILURE = 12
    OTHER_ERRORS = 13

class EnrollKeyUsages(enum.IntFlag):
    NONE = 0
    DECRYPTION = 0x1
    SIGNING = 0x2
    KEY_AGREEMENT = 0x4
    ALL = 0xffffff

class ExportOption(enum.IntEnum):
    NOT_EXPORTABLE = 0
    EXPORTABLE = 1

class InstallOptions(enum.IntFlag):
    NONE = 0
    DELETE_EXPIRED = 0x1

class KeyProtectionLevel(enum.IntEnum):
    NO_CONSENT = 0
    CONSENT_ONLY = 1
    CONSENT_WITH_PASSWORD = 2
    CONSENT_WITH_FINGERPRINT = 3

class KeySize(enum.IntEnum):
    INVALID = 0
    RSA2048 = 2048
    RSA4096 = 4096

class SignatureValidationResult(enum.IntEnum):
    SUCCESS = 0
    INVALID_PARAMETER = 1
    BAD_MESSAGE = 2
    INVALID_SIGNATURE = 3
    OTHER_ERRORS = 4

class Certificate(_winrt.winrt_base):
    ...
    friendly_name: str
    enhanced_key_usages: winrt.windows.foundation.collections.IVectorView[str]
    has_private_key: bool
    is_strongly_protected: bool
    issuer: str
    serial_number: int
    subject: str
    valid_from: winrt.windows.foundation.DateTime
    valid_to: winrt.windows.foundation.DateTime
    is_security_device_bound: bool
    key_algorithm_name: str
    key_usages: CertificateKeyUsages
    signature_algorithm_name: str
    signature_hash_algorithm_name: str
    subject_alternative_name: SubjectAlternativeNameInfo
    is_per_user: bool
    key_storage_provider_name: str
    store_name: str
    def build_chain_async(certificates: typing.Iterable[Certificate]) -> winrt.windows.foundation.IAsyncOperation[CertificateChain]:
        ...
    def build_chain_async(certificates: typing.Iterable[Certificate], parameters: ChainBuildingParameters) -> winrt.windows.foundation.IAsyncOperation[CertificateChain]:
        ...
    def get_certificate_blob() -> winrt.windows.storage.streams.IBuffer:
        ...
    def get_hash_value() -> int:
        ...
    def get_hash_value(hash_algorithm_name: str) -> int:
        ...

class CertificateChain(_winrt.winrt_base):
    ...
    def get_certificates(include_root: bool) -> winrt.windows.foundation.collections.IVectorView[Certificate]:
        ...
    def validate() -> ChainValidationResult:
        ...
    def validate(parameter: ChainValidationParameters) -> ChainValidationResult:
        ...

class CertificateEnrollmentManager(_winrt.winrt_base):
    ...
    user_certificate_enrollment_manager: UserCertificateEnrollmentManager
    def create_request_async(request: CertificateRequestProperties) -> winrt.windows.foundation.IAsyncOperation[str]:
        ...
    def import_pfx_data_async(pfx_data: str, password: str, pfx_import_parameters: PfxImportParameters) -> winrt.windows.foundation.IAsyncAction:
        ...
    def import_pfx_data_async(pfx_data: str, password: str, exportable: ExportOption, key_protection_level: KeyProtectionLevel, install_option: InstallOptions, friendly_name: str) -> winrt.windows.foundation.IAsyncAction:
        ...
    def import_pfx_data_async(pfx_data: str, password: str, exportable: ExportOption, key_protection_level: KeyProtectionLevel, install_option: InstallOptions, friendly_name: str, key_storage_provider: str) -> winrt.windows.foundation.IAsyncAction:
        ...
    def install_certificate_async(certificate: str, install_option: InstallOptions) -> winrt.windows.foundation.IAsyncAction:
        ...

class CertificateExtension(_winrt.winrt_base):
    ...
    value: int
    object_id: str
    is_critical: bool
    def encode_value(value: str) -> None:
        ...

class CertificateKeyUsages(_winrt.winrt_base):
    ...
    non_repudiation: bool
    key_encipherment: bool
    key_certificate_sign: bool
    key_agreement: bool
    encipher_only: bool
    digital_signature: bool
    data_encipherment: bool
    crl_sign: bool

class CertificateQuery(_winrt.winrt_base):
    ...
    thumbprint: int
    issuer_name: str
    hardware_only: bool
    friendly_name: str
    enhanced_key_usages: winrt.windows.foundation.collections.IVector[str]
    store_name: str
    include_expired_certificates: bool
    include_duplicates: bool

class CertificateRequestProperties(_winrt.winrt_base):
    ...
    subject: str
    key_usages: EnrollKeyUsages
    key_storage_provider_name: str
    key_size: int
    exportable: ExportOption
    key_protection_level: KeyProtectionLevel
    key_algorithm_name: str
    hash_algorithm_name: str
    friendly_name: str
    attestation_credential_certificate: Certificate
    signing_certificate: Certificate
    smartcard_reader_name: str
    use_existing_key: bool
    curve_parameters: int
    curve_name: str
    container_name_prefix: str
    container_name: str
    extensions: winrt.windows.foundation.collections.IVector[CertificateExtension]
    subject_alternative_name: SubjectAlternativeNameInfo
    suppressed_defaults: winrt.windows.foundation.collections.IVector[str]

class CertificateStore(_winrt.winrt_base):
    ...
    name: str
    def add(certificate: Certificate) -> None:
        ...
    def delete(certificate: Certificate) -> None:
        ...

class CertificateStores(_winrt.winrt_base):
    ...
    intermediate_certification_authorities: CertificateStore
    trusted_root_certification_authorities: CertificateStore
    def find_all_async() -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[Certificate]]:
        ...
    def find_all_async(query: CertificateQuery) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[Certificate]]:
        ...
    def get_store_by_name(store_name: str) -> CertificateStore:
        ...
    def get_user_store_by_name(store_name: str) -> UserCertificateStore:
        ...

class ChainBuildingParameters(_winrt.winrt_base):
    ...
    validation_timestamp: winrt.windows.foundation.DateTime
    revocation_check_enabled: bool
    network_retrieval_enabled: bool
    current_time_validation_enabled: bool
    authority_information_access_enabled: bool
    enhanced_key_usages: winrt.windows.foundation.collections.IVector[str]
    exclusive_trust_roots: winrt.windows.foundation.collections.IVector[Certificate]

class ChainValidationParameters(_winrt.winrt_base):
    ...
    server_dns_name: winrt.windows.networking.HostName
    certificate_chain_policy: CertificateChainPolicy

class CmsAttachedSignature(_winrt.winrt_base):
    ...
    certificates: winrt.windows.foundation.collections.IVectorView[Certificate]
    content: int
    signers: winrt.windows.foundation.collections.IVectorView[CmsSignerInfo]
    def generate_signature_async(data: winrt.windows.storage.streams.IBuffer, signers: typing.Iterable[CmsSignerInfo], certificates: typing.Iterable[Certificate]) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IBuffer]:
        ...
    def verify_signature() -> SignatureValidationResult:
        ...

class CmsDetachedSignature(_winrt.winrt_base):
    ...
    certificates: winrt.windows.foundation.collections.IVectorView[Certificate]
    signers: winrt.windows.foundation.collections.IVectorView[CmsSignerInfo]
    def generate_signature_async(data: winrt.windows.storage.streams.IInputStream, signers: typing.Iterable[CmsSignerInfo], certificates: typing.Iterable[Certificate]) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.streams.IBuffer]:
        ...
    def verify_signature_async(data: winrt.windows.storage.streams.IInputStream) -> winrt.windows.foundation.IAsyncOperation[SignatureValidationResult]:
        ...

class CmsSignerInfo(_winrt.winrt_base):
    ...
    hash_algorithm_name: str
    certificate: Certificate
    timestamp_info: CmsTimestampInfo

class CmsTimestampInfo(_winrt.winrt_base):
    ...
    certificates: winrt.windows.foundation.collections.IVectorView[Certificate]
    signing_certificate: Certificate
    timestamp: winrt.windows.foundation.DateTime

class KeyAlgorithmNames(_winrt.winrt_base):
    ...
    dsa: str
    ecdh256: str
    ecdh384: str
    ecdh521: str
    ecdsa256: str
    ecdsa384: str
    ecdsa521: str
    rsa: str
    ecdh: str
    ecdsa: str

class KeyAttestationHelper(_winrt.winrt_base):
    ...
    def decrypt_tpm_attestation_credential_async(credential: str) -> winrt.windows.foundation.IAsyncOperation[str]:
        ...
    def decrypt_tpm_attestation_credential_async(credential: str, container_name: str) -> winrt.windows.foundation.IAsyncOperation[str]:
        ...
    def get_tpm_attestation_credential_id(credential: str) -> str:
        ...

class KeyStorageProviderNames(_winrt.winrt_base):
    ...
    platform_key_storage_provider: str
    smartcard_key_storage_provider: str
    software_key_storage_provider: str
    passport_key_storage_provider: str

class PfxImportParameters(_winrt.winrt_base):
    ...
    reader_name: str
    key_storage_provider_name: str
    key_protection_level: KeyProtectionLevel
    install_options: InstallOptions
    friendly_name: str
    exportable: ExportOption
    container_name_prefix: str

class StandardCertificateStoreNames(_winrt.winrt_base):
    ...
    intermediate_certification_authorities: str
    personal: str
    trusted_root_certification_authorities: str

class SubjectAlternativeNameInfo(_winrt.winrt_base):
    ...
    distinguished_name: winrt.windows.foundation.collections.IVectorView[str]
    dns_name: winrt.windows.foundation.collections.IVectorView[str]
    email_name: winrt.windows.foundation.collections.IVectorView[str]
    ip_address: winrt.windows.foundation.collections.IVectorView[str]
    principal_name: winrt.windows.foundation.collections.IVectorView[str]
    url: winrt.windows.foundation.collections.IVectorView[str]
    distinguished_names: winrt.windows.foundation.collections.IVector[str]
    dns_names: winrt.windows.foundation.collections.IVector[str]
    email_names: winrt.windows.foundation.collections.IVector[str]
    extension: CertificateExtension
    ip_addresses: winrt.windows.foundation.collections.IVector[str]
    principal_names: winrt.windows.foundation.collections.IVector[str]
    urls: winrt.windows.foundation.collections.IVector[str]

class UserCertificateEnrollmentManager(_winrt.winrt_base):
    ...
    def create_request_async(request: CertificateRequestProperties) -> winrt.windows.foundation.IAsyncOperation[str]:
        ...
    def import_pfx_data_async(pfx_data: str, password: str, pfx_import_parameters: PfxImportParameters) -> winrt.windows.foundation.IAsyncAction:
        ...
    def import_pfx_data_async(pfx_data: str, password: str, exportable: ExportOption, key_protection_level: KeyProtectionLevel, install_option: InstallOptions, friendly_name: str) -> winrt.windows.foundation.IAsyncAction:
        ...
    def import_pfx_data_async(pfx_data: str, password: str, exportable: ExportOption, key_protection_level: KeyProtectionLevel, install_option: InstallOptions, friendly_name: str, key_storage_provider: str) -> winrt.windows.foundation.IAsyncAction:
        ...
    def install_certificate_async(certificate: str, install_option: InstallOptions) -> winrt.windows.foundation.IAsyncAction:
        ...

class UserCertificateStore(_winrt.winrt_base):
    ...
    name: str
    def request_add_async(certificate: Certificate) -> winrt.windows.foundation.IAsyncOperation[bool]:
        ...
    def request_delete_async(certificate: Certificate) -> winrt.windows.foundation.IAsyncOperation[bool]:
        ...

