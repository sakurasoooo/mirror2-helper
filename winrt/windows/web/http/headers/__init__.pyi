# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

import typing
import uuid

import winrt._winrt as _winrt
try:
    import winrt.windows.foundation
except Exception:
    pass

try:
    import winrt.windows.foundation.collections
except Exception:
    pass

try:
    import winrt.windows.globalization
except Exception:
    pass

try:
    import winrt.windows.networking
except Exception:
    pass

try:
    import winrt.windows.storage.streams
except Exception:
    pass

try:
    import winrt.windows.web.http
except Exception:
    pass

class HttpCacheDirectiveHeaderValueCollection(winrt.windows.foundation.collections.IVector[HttpNameValueHeaderValue], winrt.windows.foundation.collections.IIterable[HttpNameValueHeaderValue], winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    size: int
    shared_max_age: typing.Optional[winrt.windows.foundation.TimeSpan]
    min_fresh: typing.Optional[winrt.windows.foundation.TimeSpan]
    max_stale: typing.Optional[winrt.windows.foundation.TimeSpan]
    max_age: typing.Optional[winrt.windows.foundation.TimeSpan]
    def append(value: HttpNameValueHeaderValue) -> None:
        ...
    def clear() -> None:
        ...
    def first() -> winrt.windows.foundation.collections.IIterator[HttpNameValueHeaderValue]:
        ...
    def get_at(index: int) -> HttpNameValueHeaderValue:
        ...
    def get_many(start_index: int, items_size: int) -> typing.Tuple[int, typing.List[HttpNameValueHeaderValue]]:
        ...
    def get_view() -> winrt.windows.foundation.collections.IVectorView[HttpNameValueHeaderValue]:
        ...
    def index_of(value: HttpNameValueHeaderValue) -> typing.Tuple[bool, int]:
        ...
    def insert_at(index: int, value: HttpNameValueHeaderValue) -> None:
        ...
    def parse_add(input: str) -> None:
        ...
    def remove_at(index: int) -> None:
        ...
    def remove_at_end() -> None:
        ...
    def replace_all(items: typing.Sequence[HttpNameValueHeaderValue]) -> None:
        ...
    def set_at(index: int, value: HttpNameValueHeaderValue) -> None:
        ...
    def to_string() -> str:
        ...
    def try_parse_add(input: str) -> bool:
        ...

class HttpChallengeHeaderValue(winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    parameters: winrt.windows.foundation.collections.IVector[HttpNameValueHeaderValue]
    scheme: str
    token: str
    def parse(input: str) -> HttpChallengeHeaderValue:
        ...
    def to_string() -> str:
        ...
    def try_parse(input: str) -> typing.Tuple[bool, HttpChallengeHeaderValue]:
        ...

class HttpChallengeHeaderValueCollection(winrt.windows.foundation.collections.IVector[HttpChallengeHeaderValue], winrt.windows.foundation.collections.IIterable[HttpChallengeHeaderValue], winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    size: int
    def append(value: HttpChallengeHeaderValue) -> None:
        ...
    def clear() -> None:
        ...
    def first() -> winrt.windows.foundation.collections.IIterator[HttpChallengeHeaderValue]:
        ...
    def get_at(index: int) -> HttpChallengeHeaderValue:
        ...
    def get_many(start_index: int, items_size: int) -> typing.Tuple[int, typing.List[HttpChallengeHeaderValue]]:
        ...
    def get_view() -> winrt.windows.foundation.collections.IVectorView[HttpChallengeHeaderValue]:
        ...
    def index_of(value: HttpChallengeHeaderValue) -> typing.Tuple[bool, int]:
        ...
    def insert_at(index: int, value: HttpChallengeHeaderValue) -> None:
        ...
    def parse_add(input: str) -> None:
        ...
    def remove_at(index: int) -> None:
        ...
    def remove_at_end() -> None:
        ...
    def replace_all(items: typing.Sequence[HttpChallengeHeaderValue]) -> None:
        ...
    def set_at(index: int, value: HttpChallengeHeaderValue) -> None:
        ...
    def to_string() -> str:
        ...
    def try_parse_add(input: str) -> bool:
        ...

class HttpConnectionOptionHeaderValue(winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    token: str
    def parse(input: str) -> HttpConnectionOptionHeaderValue:
        ...
    def to_string() -> str:
        ...
    def try_parse(input: str) -> typing.Tuple[bool, HttpConnectionOptionHeaderValue]:
        ...

class HttpConnectionOptionHeaderValueCollection(winrt.windows.foundation.collections.IVector[HttpConnectionOptionHeaderValue], winrt.windows.foundation.collections.IIterable[HttpConnectionOptionHeaderValue], winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    size: int
    def append(value: HttpConnectionOptionHeaderValue) -> None:
        ...
    def clear() -> None:
        ...
    def first() -> winrt.windows.foundation.collections.IIterator[HttpConnectionOptionHeaderValue]:
        ...
    def get_at(index: int) -> HttpConnectionOptionHeaderValue:
        ...
    def get_many(start_index: int, items_size: int) -> typing.Tuple[int, typing.List[HttpConnectionOptionHeaderValue]]:
        ...
    def get_view() -> winrt.windows.foundation.collections.IVectorView[HttpConnectionOptionHeaderValue]:
        ...
    def index_of(value: HttpConnectionOptionHeaderValue) -> typing.Tuple[bool, int]:
        ...
    def insert_at(index: int, value: HttpConnectionOptionHeaderValue) -> None:
        ...
    def parse_add(input: str) -> None:
        ...
    def remove_at(index: int) -> None:
        ...
    def remove_at_end() -> None:
        ...
    def replace_all(items: typing.Sequence[HttpConnectionOptionHeaderValue]) -> None:
        ...
    def set_at(index: int, value: HttpConnectionOptionHeaderValue) -> None:
        ...
    def to_string() -> str:
        ...
    def try_parse_add(input: str) -> bool:
        ...

class HttpContentCodingHeaderValue(winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    content_coding: str
    def parse(input: str) -> HttpContentCodingHeaderValue:
        ...
    def to_string() -> str:
        ...
    def try_parse(input: str) -> typing.Tuple[bool, HttpContentCodingHeaderValue]:
        ...

class HttpContentCodingHeaderValueCollection(winrt.windows.foundation.collections.IVector[HttpContentCodingHeaderValue], winrt.windows.foundation.collections.IIterable[HttpContentCodingHeaderValue], winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    size: int
    def append(value: HttpContentCodingHeaderValue) -> None:
        ...
    def clear() -> None:
        ...
    def first() -> winrt.windows.foundation.collections.IIterator[HttpContentCodingHeaderValue]:
        ...
    def get_at(index: int) -> HttpContentCodingHeaderValue:
        ...
    def get_many(start_index: int, items_size: int) -> typing.Tuple[int, typing.List[HttpContentCodingHeaderValue]]:
        ...
    def get_view() -> winrt.windows.foundation.collections.IVectorView[HttpContentCodingHeaderValue]:
        ...
    def index_of(value: HttpContentCodingHeaderValue) -> typing.Tuple[bool, int]:
        ...
    def insert_at(index: int, value: HttpContentCodingHeaderValue) -> None:
        ...
    def parse_add(input: str) -> None:
        ...
    def remove_at(index: int) -> None:
        ...
    def remove_at_end() -> None:
        ...
    def replace_all(items: typing.Sequence[HttpContentCodingHeaderValue]) -> None:
        ...
    def set_at(index: int, value: HttpContentCodingHeaderValue) -> None:
        ...
    def to_string() -> str:
        ...
    def try_parse_add(input: str) -> bool:
        ...

class HttpContentCodingWithQualityHeaderValue(winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    content_coding: str
    quality: typing.Optional[float]
    def parse(input: str) -> HttpContentCodingWithQualityHeaderValue:
        ...
    def to_string() -> str:
        ...
    def try_parse(input: str) -> typing.Tuple[bool, HttpContentCodingWithQualityHeaderValue]:
        ...

class HttpContentCodingWithQualityHeaderValueCollection(winrt.windows.foundation.collections.IVector[HttpContentCodingWithQualityHeaderValue], winrt.windows.foundation.collections.IIterable[HttpContentCodingWithQualityHeaderValue], winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    size: int
    def append(value: HttpContentCodingWithQualityHeaderValue) -> None:
        ...
    def clear() -> None:
        ...
    def first() -> winrt.windows.foundation.collections.IIterator[HttpContentCodingWithQualityHeaderValue]:
        ...
    def get_at(index: int) -> HttpContentCodingWithQualityHeaderValue:
        ...
    def get_many(start_index: int, items_size: int) -> typing.Tuple[int, typing.List[HttpContentCodingWithQualityHeaderValue]]:
        ...
    def get_view() -> winrt.windows.foundation.collections.IVectorView[HttpContentCodingWithQualityHeaderValue]:
        ...
    def index_of(value: HttpContentCodingWithQualityHeaderValue) -> typing.Tuple[bool, int]:
        ...
    def insert_at(index: int, value: HttpContentCodingWithQualityHeaderValue) -> None:
        ...
    def parse_add(input: str) -> None:
        ...
    def remove_at(index: int) -> None:
        ...
    def remove_at_end() -> None:
        ...
    def replace_all(items: typing.Sequence[HttpContentCodingWithQualityHeaderValue]) -> None:
        ...
    def set_at(index: int, value: HttpContentCodingWithQualityHeaderValue) -> None:
        ...
    def to_string() -> str:
        ...
    def try_parse_add(input: str) -> bool:
        ...

class HttpContentDispositionHeaderValue(winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    size: typing.Optional[int]
    name: str
    file_name_star: str
    file_name: str
    disposition_type: str
    parameters: winrt.windows.foundation.collections.IVector[HttpNameValueHeaderValue]
    def parse(input: str) -> HttpContentDispositionHeaderValue:
        ...
    def to_string() -> str:
        ...
    def try_parse(input: str) -> typing.Tuple[bool, HttpContentDispositionHeaderValue]:
        ...

class HttpContentHeaderCollection(winrt.windows.foundation.collections.IMap[str, str], winrt.windows.foundation.collections.IIterable[winrt.windows.foundation.collections.IKeyValuePair[str, str]], winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    size: int
    last_modified: typing.Optional[winrt.windows.foundation.DateTime]
    expires: typing.Optional[winrt.windows.foundation.DateTime]
    content_type: HttpMediaTypeHeaderValue
    content_range: HttpContentRangeHeaderValue
    content_m_d5: winrt.windows.storage.streams.IBuffer
    content_location: winrt.windows.foundation.Uri
    content_length: typing.Optional[int]
    content_disposition: HttpContentDispositionHeaderValue
    content_encoding: HttpContentCodingHeaderValueCollection
    content_language: HttpLanguageHeaderValueCollection
    def append(name: str, value: str) -> None:
        ...
    def clear() -> None:
        ...
    def first() -> winrt.windows.foundation.collections.IIterator[winrt.windows.foundation.collections.IKeyValuePair[str, str]]:
        ...
    def get_view() -> winrt.windows.foundation.collections.IMapView[str, str]:
        ...
    def has_key(key: str) -> bool:
        ...
    def insert(key: str, value: str) -> bool:
        ...
    def lookup(key: str) -> str:
        ...
    def remove(key: str) -> None:
        ...
    def to_string() -> str:
        ...
    def try_append_without_validation(name: str, value: str) -> bool:
        ...

class HttpContentRangeHeaderValue(winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    unit: str
    first_byte_position: typing.Optional[int]
    last_byte_position: typing.Optional[int]
    length: typing.Optional[int]
    def parse(input: str) -> HttpContentRangeHeaderValue:
        ...
    def to_string() -> str:
        ...
    def try_parse(input: str) -> typing.Tuple[bool, HttpContentRangeHeaderValue]:
        ...

class HttpCookiePairHeaderValue(winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    value: str
    name: str
    def parse(input: str) -> HttpCookiePairHeaderValue:
        ...
    def to_string() -> str:
        ...
    def try_parse(input: str) -> typing.Tuple[bool, HttpCookiePairHeaderValue]:
        ...

class HttpCookiePairHeaderValueCollection(winrt.windows.foundation.collections.IVector[HttpCookiePairHeaderValue], winrt.windows.foundation.collections.IIterable[HttpCookiePairHeaderValue], winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    size: int
    def append(value: HttpCookiePairHeaderValue) -> None:
        ...
    def clear() -> None:
        ...
    def first() -> winrt.windows.foundation.collections.IIterator[HttpCookiePairHeaderValue]:
        ...
    def get_at(index: int) -> HttpCookiePairHeaderValue:
        ...
    def get_many(start_index: int, items_size: int) -> typing.Tuple[int, typing.List[HttpCookiePairHeaderValue]]:
        ...
    def get_view() -> winrt.windows.foundation.collections.IVectorView[HttpCookiePairHeaderValue]:
        ...
    def index_of(value: HttpCookiePairHeaderValue) -> typing.Tuple[bool, int]:
        ...
    def insert_at(index: int, value: HttpCookiePairHeaderValue) -> None:
        ...
    def parse_add(input: str) -> None:
        ...
    def remove_at(index: int) -> None:
        ...
    def remove_at_end() -> None:
        ...
    def replace_all(items: typing.Sequence[HttpCookiePairHeaderValue]) -> None:
        ...
    def set_at(index: int, value: HttpCookiePairHeaderValue) -> None:
        ...
    def to_string() -> str:
        ...
    def try_parse_add(input: str) -> bool:
        ...

class HttpCredentialsHeaderValue(winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    parameters: winrt.windows.foundation.collections.IVector[HttpNameValueHeaderValue]
    scheme: str
    token: str
    def parse(input: str) -> HttpCredentialsHeaderValue:
        ...
    def to_string() -> str:
        ...
    def try_parse(input: str) -> typing.Tuple[bool, HttpCredentialsHeaderValue]:
        ...

class HttpDateOrDeltaHeaderValue(winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    date: typing.Optional[winrt.windows.foundation.DateTime]
    delta: typing.Optional[winrt.windows.foundation.TimeSpan]
    def parse(input: str) -> HttpDateOrDeltaHeaderValue:
        ...
    def to_string() -> str:
        ...
    def try_parse(input: str) -> typing.Tuple[bool, HttpDateOrDeltaHeaderValue]:
        ...

class HttpExpectationHeaderValue(winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    value: str
    name: str
    parameters: winrt.windows.foundation.collections.IVector[HttpNameValueHeaderValue]
    def parse(input: str) -> HttpExpectationHeaderValue:
        ...
    def to_string() -> str:
        ...
    def try_parse(input: str) -> typing.Tuple[bool, HttpExpectationHeaderValue]:
        ...

class HttpExpectationHeaderValueCollection(winrt.windows.foundation.collections.IVector[HttpExpectationHeaderValue], winrt.windows.foundation.collections.IIterable[HttpExpectationHeaderValue], winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    size: int
    def append(value: HttpExpectationHeaderValue) -> None:
        ...
    def clear() -> None:
        ...
    def first() -> winrt.windows.foundation.collections.IIterator[HttpExpectationHeaderValue]:
        ...
    def get_at(index: int) -> HttpExpectationHeaderValue:
        ...
    def get_many(start_index: int, items_size: int) -> typing.Tuple[int, typing.List[HttpExpectationHeaderValue]]:
        ...
    def get_view() -> winrt.windows.foundation.collections.IVectorView[HttpExpectationHeaderValue]:
        ...
    def index_of(value: HttpExpectationHeaderValue) -> typing.Tuple[bool, int]:
        ...
    def insert_at(index: int, value: HttpExpectationHeaderValue) -> None:
        ...
    def parse_add(input: str) -> None:
        ...
    def remove_at(index: int) -> None:
        ...
    def remove_at_end() -> None:
        ...
    def replace_all(items: typing.Sequence[HttpExpectationHeaderValue]) -> None:
        ...
    def set_at(index: int, value: HttpExpectationHeaderValue) -> None:
        ...
    def to_string() -> str:
        ...
    def try_parse_add(input: str) -> bool:
        ...

class HttpLanguageHeaderValueCollection(winrt.windows.foundation.collections.IVector[winrt.windows.globalization.Language], winrt.windows.foundation.collections.IIterable[winrt.windows.globalization.Language], winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    size: int
    def append(value: winrt.windows.globalization.Language) -> None:
        ...
    def clear() -> None:
        ...
    def first() -> winrt.windows.foundation.collections.IIterator[winrt.windows.globalization.Language]:
        ...
    def get_at(index: int) -> winrt.windows.globalization.Language:
        ...
    def get_many(start_index: int, items_size: int) -> typing.Tuple[int, typing.List[winrt.windows.globalization.Language]]:
        ...
    def get_view() -> winrt.windows.foundation.collections.IVectorView[winrt.windows.globalization.Language]:
        ...
    def index_of(value: winrt.windows.globalization.Language) -> typing.Tuple[bool, int]:
        ...
    def insert_at(index: int, value: winrt.windows.globalization.Language) -> None:
        ...
    def parse_add(input: str) -> None:
        ...
    def remove_at(index: int) -> None:
        ...
    def remove_at_end() -> None:
        ...
    def replace_all(items: typing.Sequence[winrt.windows.globalization.Language]) -> None:
        ...
    def set_at(index: int, value: winrt.windows.globalization.Language) -> None:
        ...
    def to_string() -> str:
        ...
    def try_parse_add(input: str) -> bool:
        ...

class HttpLanguageRangeWithQualityHeaderValue(winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    language_range: str
    quality: typing.Optional[float]
    def parse(input: str) -> HttpLanguageRangeWithQualityHeaderValue:
        ...
    def to_string() -> str:
        ...
    def try_parse(input: str) -> typing.Tuple[bool, HttpLanguageRangeWithQualityHeaderValue]:
        ...

class HttpLanguageRangeWithQualityHeaderValueCollection(winrt.windows.foundation.collections.IVector[HttpLanguageRangeWithQualityHeaderValue], winrt.windows.foundation.collections.IIterable[HttpLanguageRangeWithQualityHeaderValue], winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    size: int
    def append(value: HttpLanguageRangeWithQualityHeaderValue) -> None:
        ...
    def clear() -> None:
        ...
    def first() -> winrt.windows.foundation.collections.IIterator[HttpLanguageRangeWithQualityHeaderValue]:
        ...
    def get_at(index: int) -> HttpLanguageRangeWithQualityHeaderValue:
        ...
    def get_many(start_index: int, items_size: int) -> typing.Tuple[int, typing.List[HttpLanguageRangeWithQualityHeaderValue]]:
        ...
    def get_view() -> winrt.windows.foundation.collections.IVectorView[HttpLanguageRangeWithQualityHeaderValue]:
        ...
    def index_of(value: HttpLanguageRangeWithQualityHeaderValue) -> typing.Tuple[bool, int]:
        ...
    def insert_at(index: int, value: HttpLanguageRangeWithQualityHeaderValue) -> None:
        ...
    def parse_add(input: str) -> None:
        ...
    def remove_at(index: int) -> None:
        ...
    def remove_at_end() -> None:
        ...
    def replace_all(items: typing.Sequence[HttpLanguageRangeWithQualityHeaderValue]) -> None:
        ...
    def set_at(index: int, value: HttpLanguageRangeWithQualityHeaderValue) -> None:
        ...
    def to_string() -> str:
        ...
    def try_parse_add(input: str) -> bool:
        ...

class HttpMediaTypeHeaderValue(winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    media_type: str
    char_set: str
    parameters: winrt.windows.foundation.collections.IVector[HttpNameValueHeaderValue]
    def parse(input: str) -> HttpMediaTypeHeaderValue:
        ...
    def to_string() -> str:
        ...
    def try_parse(input: str) -> typing.Tuple[bool, HttpMediaTypeHeaderValue]:
        ...

class HttpMediaTypeWithQualityHeaderValue(winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    quality: typing.Optional[float]
    media_type: str
    char_set: str
    parameters: winrt.windows.foundation.collections.IVector[HttpNameValueHeaderValue]
    def parse(input: str) -> HttpMediaTypeWithQualityHeaderValue:
        ...
    def to_string() -> str:
        ...
    def try_parse(input: str) -> typing.Tuple[bool, HttpMediaTypeWithQualityHeaderValue]:
        ...

class HttpMediaTypeWithQualityHeaderValueCollection(winrt.windows.foundation.collections.IVector[HttpMediaTypeWithQualityHeaderValue], winrt.windows.foundation.collections.IIterable[HttpMediaTypeWithQualityHeaderValue], winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    size: int
    def append(value: HttpMediaTypeWithQualityHeaderValue) -> None:
        ...
    def clear() -> None:
        ...
    def first() -> winrt.windows.foundation.collections.IIterator[HttpMediaTypeWithQualityHeaderValue]:
        ...
    def get_at(index: int) -> HttpMediaTypeWithQualityHeaderValue:
        ...
    def get_many(start_index: int, items_size: int) -> typing.Tuple[int, typing.List[HttpMediaTypeWithQualityHeaderValue]]:
        ...
    def get_view() -> winrt.windows.foundation.collections.IVectorView[HttpMediaTypeWithQualityHeaderValue]:
        ...
    def index_of(value: HttpMediaTypeWithQualityHeaderValue) -> typing.Tuple[bool, int]:
        ...
    def insert_at(index: int, value: HttpMediaTypeWithQualityHeaderValue) -> None:
        ...
    def parse_add(input: str) -> None:
        ...
    def remove_at(index: int) -> None:
        ...
    def remove_at_end() -> None:
        ...
    def replace_all(items: typing.Sequence[HttpMediaTypeWithQualityHeaderValue]) -> None:
        ...
    def set_at(index: int, value: HttpMediaTypeWithQualityHeaderValue) -> None:
        ...
    def to_string() -> str:
        ...
    def try_parse_add(input: str) -> bool:
        ...

class HttpMethodHeaderValueCollection(winrt.windows.foundation.collections.IVector[winrt.windows.web.http.HttpMethod], winrt.windows.foundation.collections.IIterable[winrt.windows.web.http.HttpMethod], winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    size: int
    def append(value: winrt.windows.web.http.HttpMethod) -> None:
        ...
    def clear() -> None:
        ...
    def first() -> winrt.windows.foundation.collections.IIterator[winrt.windows.web.http.HttpMethod]:
        ...
    def get_at(index: int) -> winrt.windows.web.http.HttpMethod:
        ...
    def get_many(start_index: int, items_size: int) -> typing.Tuple[int, typing.List[winrt.windows.web.http.HttpMethod]]:
        ...
    def get_view() -> winrt.windows.foundation.collections.IVectorView[winrt.windows.web.http.HttpMethod]:
        ...
    def index_of(value: winrt.windows.web.http.HttpMethod) -> typing.Tuple[bool, int]:
        ...
    def insert_at(index: int, value: winrt.windows.web.http.HttpMethod) -> None:
        ...
    def parse_add(input: str) -> None:
        ...
    def remove_at(index: int) -> None:
        ...
    def remove_at_end() -> None:
        ...
    def replace_all(items: typing.Sequence[winrt.windows.web.http.HttpMethod]) -> None:
        ...
    def set_at(index: int, value: winrt.windows.web.http.HttpMethod) -> None:
        ...
    def to_string() -> str:
        ...
    def try_parse_add(input: str) -> bool:
        ...

class HttpNameValueHeaderValue(winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    value: str
    name: str
    def parse(input: str) -> HttpNameValueHeaderValue:
        ...
    def to_string() -> str:
        ...
    def try_parse(input: str) -> typing.Tuple[bool, HttpNameValueHeaderValue]:
        ...

class HttpProductHeaderValue(winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    name: str
    version: str
    def parse(input: str) -> HttpProductHeaderValue:
        ...
    def to_string() -> str:
        ...
    def try_parse(input: str) -> typing.Tuple[bool, HttpProductHeaderValue]:
        ...

class HttpProductInfoHeaderValue(winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    comment: str
    product: HttpProductHeaderValue
    def parse(input: str) -> HttpProductInfoHeaderValue:
        ...
    def to_string() -> str:
        ...
    def try_parse(input: str) -> typing.Tuple[bool, HttpProductInfoHeaderValue]:
        ...

class HttpProductInfoHeaderValueCollection(winrt.windows.foundation.collections.IVector[HttpProductInfoHeaderValue], winrt.windows.foundation.collections.IIterable[HttpProductInfoHeaderValue], winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    size: int
    def append(value: HttpProductInfoHeaderValue) -> None:
        ...
    def clear() -> None:
        ...
    def first() -> winrt.windows.foundation.collections.IIterator[HttpProductInfoHeaderValue]:
        ...
    def get_at(index: int) -> HttpProductInfoHeaderValue:
        ...
    def get_many(start_index: int, items_size: int) -> typing.Tuple[int, typing.List[HttpProductInfoHeaderValue]]:
        ...
    def get_view() -> winrt.windows.foundation.collections.IVectorView[HttpProductInfoHeaderValue]:
        ...
    def index_of(value: HttpProductInfoHeaderValue) -> typing.Tuple[bool, int]:
        ...
    def insert_at(index: int, value: HttpProductInfoHeaderValue) -> None:
        ...
    def parse_add(input: str) -> None:
        ...
    def remove_at(index: int) -> None:
        ...
    def remove_at_end() -> None:
        ...
    def replace_all(items: typing.Sequence[HttpProductInfoHeaderValue]) -> None:
        ...
    def set_at(index: int, value: HttpProductInfoHeaderValue) -> None:
        ...
    def to_string() -> str:
        ...
    def try_parse_add(input: str) -> bool:
        ...

class HttpRequestHeaderCollection(winrt.windows.foundation.collections.IMap[str, str], winrt.windows.foundation.collections.IIterable[winrt.windows.foundation.collections.IKeyValuePair[str, str]], winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    size: int
    referer: winrt.windows.foundation.Uri
    proxy_authorization: HttpCredentialsHeaderValue
    max_forwards: typing.Optional[int]
    if_unmodified_since: typing.Optional[winrt.windows.foundation.DateTime]
    if_modified_since: typing.Optional[winrt.windows.foundation.DateTime]
    host: winrt.windows.networking.HostName
    from: str
    date: typing.Optional[winrt.windows.foundation.DateTime]
    authorization: HttpCredentialsHeaderValue
    accept: HttpMediaTypeWithQualityHeaderValueCollection
    accept_encoding: HttpContentCodingWithQualityHeaderValueCollection
    accept_language: HttpLanguageRangeWithQualityHeaderValueCollection
    cache_control: HttpCacheDirectiveHeaderValueCollection
    connection: HttpConnectionOptionHeaderValueCollection
    cookie: HttpCookiePairHeaderValueCollection
    expect: HttpExpectationHeaderValueCollection
    transfer_encoding: HttpTransferCodingHeaderValueCollection
    user_agent: HttpProductInfoHeaderValueCollection
    def append(name: str, value: str) -> None:
        ...
    def clear() -> None:
        ...
    def first() -> winrt.windows.foundation.collections.IIterator[winrt.windows.foundation.collections.IKeyValuePair[str, str]]:
        ...
    def get_view() -> winrt.windows.foundation.collections.IMapView[str, str]:
        ...
    def has_key(key: str) -> bool:
        ...
    def insert(key: str, value: str) -> bool:
        ...
    def lookup(key: str) -> str:
        ...
    def remove(key: str) -> None:
        ...
    def to_string() -> str:
        ...
    def try_append_without_validation(name: str, value: str) -> bool:
        ...

class HttpResponseHeaderCollection(winrt.windows.foundation.collections.IMap[str, str], winrt.windows.foundation.collections.IIterable[winrt.windows.foundation.collections.IKeyValuePair[str, str]], winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    size: int
    retry_after: HttpDateOrDeltaHeaderValue
    location: winrt.windows.foundation.Uri
    date: typing.Optional[winrt.windows.foundation.DateTime]
    age: typing.Optional[winrt.windows.foundation.TimeSpan]
    allow: HttpMethodHeaderValueCollection
    cache_control: HttpCacheDirectiveHeaderValueCollection
    connection: HttpConnectionOptionHeaderValueCollection
    proxy_authenticate: HttpChallengeHeaderValueCollection
    transfer_encoding: HttpTransferCodingHeaderValueCollection
    www_authenticate: HttpChallengeHeaderValueCollection
    def append(name: str, value: str) -> None:
        ...
    def clear() -> None:
        ...
    def first() -> winrt.windows.foundation.collections.IIterator[winrt.windows.foundation.collections.IKeyValuePair[str, str]]:
        ...
    def get_view() -> winrt.windows.foundation.collections.IMapView[str, str]:
        ...
    def has_key(key: str) -> bool:
        ...
    def insert(key: str, value: str) -> bool:
        ...
    def lookup(key: str) -> str:
        ...
    def remove(key: str) -> None:
        ...
    def to_string() -> str:
        ...
    def try_append_without_validation(name: str, value: str) -> bool:
        ...

class HttpTransferCodingHeaderValue(winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    parameters: winrt.windows.foundation.collections.IVector[HttpNameValueHeaderValue]
    value: str
    def parse(input: str) -> HttpTransferCodingHeaderValue:
        ...
    def to_string() -> str:
        ...
    def try_parse(input: str) -> typing.Tuple[bool, HttpTransferCodingHeaderValue]:
        ...

class HttpTransferCodingHeaderValueCollection(winrt.windows.foundation.collections.IVector[HttpTransferCodingHeaderValue], winrt.windows.foundation.collections.IIterable[HttpTransferCodingHeaderValue], winrt.windows.foundation.IStringable, _winrt.winrt_base):
    ...
    size: int
    def append(value: HttpTransferCodingHeaderValue) -> None:
        ...
    def clear() -> None:
        ...
    def first() -> winrt.windows.foundation.collections.IIterator[HttpTransferCodingHeaderValue]:
        ...
    def get_at(index: int) -> HttpTransferCodingHeaderValue:
        ...
    def get_many(start_index: int, items_size: int) -> typing.Tuple[int, typing.List[HttpTransferCodingHeaderValue]]:
        ...
    def get_view() -> winrt.windows.foundation.collections.IVectorView[HttpTransferCodingHeaderValue]:
        ...
    def index_of(value: HttpTransferCodingHeaderValue) -> typing.Tuple[bool, int]:
        ...
    def insert_at(index: int, value: HttpTransferCodingHeaderValue) -> None:
        ...
    def parse_add(input: str) -> None:
        ...
    def remove_at(index: int) -> None:
        ...
    def remove_at_end() -> None:
        ...
    def replace_all(items: typing.Sequence[HttpTransferCodingHeaderValue]) -> None:
        ...
    def set_at(index: int, value: HttpTransferCodingHeaderValue) -> None:
        ...
    def to_string() -> str:
        ...
    def try_parse_add(input: str) -> bool:
        ...

