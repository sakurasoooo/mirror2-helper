// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Foundation.Diagnostics.h"

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::ErrorDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::FileLoggingSession>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingActivity>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingChannel>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingChannelOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingFields>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingSession>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::IErrorReportingSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::IFileLoggingSession>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::ILoggingSession>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::ILoggingTarget>::python_type;

namespace py::cpp::Windows::Foundation::Diagnostics
{
    // ----- AsyncCausalityTracer class --------------------
    constexpr const char* const _type_name_AsyncCausalityTracer = "AsyncCausalityTracer";

    static PyObject* _new_AsyncCausalityTracer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AsyncCausalityTracer);
        return nullptr;
    }

    static PyObject* AsyncCausalityTracer_TraceOperationCompletion(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalityTraceLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalitySource>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);
                auto param3 = py::convert_to<uint64_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::AsyncStatus>(args, 4);

                winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer::TraceOperationCompletion(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsyncCausalityTracer_TraceOperationCreation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalityTraceLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalitySource>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);
                auto param3 = py::convert_to<uint64_t>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<uint64_t>(args, 5);

                winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer::TraceOperationCreation(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsyncCausalityTracer_TraceOperationRelation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalityTraceLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalitySource>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);
                auto param3 = py::convert_to<uint64_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalityRelation>(args, 4);

                winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer::TraceOperationRelation(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsyncCausalityTracer_TraceSynchronousWorkCompletion(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalityTraceLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalitySource>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalitySynchronousWork>(args, 2);

                winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer::TraceSynchronousWorkCompletion(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsyncCausalityTracer_TraceSynchronousWorkStart(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalityTraceLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalitySource>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);
                auto param3 = py::convert_to<uint64_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalitySynchronousWork>(args, 4);

                winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer::TraceSynchronousWorkStart(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsyncCausalityTracer_add_TracingStatusChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs>>(arg);

            return py::convert(winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer::TracingStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsyncCausalityTracer_remove_TracingStatusChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer::TracingStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AsyncCausalityTracer[] = {
        { "trace_operation_completion", (PyCFunction)AsyncCausalityTracer_TraceOperationCompletion, METH_VARARGS | METH_STATIC, nullptr },
        { "trace_operation_creation", (PyCFunction)AsyncCausalityTracer_TraceOperationCreation, METH_VARARGS | METH_STATIC, nullptr },
        { "trace_operation_relation", (PyCFunction)AsyncCausalityTracer_TraceOperationRelation, METH_VARARGS | METH_STATIC, nullptr },
        { "trace_synchronous_work_completion", (PyCFunction)AsyncCausalityTracer_TraceSynchronousWorkCompletion, METH_VARARGS | METH_STATIC, nullptr },
        { "trace_synchronous_work_start", (PyCFunction)AsyncCausalityTracer_TraceSynchronousWorkStart, METH_VARARGS | METH_STATIC, nullptr },
        { "add_tracing_status_changed", (PyCFunction)AsyncCausalityTracer_add_TracingStatusChanged, METH_O | METH_STATIC, nullptr },
        { "remove_tracing_status_changed", (PyCFunction)AsyncCausalityTracer_remove_TracingStatusChanged, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AsyncCausalityTracer[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_AsyncCausalityTracer[] = 
    {
        { Py_tp_new, _new_AsyncCausalityTracer },
        { Py_tp_methods, _methods_AsyncCausalityTracer },
        { Py_tp_getset, _getset_AsyncCausalityTracer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AsyncCausalityTracer =
    {
        "_winrt_Windows_Foundation_Diagnostics.AsyncCausalityTracer",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AsyncCausalityTracer
    };

    // ----- ErrorDetails class --------------------
    constexpr const char* const _type_name_ErrorDetails = "ErrorDetails";

    static PyObject* _new_ErrorDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ErrorDetails);
        return nullptr;
    }

    static void _dealloc_ErrorDetails(py::wrapper::Windows::Foundation::Diagnostics::ErrorDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ErrorDetails_CreateFromHResultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::Diagnostics::ErrorDetails::CreateFromHResultAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ErrorDetails_get_Description(py::wrapper::Windows::Foundation::Diagnostics::ErrorDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ErrorDetails_get_HelpUri(py::wrapper::Windows::Foundation::Diagnostics::ErrorDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HelpUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ErrorDetails_get_LongDescription(py::wrapper::Windows::Foundation::Diagnostics::ErrorDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LongDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ErrorDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::ErrorDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ErrorDetails[] = {
        { "create_from_h_result_async", (PyCFunction)ErrorDetails_CreateFromHResultAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_ErrorDetails, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ErrorDetails[] = {
        { const_cast<char*>("description"), (getter)ErrorDetails_get_Description, nullptr, nullptr, nullptr },
        { const_cast<char*>("help_uri"), (getter)ErrorDetails_get_HelpUri, nullptr, nullptr, nullptr },
        { const_cast<char*>("long_description"), (getter)ErrorDetails_get_LongDescription, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ErrorDetails[] = 
    {
        { Py_tp_new, _new_ErrorDetails },
        { Py_tp_dealloc, _dealloc_ErrorDetails },
        { Py_tp_methods, _methods_ErrorDetails },
        { Py_tp_getset, _getset_ErrorDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ErrorDetails =
    {
        "_winrt_Windows_Foundation_Diagnostics.ErrorDetails",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::ErrorDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ErrorDetails
    };

    // ----- FileLoggingSession class --------------------
    constexpr const char* const _type_name_FileLoggingSession = "FileLoggingSession";

    static PyObject* _new_FileLoggingSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Foundation::Diagnostics::FileLoggingSession instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FileLoggingSession(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FileLoggingSession_AddLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                self->obj.AddLoggingChannel(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 1);

                self->obj.AddLoggingChannel(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileLoggingSession_Close(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileLoggingSession_CloseAndSaveToFileAsync(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CloseAndSaveToFileAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileLoggingSession_RemoveLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                self->obj.RemoveLoggingChannel(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileLoggingSession_get_Name(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileLoggingSession_add_LogFileGenerated(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::Diagnostics::IFileLoggingSession, winrt::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs>>(arg);

            return py::convert(self->obj.LogFileGenerated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileLoggingSession_remove_LogFileGenerated(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LogFileGenerated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FileLoggingSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::FileLoggingSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_FileLoggingSession(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_FileLoggingSession(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileLoggingSession[] = {
        { "add_logging_channel", (PyCFunction)FileLoggingSession_AddLoggingChannel, METH_VARARGS, nullptr },
        { "close", (PyCFunction)FileLoggingSession_Close, METH_VARARGS, nullptr },
        { "close_and_save_to_file_async", (PyCFunction)FileLoggingSession_CloseAndSaveToFileAsync, METH_VARARGS, nullptr },
        { "remove_logging_channel", (PyCFunction)FileLoggingSession_RemoveLoggingChannel, METH_VARARGS, nullptr },
        { "add_log_file_generated", (PyCFunction)FileLoggingSession_add_LogFileGenerated, METH_O, nullptr },
        { "remove_log_file_generated", (PyCFunction)FileLoggingSession_remove_LogFileGenerated, METH_O, nullptr },
        { "_from", (PyCFunction)_from_FileLoggingSession, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_FileLoggingSession, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_FileLoggingSession, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FileLoggingSession[] = {
        { const_cast<char*>("name"), (getter)FileLoggingSession_get_Name, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FileLoggingSession[] = 
    {
        { Py_tp_new, _new_FileLoggingSession },
        { Py_tp_dealloc, _dealloc_FileLoggingSession },
        { Py_tp_methods, _methods_FileLoggingSession },
        { Py_tp_getset, _getset_FileLoggingSession },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FileLoggingSession =
    {
        "_winrt_Windows_Foundation_Diagnostics.FileLoggingSession",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileLoggingSession
    };

    // ----- LogFileGeneratedEventArgs class --------------------
    constexpr const char* const _type_name_LogFileGeneratedEventArgs = "LogFileGeneratedEventArgs";

    static PyObject* _new_LogFileGeneratedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LogFileGeneratedEventArgs);
        return nullptr;
    }

    static void _dealloc_LogFileGeneratedEventArgs(py::wrapper::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LogFileGeneratedEventArgs_get_File(py::wrapper::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LogFileGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LogFileGeneratedEventArgs[] = {
        { "_from", (PyCFunction)_from_LogFileGeneratedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LogFileGeneratedEventArgs[] = {
        { const_cast<char*>("file"), (getter)LogFileGeneratedEventArgs_get_File, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LogFileGeneratedEventArgs[] = 
    {
        { Py_tp_new, _new_LogFileGeneratedEventArgs },
        { Py_tp_dealloc, _dealloc_LogFileGeneratedEventArgs },
        { Py_tp_methods, _methods_LogFileGeneratedEventArgs },
        { Py_tp_getset, _getset_LogFileGeneratedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LogFileGeneratedEventArgs =
    {
        "_winrt_Windows_Foundation_Diagnostics.LogFileGeneratedEventArgs",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LogFileGeneratedEventArgs
    };

    // ----- LoggingActivity class --------------------
    constexpr const char* const _type_name_LoggingActivity = "LoggingActivity";

    static PyObject* _new_LoggingActivity(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 1);

                winrt::Windows::Foundation::Diagnostics::LoggingActivity instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                winrt::Windows::Foundation::Diagnostics::LoggingActivity instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LoggingActivity(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LoggingActivity_Close(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_IsEnabled(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.IsEnabled());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 0);

                return py::convert(self->obj.IsEnabled(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                return py::convert(self->obj.IsEnabled(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_LogEvent(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.LogEvent(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);

                self->obj.LogEvent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                self->obj.LogEvent(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOptions>(args, 3);

                self->obj.LogEvent(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_StartActivity(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.StartActivity(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);

                return py::convert(self->obj.StartActivity(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                return py::convert(self->obj.StartActivity(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOptions>(args, 3);

                return py::convert(self->obj.StartActivity(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_StopActivity(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.StopActivity(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);

                self->obj.StopActivity(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOptions>(args, 2);

                self->obj.StopActivity(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_get_Id(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_get_Name(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_get_Channel(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LoggingActivity(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::LoggingActivity>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LoggingActivity(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_LoggingActivity(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoggingActivity[] = {
        { "close", (PyCFunction)LoggingActivity_Close, METH_VARARGS, nullptr },
        { "is_enabled", (PyCFunction)LoggingActivity_IsEnabled, METH_VARARGS, nullptr },
        { "log_event", (PyCFunction)LoggingActivity_LogEvent, METH_VARARGS, nullptr },
        { "start_activity", (PyCFunction)LoggingActivity_StartActivity, METH_VARARGS, nullptr },
        { "stop_activity", (PyCFunction)LoggingActivity_StopActivity, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_LoggingActivity, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_LoggingActivity, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_LoggingActivity, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LoggingActivity[] = {
        { const_cast<char*>("id"), (getter)LoggingActivity_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)LoggingActivity_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("channel"), (getter)LoggingActivity_get_Channel, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LoggingActivity[] = 
    {
        { Py_tp_new, _new_LoggingActivity },
        { Py_tp_dealloc, _dealloc_LoggingActivity },
        { Py_tp_methods, _methods_LoggingActivity },
        { Py_tp_getset, _getset_LoggingActivity },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LoggingActivity =
    {
        "_winrt_Windows_Foundation_Diagnostics.LoggingActivity",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoggingActivity
    };

    // ----- LoggingChannel class --------------------
    constexpr const char* const _type_name_LoggingChannel = "LoggingChannel";

    static PyObject* _new_LoggingChannel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingChannelOptions>(args, 1);

                winrt::Windows::Foundation::Diagnostics::LoggingChannel instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingChannelOptions>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                winrt::Windows::Foundation::Diagnostics::LoggingChannel instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Foundation::Diagnostics::LoggingChannel instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LoggingChannel_Close(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_IsEnabled(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.IsEnabled());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 0);

                return py::convert(self->obj.IsEnabled(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                return py::convert(self->obj.IsEnabled(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_LogEvent(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.LogEvent(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);

                self->obj.LogEvent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                self->obj.LogEvent(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOptions>(args, 3);

                self->obj.LogEvent(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_LogMessage(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.LogMessage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 1);

                self->obj.LogMessage(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_LogValuePair(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.LogValuePair(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                self->obj.LogValuePair(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_StartActivity(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.StartActivity(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);

                return py::convert(self->obj.StartActivity(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                return py::convert(self->obj.StartActivity(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOptions>(args, 3);

                return py::convert(self->obj.StartActivity(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_get_Enabled(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_get_Level(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Level());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_get_Name(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_get_Id(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_add_LoggingEnabled(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::Diagnostics::ILoggingChannel, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.LoggingEnabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_remove_LoggingEnabled(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LoggingEnabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LoggingChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::LoggingChannel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_LoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoggingChannel[] = {
        { "close", (PyCFunction)LoggingChannel_Close, METH_VARARGS, nullptr },
        { "is_enabled", (PyCFunction)LoggingChannel_IsEnabled, METH_VARARGS, nullptr },
        { "log_event", (PyCFunction)LoggingChannel_LogEvent, METH_VARARGS, nullptr },
        { "log_message", (PyCFunction)LoggingChannel_LogMessage, METH_VARARGS, nullptr },
        { "log_value_pair", (PyCFunction)LoggingChannel_LogValuePair, METH_VARARGS, nullptr },
        { "start_activity", (PyCFunction)LoggingChannel_StartActivity, METH_VARARGS, nullptr },
        { "add_logging_enabled", (PyCFunction)LoggingChannel_add_LoggingEnabled, METH_O, nullptr },
        { "remove_logging_enabled", (PyCFunction)LoggingChannel_remove_LoggingEnabled, METH_O, nullptr },
        { "_from", (PyCFunction)_from_LoggingChannel, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_LoggingChannel, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_LoggingChannel, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LoggingChannel[] = {
        { const_cast<char*>("enabled"), (getter)LoggingChannel_get_Enabled, nullptr, nullptr, nullptr },
        { const_cast<char*>("level"), (getter)LoggingChannel_get_Level, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)LoggingChannel_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)LoggingChannel_get_Id, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LoggingChannel[] = 
    {
        { Py_tp_new, _new_LoggingChannel },
        { Py_tp_dealloc, _dealloc_LoggingChannel },
        { Py_tp_methods, _methods_LoggingChannel },
        { Py_tp_getset, _getset_LoggingChannel },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LoggingChannel =
    {
        "_winrt_Windows_Foundation_Diagnostics.LoggingChannel",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoggingChannel
    };

    // ----- LoggingChannelOptions class --------------------
    constexpr const char* const _type_name_LoggingChannelOptions = "LoggingChannelOptions";

    static PyObject* _new_LoggingChannelOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Foundation::Diagnostics::LoggingChannelOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                winrt::Windows::Foundation::Diagnostics::LoggingChannelOptions instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LoggingChannelOptions(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannelOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LoggingChannelOptions_get_Group(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannelOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoggingChannelOptions_put_Group(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannelOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.Group(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_LoggingChannelOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::LoggingChannelOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoggingChannelOptions[] = {
        { "_from", (PyCFunction)_from_LoggingChannelOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LoggingChannelOptions[] = {
        { const_cast<char*>("group"), (getter)LoggingChannelOptions_get_Group, (setter)LoggingChannelOptions_put_Group, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LoggingChannelOptions[] = 
    {
        { Py_tp_new, _new_LoggingChannelOptions },
        { Py_tp_dealloc, _dealloc_LoggingChannelOptions },
        { Py_tp_methods, _methods_LoggingChannelOptions },
        { Py_tp_getset, _getset_LoggingChannelOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LoggingChannelOptions =
    {
        "_winrt_Windows_Foundation_Diagnostics.LoggingChannelOptions",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannelOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoggingChannelOptions
    };

    // ----- LoggingFields class --------------------
    constexpr const char* const _type_name_LoggingFields = "LoggingFields";

    static PyObject* _new_LoggingFields(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Foundation::Diagnostics::LoggingFields instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LoggingFields(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LoggingFields_AddBoolean(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.AddBoolean(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddBoolean(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddBoolean(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddBooleanArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<bool>>(args, 1);

                self->obj.AddBooleanArray(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<bool>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddBooleanArray(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<bool>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddBooleanArray(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddChar16(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<char16_t>(args, 1);

                self->obj.AddChar16(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<char16_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddChar16(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<char16_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddChar16(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddChar16Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<char16_t>>(args, 1);

                self->obj.AddChar16Array(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<char16_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddChar16Array(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<char16_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddChar16Array(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddDateTime(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                self->obj.AddDateTime(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddDateTime(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddDateTime(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddDateTimeArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::DateTime>>(args, 1);

                self->obj.AddDateTimeArray(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::DateTime>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddDateTimeArray(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::DateTime>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddDateTimeArray(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddDouble(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddDouble(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddDouble(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddDouble(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddDoubleArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<double>>(args, 1);

                self->obj.AddDoubleArray(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<double>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddDoubleArray(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<double>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddDoubleArray(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddEmpty(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.AddEmpty(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 1);

                self->obj.AddEmpty(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                self->obj.AddEmpty(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddGuid(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                self->obj.AddGuid(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddGuid(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddGuid(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddGuidArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::guid>>(args, 1);

                self->obj.AddGuidArray(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::guid>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddGuidArray(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::guid>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddGuidArray(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt16(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int16_t>(args, 1);

                self->obj.AddInt16(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int16_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddInt16(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int16_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddInt16(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt16Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int16_t>>(args, 1);

                self->obj.AddInt16Array(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int16_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddInt16Array(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int16_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddInt16Array(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt32(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.AddInt32(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddInt32(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddInt32(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt32Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);

                self->obj.AddInt32Array(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddInt32Array(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddInt32Array(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt64(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.AddInt64(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddInt64(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddInt64(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt64Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int64_t>>(args, 1);

                self->obj.AddInt64Array(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int64_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddInt64Array(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int64_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddInt64Array(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddPoint(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                self->obj.AddPoint(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddPoint(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddPoint(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddPointArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Point>>(args, 1);

                self->obj.AddPointArray(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Point>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddPointArray(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Point>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddPointArray(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddRect(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                self->obj.AddRect(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddRect(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddRect(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddRectArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Rect>>(args, 1);

                self->obj.AddRectArray(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Rect>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddRectArray(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Rect>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddRectArray(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddSingle(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                self->obj.AddSingle(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddSingle(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddSingle(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddSingleArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<float>>(args, 1);

                self->obj.AddSingleArray(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<float>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddSingleArray(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<float>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddSingleArray(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddSize(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);

                self->obj.AddSize(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddSize(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddSize(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddSizeArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Size>>(args, 1);

                self->obj.AddSizeArray(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Size>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddSizeArray(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Size>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddSizeArray(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddString(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.AddString(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddString(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddString(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddStringArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::hstring>>(args, 1);

                self->obj.AddStringArray(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddStringArray(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddStringArray(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddTimeSpan(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                self->obj.AddTimeSpan(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddTimeSpan(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddTimeSpan(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddTimeSpanArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::TimeSpan>>(args, 1);

                self->obj.AddTimeSpanArray(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::TimeSpan>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddTimeSpanArray(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::TimeSpan>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddTimeSpanArray(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt16(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                self->obj.AddUInt16(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddUInt16(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddUInt16(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt16Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint16_t>>(args, 1);

                self->obj.AddUInt16Array(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint16_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddUInt16Array(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint16_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddUInt16Array(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt32(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.AddUInt32(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddUInt32(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddUInt32(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt32Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint32_t>>(args, 1);

                self->obj.AddUInt32Array(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint32_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddUInt32Array(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint32_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddUInt32Array(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt64(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);

                self->obj.AddUInt64(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddUInt64(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddUInt64(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt64Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint64_t>>(args, 1);

                self->obj.AddUInt64Array(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint64_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddUInt64Array(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint64_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddUInt64Array(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt8(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);

                self->obj.AddUInt8(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddUInt8(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddUInt8(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt8Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                self->obj.AddUInt8Array(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddUInt8Array(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddUInt8Array(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_BeginStruct(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.BeginStruct(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.BeginStruct(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_Clear(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_EndStruct(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.EndStruct();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_LoggingFields(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::LoggingFields>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoggingFields[] = {
        { "add_boolean", (PyCFunction)LoggingFields_AddBoolean, METH_VARARGS, nullptr },
        { "add_boolean_array", (PyCFunction)LoggingFields_AddBooleanArray, METH_VARARGS, nullptr },
        { "add_char16", (PyCFunction)LoggingFields_AddChar16, METH_VARARGS, nullptr },
        { "add_char16_array", (PyCFunction)LoggingFields_AddChar16Array, METH_VARARGS, nullptr },
        { "add_date_time", (PyCFunction)LoggingFields_AddDateTime, METH_VARARGS, nullptr },
        { "add_date_time_array", (PyCFunction)LoggingFields_AddDateTimeArray, METH_VARARGS, nullptr },
        { "add_double", (PyCFunction)LoggingFields_AddDouble, METH_VARARGS, nullptr },
        { "add_double_array", (PyCFunction)LoggingFields_AddDoubleArray, METH_VARARGS, nullptr },
        { "add_empty", (PyCFunction)LoggingFields_AddEmpty, METH_VARARGS, nullptr },
        { "add_guid", (PyCFunction)LoggingFields_AddGuid, METH_VARARGS, nullptr },
        { "add_guid_array", (PyCFunction)LoggingFields_AddGuidArray, METH_VARARGS, nullptr },
        { "add_int16", (PyCFunction)LoggingFields_AddInt16, METH_VARARGS, nullptr },
        { "add_int16_array", (PyCFunction)LoggingFields_AddInt16Array, METH_VARARGS, nullptr },
        { "add_int32", (PyCFunction)LoggingFields_AddInt32, METH_VARARGS, nullptr },
        { "add_int32_array", (PyCFunction)LoggingFields_AddInt32Array, METH_VARARGS, nullptr },
        { "add_int64", (PyCFunction)LoggingFields_AddInt64, METH_VARARGS, nullptr },
        { "add_int64_array", (PyCFunction)LoggingFields_AddInt64Array, METH_VARARGS, nullptr },
        { "add_point", (PyCFunction)LoggingFields_AddPoint, METH_VARARGS, nullptr },
        { "add_point_array", (PyCFunction)LoggingFields_AddPointArray, METH_VARARGS, nullptr },
        { "add_rect", (PyCFunction)LoggingFields_AddRect, METH_VARARGS, nullptr },
        { "add_rect_array", (PyCFunction)LoggingFields_AddRectArray, METH_VARARGS, nullptr },
        { "add_single", (PyCFunction)LoggingFields_AddSingle, METH_VARARGS, nullptr },
        { "add_single_array", (PyCFunction)LoggingFields_AddSingleArray, METH_VARARGS, nullptr },
        { "add_size", (PyCFunction)LoggingFields_AddSize, METH_VARARGS, nullptr },
        { "add_size_array", (PyCFunction)LoggingFields_AddSizeArray, METH_VARARGS, nullptr },
        { "add_string", (PyCFunction)LoggingFields_AddString, METH_VARARGS, nullptr },
        { "add_string_array", (PyCFunction)LoggingFields_AddStringArray, METH_VARARGS, nullptr },
        { "add_time_span", (PyCFunction)LoggingFields_AddTimeSpan, METH_VARARGS, nullptr },
        { "add_time_span_array", (PyCFunction)LoggingFields_AddTimeSpanArray, METH_VARARGS, nullptr },
        { "add_uint16", (PyCFunction)LoggingFields_AddUInt16, METH_VARARGS, nullptr },
        { "add_uint16_array", (PyCFunction)LoggingFields_AddUInt16Array, METH_VARARGS, nullptr },
        { "add_uint32", (PyCFunction)LoggingFields_AddUInt32, METH_VARARGS, nullptr },
        { "add_uint32_array", (PyCFunction)LoggingFields_AddUInt32Array, METH_VARARGS, nullptr },
        { "add_uint64", (PyCFunction)LoggingFields_AddUInt64, METH_VARARGS, nullptr },
        { "add_uint64_array", (PyCFunction)LoggingFields_AddUInt64Array, METH_VARARGS, nullptr },
        { "add_uint8", (PyCFunction)LoggingFields_AddUInt8, METH_VARARGS, nullptr },
        { "add_uint8_array", (PyCFunction)LoggingFields_AddUInt8Array, METH_VARARGS, nullptr },
        { "begin_struct", (PyCFunction)LoggingFields_BeginStruct, METH_VARARGS, nullptr },
        { "clear", (PyCFunction)LoggingFields_Clear, METH_VARARGS, nullptr },
        { "end_struct", (PyCFunction)LoggingFields_EndStruct, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_LoggingFields, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LoggingFields[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_LoggingFields[] = 
    {
        { Py_tp_new, _new_LoggingFields },
        { Py_tp_dealloc, _dealloc_LoggingFields },
        { Py_tp_methods, _methods_LoggingFields },
        { Py_tp_getset, _getset_LoggingFields },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LoggingFields =
    {
        "_winrt_Windows_Foundation_Diagnostics.LoggingFields",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoggingFields
    };

    // ----- LoggingOptions class --------------------
    constexpr const char* const _type_name_LoggingOptions = "LoggingOptions";

    static PyObject* _new_LoggingOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Foundation::Diagnostics::LoggingOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int64_t>(args, 0);

                winrt::Windows::Foundation::Diagnostics::LoggingOptions instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LoggingOptions(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LoggingOptions_get_Task(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Task());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoggingOptions_put_Task(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int16_t>(arg);

            self->obj.Task(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoggingOptions_get_Tags(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tags());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoggingOptions_put_Tags(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Tags(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoggingOptions_get_RelatedActivityId(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelatedActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoggingOptions_put_RelatedActivityId(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.RelatedActivityId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoggingOptions_get_Opcode(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Opcode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoggingOptions_put_Opcode(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOpcode>(arg);

            self->obj.Opcode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoggingOptions_get_Keywords(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Keywords());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoggingOptions_put_Keywords(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int64_t>(arg);

            self->obj.Keywords(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoggingOptions_get_ActivityId(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoggingOptions_put_ActivityId(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.ActivityId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_LoggingOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::LoggingOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoggingOptions[] = {
        { "_from", (PyCFunction)_from_LoggingOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LoggingOptions[] = {
        { const_cast<char*>("task"), (getter)LoggingOptions_get_Task, (setter)LoggingOptions_put_Task, nullptr, nullptr },
        { const_cast<char*>("tags"), (getter)LoggingOptions_get_Tags, (setter)LoggingOptions_put_Tags, nullptr, nullptr },
        { const_cast<char*>("related_activity_id"), (getter)LoggingOptions_get_RelatedActivityId, (setter)LoggingOptions_put_RelatedActivityId, nullptr, nullptr },
        { const_cast<char*>("opcode"), (getter)LoggingOptions_get_Opcode, (setter)LoggingOptions_put_Opcode, nullptr, nullptr },
        { const_cast<char*>("keywords"), (getter)LoggingOptions_get_Keywords, (setter)LoggingOptions_put_Keywords, nullptr, nullptr },
        { const_cast<char*>("activity_id"), (getter)LoggingOptions_get_ActivityId, (setter)LoggingOptions_put_ActivityId, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LoggingOptions[] = 
    {
        { Py_tp_new, _new_LoggingOptions },
        { Py_tp_dealloc, _dealloc_LoggingOptions },
        { Py_tp_methods, _methods_LoggingOptions },
        { Py_tp_getset, _getset_LoggingOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LoggingOptions =
    {
        "_winrt_Windows_Foundation_Diagnostics.LoggingOptions",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoggingOptions
    };

    // ----- LoggingSession class --------------------
    constexpr const char* const _type_name_LoggingSession = "LoggingSession";

    static PyObject* _new_LoggingSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Foundation::Diagnostics::LoggingSession instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LoggingSession(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LoggingSession_AddLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                self->obj.AddLoggingChannel(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 1);

                self->obj.AddLoggingChannel(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingSession_Close(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingSession_RemoveLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                self->obj.RemoveLoggingChannel(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingSession_SaveToFileAsync(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.SaveToFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingSession_get_Name(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LoggingSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::LoggingSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LoggingSession(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_LoggingSession(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoggingSession[] = {
        { "add_logging_channel", (PyCFunction)LoggingSession_AddLoggingChannel, METH_VARARGS, nullptr },
        { "close", (PyCFunction)LoggingSession_Close, METH_VARARGS, nullptr },
        { "remove_logging_channel", (PyCFunction)LoggingSession_RemoveLoggingChannel, METH_VARARGS, nullptr },
        { "save_to_file_async", (PyCFunction)LoggingSession_SaveToFileAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_LoggingSession, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_LoggingSession, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_LoggingSession, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LoggingSession[] = {
        { const_cast<char*>("name"), (getter)LoggingSession_get_Name, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LoggingSession[] = 
    {
        { Py_tp_new, _new_LoggingSession },
        { Py_tp_dealloc, _dealloc_LoggingSession },
        { Py_tp_methods, _methods_LoggingSession },
        { Py_tp_getset, _getset_LoggingSession },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LoggingSession =
    {
        "_winrt_Windows_Foundation_Diagnostics.LoggingSession",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoggingSession
    };

    // ----- RuntimeBrokerErrorSettings class --------------------
    constexpr const char* const _type_name_RuntimeBrokerErrorSettings = "RuntimeBrokerErrorSettings";

    static PyObject* _new_RuntimeBrokerErrorSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RuntimeBrokerErrorSettings(py::wrapper::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RuntimeBrokerErrorSettings_GetErrorOptions(py::wrapper::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetErrorOptions());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RuntimeBrokerErrorSettings_SetErrorOptions(py::wrapper::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ErrorOptions>(args, 0);

                self->obj.SetErrorOptions(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_RuntimeBrokerErrorSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RuntimeBrokerErrorSettings[] = {
        { "get_error_options", (PyCFunction)RuntimeBrokerErrorSettings_GetErrorOptions, METH_VARARGS, nullptr },
        { "set_error_options", (PyCFunction)RuntimeBrokerErrorSettings_SetErrorOptions, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_RuntimeBrokerErrorSettings, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RuntimeBrokerErrorSettings[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_RuntimeBrokerErrorSettings[] = 
    {
        { Py_tp_new, _new_RuntimeBrokerErrorSettings },
        { Py_tp_dealloc, _dealloc_RuntimeBrokerErrorSettings },
        { Py_tp_methods, _methods_RuntimeBrokerErrorSettings },
        { Py_tp_getset, _getset_RuntimeBrokerErrorSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RuntimeBrokerErrorSettings =
    {
        "_winrt_Windows_Foundation_Diagnostics.RuntimeBrokerErrorSettings",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RuntimeBrokerErrorSettings
    };

    // ----- TracingStatusChangedEventArgs class --------------------
    constexpr const char* const _type_name_TracingStatusChangedEventArgs = "TracingStatusChangedEventArgs";

    static PyObject* _new_TracingStatusChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TracingStatusChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_TracingStatusChangedEventArgs(py::wrapper::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TracingStatusChangedEventArgs_get_Enabled(py::wrapper::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TracingStatusChangedEventArgs_get_TraceLevel(py::wrapper::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TraceLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TracingStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TracingStatusChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_TracingStatusChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TracingStatusChangedEventArgs[] = {
        { const_cast<char*>("enabled"), (getter)TracingStatusChangedEventArgs_get_Enabled, nullptr, nullptr, nullptr },
        { const_cast<char*>("trace_level"), (getter)TracingStatusChangedEventArgs_get_TraceLevel, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TracingStatusChangedEventArgs[] = 
    {
        { Py_tp_new, _new_TracingStatusChangedEventArgs },
        { Py_tp_dealloc, _dealloc_TracingStatusChangedEventArgs },
        { Py_tp_methods, _methods_TracingStatusChangedEventArgs },
        { Py_tp_getset, _getset_TracingStatusChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TracingStatusChangedEventArgs =
    {
        "_winrt_Windows_Foundation_Diagnostics.TracingStatusChangedEventArgs",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TracingStatusChangedEventArgs
    };

    // ----- IErrorReportingSettings interface --------------------
    constexpr const char* const _type_name_IErrorReportingSettings = "IErrorReportingSettings";

    static PyObject* _new_IErrorReportingSettings(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IErrorReportingSettings);
        return nullptr;
    }

    static void _dealloc_IErrorReportingSettings(py::wrapper::Windows::Foundation::Diagnostics::IErrorReportingSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IErrorReportingSettings_GetErrorOptions(py::wrapper::Windows::Foundation::Diagnostics::IErrorReportingSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetErrorOptions());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IErrorReportingSettings_SetErrorOptions(py::wrapper::Windows::Foundation::Diagnostics::IErrorReportingSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ErrorOptions>(args, 0);

                self->obj.SetErrorOptions(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IErrorReportingSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::IErrorReportingSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IErrorReportingSettings[] = {
        { "get_error_options", (PyCFunction)IErrorReportingSettings_GetErrorOptions, METH_VARARGS, nullptr },
        { "set_error_options", (PyCFunction)IErrorReportingSettings_SetErrorOptions, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IErrorReportingSettings, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IErrorReportingSettings[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IErrorReportingSettings[] = 
    {
        { Py_tp_new, _new_IErrorReportingSettings },
        { Py_tp_dealloc, _dealloc_IErrorReportingSettings },
        { Py_tp_methods, _methods_IErrorReportingSettings },
        { Py_tp_getset, _getset_IErrorReportingSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IErrorReportingSettings =
    {
        "_winrt_Windows_Foundation_Diagnostics.IErrorReportingSettings",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::IErrorReportingSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IErrorReportingSettings
    };

    // ----- IFileLoggingSession interface --------------------
    constexpr const char* const _type_name_IFileLoggingSession = "IFileLoggingSession";

    static PyObject* _new_IFileLoggingSession(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IFileLoggingSession);
        return nullptr;
    }

    static void _dealloc_IFileLoggingSession(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IFileLoggingSession_AddLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                self->obj.AddLoggingChannel(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 1);

                self->obj.AddLoggingChannel(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IFileLoggingSession_Close(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IFileLoggingSession_CloseAndSaveToFileAsync(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CloseAndSaveToFileAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IFileLoggingSession_RemoveLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                self->obj.RemoveLoggingChannel(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IFileLoggingSession_get_Name(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileLoggingSession_add_LogFileGenerated(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::Diagnostics::IFileLoggingSession, winrt::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs>>(arg);

            return py::convert(self->obj.LogFileGenerated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileLoggingSession_remove_LogFileGenerated(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LogFileGenerated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IFileLoggingSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::IFileLoggingSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IFileLoggingSession(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_IFileLoggingSession(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileLoggingSession[] = {
        { "add_logging_channel", (PyCFunction)IFileLoggingSession_AddLoggingChannel, METH_VARARGS, nullptr },
        { "close_and_save_to_file_async", (PyCFunction)IFileLoggingSession_CloseAndSaveToFileAsync, METH_VARARGS, nullptr },
        { "remove_logging_channel", (PyCFunction)IFileLoggingSession_RemoveLoggingChannel, METH_VARARGS, nullptr },
        { "close", (PyCFunction)IFileLoggingSession_Close, METH_VARARGS, nullptr },
        { "add_log_file_generated", (PyCFunction)IFileLoggingSession_add_LogFileGenerated, METH_O, nullptr },
        { "remove_log_file_generated", (PyCFunction)IFileLoggingSession_remove_LogFileGenerated, METH_O, nullptr },
        { "_from", (PyCFunction)_from_IFileLoggingSession, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_IFileLoggingSession, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_IFileLoggingSession, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IFileLoggingSession[] = {
        { const_cast<char*>("name"), (getter)IFileLoggingSession_get_Name, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IFileLoggingSession[] = 
    {
        { Py_tp_new, _new_IFileLoggingSession },
        { Py_tp_dealloc, _dealloc_IFileLoggingSession },
        { Py_tp_methods, _methods_IFileLoggingSession },
        { Py_tp_getset, _getset_IFileLoggingSession },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IFileLoggingSession =
    {
        "_winrt_Windows_Foundation_Diagnostics.IFileLoggingSession",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFileLoggingSession
    };

    // ----- ILoggingChannel interface --------------------
    constexpr const char* const _type_name_ILoggingChannel = "ILoggingChannel";

    static PyObject* _new_ILoggingChannel(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ILoggingChannel);
        return nullptr;
    }

    static void _dealloc_ILoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ILoggingChannel_Close(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_LogMessage(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.LogMessage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 1);

                self->obj.LogMessage(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_LogValuePair(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.LogValuePair(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                self->obj.LogValuePair(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_get_Enabled(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_get_Level(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Level());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_get_Name(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_add_LoggingEnabled(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::Diagnostics::ILoggingChannel, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.LoggingEnabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_remove_LoggingEnabled(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LoggingEnabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ILoggingChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ILoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_ILoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILoggingChannel[] = {
        { "log_message", (PyCFunction)ILoggingChannel_LogMessage, METH_VARARGS, nullptr },
        { "log_value_pair", (PyCFunction)ILoggingChannel_LogValuePair, METH_VARARGS, nullptr },
        { "close", (PyCFunction)ILoggingChannel_Close, METH_VARARGS, nullptr },
        { "add_logging_enabled", (PyCFunction)ILoggingChannel_add_LoggingEnabled, METH_O, nullptr },
        { "remove_logging_enabled", (PyCFunction)ILoggingChannel_remove_LoggingEnabled, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ILoggingChannel, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_ILoggingChannel, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_ILoggingChannel, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ILoggingChannel[] = {
        { const_cast<char*>("enabled"), (getter)ILoggingChannel_get_Enabled, nullptr, nullptr, nullptr },
        { const_cast<char*>("level"), (getter)ILoggingChannel_get_Level, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)ILoggingChannel_get_Name, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ILoggingChannel[] = 
    {
        { Py_tp_new, _new_ILoggingChannel },
        { Py_tp_dealloc, _dealloc_ILoggingChannel },
        { Py_tp_methods, _methods_ILoggingChannel },
        { Py_tp_getset, _getset_ILoggingChannel },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ILoggingChannel =
    {
        "_winrt_Windows_Foundation_Diagnostics.ILoggingChannel",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILoggingChannel
    };

    // ----- ILoggingSession interface --------------------
    constexpr const char* const _type_name_ILoggingSession = "ILoggingSession";

    static PyObject* _new_ILoggingSession(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ILoggingSession);
        return nullptr;
    }

    static void _dealloc_ILoggingSession(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ILoggingSession_AddLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                self->obj.AddLoggingChannel(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 1);

                self->obj.AddLoggingChannel(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingSession_Close(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingSession_RemoveLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                self->obj.RemoveLoggingChannel(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingSession_SaveToFileAsync(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.SaveToFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingSession_get_Name(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ILoggingSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::ILoggingSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ILoggingSession(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_ILoggingSession(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILoggingSession[] = {
        { "add_logging_channel", (PyCFunction)ILoggingSession_AddLoggingChannel, METH_VARARGS, nullptr },
        { "remove_logging_channel", (PyCFunction)ILoggingSession_RemoveLoggingChannel, METH_VARARGS, nullptr },
        { "save_to_file_async", (PyCFunction)ILoggingSession_SaveToFileAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)ILoggingSession_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ILoggingSession, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_ILoggingSession, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_ILoggingSession, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ILoggingSession[] = {
        { const_cast<char*>("name"), (getter)ILoggingSession_get_Name, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ILoggingSession[] = 
    {
        { Py_tp_new, _new_ILoggingSession },
        { Py_tp_dealloc, _dealloc_ILoggingSession },
        { Py_tp_methods, _methods_ILoggingSession },
        { Py_tp_getset, _getset_ILoggingSession },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ILoggingSession =
    {
        "_winrt_Windows_Foundation_Diagnostics.ILoggingSession",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILoggingSession
    };

    // ----- ILoggingTarget interface --------------------
    constexpr const char* const _type_name_ILoggingTarget = "ILoggingTarget";

    static PyObject* _new_ILoggingTarget(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ILoggingTarget);
        return nullptr;
    }

    static void _dealloc_ILoggingTarget(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ILoggingTarget_IsEnabled(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.IsEnabled());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 0);

                return py::convert(self->obj.IsEnabled(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                return py::convert(self->obj.IsEnabled(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingTarget_LogEvent(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.LogEvent(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);

                self->obj.LogEvent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                self->obj.LogEvent(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOptions>(args, 3);

                self->obj.LogEvent(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingTarget_StartActivity(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.StartActivity(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);

                return py::convert(self->obj.StartActivity(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                return py::convert(self->obj.StartActivity(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOptions>(args, 3);

                return py::convert(self->obj.StartActivity(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ILoggingTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::ILoggingTarget>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILoggingTarget[] = {
        { "is_enabled", (PyCFunction)ILoggingTarget_IsEnabled, METH_VARARGS, nullptr },
        { "log_event", (PyCFunction)ILoggingTarget_LogEvent, METH_VARARGS, nullptr },
        { "start_activity", (PyCFunction)ILoggingTarget_StartActivity, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ILoggingTarget, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ILoggingTarget[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ILoggingTarget[] = 
    {
        { Py_tp_new, _new_ILoggingTarget },
        { Py_tp_dealloc, _dealloc_ILoggingTarget },
        { Py_tp_methods, _methods_ILoggingTarget },
        { Py_tp_getset, _getset_ILoggingTarget },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ILoggingTarget =
    {
        "_winrt_Windows_Foundation_Diagnostics.ILoggingTarget",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILoggingTarget
    };

    // ----- Windows.Foundation.Diagnostics Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer>::python_type = py::register_python_type(module, _type_name_AsyncCausalityTracer, &_type_spec_AsyncCausalityTracer, nullptr);
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::ErrorDetails>::python_type = py::register_python_type(module, _type_name_ErrorDetails, &_type_spec_ErrorDetails, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::FileLoggingSession>::python_type = py::register_python_type(module, _type_name_FileLoggingSession, &_type_spec_FileLoggingSession, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs>::python_type = py::register_python_type(module, _type_name_LogFileGeneratedEventArgs, &_type_spec_LogFileGeneratedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingActivity>::python_type = py::register_python_type(module, _type_name_LoggingActivity, &_type_spec_LoggingActivity, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingChannel>::python_type = py::register_python_type(module, _type_name_LoggingChannel, &_type_spec_LoggingChannel, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingChannelOptions>::python_type = py::register_python_type(module, _type_name_LoggingChannelOptions, &_type_spec_LoggingChannelOptions, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingFields>::python_type = py::register_python_type(module, _type_name_LoggingFields, &_type_spec_LoggingFields, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingOptions>::python_type = py::register_python_type(module, _type_name_LoggingOptions, &_type_spec_LoggingOptions, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingSession>::python_type = py::register_python_type(module, _type_name_LoggingSession, &_type_spec_LoggingSession, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings>::python_type = py::register_python_type(module, _type_name_RuntimeBrokerErrorSettings, &_type_spec_RuntimeBrokerErrorSettings, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs>::python_type = py::register_python_type(module, _type_name_TracingStatusChangedEventArgs, &_type_spec_TracingStatusChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::IErrorReportingSettings>::python_type = py::register_python_type(module, _type_name_IErrorReportingSettings, &_type_spec_IErrorReportingSettings, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::IFileLoggingSession>::python_type = py::register_python_type(module, _type_name_IFileLoggingSession, &_type_spec_IFileLoggingSession, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>::python_type = py::register_python_type(module, _type_name_ILoggingChannel, &_type_spec_ILoggingChannel, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::ILoggingSession>::python_type = py::register_python_type(module, _type_name_ILoggingSession, &_type_spec_ILoggingSession, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::ILoggingTarget>::python_type = py::register_python_type(module, _type_name_ILoggingTarget, &_type_spec_ILoggingTarget, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Foundation.Diagnostics");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Foundation_Diagnostics",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Foundation::Diagnostics

PyMODINIT_FUNC
PyInit__winrt_Windows_Foundation_Diagnostics (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Foundation::Diagnostics::module_def);
}
