// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Media.SpeechRecognition.h"

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint>::python_type;

namespace py::cpp::Windows::Media::SpeechRecognition
{
    // ----- SpeechContinuousRecognitionCompletedEventArgs class --------------------
    constexpr const char* const _type_name_SpeechContinuousRecognitionCompletedEventArgs = "SpeechContinuousRecognitionCompletedEventArgs";

    static PyObject* _new_SpeechContinuousRecognitionCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechContinuousRecognitionCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpeechContinuousRecognitionCompletedEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechContinuousRecognitionCompletedEventArgs_get_Status(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechContinuousRecognitionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechContinuousRecognitionCompletedEventArgs[] = {
        { "_from", (PyCFunction)_from_SpeechContinuousRecognitionCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SpeechContinuousRecognitionCompletedEventArgs[] = {
        { const_cast<char*>("status"), (getter)SpeechContinuousRecognitionCompletedEventArgs_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SpeechContinuousRecognitionCompletedEventArgs[] = 
    {
        { Py_tp_new, _new_SpeechContinuousRecognitionCompletedEventArgs },
        { Py_tp_dealloc, _dealloc_SpeechContinuousRecognitionCompletedEventArgs },
        { Py_tp_methods, _methods_SpeechContinuousRecognitionCompletedEventArgs },
        { Py_tp_getset, _getset_SpeechContinuousRecognitionCompletedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechContinuousRecognitionCompletedEventArgs =
    {
        "_winrt_Windows_Media_SpeechRecognition.SpeechContinuousRecognitionCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechContinuousRecognitionCompletedEventArgs
    };

    // ----- SpeechContinuousRecognitionResultGeneratedEventArgs class --------------------
    constexpr const char* const _type_name_SpeechContinuousRecognitionResultGeneratedEventArgs = "SpeechContinuousRecognitionResultGeneratedEventArgs";

    static PyObject* _new_SpeechContinuousRecognitionResultGeneratedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechContinuousRecognitionResultGeneratedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpeechContinuousRecognitionResultGeneratedEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechContinuousRecognitionResultGeneratedEventArgs_get_Result(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechContinuousRecognitionResultGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechContinuousRecognitionResultGeneratedEventArgs[] = {
        { "_from", (PyCFunction)_from_SpeechContinuousRecognitionResultGeneratedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SpeechContinuousRecognitionResultGeneratedEventArgs[] = {
        { const_cast<char*>("result"), (getter)SpeechContinuousRecognitionResultGeneratedEventArgs_get_Result, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SpeechContinuousRecognitionResultGeneratedEventArgs[] = 
    {
        { Py_tp_new, _new_SpeechContinuousRecognitionResultGeneratedEventArgs },
        { Py_tp_dealloc, _dealloc_SpeechContinuousRecognitionResultGeneratedEventArgs },
        { Py_tp_methods, _methods_SpeechContinuousRecognitionResultGeneratedEventArgs },
        { Py_tp_getset, _getset_SpeechContinuousRecognitionResultGeneratedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechContinuousRecognitionResultGeneratedEventArgs =
    {
        "_winrt_Windows_Media_SpeechRecognition.SpeechContinuousRecognitionResultGeneratedEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechContinuousRecognitionResultGeneratedEventArgs
    };

    // ----- SpeechContinuousRecognitionSession class --------------------
    constexpr const char* const _type_name_SpeechContinuousRecognitionSession = "SpeechContinuousRecognitionSession";

    static PyObject* _new_SpeechContinuousRecognitionSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechContinuousRecognitionSession);
        return nullptr;
    }

    static void _dealloc_SpeechContinuousRecognitionSession(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechContinuousRecognitionSession_CancelAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CancelAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_PauseAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.PauseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_Resume(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Resume();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_StartAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionMode>(args, 0);

                return py::convert(self->obj.StartAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_StopAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StopAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_get_AutoStopSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoStopSilenceTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechContinuousRecognitionSession_put_AutoStopSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.AutoStopSilenceTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_add_Completed(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession, winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs>>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_remove_Completed(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_add_ResultGenerated(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession, winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs>>(arg);

            return py::convert(self->obj.ResultGenerated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_remove_ResultGenerated(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ResultGenerated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechContinuousRecognitionSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechContinuousRecognitionSession[] = {
        { "cancel_async", (PyCFunction)SpeechContinuousRecognitionSession_CancelAsync, METH_VARARGS, nullptr },
        { "pause_async", (PyCFunction)SpeechContinuousRecognitionSession_PauseAsync, METH_VARARGS, nullptr },
        { "resume", (PyCFunction)SpeechContinuousRecognitionSession_Resume, METH_VARARGS, nullptr },
        { "start_async", (PyCFunction)SpeechContinuousRecognitionSession_StartAsync, METH_VARARGS, nullptr },
        { "stop_async", (PyCFunction)SpeechContinuousRecognitionSession_StopAsync, METH_VARARGS, nullptr },
        { "add_completed", (PyCFunction)SpeechContinuousRecognitionSession_add_Completed, METH_O, nullptr },
        { "remove_completed", (PyCFunction)SpeechContinuousRecognitionSession_remove_Completed, METH_O, nullptr },
        { "add_result_generated", (PyCFunction)SpeechContinuousRecognitionSession_add_ResultGenerated, METH_O, nullptr },
        { "remove_result_generated", (PyCFunction)SpeechContinuousRecognitionSession_remove_ResultGenerated, METH_O, nullptr },
        { "_from", (PyCFunction)_from_SpeechContinuousRecognitionSession, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SpeechContinuousRecognitionSession[] = {
        { const_cast<char*>("auto_stop_silence_timeout"), (getter)SpeechContinuousRecognitionSession_get_AutoStopSilenceTimeout, (setter)SpeechContinuousRecognitionSession_put_AutoStopSilenceTimeout, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SpeechContinuousRecognitionSession[] = 
    {
        { Py_tp_new, _new_SpeechContinuousRecognitionSession },
        { Py_tp_dealloc, _dealloc_SpeechContinuousRecognitionSession },
        { Py_tp_methods, _methods_SpeechContinuousRecognitionSession },
        { Py_tp_getset, _getset_SpeechContinuousRecognitionSession },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechContinuousRecognitionSession =
    {
        "_winrt_Windows_Media_SpeechRecognition.SpeechContinuousRecognitionSession",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechContinuousRecognitionSession
    };

    // ----- SpeechRecognitionCompilationResult class --------------------
    constexpr const char* const _type_name_SpeechRecognitionCompilationResult = "SpeechRecognitionCompilationResult";

    static PyObject* _new_SpeechRecognitionCompilationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechRecognitionCompilationResult);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionCompilationResult(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognitionCompilationResult_get_Status(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionCompilationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionCompilationResult[] = {
        { "_from", (PyCFunction)_from_SpeechRecognitionCompilationResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SpeechRecognitionCompilationResult[] = {
        { const_cast<char*>("status"), (getter)SpeechRecognitionCompilationResult_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SpeechRecognitionCompilationResult[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionCompilationResult },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionCompilationResult },
        { Py_tp_methods, _methods_SpeechRecognitionCompilationResult },
        { Py_tp_getset, _getset_SpeechRecognitionCompilationResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognitionCompilationResult =
    {
        "_winrt_Windows_Media_SpeechRecognition.SpeechRecognitionCompilationResult",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionCompilationResult
    };

    // ----- SpeechRecognitionGrammarFileConstraint class --------------------
    constexpr const char* const _type_name_SpeechRecognitionGrammarFileConstraint = "SpeechRecognitionGrammarFileConstraint";

    static PyObject* _new_SpeechRecognitionGrammarFileConstraint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechRecognitionGrammarFileConstraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionGrammarFileConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Probability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionGrammarFileConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            self->obj.Probability(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionGrammarFileConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_GrammarFile(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.GrammarFile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionGrammarFileConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionGrammarFileConstraint[] = {
        { "_from", (PyCFunction)_from_SpeechRecognitionGrammarFileConstraint, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SpeechRecognitionGrammarFileConstraint[] = {
        { const_cast<char*>("tag"), (getter)SpeechRecognitionGrammarFileConstraint_get_Tag, (setter)SpeechRecognitionGrammarFileConstraint_put_Tag, nullptr, nullptr },
        { const_cast<char*>("probability"), (getter)SpeechRecognitionGrammarFileConstraint_get_Probability, (setter)SpeechRecognitionGrammarFileConstraint_put_Probability, nullptr, nullptr },
        { const_cast<char*>("is_enabled"), (getter)SpeechRecognitionGrammarFileConstraint_get_IsEnabled, (setter)SpeechRecognitionGrammarFileConstraint_put_IsEnabled, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)SpeechRecognitionGrammarFileConstraint_get_Type, nullptr, nullptr, nullptr },
        { const_cast<char*>("grammar_file"), (getter)SpeechRecognitionGrammarFileConstraint_get_GrammarFile, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SpeechRecognitionGrammarFileConstraint[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionGrammarFileConstraint },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionGrammarFileConstraint },
        { Py_tp_methods, _methods_SpeechRecognitionGrammarFileConstraint },
        { Py_tp_getset, _getset_SpeechRecognitionGrammarFileConstraint },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognitionGrammarFileConstraint =
    {
        "_winrt_Windows_Media_SpeechRecognition.SpeechRecognitionGrammarFileConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionGrammarFileConstraint
    };

    // ----- SpeechRecognitionHypothesis class --------------------
    constexpr const char* const _type_name_SpeechRecognitionHypothesis = "SpeechRecognitionHypothesis";

    static PyObject* _new_SpeechRecognitionHypothesis(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechRecognitionHypothesis);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionHypothesis(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognitionHypothesis_get_Text(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionHypothesis(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionHypothesis[] = {
        { "_from", (PyCFunction)_from_SpeechRecognitionHypothesis, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SpeechRecognitionHypothesis[] = {
        { const_cast<char*>("text"), (getter)SpeechRecognitionHypothesis_get_Text, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SpeechRecognitionHypothesis[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionHypothesis },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionHypothesis },
        { Py_tp_methods, _methods_SpeechRecognitionHypothesis },
        { Py_tp_getset, _getset_SpeechRecognitionHypothesis },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognitionHypothesis =
    {
        "_winrt_Windows_Media_SpeechRecognition.SpeechRecognitionHypothesis",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionHypothesis
    };

    // ----- SpeechRecognitionHypothesisGeneratedEventArgs class --------------------
    constexpr const char* const _type_name_SpeechRecognitionHypothesisGeneratedEventArgs = "SpeechRecognitionHypothesisGeneratedEventArgs";

    static PyObject* _new_SpeechRecognitionHypothesisGeneratedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechRecognitionHypothesisGeneratedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionHypothesisGeneratedEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognitionHypothesisGeneratedEventArgs_get_Hypothesis(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Hypothesis());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionHypothesisGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionHypothesisGeneratedEventArgs[] = {
        { "_from", (PyCFunction)_from_SpeechRecognitionHypothesisGeneratedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SpeechRecognitionHypothesisGeneratedEventArgs[] = {
        { const_cast<char*>("hypothesis"), (getter)SpeechRecognitionHypothesisGeneratedEventArgs_get_Hypothesis, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SpeechRecognitionHypothesisGeneratedEventArgs[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionHypothesisGeneratedEventArgs },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionHypothesisGeneratedEventArgs },
        { Py_tp_methods, _methods_SpeechRecognitionHypothesisGeneratedEventArgs },
        { Py_tp_getset, _getset_SpeechRecognitionHypothesisGeneratedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognitionHypothesisGeneratedEventArgs =
    {
        "_winrt_Windows_Media_SpeechRecognition.SpeechRecognitionHypothesisGeneratedEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionHypothesisGeneratedEventArgs
    };

    // ----- SpeechRecognitionListConstraint class --------------------
    constexpr const char* const _type_name_SpeechRecognitionListConstraint = "SpeechRecognitionListConstraint";

    static PyObject* _new_SpeechRecognitionListConstraint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechRecognitionListConstraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognitionListConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionListConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionListConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Probability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionListConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            self->obj.Probability(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionListConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionListConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionListConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionListConstraint_get_Commands(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Commands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionListConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionListConstraint[] = {
        { "_from", (PyCFunction)_from_SpeechRecognitionListConstraint, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SpeechRecognitionListConstraint[] = {
        { const_cast<char*>("tag"), (getter)SpeechRecognitionListConstraint_get_Tag, (setter)SpeechRecognitionListConstraint_put_Tag, nullptr, nullptr },
        { const_cast<char*>("probability"), (getter)SpeechRecognitionListConstraint_get_Probability, (setter)SpeechRecognitionListConstraint_put_Probability, nullptr, nullptr },
        { const_cast<char*>("is_enabled"), (getter)SpeechRecognitionListConstraint_get_IsEnabled, (setter)SpeechRecognitionListConstraint_put_IsEnabled, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)SpeechRecognitionListConstraint_get_Type, nullptr, nullptr, nullptr },
        { const_cast<char*>("commands"), (getter)SpeechRecognitionListConstraint_get_Commands, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SpeechRecognitionListConstraint[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionListConstraint },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionListConstraint },
        { Py_tp_methods, _methods_SpeechRecognitionListConstraint },
        { Py_tp_getset, _getset_SpeechRecognitionListConstraint },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognitionListConstraint =
    {
        "_winrt_Windows_Media_SpeechRecognition.SpeechRecognitionListConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionListConstraint
    };

    // ----- SpeechRecognitionQualityDegradingEventArgs class --------------------
    constexpr const char* const _type_name_SpeechRecognitionQualityDegradingEventArgs = "SpeechRecognitionQualityDegradingEventArgs";

    static PyObject* _new_SpeechRecognitionQualityDegradingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechRecognitionQualityDegradingEventArgs);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionQualityDegradingEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognitionQualityDegradingEventArgs_get_Problem(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Problem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionQualityDegradingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionQualityDegradingEventArgs[] = {
        { "_from", (PyCFunction)_from_SpeechRecognitionQualityDegradingEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SpeechRecognitionQualityDegradingEventArgs[] = {
        { const_cast<char*>("problem"), (getter)SpeechRecognitionQualityDegradingEventArgs_get_Problem, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SpeechRecognitionQualityDegradingEventArgs[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionQualityDegradingEventArgs },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionQualityDegradingEventArgs },
        { Py_tp_methods, _methods_SpeechRecognitionQualityDegradingEventArgs },
        { Py_tp_getset, _getset_SpeechRecognitionQualityDegradingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognitionQualityDegradingEventArgs =
    {
        "_winrt_Windows_Media_SpeechRecognition.SpeechRecognitionQualityDegradingEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionQualityDegradingEventArgs
    };

    // ----- SpeechRecognitionResult class --------------------
    constexpr const char* const _type_name_SpeechRecognitionResult = "SpeechRecognitionResult";

    static PyObject* _new_SpeechRecognitionResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechRecognitionResult);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionResult(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognitionResult_GetAlternates(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAlternates(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_Confidence(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Confidence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_Constraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Constraint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_RawConfidence(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawConfidence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_RulePath(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RulePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_SemanticInterpretation(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SemanticInterpretation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_Status(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_Text(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_PhraseDuration(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhraseDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_PhraseStartTime(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhraseStartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionResult[] = {
        { "get_alternates", (PyCFunction)SpeechRecognitionResult_GetAlternates, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_SpeechRecognitionResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SpeechRecognitionResult[] = {
        { const_cast<char*>("confidence"), (getter)SpeechRecognitionResult_get_Confidence, nullptr, nullptr, nullptr },
        { const_cast<char*>("constraint"), (getter)SpeechRecognitionResult_get_Constraint, nullptr, nullptr, nullptr },
        { const_cast<char*>("raw_confidence"), (getter)SpeechRecognitionResult_get_RawConfidence, nullptr, nullptr, nullptr },
        { const_cast<char*>("rule_path"), (getter)SpeechRecognitionResult_get_RulePath, nullptr, nullptr, nullptr },
        { const_cast<char*>("semantic_interpretation"), (getter)SpeechRecognitionResult_get_SemanticInterpretation, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)SpeechRecognitionResult_get_Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("text"), (getter)SpeechRecognitionResult_get_Text, nullptr, nullptr, nullptr },
        { const_cast<char*>("phrase_duration"), (getter)SpeechRecognitionResult_get_PhraseDuration, nullptr, nullptr, nullptr },
        { const_cast<char*>("phrase_start_time"), (getter)SpeechRecognitionResult_get_PhraseStartTime, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SpeechRecognitionResult[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionResult },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionResult },
        { Py_tp_methods, _methods_SpeechRecognitionResult },
        { Py_tp_getset, _getset_SpeechRecognitionResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognitionResult =
    {
        "_winrt_Windows_Media_SpeechRecognition.SpeechRecognitionResult",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionResult
    };

    // ----- SpeechRecognitionSemanticInterpretation class --------------------
    constexpr const char* const _type_name_SpeechRecognitionSemanticInterpretation = "SpeechRecognitionSemanticInterpretation";

    static PyObject* _new_SpeechRecognitionSemanticInterpretation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechRecognitionSemanticInterpretation);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionSemanticInterpretation(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognitionSemanticInterpretation_get_Properties(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionSemanticInterpretation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionSemanticInterpretation[] = {
        { "_from", (PyCFunction)_from_SpeechRecognitionSemanticInterpretation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SpeechRecognitionSemanticInterpretation[] = {
        { const_cast<char*>("properties"), (getter)SpeechRecognitionSemanticInterpretation_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SpeechRecognitionSemanticInterpretation[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionSemanticInterpretation },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionSemanticInterpretation },
        { Py_tp_methods, _methods_SpeechRecognitionSemanticInterpretation },
        { Py_tp_getset, _getset_SpeechRecognitionSemanticInterpretation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognitionSemanticInterpretation =
    {
        "_winrt_Windows_Media_SpeechRecognition.SpeechRecognitionSemanticInterpretation",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionSemanticInterpretation
    };

    // ----- SpeechRecognitionTopicConstraint class --------------------
    constexpr const char* const _type_name_SpeechRecognitionTopicConstraint = "SpeechRecognitionTopicConstraint";

    static PyObject* _new_SpeechRecognitionTopicConstraint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionScenario>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionScenario>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechRecognitionTopicConstraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionTopicConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Probability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionTopicConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            self->obj.Probability(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionTopicConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_Scenario(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Scenario());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_TopicHint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TopicHint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionTopicConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionTopicConstraint[] = {
        { "_from", (PyCFunction)_from_SpeechRecognitionTopicConstraint, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SpeechRecognitionTopicConstraint[] = {
        { const_cast<char*>("tag"), (getter)SpeechRecognitionTopicConstraint_get_Tag, (setter)SpeechRecognitionTopicConstraint_put_Tag, nullptr, nullptr },
        { const_cast<char*>("probability"), (getter)SpeechRecognitionTopicConstraint_get_Probability, (setter)SpeechRecognitionTopicConstraint_put_Probability, nullptr, nullptr },
        { const_cast<char*>("is_enabled"), (getter)SpeechRecognitionTopicConstraint_get_IsEnabled, (setter)SpeechRecognitionTopicConstraint_put_IsEnabled, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)SpeechRecognitionTopicConstraint_get_Type, nullptr, nullptr, nullptr },
        { const_cast<char*>("scenario"), (getter)SpeechRecognitionTopicConstraint_get_Scenario, nullptr, nullptr, nullptr },
        { const_cast<char*>("topic_hint"), (getter)SpeechRecognitionTopicConstraint_get_TopicHint, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SpeechRecognitionTopicConstraint[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionTopicConstraint },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionTopicConstraint },
        { Py_tp_methods, _methods_SpeechRecognitionTopicConstraint },
        { Py_tp_getset, _getset_SpeechRecognitionTopicConstraint },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognitionTopicConstraint =
    {
        "_winrt_Windows_Media_SpeechRecognition.SpeechRecognitionTopicConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionTopicConstraint
    };

    // ----- SpeechRecognitionVoiceCommandDefinitionConstraint class --------------------
    constexpr const char* const _type_name_SpeechRecognitionVoiceCommandDefinitionConstraint = "SpeechRecognitionVoiceCommandDefinitionConstraint";

    static PyObject* _new_SpeechRecognitionVoiceCommandDefinitionConstraint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechRecognitionVoiceCommandDefinitionConstraint);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionVoiceCommandDefinitionConstraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognitionVoiceCommandDefinitionConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionVoiceCommandDefinitionConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionVoiceCommandDefinitionConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Probability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionVoiceCommandDefinitionConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            self->obj.Probability(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionVoiceCommandDefinitionConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionVoiceCommandDefinitionConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionVoiceCommandDefinitionConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionVoiceCommandDefinitionConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionVoiceCommandDefinitionConstraint[] = {
        { "_from", (PyCFunction)_from_SpeechRecognitionVoiceCommandDefinitionConstraint, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SpeechRecognitionVoiceCommandDefinitionConstraint[] = {
        { const_cast<char*>("tag"), (getter)SpeechRecognitionVoiceCommandDefinitionConstraint_get_Tag, (setter)SpeechRecognitionVoiceCommandDefinitionConstraint_put_Tag, nullptr, nullptr },
        { const_cast<char*>("probability"), (getter)SpeechRecognitionVoiceCommandDefinitionConstraint_get_Probability, (setter)SpeechRecognitionVoiceCommandDefinitionConstraint_put_Probability, nullptr, nullptr },
        { const_cast<char*>("is_enabled"), (getter)SpeechRecognitionVoiceCommandDefinitionConstraint_get_IsEnabled, (setter)SpeechRecognitionVoiceCommandDefinitionConstraint_put_IsEnabled, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)SpeechRecognitionVoiceCommandDefinitionConstraint_get_Type, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SpeechRecognitionVoiceCommandDefinitionConstraint[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionVoiceCommandDefinitionConstraint },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionVoiceCommandDefinitionConstraint },
        { Py_tp_methods, _methods_SpeechRecognitionVoiceCommandDefinitionConstraint },
        { Py_tp_getset, _getset_SpeechRecognitionVoiceCommandDefinitionConstraint },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognitionVoiceCommandDefinitionConstraint =
    {
        "_winrt_Windows_Media_SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionVoiceCommandDefinitionConstraint
    };

    // ----- SpeechRecognizer class --------------------
    constexpr const char* const _type_name_SpeechRecognizer = "SpeechRecognizer";

    static PyObject* _new_SpeechRecognizer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Globalization::Language>(args, 0);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognizer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::SpeechRecognition::SpeechRecognizer instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechRecognizer(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognizer_Close(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_CompileConstraintsAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CompileConstraintsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_RecognizeAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RecognizeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_RecognizeWithUIAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RecognizeWithUIAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_StopRecognitionAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StopRecognitionAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_TrySetSystemSpeechLanguageAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Globalization::Language>(args, 0);

                return py::convert(winrt::Windows::Media::SpeechRecognition::SpeechRecognizer::TrySetSystemSpeechLanguageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_Constraints(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Constraints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_CurrentLanguage(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_Timeouts(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timeouts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_UIOptions(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UIOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_ContinuousRecognitionSession(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContinuousRecognitionSession());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_State(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_SupportedGrammarLanguages(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::SpeechRecognition::SpeechRecognizer::SupportedGrammarLanguages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_SupportedTopicLanguages(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::SpeechRecognition::SpeechRecognizer::SupportedTopicLanguages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_SystemSpeechLanguage(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::SpeechRecognition::SpeechRecognizer::SystemSpeechLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_add_RecognitionQualityDegrading(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer, winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs>>(arg);

            return py::convert(self->obj.RecognitionQualityDegrading(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_remove_RecognitionQualityDegrading(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RecognitionQualityDegrading(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_add_StateChanged(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer, winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_remove_StateChanged(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_add_HypothesisGenerated(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer, winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs>>(arg);

            return py::convert(self->obj.HypothesisGenerated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_remove_HypothesisGenerated(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HypothesisGenerated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_SpeechRecognizer(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_SpeechRecognizer(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognizer[] = {
        { "close", (PyCFunction)SpeechRecognizer_Close, METH_VARARGS, nullptr },
        { "compile_constraints_async", (PyCFunction)SpeechRecognizer_CompileConstraintsAsync, METH_VARARGS, nullptr },
        { "recognize_async", (PyCFunction)SpeechRecognizer_RecognizeAsync, METH_VARARGS, nullptr },
        { "recognize_with_u_i_async", (PyCFunction)SpeechRecognizer_RecognizeWithUIAsync, METH_VARARGS, nullptr },
        { "stop_recognition_async", (PyCFunction)SpeechRecognizer_StopRecognitionAsync, METH_VARARGS, nullptr },
        { "try_set_system_speech_language_async", (PyCFunction)SpeechRecognizer_TrySetSystemSpeechLanguageAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_supported_grammar_languages", (PyCFunction)SpeechRecognizer_get_SupportedGrammarLanguages, METH_NOARGS | METH_STATIC, nullptr },
        { "get_supported_topic_languages", (PyCFunction)SpeechRecognizer_get_SupportedTopicLanguages, METH_NOARGS | METH_STATIC, nullptr },
        { "get_system_speech_language", (PyCFunction)SpeechRecognizer_get_SystemSpeechLanguage, METH_NOARGS | METH_STATIC, nullptr },
        { "add_recognition_quality_degrading", (PyCFunction)SpeechRecognizer_add_RecognitionQualityDegrading, METH_O, nullptr },
        { "remove_recognition_quality_degrading", (PyCFunction)SpeechRecognizer_remove_RecognitionQualityDegrading, METH_O, nullptr },
        { "add_state_changed", (PyCFunction)SpeechRecognizer_add_StateChanged, METH_O, nullptr },
        { "remove_state_changed", (PyCFunction)SpeechRecognizer_remove_StateChanged, METH_O, nullptr },
        { "add_hypothesis_generated", (PyCFunction)SpeechRecognizer_add_HypothesisGenerated, METH_O, nullptr },
        { "remove_hypothesis_generated", (PyCFunction)SpeechRecognizer_remove_HypothesisGenerated, METH_O, nullptr },
        { "_from", (PyCFunction)_from_SpeechRecognizer, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_SpeechRecognizer, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_SpeechRecognizer, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SpeechRecognizer[] = {
        { const_cast<char*>("constraints"), (getter)SpeechRecognizer_get_Constraints, nullptr, nullptr, nullptr },
        { const_cast<char*>("current_language"), (getter)SpeechRecognizer_get_CurrentLanguage, nullptr, nullptr, nullptr },
        { const_cast<char*>("timeouts"), (getter)SpeechRecognizer_get_Timeouts, nullptr, nullptr, nullptr },
        { const_cast<char*>("u_i_options"), (getter)SpeechRecognizer_get_UIOptions, nullptr, nullptr, nullptr },
        { const_cast<char*>("continuous_recognition_session"), (getter)SpeechRecognizer_get_ContinuousRecognitionSession, nullptr, nullptr, nullptr },
        { const_cast<char*>("state"), (getter)SpeechRecognizer_get_State, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SpeechRecognizer[] = 
    {
        { Py_tp_new, _new_SpeechRecognizer },
        { Py_tp_dealloc, _dealloc_SpeechRecognizer },
        { Py_tp_methods, _methods_SpeechRecognizer },
        { Py_tp_getset, _getset_SpeechRecognizer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognizer =
    {
        "_winrt_Windows_Media_SpeechRecognition.SpeechRecognizer",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognizer
    };

    // ----- SpeechRecognizerStateChangedEventArgs class --------------------
    constexpr const char* const _type_name_SpeechRecognizerStateChangedEventArgs = "SpeechRecognizerStateChangedEventArgs";

    static PyObject* _new_SpeechRecognizerStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechRecognizerStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpeechRecognizerStateChangedEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognizerStateChangedEventArgs_get_State(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognizerStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognizerStateChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_SpeechRecognizerStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SpeechRecognizerStateChangedEventArgs[] = {
        { const_cast<char*>("state"), (getter)SpeechRecognizerStateChangedEventArgs_get_State, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SpeechRecognizerStateChangedEventArgs[] = 
    {
        { Py_tp_new, _new_SpeechRecognizerStateChangedEventArgs },
        { Py_tp_dealloc, _dealloc_SpeechRecognizerStateChangedEventArgs },
        { Py_tp_methods, _methods_SpeechRecognizerStateChangedEventArgs },
        { Py_tp_getset, _getset_SpeechRecognizerStateChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognizerStateChangedEventArgs =
    {
        "_winrt_Windows_Media_SpeechRecognition.SpeechRecognizerStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognizerStateChangedEventArgs
    };

    // ----- SpeechRecognizerTimeouts class --------------------
    constexpr const char* const _type_name_SpeechRecognizerTimeouts = "SpeechRecognizerTimeouts";

    static PyObject* _new_SpeechRecognizerTimeouts(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechRecognizerTimeouts);
        return nullptr;
    }

    static void _dealloc_SpeechRecognizerTimeouts(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognizerTimeouts_get_InitialSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InitialSilenceTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerTimeouts_put_InitialSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.InitialSilenceTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerTimeouts_get_EndSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndSilenceTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerTimeouts_put_EndSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.EndSilenceTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerTimeouts_get_BabbleTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BabbleTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerTimeouts_put_BabbleTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.BabbleTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_SpeechRecognizerTimeouts(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognizerTimeouts[] = {
        { "_from", (PyCFunction)_from_SpeechRecognizerTimeouts, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SpeechRecognizerTimeouts[] = {
        { const_cast<char*>("initial_silence_timeout"), (getter)SpeechRecognizerTimeouts_get_InitialSilenceTimeout, (setter)SpeechRecognizerTimeouts_put_InitialSilenceTimeout, nullptr, nullptr },
        { const_cast<char*>("end_silence_timeout"), (getter)SpeechRecognizerTimeouts_get_EndSilenceTimeout, (setter)SpeechRecognizerTimeouts_put_EndSilenceTimeout, nullptr, nullptr },
        { const_cast<char*>("babble_timeout"), (getter)SpeechRecognizerTimeouts_get_BabbleTimeout, (setter)SpeechRecognizerTimeouts_put_BabbleTimeout, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SpeechRecognizerTimeouts[] = 
    {
        { Py_tp_new, _new_SpeechRecognizerTimeouts },
        { Py_tp_dealloc, _dealloc_SpeechRecognizerTimeouts },
        { Py_tp_methods, _methods_SpeechRecognizerTimeouts },
        { Py_tp_getset, _getset_SpeechRecognizerTimeouts },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognizerTimeouts =
    {
        "_winrt_Windows_Media_SpeechRecognition.SpeechRecognizerTimeouts",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognizerTimeouts
    };

    // ----- SpeechRecognizerUIOptions class --------------------
    constexpr const char* const _type_name_SpeechRecognizerUIOptions = "SpeechRecognizerUIOptions";

    static PyObject* _new_SpeechRecognizerUIOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechRecognizerUIOptions);
        return nullptr;
    }

    static void _dealloc_SpeechRecognizerUIOptions(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognizerUIOptions_get_ShowConfirmation(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShowConfirmation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerUIOptions_put_ShowConfirmation(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowConfirmation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerUIOptions_get_IsReadBackEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadBackEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerUIOptions_put_IsReadBackEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsReadBackEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerUIOptions_get_ExampleText(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExampleText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerUIOptions_put_ExampleText(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ExampleText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerUIOptions_get_AudiblePrompt(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudiblePrompt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerUIOptions_put_AudiblePrompt(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AudiblePrompt(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_SpeechRecognizerUIOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognizerUIOptions[] = {
        { "_from", (PyCFunction)_from_SpeechRecognizerUIOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SpeechRecognizerUIOptions[] = {
        { const_cast<char*>("show_confirmation"), (getter)SpeechRecognizerUIOptions_get_ShowConfirmation, (setter)SpeechRecognizerUIOptions_put_ShowConfirmation, nullptr, nullptr },
        { const_cast<char*>("is_read_back_enabled"), (getter)SpeechRecognizerUIOptions_get_IsReadBackEnabled, (setter)SpeechRecognizerUIOptions_put_IsReadBackEnabled, nullptr, nullptr },
        { const_cast<char*>("example_text"), (getter)SpeechRecognizerUIOptions_get_ExampleText, (setter)SpeechRecognizerUIOptions_put_ExampleText, nullptr, nullptr },
        { const_cast<char*>("audible_prompt"), (getter)SpeechRecognizerUIOptions_get_AudiblePrompt, (setter)SpeechRecognizerUIOptions_put_AudiblePrompt, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SpeechRecognizerUIOptions[] = 
    {
        { Py_tp_new, _new_SpeechRecognizerUIOptions },
        { Py_tp_dealloc, _dealloc_SpeechRecognizerUIOptions },
        { Py_tp_methods, _methods_SpeechRecognizerUIOptions },
        { Py_tp_getset, _getset_SpeechRecognizerUIOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognizerUIOptions =
    {
        "_winrt_Windows_Media_SpeechRecognition.SpeechRecognizerUIOptions",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognizerUIOptions
    };

    // ----- ISpeechRecognitionConstraint interface --------------------
    constexpr const char* const _type_name_ISpeechRecognitionConstraint = "ISpeechRecognitionConstraint";

    static PyObject* _new_ISpeechRecognitionConstraint(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ISpeechRecognitionConstraint);
        return nullptr;
    }

    static void _dealloc_ISpeechRecognitionConstraint(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ISpeechRecognitionConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISpeechRecognitionConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISpeechRecognitionConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Probability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISpeechRecognitionConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            self->obj.Probability(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISpeechRecognitionConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISpeechRecognitionConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISpeechRecognitionConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ISpeechRecognitionConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISpeechRecognitionConstraint[] = {
        { "_from", (PyCFunction)_from_ISpeechRecognitionConstraint, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ISpeechRecognitionConstraint[] = {
        { const_cast<char*>("is_enabled"), (getter)ISpeechRecognitionConstraint_get_IsEnabled, (setter)ISpeechRecognitionConstraint_put_IsEnabled, nullptr, nullptr },
        { const_cast<char*>("probability"), (getter)ISpeechRecognitionConstraint_get_Probability, (setter)ISpeechRecognitionConstraint_put_Probability, nullptr, nullptr },
        { const_cast<char*>("tag"), (getter)ISpeechRecognitionConstraint_get_Tag, (setter)ISpeechRecognitionConstraint_put_Tag, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)ISpeechRecognitionConstraint_get_Type, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ISpeechRecognitionConstraint[] = 
    {
        { Py_tp_new, _new_ISpeechRecognitionConstraint },
        { Py_tp_dealloc, _dealloc_ISpeechRecognitionConstraint },
        { Py_tp_methods, _methods_ISpeechRecognitionConstraint },
        { Py_tp_getset, _getset_ISpeechRecognitionConstraint },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ISpeechRecognitionConstraint =
    {
        "_winrt_Windows_Media_SpeechRecognition.ISpeechRecognitionConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISpeechRecognitionConstraint
    };

    // ----- Windows.Media.SpeechRecognition Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs>::python_type = py::register_python_type(module, _type_name_SpeechContinuousRecognitionCompletedEventArgs, &_type_spec_SpeechContinuousRecognitionCompletedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs>::python_type = py::register_python_type(module, _type_name_SpeechContinuousRecognitionResultGeneratedEventArgs, &_type_spec_SpeechContinuousRecognitionResultGeneratedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession>::python_type = py::register_python_type(module, _type_name_SpeechContinuousRecognitionSession, &_type_spec_SpeechContinuousRecognitionSession, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult>::python_type = py::register_python_type(module, _type_name_SpeechRecognitionCompilationResult, &_type_spec_SpeechRecognitionCompilationResult, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint>::python_type = py::register_python_type(module, _type_name_SpeechRecognitionGrammarFileConstraint, &_type_spec_SpeechRecognitionGrammarFileConstraint, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis>::python_type = py::register_python_type(module, _type_name_SpeechRecognitionHypothesis, &_type_spec_SpeechRecognitionHypothesis, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs>::python_type = py::register_python_type(module, _type_name_SpeechRecognitionHypothesisGeneratedEventArgs, &_type_spec_SpeechRecognitionHypothesisGeneratedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint>::python_type = py::register_python_type(module, _type_name_SpeechRecognitionListConstraint, &_type_spec_SpeechRecognitionListConstraint, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs>::python_type = py::register_python_type(module, _type_name_SpeechRecognitionQualityDegradingEventArgs, &_type_spec_SpeechRecognitionQualityDegradingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionResult>::python_type = py::register_python_type(module, _type_name_SpeechRecognitionResult, &_type_spec_SpeechRecognitionResult, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation>::python_type = py::register_python_type(module, _type_name_SpeechRecognitionSemanticInterpretation, &_type_spec_SpeechRecognitionSemanticInterpretation, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint>::python_type = py::register_python_type(module, _type_name_SpeechRecognitionTopicConstraint, &_type_spec_SpeechRecognitionTopicConstraint, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint>::python_type = py::register_python_type(module, _type_name_SpeechRecognitionVoiceCommandDefinitionConstraint, &_type_spec_SpeechRecognitionVoiceCommandDefinitionConstraint, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer>::python_type = py::register_python_type(module, _type_name_SpeechRecognizer, &_type_spec_SpeechRecognizer, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs>::python_type = py::register_python_type(module, _type_name_SpeechRecognizerStateChangedEventArgs, &_type_spec_SpeechRecognizerStateChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts>::python_type = py::register_python_type(module, _type_name_SpeechRecognizerTimeouts, &_type_spec_SpeechRecognizerTimeouts, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions>::python_type = py::register_python_type(module, _type_name_SpeechRecognizerUIOptions, &_type_spec_SpeechRecognizerUIOptions, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint>::python_type = py::register_python_type(module, _type_name_ISpeechRecognitionConstraint, &_type_spec_ISpeechRecognitionConstraint, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Media.SpeechRecognition");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Media_SpeechRecognition",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Media::SpeechRecognition

PyMODINIT_FUNC
PyInit__winrt_Windows_Media_SpeechRecognition (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Media::SpeechRecognition::module_def);
}
