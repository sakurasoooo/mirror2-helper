// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.System.h"

PyTypeObject* py::winrt_type<winrt::Windows::System::AppActivationResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::AppDiagnosticInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::AppDiagnosticInfoWatcher>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::AppDiagnosticInfoWatcherEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::AppExecutionStateChangeResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::AppMemoryReport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::AppMemoryUsageLimitChangingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::AppResourceGroupBackgroundTaskReport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::AppResourceGroupInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::AppResourceGroupInfoWatcher>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::AppResourceGroupInfoWatcherEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::AppResourceGroupMemoryReport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::AppResourceGroupStateReport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::AppUriHandlerHost>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::AppUriHandlerRegistration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::AppUriHandlerRegistrationManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::DateTimeSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::DispatcherQueue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::DispatcherQueueController>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::DispatcherQueueShutdownStartingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::DispatcherQueueTimer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::FolderLauncherOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::KnownUserProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::LaunchUriResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Launcher>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::LauncherOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::LauncherUIOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::MemoryManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::ProcessLauncher>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::ProcessLauncherOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::ProcessLauncherResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::ProcessMemoryReport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::ProtocolForResultsOperation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::RemoteLauncher>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::RemoteLauncherOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::ShutdownManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::TimeZoneSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::User>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::UserAuthenticationStatusChangeDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::UserAuthenticationStatusChangingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::UserChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::UserDeviceAssociation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::UserDeviceAssociationChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::UserPicker>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::UserWatcher>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::ILauncherViewOptions>::python_type;

namespace py::cpp::Windows::System
{
    // ----- AppActivationResult class --------------------
    constexpr const char* const _type_name_AppActivationResult = "AppActivationResult";

    static PyObject* _new_AppActivationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppActivationResult);
        return nullptr;
    }

    static void _dealloc_AppActivationResult(py::wrapper::Windows::System::AppActivationResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppActivationResult_get_AppResourceGroupInfo(py::wrapper::Windows::System::AppActivationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppResourceGroupInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppActivationResult_get_ExtendedError(py::wrapper::Windows::System::AppActivationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppActivationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppActivationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppActivationResult[] = {
        { "_from", (PyCFunction)_from_AppActivationResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppActivationResult[] = {
        { const_cast<char*>("app_resource_group_info"), (getter)AppActivationResult_get_AppResourceGroupInfo, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_error"), (getter)AppActivationResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppActivationResult[] = 
    {
        { Py_tp_new, _new_AppActivationResult },
        { Py_tp_dealloc, _dealloc_AppActivationResult },
        { Py_tp_methods, _methods_AppActivationResult },
        { Py_tp_getset, _getset_AppActivationResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppActivationResult =
    {
        "_winrt_Windows_System.AppActivationResult",
        sizeof(py::wrapper::Windows::System::AppActivationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppActivationResult
    };

    // ----- AppDiagnosticInfo class --------------------
    constexpr const char* const _type_name_AppDiagnosticInfo = "AppDiagnosticInfo";

    static PyObject* _new_AppDiagnosticInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppDiagnosticInfo);
        return nullptr;
    }

    static void _dealloc_AppDiagnosticInfo(py::wrapper::Windows::System::AppDiagnosticInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppDiagnosticInfo_CreateResourceGroupWatcher(py::wrapper::Windows::System::AppDiagnosticInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateResourceGroupWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::System::AppDiagnosticInfo::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_GetResourceGroups(py::wrapper::Windows::System::AppDiagnosticInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetResourceGroups());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_LaunchAsync(py::wrapper::Windows::System::AppDiagnosticInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.LaunchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::System::AppDiagnosticInfo::RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_RequestInfoAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::System::AppDiagnosticInfo::RequestInfoAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_RequestInfoForAppAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::System::AppDiagnosticInfo::RequestInfoForAppAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::AppDiagnosticInfo::RequestInfoForAppAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_RequestInfoForPackageAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::AppDiagnosticInfo::RequestInfoForPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfo_get_AppInfo(py::wrapper::Windows::System::AppDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppDiagnosticInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppDiagnosticInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppDiagnosticInfo[] = {
        { "create_resource_group_watcher", (PyCFunction)AppDiagnosticInfo_CreateResourceGroupWatcher, METH_VARARGS, nullptr },
        { "create_watcher", (PyCFunction)AppDiagnosticInfo_CreateWatcher, METH_VARARGS | METH_STATIC, nullptr },
        { "get_resource_groups", (PyCFunction)AppDiagnosticInfo_GetResourceGroups, METH_VARARGS, nullptr },
        { "launch_async", (PyCFunction)AppDiagnosticInfo_LaunchAsync, METH_VARARGS, nullptr },
        { "request_access_async", (PyCFunction)AppDiagnosticInfo_RequestAccessAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "request_info_async", (PyCFunction)AppDiagnosticInfo_RequestInfoAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "request_info_for_app_async", (PyCFunction)AppDiagnosticInfo_RequestInfoForAppAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "request_info_for_package_async", (PyCFunction)AppDiagnosticInfo_RequestInfoForPackageAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_AppDiagnosticInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppDiagnosticInfo[] = {
        { const_cast<char*>("app_info"), (getter)AppDiagnosticInfo_get_AppInfo, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppDiagnosticInfo[] = 
    {
        { Py_tp_new, _new_AppDiagnosticInfo },
        { Py_tp_dealloc, _dealloc_AppDiagnosticInfo },
        { Py_tp_methods, _methods_AppDiagnosticInfo },
        { Py_tp_getset, _getset_AppDiagnosticInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppDiagnosticInfo =
    {
        "_winrt_Windows_System.AppDiagnosticInfo",
        sizeof(py::wrapper::Windows::System::AppDiagnosticInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppDiagnosticInfo
    };

    // ----- AppDiagnosticInfoWatcher class --------------------
    constexpr const char* const _type_name_AppDiagnosticInfoWatcher = "AppDiagnosticInfoWatcher";

    static PyObject* _new_AppDiagnosticInfoWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppDiagnosticInfoWatcher);
        return nullptr;
    }

    static void _dealloc_AppDiagnosticInfoWatcher(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppDiagnosticInfoWatcher_Start(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_Stop(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_get_Status(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_add_Added(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppDiagnosticInfoWatcher, winrt::Windows::System::AppDiagnosticInfoWatcherEventArgs>>(arg);

            return py::convert(self->obj.Added(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_remove_Added(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Added(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_add_EnumerationCompleted(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppDiagnosticInfoWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_remove_EnumerationCompleted(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_add_Removed(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppDiagnosticInfoWatcher, winrt::Windows::System::AppDiagnosticInfoWatcherEventArgs>>(arg);

            return py::convert(self->obj.Removed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_remove_Removed(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Removed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_add_Stopped(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppDiagnosticInfoWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDiagnosticInfoWatcher_remove_Stopped(py::wrapper::Windows::System::AppDiagnosticInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppDiagnosticInfoWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppDiagnosticInfoWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppDiagnosticInfoWatcher[] = {
        { "start", (PyCFunction)AppDiagnosticInfoWatcher_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)AppDiagnosticInfoWatcher_Stop, METH_VARARGS, nullptr },
        { "add_added", (PyCFunction)AppDiagnosticInfoWatcher_add_Added, METH_O, nullptr },
        { "remove_added", (PyCFunction)AppDiagnosticInfoWatcher_remove_Added, METH_O, nullptr },
        { "add_enumeration_completed", (PyCFunction)AppDiagnosticInfoWatcher_add_EnumerationCompleted, METH_O, nullptr },
        { "remove_enumeration_completed", (PyCFunction)AppDiagnosticInfoWatcher_remove_EnumerationCompleted, METH_O, nullptr },
        { "add_removed", (PyCFunction)AppDiagnosticInfoWatcher_add_Removed, METH_O, nullptr },
        { "remove_removed", (PyCFunction)AppDiagnosticInfoWatcher_remove_Removed, METH_O, nullptr },
        { "add_stopped", (PyCFunction)AppDiagnosticInfoWatcher_add_Stopped, METH_O, nullptr },
        { "remove_stopped", (PyCFunction)AppDiagnosticInfoWatcher_remove_Stopped, METH_O, nullptr },
        { "_from", (PyCFunction)_from_AppDiagnosticInfoWatcher, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppDiagnosticInfoWatcher[] = {
        { const_cast<char*>("status"), (getter)AppDiagnosticInfoWatcher_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppDiagnosticInfoWatcher[] = 
    {
        { Py_tp_new, _new_AppDiagnosticInfoWatcher },
        { Py_tp_dealloc, _dealloc_AppDiagnosticInfoWatcher },
        { Py_tp_methods, _methods_AppDiagnosticInfoWatcher },
        { Py_tp_getset, _getset_AppDiagnosticInfoWatcher },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppDiagnosticInfoWatcher =
    {
        "_winrt_Windows_System.AppDiagnosticInfoWatcher",
        sizeof(py::wrapper::Windows::System::AppDiagnosticInfoWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppDiagnosticInfoWatcher
    };

    // ----- AppDiagnosticInfoWatcherEventArgs class --------------------
    constexpr const char* const _type_name_AppDiagnosticInfoWatcherEventArgs = "AppDiagnosticInfoWatcherEventArgs";

    static PyObject* _new_AppDiagnosticInfoWatcherEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppDiagnosticInfoWatcherEventArgs);
        return nullptr;
    }

    static void _dealloc_AppDiagnosticInfoWatcherEventArgs(py::wrapper::Windows::System::AppDiagnosticInfoWatcherEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppDiagnosticInfoWatcherEventArgs_get_AppDiagnosticInfo(py::wrapper::Windows::System::AppDiagnosticInfoWatcherEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppDiagnosticInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppDiagnosticInfoWatcherEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppDiagnosticInfoWatcherEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppDiagnosticInfoWatcherEventArgs[] = {
        { "_from", (PyCFunction)_from_AppDiagnosticInfoWatcherEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppDiagnosticInfoWatcherEventArgs[] = {
        { const_cast<char*>("app_diagnostic_info"), (getter)AppDiagnosticInfoWatcherEventArgs_get_AppDiagnosticInfo, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppDiagnosticInfoWatcherEventArgs[] = 
    {
        { Py_tp_new, _new_AppDiagnosticInfoWatcherEventArgs },
        { Py_tp_dealloc, _dealloc_AppDiagnosticInfoWatcherEventArgs },
        { Py_tp_methods, _methods_AppDiagnosticInfoWatcherEventArgs },
        { Py_tp_getset, _getset_AppDiagnosticInfoWatcherEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppDiagnosticInfoWatcherEventArgs =
    {
        "_winrt_Windows_System.AppDiagnosticInfoWatcherEventArgs",
        sizeof(py::wrapper::Windows::System::AppDiagnosticInfoWatcherEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppDiagnosticInfoWatcherEventArgs
    };

    // ----- AppExecutionStateChangeResult class --------------------
    constexpr const char* const _type_name_AppExecutionStateChangeResult = "AppExecutionStateChangeResult";

    static PyObject* _new_AppExecutionStateChangeResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppExecutionStateChangeResult);
        return nullptr;
    }

    static void _dealloc_AppExecutionStateChangeResult(py::wrapper::Windows::System::AppExecutionStateChangeResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppExecutionStateChangeResult_get_ExtendedError(py::wrapper::Windows::System::AppExecutionStateChangeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppExecutionStateChangeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppExecutionStateChangeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppExecutionStateChangeResult[] = {
        { "_from", (PyCFunction)_from_AppExecutionStateChangeResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppExecutionStateChangeResult[] = {
        { const_cast<char*>("extended_error"), (getter)AppExecutionStateChangeResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppExecutionStateChangeResult[] = 
    {
        { Py_tp_new, _new_AppExecutionStateChangeResult },
        { Py_tp_dealloc, _dealloc_AppExecutionStateChangeResult },
        { Py_tp_methods, _methods_AppExecutionStateChangeResult },
        { Py_tp_getset, _getset_AppExecutionStateChangeResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppExecutionStateChangeResult =
    {
        "_winrt_Windows_System.AppExecutionStateChangeResult",
        sizeof(py::wrapper::Windows::System::AppExecutionStateChangeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppExecutionStateChangeResult
    };

    // ----- AppMemoryReport class --------------------
    constexpr const char* const _type_name_AppMemoryReport = "AppMemoryReport";

    static PyObject* _new_AppMemoryReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppMemoryReport);
        return nullptr;
    }

    static void _dealloc_AppMemoryReport(py::wrapper::Windows::System::AppMemoryReport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppMemoryReport_get_PeakPrivateCommitUsage(py::wrapper::Windows::System::AppMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PeakPrivateCommitUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppMemoryReport_get_PrivateCommitUsage(py::wrapper::Windows::System::AppMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrivateCommitUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppMemoryReport_get_TotalCommitLimit(py::wrapper::Windows::System::AppMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalCommitLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppMemoryReport_get_TotalCommitUsage(py::wrapper::Windows::System::AppMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalCommitUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppMemoryReport_get_ExpectedTotalCommitLimit(py::wrapper::Windows::System::AppMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpectedTotalCommitLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppMemoryReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppMemoryReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppMemoryReport[] = {
        { "_from", (PyCFunction)_from_AppMemoryReport, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppMemoryReport[] = {
        { const_cast<char*>("peak_private_commit_usage"), (getter)AppMemoryReport_get_PeakPrivateCommitUsage, nullptr, nullptr, nullptr },
        { const_cast<char*>("private_commit_usage"), (getter)AppMemoryReport_get_PrivateCommitUsage, nullptr, nullptr, nullptr },
        { const_cast<char*>("total_commit_limit"), (getter)AppMemoryReport_get_TotalCommitLimit, nullptr, nullptr, nullptr },
        { const_cast<char*>("total_commit_usage"), (getter)AppMemoryReport_get_TotalCommitUsage, nullptr, nullptr, nullptr },
        { const_cast<char*>("expected_total_commit_limit"), (getter)AppMemoryReport_get_ExpectedTotalCommitLimit, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppMemoryReport[] = 
    {
        { Py_tp_new, _new_AppMemoryReport },
        { Py_tp_dealloc, _dealloc_AppMemoryReport },
        { Py_tp_methods, _methods_AppMemoryReport },
        { Py_tp_getset, _getset_AppMemoryReport },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppMemoryReport =
    {
        "_winrt_Windows_System.AppMemoryReport",
        sizeof(py::wrapper::Windows::System::AppMemoryReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppMemoryReport
    };

    // ----- AppMemoryUsageLimitChangingEventArgs class --------------------
    constexpr const char* const _type_name_AppMemoryUsageLimitChangingEventArgs = "AppMemoryUsageLimitChangingEventArgs";

    static PyObject* _new_AppMemoryUsageLimitChangingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppMemoryUsageLimitChangingEventArgs);
        return nullptr;
    }

    static void _dealloc_AppMemoryUsageLimitChangingEventArgs(py::wrapper::Windows::System::AppMemoryUsageLimitChangingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppMemoryUsageLimitChangingEventArgs_get_NewLimit(py::wrapper::Windows::System::AppMemoryUsageLimitChangingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NewLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppMemoryUsageLimitChangingEventArgs_get_OldLimit(py::wrapper::Windows::System::AppMemoryUsageLimitChangingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OldLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppMemoryUsageLimitChangingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppMemoryUsageLimitChangingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppMemoryUsageLimitChangingEventArgs[] = {
        { "_from", (PyCFunction)_from_AppMemoryUsageLimitChangingEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppMemoryUsageLimitChangingEventArgs[] = {
        { const_cast<char*>("new_limit"), (getter)AppMemoryUsageLimitChangingEventArgs_get_NewLimit, nullptr, nullptr, nullptr },
        { const_cast<char*>("old_limit"), (getter)AppMemoryUsageLimitChangingEventArgs_get_OldLimit, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppMemoryUsageLimitChangingEventArgs[] = 
    {
        { Py_tp_new, _new_AppMemoryUsageLimitChangingEventArgs },
        { Py_tp_dealloc, _dealloc_AppMemoryUsageLimitChangingEventArgs },
        { Py_tp_methods, _methods_AppMemoryUsageLimitChangingEventArgs },
        { Py_tp_getset, _getset_AppMemoryUsageLimitChangingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppMemoryUsageLimitChangingEventArgs =
    {
        "_winrt_Windows_System.AppMemoryUsageLimitChangingEventArgs",
        sizeof(py::wrapper::Windows::System::AppMemoryUsageLimitChangingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppMemoryUsageLimitChangingEventArgs
    };

    // ----- AppResourceGroupBackgroundTaskReport class --------------------
    constexpr const char* const _type_name_AppResourceGroupBackgroundTaskReport = "AppResourceGroupBackgroundTaskReport";

    static PyObject* _new_AppResourceGroupBackgroundTaskReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppResourceGroupBackgroundTaskReport);
        return nullptr;
    }

    static void _dealloc_AppResourceGroupBackgroundTaskReport(py::wrapper::Windows::System::AppResourceGroupBackgroundTaskReport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppResourceGroupBackgroundTaskReport_get_EntryPoint(py::wrapper::Windows::System::AppResourceGroupBackgroundTaskReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EntryPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupBackgroundTaskReport_get_Name(py::wrapper::Windows::System::AppResourceGroupBackgroundTaskReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupBackgroundTaskReport_get_TaskId(py::wrapper::Windows::System::AppResourceGroupBackgroundTaskReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupBackgroundTaskReport_get_Trigger(py::wrapper::Windows::System::AppResourceGroupBackgroundTaskReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Trigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppResourceGroupBackgroundTaskReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppResourceGroupBackgroundTaskReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppResourceGroupBackgroundTaskReport[] = {
        { "_from", (PyCFunction)_from_AppResourceGroupBackgroundTaskReport, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppResourceGroupBackgroundTaskReport[] = {
        { const_cast<char*>("entry_point"), (getter)AppResourceGroupBackgroundTaskReport_get_EntryPoint, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)AppResourceGroupBackgroundTaskReport_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("task_id"), (getter)AppResourceGroupBackgroundTaskReport_get_TaskId, nullptr, nullptr, nullptr },
        { const_cast<char*>("trigger"), (getter)AppResourceGroupBackgroundTaskReport_get_Trigger, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppResourceGroupBackgroundTaskReport[] = 
    {
        { Py_tp_new, _new_AppResourceGroupBackgroundTaskReport },
        { Py_tp_dealloc, _dealloc_AppResourceGroupBackgroundTaskReport },
        { Py_tp_methods, _methods_AppResourceGroupBackgroundTaskReport },
        { Py_tp_getset, _getset_AppResourceGroupBackgroundTaskReport },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppResourceGroupBackgroundTaskReport =
    {
        "_winrt_Windows_System.AppResourceGroupBackgroundTaskReport",
        sizeof(py::wrapper::Windows::System::AppResourceGroupBackgroundTaskReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppResourceGroupBackgroundTaskReport
    };

    // ----- AppResourceGroupInfo class --------------------
    constexpr const char* const _type_name_AppResourceGroupInfo = "AppResourceGroupInfo";

    static PyObject* _new_AppResourceGroupInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppResourceGroupInfo);
        return nullptr;
    }

    static void _dealloc_AppResourceGroupInfo(py::wrapper::Windows::System::AppResourceGroupInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppResourceGroupInfo_GetBackgroundTaskReports(py::wrapper::Windows::System::AppResourceGroupInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetBackgroundTaskReports());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_GetMemoryReport(py::wrapper::Windows::System::AppResourceGroupInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetMemoryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_GetProcessDiagnosticInfos(py::wrapper::Windows::System::AppResourceGroupInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetProcessDiagnosticInfos());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_GetStateReport(py::wrapper::Windows::System::AppResourceGroupInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetStateReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_StartResumeAsync(py::wrapper::Windows::System::AppResourceGroupInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartResumeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_StartSuspendAsync(py::wrapper::Windows::System::AppResourceGroupInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartSuspendAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_StartTerminateAsync(py::wrapper::Windows::System::AppResourceGroupInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartTerminateAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_get_InstanceId(py::wrapper::Windows::System::AppResourceGroupInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfo_get_IsShared(py::wrapper::Windows::System::AppResourceGroupInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsShared());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppResourceGroupInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppResourceGroupInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppResourceGroupInfo[] = {
        { "get_background_task_reports", (PyCFunction)AppResourceGroupInfo_GetBackgroundTaskReports, METH_VARARGS, nullptr },
        { "get_memory_report", (PyCFunction)AppResourceGroupInfo_GetMemoryReport, METH_VARARGS, nullptr },
        { "get_process_diagnostic_infos", (PyCFunction)AppResourceGroupInfo_GetProcessDiagnosticInfos, METH_VARARGS, nullptr },
        { "get_state_report", (PyCFunction)AppResourceGroupInfo_GetStateReport, METH_VARARGS, nullptr },
        { "start_resume_async", (PyCFunction)AppResourceGroupInfo_StartResumeAsync, METH_VARARGS, nullptr },
        { "start_suspend_async", (PyCFunction)AppResourceGroupInfo_StartSuspendAsync, METH_VARARGS, nullptr },
        { "start_terminate_async", (PyCFunction)AppResourceGroupInfo_StartTerminateAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AppResourceGroupInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppResourceGroupInfo[] = {
        { const_cast<char*>("instance_id"), (getter)AppResourceGroupInfo_get_InstanceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_shared"), (getter)AppResourceGroupInfo_get_IsShared, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppResourceGroupInfo[] = 
    {
        { Py_tp_new, _new_AppResourceGroupInfo },
        { Py_tp_dealloc, _dealloc_AppResourceGroupInfo },
        { Py_tp_methods, _methods_AppResourceGroupInfo },
        { Py_tp_getset, _getset_AppResourceGroupInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppResourceGroupInfo =
    {
        "_winrt_Windows_System.AppResourceGroupInfo",
        sizeof(py::wrapper::Windows::System::AppResourceGroupInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppResourceGroupInfo
    };

    // ----- AppResourceGroupInfoWatcher class --------------------
    constexpr const char* const _type_name_AppResourceGroupInfoWatcher = "AppResourceGroupInfoWatcher";

    static PyObject* _new_AppResourceGroupInfoWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppResourceGroupInfoWatcher);
        return nullptr;
    }

    static void _dealloc_AppResourceGroupInfoWatcher(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppResourceGroupInfoWatcher_Start(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_Stop(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_get_Status(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_add_Added(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppResourceGroupInfoWatcher, winrt::Windows::System::AppResourceGroupInfoWatcherEventArgs>>(arg);

            return py::convert(self->obj.Added(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_remove_Added(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Added(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_add_EnumerationCompleted(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppResourceGroupInfoWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_remove_EnumerationCompleted(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_add_ExecutionStateChanged(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppResourceGroupInfoWatcher, winrt::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs>>(arg);

            return py::convert(self->obj.ExecutionStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_remove_ExecutionStateChanged(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ExecutionStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_add_Removed(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppResourceGroupInfoWatcher, winrt::Windows::System::AppResourceGroupInfoWatcherEventArgs>>(arg);

            return py::convert(self->obj.Removed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_remove_Removed(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Removed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_add_Stopped(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::AppResourceGroupInfoWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcher_remove_Stopped(py::wrapper::Windows::System::AppResourceGroupInfoWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppResourceGroupInfoWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppResourceGroupInfoWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppResourceGroupInfoWatcher[] = {
        { "start", (PyCFunction)AppResourceGroupInfoWatcher_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)AppResourceGroupInfoWatcher_Stop, METH_VARARGS, nullptr },
        { "add_added", (PyCFunction)AppResourceGroupInfoWatcher_add_Added, METH_O, nullptr },
        { "remove_added", (PyCFunction)AppResourceGroupInfoWatcher_remove_Added, METH_O, nullptr },
        { "add_enumeration_completed", (PyCFunction)AppResourceGroupInfoWatcher_add_EnumerationCompleted, METH_O, nullptr },
        { "remove_enumeration_completed", (PyCFunction)AppResourceGroupInfoWatcher_remove_EnumerationCompleted, METH_O, nullptr },
        { "add_execution_state_changed", (PyCFunction)AppResourceGroupInfoWatcher_add_ExecutionStateChanged, METH_O, nullptr },
        { "remove_execution_state_changed", (PyCFunction)AppResourceGroupInfoWatcher_remove_ExecutionStateChanged, METH_O, nullptr },
        { "add_removed", (PyCFunction)AppResourceGroupInfoWatcher_add_Removed, METH_O, nullptr },
        { "remove_removed", (PyCFunction)AppResourceGroupInfoWatcher_remove_Removed, METH_O, nullptr },
        { "add_stopped", (PyCFunction)AppResourceGroupInfoWatcher_add_Stopped, METH_O, nullptr },
        { "remove_stopped", (PyCFunction)AppResourceGroupInfoWatcher_remove_Stopped, METH_O, nullptr },
        { "_from", (PyCFunction)_from_AppResourceGroupInfoWatcher, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppResourceGroupInfoWatcher[] = {
        { const_cast<char*>("status"), (getter)AppResourceGroupInfoWatcher_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppResourceGroupInfoWatcher[] = 
    {
        { Py_tp_new, _new_AppResourceGroupInfoWatcher },
        { Py_tp_dealloc, _dealloc_AppResourceGroupInfoWatcher },
        { Py_tp_methods, _methods_AppResourceGroupInfoWatcher },
        { Py_tp_getset, _getset_AppResourceGroupInfoWatcher },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppResourceGroupInfoWatcher =
    {
        "_winrt_Windows_System.AppResourceGroupInfoWatcher",
        sizeof(py::wrapper::Windows::System::AppResourceGroupInfoWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppResourceGroupInfoWatcher
    };

    // ----- AppResourceGroupInfoWatcherEventArgs class --------------------
    constexpr const char* const _type_name_AppResourceGroupInfoWatcherEventArgs = "AppResourceGroupInfoWatcherEventArgs";

    static PyObject* _new_AppResourceGroupInfoWatcherEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppResourceGroupInfoWatcherEventArgs);
        return nullptr;
    }

    static void _dealloc_AppResourceGroupInfoWatcherEventArgs(py::wrapper::Windows::System::AppResourceGroupInfoWatcherEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppResourceGroupInfoWatcherEventArgs_get_AppDiagnosticInfos(py::wrapper::Windows::System::AppResourceGroupInfoWatcherEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppDiagnosticInfos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcherEventArgs_get_AppResourceGroupInfo(py::wrapper::Windows::System::AppResourceGroupInfoWatcherEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppResourceGroupInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppResourceGroupInfoWatcherEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppResourceGroupInfoWatcherEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppResourceGroupInfoWatcherEventArgs[] = {
        { "_from", (PyCFunction)_from_AppResourceGroupInfoWatcherEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppResourceGroupInfoWatcherEventArgs[] = {
        { const_cast<char*>("app_diagnostic_infos"), (getter)AppResourceGroupInfoWatcherEventArgs_get_AppDiagnosticInfos, nullptr, nullptr, nullptr },
        { const_cast<char*>("app_resource_group_info"), (getter)AppResourceGroupInfoWatcherEventArgs_get_AppResourceGroupInfo, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppResourceGroupInfoWatcherEventArgs[] = 
    {
        { Py_tp_new, _new_AppResourceGroupInfoWatcherEventArgs },
        { Py_tp_dealloc, _dealloc_AppResourceGroupInfoWatcherEventArgs },
        { Py_tp_methods, _methods_AppResourceGroupInfoWatcherEventArgs },
        { Py_tp_getset, _getset_AppResourceGroupInfoWatcherEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppResourceGroupInfoWatcherEventArgs =
    {
        "_winrt_Windows_System.AppResourceGroupInfoWatcherEventArgs",
        sizeof(py::wrapper::Windows::System::AppResourceGroupInfoWatcherEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppResourceGroupInfoWatcherEventArgs
    };

    // ----- AppResourceGroupInfoWatcherExecutionStateChangedEventArgs class --------------------
    constexpr const char* const _type_name_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs = "AppResourceGroupInfoWatcherExecutionStateChangedEventArgs";

    static PyObject* _new_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs(py::wrapper::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppResourceGroupInfoWatcherExecutionStateChangedEventArgs_get_AppDiagnosticInfos(py::wrapper::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppDiagnosticInfos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupInfoWatcherExecutionStateChangedEventArgs_get_AppResourceGroupInfo(py::wrapper::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppResourceGroupInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs[] = {
        { const_cast<char*>("app_diagnostic_infos"), (getter)AppResourceGroupInfoWatcherExecutionStateChangedEventArgs_get_AppDiagnosticInfos, nullptr, nullptr, nullptr },
        { const_cast<char*>("app_resource_group_info"), (getter)AppResourceGroupInfoWatcherExecutionStateChangedEventArgs_get_AppResourceGroupInfo, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs[] = 
    {
        { Py_tp_new, _new_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs },
        { Py_tp_dealloc, _dealloc_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs },
        { Py_tp_methods, _methods_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs },
        { Py_tp_getset, _getset_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs =
    {
        "_winrt_Windows_System.AppResourceGroupInfoWatcherExecutionStateChangedEventArgs",
        sizeof(py::wrapper::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs
    };

    // ----- AppResourceGroupMemoryReport class --------------------
    constexpr const char* const _type_name_AppResourceGroupMemoryReport = "AppResourceGroupMemoryReport";

    static PyObject* _new_AppResourceGroupMemoryReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppResourceGroupMemoryReport);
        return nullptr;
    }

    static void _dealloc_AppResourceGroupMemoryReport(py::wrapper::Windows::System::AppResourceGroupMemoryReport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppResourceGroupMemoryReport_get_CommitUsageLevel(py::wrapper::Windows::System::AppResourceGroupMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CommitUsageLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupMemoryReport_get_CommitUsageLimit(py::wrapper::Windows::System::AppResourceGroupMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CommitUsageLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupMemoryReport_get_PrivateCommitUsage(py::wrapper::Windows::System::AppResourceGroupMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrivateCommitUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupMemoryReport_get_TotalCommitUsage(py::wrapper::Windows::System::AppResourceGroupMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalCommitUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppResourceGroupMemoryReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppResourceGroupMemoryReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppResourceGroupMemoryReport[] = {
        { "_from", (PyCFunction)_from_AppResourceGroupMemoryReport, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppResourceGroupMemoryReport[] = {
        { const_cast<char*>("commit_usage_level"), (getter)AppResourceGroupMemoryReport_get_CommitUsageLevel, nullptr, nullptr, nullptr },
        { const_cast<char*>("commit_usage_limit"), (getter)AppResourceGroupMemoryReport_get_CommitUsageLimit, nullptr, nullptr, nullptr },
        { const_cast<char*>("private_commit_usage"), (getter)AppResourceGroupMemoryReport_get_PrivateCommitUsage, nullptr, nullptr, nullptr },
        { const_cast<char*>("total_commit_usage"), (getter)AppResourceGroupMemoryReport_get_TotalCommitUsage, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppResourceGroupMemoryReport[] = 
    {
        { Py_tp_new, _new_AppResourceGroupMemoryReport },
        { Py_tp_dealloc, _dealloc_AppResourceGroupMemoryReport },
        { Py_tp_methods, _methods_AppResourceGroupMemoryReport },
        { Py_tp_getset, _getset_AppResourceGroupMemoryReport },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppResourceGroupMemoryReport =
    {
        "_winrt_Windows_System.AppResourceGroupMemoryReport",
        sizeof(py::wrapper::Windows::System::AppResourceGroupMemoryReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppResourceGroupMemoryReport
    };

    // ----- AppResourceGroupStateReport class --------------------
    constexpr const char* const _type_name_AppResourceGroupStateReport = "AppResourceGroupStateReport";

    static PyObject* _new_AppResourceGroupStateReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppResourceGroupStateReport);
        return nullptr;
    }

    static void _dealloc_AppResourceGroupStateReport(py::wrapper::Windows::System::AppResourceGroupStateReport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppResourceGroupStateReport_get_EnergyQuotaState(py::wrapper::Windows::System::AppResourceGroupStateReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EnergyQuotaState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppResourceGroupStateReport_get_ExecutionState(py::wrapper::Windows::System::AppResourceGroupStateReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppResourceGroupStateReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppResourceGroupStateReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppResourceGroupStateReport[] = {
        { "_from", (PyCFunction)_from_AppResourceGroupStateReport, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppResourceGroupStateReport[] = {
        { const_cast<char*>("energy_quota_state"), (getter)AppResourceGroupStateReport_get_EnergyQuotaState, nullptr, nullptr, nullptr },
        { const_cast<char*>("execution_state"), (getter)AppResourceGroupStateReport_get_ExecutionState, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppResourceGroupStateReport[] = 
    {
        { Py_tp_new, _new_AppResourceGroupStateReport },
        { Py_tp_dealloc, _dealloc_AppResourceGroupStateReport },
        { Py_tp_methods, _methods_AppResourceGroupStateReport },
        { Py_tp_getset, _getset_AppResourceGroupStateReport },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppResourceGroupStateReport =
    {
        "_winrt_Windows_System.AppResourceGroupStateReport",
        sizeof(py::wrapper::Windows::System::AppResourceGroupStateReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppResourceGroupStateReport
    };

    // ----- AppUriHandlerHost class --------------------
    constexpr const char* const _type_name_AppUriHandlerHost = "AppUriHandlerHost";

    static PyObject* _new_AppUriHandlerHost(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::System::AppUriHandlerHost instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::AppUriHandlerHost instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppUriHandlerHost(py::wrapper::Windows::System::AppUriHandlerHost* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppUriHandlerHost_get_Name(py::wrapper::Windows::System::AppUriHandlerHost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppUriHandlerHost_put_Name(py::wrapper::Windows::System::AppUriHandlerHost* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppUriHandlerHost_get_IsEnabled(py::wrapper::Windows::System::AppUriHandlerHost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppUriHandlerHost_put_IsEnabled(py::wrapper::Windows::System::AppUriHandlerHost* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AppUriHandlerHost(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppUriHandlerHost>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppUriHandlerHost[] = {
        { "_from", (PyCFunction)_from_AppUriHandlerHost, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppUriHandlerHost[] = {
        { const_cast<char*>("name"), (getter)AppUriHandlerHost_get_Name, (setter)AppUriHandlerHost_put_Name, nullptr, nullptr },
        { const_cast<char*>("is_enabled"), (getter)AppUriHandlerHost_get_IsEnabled, (setter)AppUriHandlerHost_put_IsEnabled, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppUriHandlerHost[] = 
    {
        { Py_tp_new, _new_AppUriHandlerHost },
        { Py_tp_dealloc, _dealloc_AppUriHandlerHost },
        { Py_tp_methods, _methods_AppUriHandlerHost },
        { Py_tp_getset, _getset_AppUriHandlerHost },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppUriHandlerHost =
    {
        "_winrt_Windows_System.AppUriHandlerHost",
        sizeof(py::wrapper::Windows::System::AppUriHandlerHost),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppUriHandlerHost
    };

    // ----- AppUriHandlerRegistration class --------------------
    constexpr const char* const _type_name_AppUriHandlerRegistration = "AppUriHandlerRegistration";

    static PyObject* _new_AppUriHandlerRegistration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppUriHandlerRegistration);
        return nullptr;
    }

    static void _dealloc_AppUriHandlerRegistration(py::wrapper::Windows::System::AppUriHandlerRegistration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppUriHandlerRegistration_GetAllHosts(py::wrapper::Windows::System::AppUriHandlerRegistration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAllHosts());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistration_GetAppAddedHostsAsync(py::wrapper::Windows::System::AppUriHandlerRegistration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAppAddedHostsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistration_SetAppAddedHostsAsync(py::wrapper::Windows::System::AppUriHandlerRegistration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::System::AppUriHandlerHost>>(args, 0);

                return py::convert(self->obj.SetAppAddedHostsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistration_UpdateHosts(py::wrapper::Windows::System::AppUriHandlerRegistration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::System::AppUriHandlerHost>>(args, 0);

                self->obj.UpdateHosts(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistration_get_Name(py::wrapper::Windows::System::AppUriHandlerRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistration_get_User(py::wrapper::Windows::System::AppUriHandlerRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistration_get_PackageFamilyName(py::wrapper::Windows::System::AppUriHandlerRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppUriHandlerRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppUriHandlerRegistration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppUriHandlerRegistration[] = {
        { "get_all_hosts", (PyCFunction)AppUriHandlerRegistration_GetAllHosts, METH_VARARGS, nullptr },
        { "get_app_added_hosts_async", (PyCFunction)AppUriHandlerRegistration_GetAppAddedHostsAsync, METH_VARARGS, nullptr },
        { "set_app_added_hosts_async", (PyCFunction)AppUriHandlerRegistration_SetAppAddedHostsAsync, METH_VARARGS, nullptr },
        { "update_hosts", (PyCFunction)AppUriHandlerRegistration_UpdateHosts, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AppUriHandlerRegistration, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppUriHandlerRegistration[] = {
        { const_cast<char*>("name"), (getter)AppUriHandlerRegistration_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("user"), (getter)AppUriHandlerRegistration_get_User, nullptr, nullptr, nullptr },
        { const_cast<char*>("package_family_name"), (getter)AppUriHandlerRegistration_get_PackageFamilyName, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppUriHandlerRegistration[] = 
    {
        { Py_tp_new, _new_AppUriHandlerRegistration },
        { Py_tp_dealloc, _dealloc_AppUriHandlerRegistration },
        { Py_tp_methods, _methods_AppUriHandlerRegistration },
        { Py_tp_getset, _getset_AppUriHandlerRegistration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppUriHandlerRegistration =
    {
        "_winrt_Windows_System.AppUriHandlerRegistration",
        sizeof(py::wrapper::Windows::System::AppUriHandlerRegistration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppUriHandlerRegistration
    };

    // ----- AppUriHandlerRegistrationManager class --------------------
    constexpr const char* const _type_name_AppUriHandlerRegistrationManager = "AppUriHandlerRegistrationManager";

    static PyObject* _new_AppUriHandlerRegistrationManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppUriHandlerRegistrationManager);
        return nullptr;
    }

    static void _dealloc_AppUriHandlerRegistrationManager(py::wrapper::Windows::System::AppUriHandlerRegistrationManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppUriHandlerRegistrationManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::System::AppUriHandlerRegistrationManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistrationManager_GetForPackage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::AppUriHandlerRegistrationManager::GetForPackage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistrationManager_GetForPackageForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::User>(args, 1);

                return py::convert(winrt::Windows::System::AppUriHandlerRegistrationManager::GetForPackageForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistrationManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::System::AppUriHandlerRegistrationManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistrationManager_TryGetRegistration(py::wrapper::Windows::System::AppUriHandlerRegistrationManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryGetRegistration(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistrationManager_get_User(py::wrapper::Windows::System::AppUriHandlerRegistrationManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppUriHandlerRegistrationManager_get_PackageFamilyName(py::wrapper::Windows::System::AppUriHandlerRegistrationManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppUriHandlerRegistrationManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::AppUriHandlerRegistrationManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppUriHandlerRegistrationManager[] = {
        { "get_default", (PyCFunction)AppUriHandlerRegistrationManager_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_package", (PyCFunction)AppUriHandlerRegistrationManager_GetForPackage, METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_package_for_user", (PyCFunction)AppUriHandlerRegistrationManager_GetForPackageForUser, METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", (PyCFunction)AppUriHandlerRegistrationManager_GetForUser, METH_VARARGS | METH_STATIC, nullptr },
        { "try_get_registration", (PyCFunction)AppUriHandlerRegistrationManager_TryGetRegistration, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AppUriHandlerRegistrationManager, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppUriHandlerRegistrationManager[] = {
        { const_cast<char*>("user"), (getter)AppUriHandlerRegistrationManager_get_User, nullptr, nullptr, nullptr },
        { const_cast<char*>("package_family_name"), (getter)AppUriHandlerRegistrationManager_get_PackageFamilyName, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppUriHandlerRegistrationManager[] = 
    {
        { Py_tp_new, _new_AppUriHandlerRegistrationManager },
        { Py_tp_dealloc, _dealloc_AppUriHandlerRegistrationManager },
        { Py_tp_methods, _methods_AppUriHandlerRegistrationManager },
        { Py_tp_getset, _getset_AppUriHandlerRegistrationManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppUriHandlerRegistrationManager =
    {
        "_winrt_Windows_System.AppUriHandlerRegistrationManager",
        sizeof(py::wrapper::Windows::System::AppUriHandlerRegistrationManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppUriHandlerRegistrationManager
    };

    // ----- DateTimeSettings class --------------------
    constexpr const char* const _type_name_DateTimeSettings = "DateTimeSettings";

    static PyObject* _new_DateTimeSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DateTimeSettings);
        return nullptr;
    }

    static PyObject* DateTimeSettings_SetSystemDateTime(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                winrt::Windows::System::DateTimeSettings::SetSystemDateTime(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_DateTimeSettings[] = {
        { "set_system_date_time", (PyCFunction)DateTimeSettings_SetSystemDateTime, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DateTimeSettings[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_DateTimeSettings[] = 
    {
        { Py_tp_new, _new_DateTimeSettings },
        { Py_tp_methods, _methods_DateTimeSettings },
        { Py_tp_getset, _getset_DateTimeSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DateTimeSettings =
    {
        "_winrt_Windows_System.DateTimeSettings",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DateTimeSettings
    };

    // ----- DispatcherQueue class --------------------
    constexpr const char* const _type_name_DispatcherQueue = "DispatcherQueue";

    static PyObject* _new_DispatcherQueue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DispatcherQueue);
        return nullptr;
    }

    static void _dealloc_DispatcherQueue(py::wrapper::Windows::System::DispatcherQueue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DispatcherQueue_CreateTimer(py::wrapper::Windows::System::DispatcherQueue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateTimer());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherQueue_GetForCurrentThread(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::System::DispatcherQueue::GetForCurrentThread());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherQueue_TryEnqueue(py::wrapper::Windows::System::DispatcherQueue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::DispatcherQueueHandler>(args, 0);

                return py::convert(self->obj.TryEnqueue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::DispatcherQueuePriority>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::DispatcherQueueHandler>(args, 1);

                return py::convert(self->obj.TryEnqueue(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherQueue_get_HasThreadAccess(py::wrapper::Windows::System::DispatcherQueue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasThreadAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DispatcherQueue_add_ShutdownCompleted(py::wrapper::Windows::System::DispatcherQueue* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::DispatcherQueue, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ShutdownCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DispatcherQueue_remove_ShutdownCompleted(py::wrapper::Windows::System::DispatcherQueue* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ShutdownCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DispatcherQueue_add_ShutdownStarting(py::wrapper::Windows::System::DispatcherQueue* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::DispatcherQueue, winrt::Windows::System::DispatcherQueueShutdownStartingEventArgs>>(arg);

            return py::convert(self->obj.ShutdownStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DispatcherQueue_remove_ShutdownStarting(py::wrapper::Windows::System::DispatcherQueue* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ShutdownStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DispatcherQueue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::DispatcherQueue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DispatcherQueue[] = {
        { "create_timer", (PyCFunction)DispatcherQueue_CreateTimer, METH_VARARGS, nullptr },
        { "get_for_current_thread", (PyCFunction)DispatcherQueue_GetForCurrentThread, METH_VARARGS | METH_STATIC, nullptr },
        { "try_enqueue", (PyCFunction)DispatcherQueue_TryEnqueue, METH_VARARGS, nullptr },
        { "add_shutdown_completed", (PyCFunction)DispatcherQueue_add_ShutdownCompleted, METH_O, nullptr },
        { "remove_shutdown_completed", (PyCFunction)DispatcherQueue_remove_ShutdownCompleted, METH_O, nullptr },
        { "add_shutdown_starting", (PyCFunction)DispatcherQueue_add_ShutdownStarting, METH_O, nullptr },
        { "remove_shutdown_starting", (PyCFunction)DispatcherQueue_remove_ShutdownStarting, METH_O, nullptr },
        { "_from", (PyCFunction)_from_DispatcherQueue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DispatcherQueue[] = {
        { const_cast<char*>("has_thread_access"), (getter)DispatcherQueue_get_HasThreadAccess, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DispatcherQueue[] = 
    {
        { Py_tp_new, _new_DispatcherQueue },
        { Py_tp_dealloc, _dealloc_DispatcherQueue },
        { Py_tp_methods, _methods_DispatcherQueue },
        { Py_tp_getset, _getset_DispatcherQueue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DispatcherQueue =
    {
        "_winrt_Windows_System.DispatcherQueue",
        sizeof(py::wrapper::Windows::System::DispatcherQueue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DispatcherQueue
    };

    // ----- DispatcherQueueController class --------------------
    constexpr const char* const _type_name_DispatcherQueueController = "DispatcherQueueController";

    static PyObject* _new_DispatcherQueueController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DispatcherQueueController);
        return nullptr;
    }

    static void _dealloc_DispatcherQueueController(py::wrapper::Windows::System::DispatcherQueueController* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DispatcherQueueController_CreateOnDedicatedThread(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::System::DispatcherQueueController::CreateOnDedicatedThread());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherQueueController_ShutdownQueueAsync(py::wrapper::Windows::System::DispatcherQueueController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ShutdownQueueAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherQueueController_get_DispatcherQueue(py::wrapper::Windows::System::DispatcherQueueController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DispatcherQueue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DispatcherQueueController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::DispatcherQueueController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DispatcherQueueController[] = {
        { "create_on_dedicated_thread", (PyCFunction)DispatcherQueueController_CreateOnDedicatedThread, METH_VARARGS | METH_STATIC, nullptr },
        { "shutdown_queue_async", (PyCFunction)DispatcherQueueController_ShutdownQueueAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DispatcherQueueController, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DispatcherQueueController[] = {
        { const_cast<char*>("dispatcher_queue"), (getter)DispatcherQueueController_get_DispatcherQueue, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DispatcherQueueController[] = 
    {
        { Py_tp_new, _new_DispatcherQueueController },
        { Py_tp_dealloc, _dealloc_DispatcherQueueController },
        { Py_tp_methods, _methods_DispatcherQueueController },
        { Py_tp_getset, _getset_DispatcherQueueController },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DispatcherQueueController =
    {
        "_winrt_Windows_System.DispatcherQueueController",
        sizeof(py::wrapper::Windows::System::DispatcherQueueController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DispatcherQueueController
    };

    // ----- DispatcherQueueShutdownStartingEventArgs class --------------------
    constexpr const char* const _type_name_DispatcherQueueShutdownStartingEventArgs = "DispatcherQueueShutdownStartingEventArgs";

    static PyObject* _new_DispatcherQueueShutdownStartingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DispatcherQueueShutdownStartingEventArgs);
        return nullptr;
    }

    static void _dealloc_DispatcherQueueShutdownStartingEventArgs(py::wrapper::Windows::System::DispatcherQueueShutdownStartingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DispatcherQueueShutdownStartingEventArgs_GetDeferral(py::wrapper::Windows::System::DispatcherQueueShutdownStartingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_DispatcherQueueShutdownStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::DispatcherQueueShutdownStartingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DispatcherQueueShutdownStartingEventArgs[] = {
        { "get_deferral", (PyCFunction)DispatcherQueueShutdownStartingEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DispatcherQueueShutdownStartingEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DispatcherQueueShutdownStartingEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_DispatcherQueueShutdownStartingEventArgs[] = 
    {
        { Py_tp_new, _new_DispatcherQueueShutdownStartingEventArgs },
        { Py_tp_dealloc, _dealloc_DispatcherQueueShutdownStartingEventArgs },
        { Py_tp_methods, _methods_DispatcherQueueShutdownStartingEventArgs },
        { Py_tp_getset, _getset_DispatcherQueueShutdownStartingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DispatcherQueueShutdownStartingEventArgs =
    {
        "_winrt_Windows_System.DispatcherQueueShutdownStartingEventArgs",
        sizeof(py::wrapper::Windows::System::DispatcherQueueShutdownStartingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DispatcherQueueShutdownStartingEventArgs
    };

    // ----- DispatcherQueueTimer class --------------------
    constexpr const char* const _type_name_DispatcherQueueTimer = "DispatcherQueueTimer";

    static PyObject* _new_DispatcherQueueTimer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DispatcherQueueTimer);
        return nullptr;
    }

    static void _dealloc_DispatcherQueueTimer(py::wrapper::Windows::System::DispatcherQueueTimer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DispatcherQueueTimer_Start(py::wrapper::Windows::System::DispatcherQueueTimer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherQueueTimer_Stop(py::wrapper::Windows::System::DispatcherQueueTimer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DispatcherQueueTimer_get_IsRepeating(py::wrapper::Windows::System::DispatcherQueueTimer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRepeating());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DispatcherQueueTimer_put_IsRepeating(py::wrapper::Windows::System::DispatcherQueueTimer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRepeating(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DispatcherQueueTimer_get_Interval(py::wrapper::Windows::System::DispatcherQueueTimer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Interval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DispatcherQueueTimer_put_Interval(py::wrapper::Windows::System::DispatcherQueueTimer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Interval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DispatcherQueueTimer_get_IsRunning(py::wrapper::Windows::System::DispatcherQueueTimer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRunning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DispatcherQueueTimer_add_Tick(py::wrapper::Windows::System::DispatcherQueueTimer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::DispatcherQueueTimer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Tick(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DispatcherQueueTimer_remove_Tick(py::wrapper::Windows::System::DispatcherQueueTimer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Tick(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DispatcherQueueTimer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::DispatcherQueueTimer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DispatcherQueueTimer[] = {
        { "start", (PyCFunction)DispatcherQueueTimer_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)DispatcherQueueTimer_Stop, METH_VARARGS, nullptr },
        { "add_tick", (PyCFunction)DispatcherQueueTimer_add_Tick, METH_O, nullptr },
        { "remove_tick", (PyCFunction)DispatcherQueueTimer_remove_Tick, METH_O, nullptr },
        { "_from", (PyCFunction)_from_DispatcherQueueTimer, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DispatcherQueueTimer[] = {
        { const_cast<char*>("is_repeating"), (getter)DispatcherQueueTimer_get_IsRepeating, (setter)DispatcherQueueTimer_put_IsRepeating, nullptr, nullptr },
        { const_cast<char*>("interval"), (getter)DispatcherQueueTimer_get_Interval, (setter)DispatcherQueueTimer_put_Interval, nullptr, nullptr },
        { const_cast<char*>("is_running"), (getter)DispatcherQueueTimer_get_IsRunning, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DispatcherQueueTimer[] = 
    {
        { Py_tp_new, _new_DispatcherQueueTimer },
        { Py_tp_dealloc, _dealloc_DispatcherQueueTimer },
        { Py_tp_methods, _methods_DispatcherQueueTimer },
        { Py_tp_getset, _getset_DispatcherQueueTimer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DispatcherQueueTimer =
    {
        "_winrt_Windows_System.DispatcherQueueTimer",
        sizeof(py::wrapper::Windows::System::DispatcherQueueTimer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DispatcherQueueTimer
    };

    // ----- FolderLauncherOptions class --------------------
    constexpr const char* const _type_name_FolderLauncherOptions = "FolderLauncherOptions";

    static PyObject* _new_FolderLauncherOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::FolderLauncherOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FolderLauncherOptions(py::wrapper::Windows::System::FolderLauncherOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FolderLauncherOptions_get_ItemsToSelect(py::wrapper::Windows::System::FolderLauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ItemsToSelect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FolderLauncherOptions_get_DesiredRemainingView(py::wrapper::Windows::System::FolderLauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredRemainingView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FolderLauncherOptions_put_DesiredRemainingView(py::wrapper::Windows::System::FolderLauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(arg);

            self->obj.DesiredRemainingView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_FolderLauncherOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::FolderLauncherOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FolderLauncherOptions[] = {
        { "_from", (PyCFunction)_from_FolderLauncherOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FolderLauncherOptions[] = {
        { const_cast<char*>("items_to_select"), (getter)FolderLauncherOptions_get_ItemsToSelect, nullptr, nullptr, nullptr },
        { const_cast<char*>("desired_remaining_view"), (getter)FolderLauncherOptions_get_DesiredRemainingView, (setter)FolderLauncherOptions_put_DesiredRemainingView, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FolderLauncherOptions[] = 
    {
        { Py_tp_new, _new_FolderLauncherOptions },
        { Py_tp_dealloc, _dealloc_FolderLauncherOptions },
        { Py_tp_methods, _methods_FolderLauncherOptions },
        { Py_tp_getset, _getset_FolderLauncherOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FolderLauncherOptions =
    {
        "_winrt_Windows_System.FolderLauncherOptions",
        sizeof(py::wrapper::Windows::System::FolderLauncherOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FolderLauncherOptions
    };

    // ----- KnownUserProperties class --------------------
    constexpr const char* const _type_name_KnownUserProperties = "KnownUserProperties";

    static PyObject* _new_KnownUserProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KnownUserProperties);
        return nullptr;
    }

    static PyObject* KnownUserProperties_get_AccountName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::System::KnownUserProperties::AccountName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_DisplayName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::System::KnownUserProperties::DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_DomainName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::System::KnownUserProperties::DomainName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_FirstName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::System::KnownUserProperties::FirstName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_GuestHost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::System::KnownUserProperties::GuestHost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_LastName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::System::KnownUserProperties::LastName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_PrincipalName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::System::KnownUserProperties::PrincipalName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_ProviderName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::System::KnownUserProperties::ProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_SessionInitiationProtocolUri(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::System::KnownUserProperties::SessionInitiationProtocolUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUserProperties_get_AgeEnforcementRegion(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::System::KnownUserProperties::AgeEnforcementRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownUserProperties[] = {
        { "get_account_name", (PyCFunction)KnownUserProperties_get_AccountName, METH_NOARGS | METH_STATIC, nullptr },
        { "get_display_name", (PyCFunction)KnownUserProperties_get_DisplayName, METH_NOARGS | METH_STATIC, nullptr },
        { "get_domain_name", (PyCFunction)KnownUserProperties_get_DomainName, METH_NOARGS | METH_STATIC, nullptr },
        { "get_first_name", (PyCFunction)KnownUserProperties_get_FirstName, METH_NOARGS | METH_STATIC, nullptr },
        { "get_guest_host", (PyCFunction)KnownUserProperties_get_GuestHost, METH_NOARGS | METH_STATIC, nullptr },
        { "get_last_name", (PyCFunction)KnownUserProperties_get_LastName, METH_NOARGS | METH_STATIC, nullptr },
        { "get_principal_name", (PyCFunction)KnownUserProperties_get_PrincipalName, METH_NOARGS | METH_STATIC, nullptr },
        { "get_provider_name", (PyCFunction)KnownUserProperties_get_ProviderName, METH_NOARGS | METH_STATIC, nullptr },
        { "get_session_initiation_protocol_uri", (PyCFunction)KnownUserProperties_get_SessionInitiationProtocolUri, METH_NOARGS | METH_STATIC, nullptr },
        { "get_age_enforcement_region", (PyCFunction)KnownUserProperties_get_AgeEnforcementRegion, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_KnownUserProperties[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_KnownUserProperties[] = 
    {
        { Py_tp_new, _new_KnownUserProperties },
        { Py_tp_methods, _methods_KnownUserProperties },
        { Py_tp_getset, _getset_KnownUserProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_KnownUserProperties =
    {
        "_winrt_Windows_System.KnownUserProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownUserProperties
    };

    // ----- LaunchUriResult class --------------------
    constexpr const char* const _type_name_LaunchUriResult = "LaunchUriResult";

    static PyObject* _new_LaunchUriResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LaunchUriResult);
        return nullptr;
    }

    static void _dealloc_LaunchUriResult(py::wrapper::Windows::System::LaunchUriResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LaunchUriResult_get_Result(py::wrapper::Windows::System::LaunchUriResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchUriResult_get_Status(py::wrapper::Windows::System::LaunchUriResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LaunchUriResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::LaunchUriResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LaunchUriResult[] = {
        { "_from", (PyCFunction)_from_LaunchUriResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LaunchUriResult[] = {
        { const_cast<char*>("result"), (getter)LaunchUriResult_get_Result, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)LaunchUriResult_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LaunchUriResult[] = 
    {
        { Py_tp_new, _new_LaunchUriResult },
        { Py_tp_dealloc, _dealloc_LaunchUriResult },
        { Py_tp_methods, _methods_LaunchUriResult },
        { Py_tp_getset, _getset_LaunchUriResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LaunchUriResult =
    {
        "_winrt_Windows_System.LaunchUriResult",
        sizeof(py::wrapper::Windows::System::LaunchUriResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LaunchUriResult
    };

    // ----- Launcher class --------------------
    constexpr const char* const _type_name_Launcher = "Launcher";

    static PyObject* _new_Launcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_Launcher);
        return nullptr;
    }

    static PyObject* Launcher_FindAppUriHandlersAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::FindAppUriHandlersAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_FindFileHandlersAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::FindFileHandlersAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_FindUriSchemeHandlersAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::FindUriSchemeHandlersAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LaunchQuerySupportType>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::FindUriSchemeHandlersAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::LaunchFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::LaunchFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchFolderAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::LaunchFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::FolderLauncherOptions>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::LaunchFolderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchFolderPathAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::LaunchFolderPathAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::FolderLauncherOptions>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::LaunchFolderPathAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchFolderPathForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::LaunchFolderPathForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::FolderLauncherOptions>(args, 2);

                return py::convert(winrt::Windows::System::Launcher::LaunchFolderPathForUserAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchUriAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 2);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchUriForResultsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriForResultsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 2);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriForResultsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchUriForResultsForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 2);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriForResultsForUserAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 3);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriForResultsForUserAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_LaunchUriForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 2);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriForUserAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::LauncherOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 3);

                return py::convert(winrt::Windows::System::Launcher::LaunchUriForUserAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_QueryAppUriSupportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::QueryAppUriSupportAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::QueryAppUriSupportAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_QueryFileSupportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);

                return py::convert(winrt::Windows::System::Launcher::QueryFileSupportAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::QueryFileSupportAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Launcher_QueryUriSupportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LaunchQuerySupportType>(args, 1);

                return py::convert(winrt::Windows::System::Launcher::QueryUriSupportAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::LaunchQuerySupportType>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::System::Launcher::QueryUriSupportAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_Launcher[] = {
        { "find_app_uri_handlers_async", (PyCFunction)Launcher_FindAppUriHandlersAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "find_file_handlers_async", (PyCFunction)Launcher_FindFileHandlersAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "find_uri_scheme_handlers_async", (PyCFunction)Launcher_FindUriSchemeHandlersAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "launch_file_async", (PyCFunction)Launcher_LaunchFileAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "launch_folder_async", (PyCFunction)Launcher_LaunchFolderAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "launch_folder_path_async", (PyCFunction)Launcher_LaunchFolderPathAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "launch_folder_path_for_user_async", (PyCFunction)Launcher_LaunchFolderPathForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "launch_uri_async", (PyCFunction)Launcher_LaunchUriAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "launch_uri_for_results_async", (PyCFunction)Launcher_LaunchUriForResultsAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "launch_uri_for_results_for_user_async", (PyCFunction)Launcher_LaunchUriForResultsForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "launch_uri_for_user_async", (PyCFunction)Launcher_LaunchUriForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "query_app_uri_support_async", (PyCFunction)Launcher_QueryAppUriSupportAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "query_file_support_async", (PyCFunction)Launcher_QueryFileSupportAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "query_uri_support_async", (PyCFunction)Launcher_QueryUriSupportAsync, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_Launcher[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_Launcher[] = 
    {
        { Py_tp_new, _new_Launcher },
        { Py_tp_methods, _methods_Launcher },
        { Py_tp_getset, _getset_Launcher },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Launcher =
    {
        "_winrt_Windows_System.Launcher",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Launcher
    };

    // ----- LauncherOptions class --------------------
    constexpr const char* const _type_name_LauncherOptions = "LauncherOptions";

    static PyObject* _new_LauncherOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::LauncherOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LauncherOptions(py::wrapper::Windows::System::LauncherOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LauncherOptions_get_TreatAsUntrusted(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TreatAsUntrusted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_TreatAsUntrusted(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.TreatAsUntrusted(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_PreferredApplicationPackageFamilyName(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreferredApplicationPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_PreferredApplicationPackageFamilyName(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PreferredApplicationPackageFamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_PreferredApplicationDisplayName(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreferredApplicationDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_PreferredApplicationDisplayName(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PreferredApplicationDisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_FallbackUri(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FallbackUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_FallbackUri(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.FallbackUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_DisplayApplicationPicker(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayApplicationPicker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_DisplayApplicationPicker(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DisplayApplicationPicker(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_ContentType(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_ContentType(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContentType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_UI(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LauncherOptions_get_TargetApplicationPackageFamilyName(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TargetApplicationPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_TargetApplicationPackageFamilyName(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TargetApplicationPackageFamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_NeighboringFilesQuery(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NeighboringFilesQuery());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_NeighboringFilesQuery(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Search::StorageFileQueryResult>(arg);

            self->obj.NeighboringFilesQuery(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_IgnoreAppUriHandlers(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IgnoreAppUriHandlers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_IgnoreAppUriHandlers(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IgnoreAppUriHandlers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_LimitPickerToCurrentAppAndAppUriHandlers(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LimitPickerToCurrentAppAndAppUriHandlers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_LimitPickerToCurrentAppAndAppUriHandlers(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.LimitPickerToCurrentAppAndAppUriHandlers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherOptions_get_DesiredRemainingView(py::wrapper::Windows::System::LauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredRemainingView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherOptions_put_DesiredRemainingView(py::wrapper::Windows::System::LauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(arg);

            self->obj.DesiredRemainingView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_LauncherOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::LauncherOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LauncherOptions[] = {
        { "_from", (PyCFunction)_from_LauncherOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LauncherOptions[] = {
        { const_cast<char*>("treat_as_untrusted"), (getter)LauncherOptions_get_TreatAsUntrusted, (setter)LauncherOptions_put_TreatAsUntrusted, nullptr, nullptr },
        { const_cast<char*>("preferred_application_package_family_name"), (getter)LauncherOptions_get_PreferredApplicationPackageFamilyName, (setter)LauncherOptions_put_PreferredApplicationPackageFamilyName, nullptr, nullptr },
        { const_cast<char*>("preferred_application_display_name"), (getter)LauncherOptions_get_PreferredApplicationDisplayName, (setter)LauncherOptions_put_PreferredApplicationDisplayName, nullptr, nullptr },
        { const_cast<char*>("fallback_uri"), (getter)LauncherOptions_get_FallbackUri, (setter)LauncherOptions_put_FallbackUri, nullptr, nullptr },
        { const_cast<char*>("display_application_picker"), (getter)LauncherOptions_get_DisplayApplicationPicker, (setter)LauncherOptions_put_DisplayApplicationPicker, nullptr, nullptr },
        { const_cast<char*>("content_type"), (getter)LauncherOptions_get_ContentType, (setter)LauncherOptions_put_ContentType, nullptr, nullptr },
        { const_cast<char*>("u_i"), (getter)LauncherOptions_get_UI, nullptr, nullptr, nullptr },
        { const_cast<char*>("target_application_package_family_name"), (getter)LauncherOptions_get_TargetApplicationPackageFamilyName, (setter)LauncherOptions_put_TargetApplicationPackageFamilyName, nullptr, nullptr },
        { const_cast<char*>("neighboring_files_query"), (getter)LauncherOptions_get_NeighboringFilesQuery, (setter)LauncherOptions_put_NeighboringFilesQuery, nullptr, nullptr },
        { const_cast<char*>("ignore_app_uri_handlers"), (getter)LauncherOptions_get_IgnoreAppUriHandlers, (setter)LauncherOptions_put_IgnoreAppUriHandlers, nullptr, nullptr },
        { const_cast<char*>("limit_picker_to_current_app_and_app_uri_handlers"), (getter)LauncherOptions_get_LimitPickerToCurrentAppAndAppUriHandlers, (setter)LauncherOptions_put_LimitPickerToCurrentAppAndAppUriHandlers, nullptr, nullptr },
        { const_cast<char*>("desired_remaining_view"), (getter)LauncherOptions_get_DesiredRemainingView, (setter)LauncherOptions_put_DesiredRemainingView, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LauncherOptions[] = 
    {
        { Py_tp_new, _new_LauncherOptions },
        { Py_tp_dealloc, _dealloc_LauncherOptions },
        { Py_tp_methods, _methods_LauncherOptions },
        { Py_tp_getset, _getset_LauncherOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LauncherOptions =
    {
        "_winrt_Windows_System.LauncherOptions",
        sizeof(py::wrapper::Windows::System::LauncherOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LauncherOptions
    };

    // ----- LauncherUIOptions class --------------------
    constexpr const char* const _type_name_LauncherUIOptions = "LauncherUIOptions";

    static PyObject* _new_LauncherUIOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LauncherUIOptions);
        return nullptr;
    }

    static void _dealloc_LauncherUIOptions(py::wrapper::Windows::System::LauncherUIOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LauncherUIOptions_get_SelectionRect(py::wrapper::Windows::System::LauncherUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SelectionRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherUIOptions_put_SelectionRect(py::wrapper::Windows::System::LauncherUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Rect>>(arg);

            self->obj.SelectionRect(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherUIOptions_get_PreferredPlacement(py::wrapper::Windows::System::LauncherUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreferredPlacement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherUIOptions_put_PreferredPlacement(py::wrapper::Windows::System::LauncherUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Popups::Placement>(arg);

            self->obj.PreferredPlacement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LauncherUIOptions_get_InvocationPoint(py::wrapper::Windows::System::LauncherUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InvocationPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LauncherUIOptions_put_InvocationPoint(py::wrapper::Windows::System::LauncherUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Point>>(arg);

            self->obj.InvocationPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_LauncherUIOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::LauncherUIOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LauncherUIOptions[] = {
        { "_from", (PyCFunction)_from_LauncherUIOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LauncherUIOptions[] = {
        { const_cast<char*>("selection_rect"), (getter)LauncherUIOptions_get_SelectionRect, (setter)LauncherUIOptions_put_SelectionRect, nullptr, nullptr },
        { const_cast<char*>("preferred_placement"), (getter)LauncherUIOptions_get_PreferredPlacement, (setter)LauncherUIOptions_put_PreferredPlacement, nullptr, nullptr },
        { const_cast<char*>("invocation_point"), (getter)LauncherUIOptions_get_InvocationPoint, (setter)LauncherUIOptions_put_InvocationPoint, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LauncherUIOptions[] = 
    {
        { Py_tp_new, _new_LauncherUIOptions },
        { Py_tp_dealloc, _dealloc_LauncherUIOptions },
        { Py_tp_methods, _methods_LauncherUIOptions },
        { Py_tp_getset, _getset_LauncherUIOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LauncherUIOptions =
    {
        "_winrt_Windows_System.LauncherUIOptions",
        sizeof(py::wrapper::Windows::System::LauncherUIOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LauncherUIOptions
    };

    // ----- MemoryManager class --------------------
    constexpr const char* const _type_name_MemoryManager = "MemoryManager";

    static PyObject* _new_MemoryManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MemoryManager);
        return nullptr;
    }

    static PyObject* MemoryManager_GetAppMemoryReport(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::System::MemoryManager::GetAppMemoryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MemoryManager_GetProcessMemoryReport(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::System::MemoryManager::GetProcessMemoryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MemoryManager_TrySetAppMemoryUsageLimit(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(winrt::Windows::System::MemoryManager::TrySetAppMemoryUsageLimit(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MemoryManager_get_AppMemoryUsage(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::System::MemoryManager::AppMemoryUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_get_AppMemoryUsageLevel(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::System::MemoryManager::AppMemoryUsageLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_get_AppMemoryUsageLimit(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::System::MemoryManager::AppMemoryUsageLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_get_ExpectedAppMemoryUsageLimit(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::System::MemoryManager::ExpectedAppMemoryUsageLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_add_AppMemoryUsageDecreased(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::System::MemoryManager::AppMemoryUsageDecreased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_remove_AppMemoryUsageDecreased(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::System::MemoryManager::AppMemoryUsageDecreased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_add_AppMemoryUsageIncreased(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::System::MemoryManager::AppMemoryUsageIncreased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_remove_AppMemoryUsageIncreased(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::System::MemoryManager::AppMemoryUsageIncreased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_add_AppMemoryUsageLimitChanging(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::System::AppMemoryUsageLimitChangingEventArgs>>(arg);

            return py::convert(winrt::Windows::System::MemoryManager::AppMemoryUsageLimitChanging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MemoryManager_remove_AppMemoryUsageLimitChanging(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::System::MemoryManager::AppMemoryUsageLimitChanging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MemoryManager[] = {
        { "get_app_memory_report", (PyCFunction)MemoryManager_GetAppMemoryReport, METH_VARARGS | METH_STATIC, nullptr },
        { "get_process_memory_report", (PyCFunction)MemoryManager_GetProcessMemoryReport, METH_VARARGS | METH_STATIC, nullptr },
        { "try_set_app_memory_usage_limit", (PyCFunction)MemoryManager_TrySetAppMemoryUsageLimit, METH_VARARGS | METH_STATIC, nullptr },
        { "get_app_memory_usage", (PyCFunction)MemoryManager_get_AppMemoryUsage, METH_NOARGS | METH_STATIC, nullptr },
        { "get_app_memory_usage_level", (PyCFunction)MemoryManager_get_AppMemoryUsageLevel, METH_NOARGS | METH_STATIC, nullptr },
        { "get_app_memory_usage_limit", (PyCFunction)MemoryManager_get_AppMemoryUsageLimit, METH_NOARGS | METH_STATIC, nullptr },
        { "get_expected_app_memory_usage_limit", (PyCFunction)MemoryManager_get_ExpectedAppMemoryUsageLimit, METH_NOARGS | METH_STATIC, nullptr },
        { "add_app_memory_usage_decreased", (PyCFunction)MemoryManager_add_AppMemoryUsageDecreased, METH_O | METH_STATIC, nullptr },
        { "remove_app_memory_usage_decreased", (PyCFunction)MemoryManager_remove_AppMemoryUsageDecreased, METH_O | METH_STATIC, nullptr },
        { "add_app_memory_usage_increased", (PyCFunction)MemoryManager_add_AppMemoryUsageIncreased, METH_O | METH_STATIC, nullptr },
        { "remove_app_memory_usage_increased", (PyCFunction)MemoryManager_remove_AppMemoryUsageIncreased, METH_O | METH_STATIC, nullptr },
        { "add_app_memory_usage_limit_changing", (PyCFunction)MemoryManager_add_AppMemoryUsageLimitChanging, METH_O | METH_STATIC, nullptr },
        { "remove_app_memory_usage_limit_changing", (PyCFunction)MemoryManager_remove_AppMemoryUsageLimitChanging, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MemoryManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_MemoryManager[] = 
    {
        { Py_tp_new, _new_MemoryManager },
        { Py_tp_methods, _methods_MemoryManager },
        { Py_tp_getset, _getset_MemoryManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MemoryManager =
    {
        "_winrt_Windows_System.MemoryManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MemoryManager
    };

    // ----- ProcessLauncher class --------------------
    constexpr const char* const _type_name_ProcessLauncher = "ProcessLauncher";

    static PyObject* _new_ProcessLauncher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProcessLauncher);
        return nullptr;
    }

    static PyObject* ProcessLauncher_RunToCompletionAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::System::ProcessLauncher::RunToCompletionAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::ProcessLauncherOptions>(args, 2);

                return py::convert(winrt::Windows::System::ProcessLauncher::RunToCompletionAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessLauncher[] = {
        { "run_to_completion_async", (PyCFunction)ProcessLauncher_RunToCompletionAsync, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ProcessLauncher[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ProcessLauncher[] = 
    {
        { Py_tp_new, _new_ProcessLauncher },
        { Py_tp_methods, _methods_ProcessLauncher },
        { Py_tp_getset, _getset_ProcessLauncher },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProcessLauncher =
    {
        "_winrt_Windows_System.ProcessLauncher",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessLauncher
    };

    // ----- ProcessLauncherOptions class --------------------
    constexpr const char* const _type_name_ProcessLauncherOptions = "ProcessLauncherOptions";

    static PyObject* _new_ProcessLauncherOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::ProcessLauncherOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProcessLauncherOptions(py::wrapper::Windows::System::ProcessLauncherOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProcessLauncherOptions_get_WorkingDirectory(py::wrapper::Windows::System::ProcessLauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WorkingDirectory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProcessLauncherOptions_put_WorkingDirectory(py::wrapper::Windows::System::ProcessLauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.WorkingDirectory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProcessLauncherOptions_get_StandardOutput(py::wrapper::Windows::System::ProcessLauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StandardOutput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProcessLauncherOptions_put_StandardOutput(py::wrapper::Windows::System::ProcessLauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(arg);

            self->obj.StandardOutput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProcessLauncherOptions_get_StandardInput(py::wrapper::Windows::System::ProcessLauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StandardInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProcessLauncherOptions_put_StandardInput(py::wrapper::Windows::System::ProcessLauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(arg);

            self->obj.StandardInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProcessLauncherOptions_get_StandardError(py::wrapper::Windows::System::ProcessLauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StandardError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProcessLauncherOptions_put_StandardError(py::wrapper::Windows::System::ProcessLauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(arg);

            self->obj.StandardError(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ProcessLauncherOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::ProcessLauncherOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessLauncherOptions[] = {
        { "_from", (PyCFunction)_from_ProcessLauncherOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ProcessLauncherOptions[] = {
        { const_cast<char*>("working_directory"), (getter)ProcessLauncherOptions_get_WorkingDirectory, (setter)ProcessLauncherOptions_put_WorkingDirectory, nullptr, nullptr },
        { const_cast<char*>("standard_output"), (getter)ProcessLauncherOptions_get_StandardOutput, (setter)ProcessLauncherOptions_put_StandardOutput, nullptr, nullptr },
        { const_cast<char*>("standard_input"), (getter)ProcessLauncherOptions_get_StandardInput, (setter)ProcessLauncherOptions_put_StandardInput, nullptr, nullptr },
        { const_cast<char*>("standard_error"), (getter)ProcessLauncherOptions_get_StandardError, (setter)ProcessLauncherOptions_put_StandardError, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ProcessLauncherOptions[] = 
    {
        { Py_tp_new, _new_ProcessLauncherOptions },
        { Py_tp_dealloc, _dealloc_ProcessLauncherOptions },
        { Py_tp_methods, _methods_ProcessLauncherOptions },
        { Py_tp_getset, _getset_ProcessLauncherOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProcessLauncherOptions =
    {
        "_winrt_Windows_System.ProcessLauncherOptions",
        sizeof(py::wrapper::Windows::System::ProcessLauncherOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessLauncherOptions
    };

    // ----- ProcessLauncherResult class --------------------
    constexpr const char* const _type_name_ProcessLauncherResult = "ProcessLauncherResult";

    static PyObject* _new_ProcessLauncherResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProcessLauncherResult);
        return nullptr;
    }

    static void _dealloc_ProcessLauncherResult(py::wrapper::Windows::System::ProcessLauncherResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProcessLauncherResult_get_ExitCode(py::wrapper::Windows::System::ProcessLauncherResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExitCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProcessLauncherResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::ProcessLauncherResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessLauncherResult[] = {
        { "_from", (PyCFunction)_from_ProcessLauncherResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ProcessLauncherResult[] = {
        { const_cast<char*>("exit_code"), (getter)ProcessLauncherResult_get_ExitCode, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ProcessLauncherResult[] = 
    {
        { Py_tp_new, _new_ProcessLauncherResult },
        { Py_tp_dealloc, _dealloc_ProcessLauncherResult },
        { Py_tp_methods, _methods_ProcessLauncherResult },
        { Py_tp_getset, _getset_ProcessLauncherResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProcessLauncherResult =
    {
        "_winrt_Windows_System.ProcessLauncherResult",
        sizeof(py::wrapper::Windows::System::ProcessLauncherResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessLauncherResult
    };

    // ----- ProcessMemoryReport class --------------------
    constexpr const char* const _type_name_ProcessMemoryReport = "ProcessMemoryReport";

    static PyObject* _new_ProcessMemoryReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProcessMemoryReport);
        return nullptr;
    }

    static void _dealloc_ProcessMemoryReport(py::wrapper::Windows::System::ProcessMemoryReport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProcessMemoryReport_get_PrivateWorkingSetUsage(py::wrapper::Windows::System::ProcessMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrivateWorkingSetUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryReport_get_TotalWorkingSetUsage(py::wrapper::Windows::System::ProcessMemoryReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalWorkingSetUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProcessMemoryReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::ProcessMemoryReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessMemoryReport[] = {
        { "_from", (PyCFunction)_from_ProcessMemoryReport, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ProcessMemoryReport[] = {
        { const_cast<char*>("private_working_set_usage"), (getter)ProcessMemoryReport_get_PrivateWorkingSetUsage, nullptr, nullptr, nullptr },
        { const_cast<char*>("total_working_set_usage"), (getter)ProcessMemoryReport_get_TotalWorkingSetUsage, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ProcessMemoryReport[] = 
    {
        { Py_tp_new, _new_ProcessMemoryReport },
        { Py_tp_dealloc, _dealloc_ProcessMemoryReport },
        { Py_tp_methods, _methods_ProcessMemoryReport },
        { Py_tp_getset, _getset_ProcessMemoryReport },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProcessMemoryReport =
    {
        "_winrt_Windows_System.ProcessMemoryReport",
        sizeof(py::wrapper::Windows::System::ProcessMemoryReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessMemoryReport
    };

    // ----- ProtocolForResultsOperation class --------------------
    constexpr const char* const _type_name_ProtocolForResultsOperation = "ProtocolForResultsOperation";

    static PyObject* _new_ProtocolForResultsOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProtocolForResultsOperation);
        return nullptr;
    }

    static void _dealloc_ProtocolForResultsOperation(py::wrapper::Windows::System::ProtocolForResultsOperation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProtocolForResultsOperation_ReportCompleted(py::wrapper::Windows::System::ProtocolForResultsOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);

                self->obj.ReportCompleted(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ProtocolForResultsOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::ProtocolForResultsOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProtocolForResultsOperation[] = {
        { "report_completed", (PyCFunction)ProtocolForResultsOperation_ReportCompleted, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ProtocolForResultsOperation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ProtocolForResultsOperation[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ProtocolForResultsOperation[] = 
    {
        { Py_tp_new, _new_ProtocolForResultsOperation },
        { Py_tp_dealloc, _dealloc_ProtocolForResultsOperation },
        { Py_tp_methods, _methods_ProtocolForResultsOperation },
        { Py_tp_getset, _getset_ProtocolForResultsOperation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProtocolForResultsOperation =
    {
        "_winrt_Windows_System.ProtocolForResultsOperation",
        sizeof(py::wrapper::Windows::System::ProtocolForResultsOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProtocolForResultsOperation
    };

    // ----- RemoteLauncher class --------------------
    constexpr const char* const _type_name_RemoteLauncher = "RemoteLauncher";

    static PyObject* _new_RemoteLauncher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RemoteLauncher);
        return nullptr;
    }

    static PyObject* RemoteLauncher_LaunchUriAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemConnectionRequest>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);

                return py::convert(winrt::Windows::System::RemoteLauncher::LaunchUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemConnectionRequest>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::RemoteLauncherOptions>(args, 2);

                return py::convert(winrt::Windows::System::RemoteLauncher::LaunchUriAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::RemoteSystems::RemoteSystemConnectionRequest>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::System::RemoteLauncherOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 3);

                return py::convert(winrt::Windows::System::RemoteLauncher::LaunchUriAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteLauncher[] = {
        { "launch_uri_async", (PyCFunction)RemoteLauncher_LaunchUriAsync, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RemoteLauncher[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_RemoteLauncher[] = 
    {
        { Py_tp_new, _new_RemoteLauncher },
        { Py_tp_methods, _methods_RemoteLauncher },
        { Py_tp_getset, _getset_RemoteLauncher },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RemoteLauncher =
    {
        "_winrt_Windows_System.RemoteLauncher",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteLauncher
    };

    // ----- RemoteLauncherOptions class --------------------
    constexpr const char* const _type_name_RemoteLauncherOptions = "RemoteLauncherOptions";

    static PyObject* _new_RemoteLauncherOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::RemoteLauncherOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteLauncherOptions(py::wrapper::Windows::System::RemoteLauncherOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RemoteLauncherOptions_get_FallbackUri(py::wrapper::Windows::System::RemoteLauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FallbackUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RemoteLauncherOptions_put_FallbackUri(py::wrapper::Windows::System::RemoteLauncherOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.FallbackUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RemoteLauncherOptions_get_PreferredAppIds(py::wrapper::Windows::System::RemoteLauncherOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreferredAppIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RemoteLauncherOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::RemoteLauncherOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteLauncherOptions[] = {
        { "_from", (PyCFunction)_from_RemoteLauncherOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RemoteLauncherOptions[] = {
        { const_cast<char*>("fallback_uri"), (getter)RemoteLauncherOptions_get_FallbackUri, (setter)RemoteLauncherOptions_put_FallbackUri, nullptr, nullptr },
        { const_cast<char*>("preferred_app_ids"), (getter)RemoteLauncherOptions_get_PreferredAppIds, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RemoteLauncherOptions[] = 
    {
        { Py_tp_new, _new_RemoteLauncherOptions },
        { Py_tp_dealloc, _dealloc_RemoteLauncherOptions },
        { Py_tp_methods, _methods_RemoteLauncherOptions },
        { Py_tp_getset, _getset_RemoteLauncherOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RemoteLauncherOptions =
    {
        "_winrt_Windows_System.RemoteLauncherOptions",
        sizeof(py::wrapper::Windows::System::RemoteLauncherOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteLauncherOptions
    };

    // ----- ShutdownManager class --------------------
    constexpr const char* const _type_name_ShutdownManager = "ShutdownManager";

    static PyObject* _new_ShutdownManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ShutdownManager);
        return nullptr;
    }

    static PyObject* ShutdownManager_BeginShutdown(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::ShutdownKind>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                winrt::Windows::System::ShutdownManager::BeginShutdown(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShutdownManager_CancelShutdown(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::ShutdownManager::CancelShutdown();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShutdownManager_EnterPowerState(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::PowerState>(args, 0);

                winrt::Windows::System::ShutdownManager::EnterPowerState(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::PowerState>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                winrt::Windows::System::ShutdownManager::EnterPowerState(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShutdownManager_IsPowerStateSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::PowerState>(args, 0);

                return py::convert(winrt::Windows::System::ShutdownManager::IsPowerStateSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShutdownManager[] = {
        { "begin_shutdown", (PyCFunction)ShutdownManager_BeginShutdown, METH_VARARGS | METH_STATIC, nullptr },
        { "cancel_shutdown", (PyCFunction)ShutdownManager_CancelShutdown, METH_VARARGS | METH_STATIC, nullptr },
        { "enter_power_state", (PyCFunction)ShutdownManager_EnterPowerState, METH_VARARGS | METH_STATIC, nullptr },
        { "is_power_state_supported", (PyCFunction)ShutdownManager_IsPowerStateSupported, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ShutdownManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ShutdownManager[] = 
    {
        { Py_tp_new, _new_ShutdownManager },
        { Py_tp_methods, _methods_ShutdownManager },
        { Py_tp_getset, _getset_ShutdownManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ShutdownManager =
    {
        "_winrt_Windows_System.ShutdownManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShutdownManager
    };

    // ----- TimeZoneSettings class --------------------
    constexpr const char* const _type_name_TimeZoneSettings = "TimeZoneSettings";

    static PyObject* _new_TimeZoneSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TimeZoneSettings);
        return nullptr;
    }

    static PyObject* TimeZoneSettings_AutoUpdateTimeZoneAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(winrt::Windows::System::TimeZoneSettings::AutoUpdateTimeZoneAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimeZoneSettings_ChangeTimeZoneByDisplayName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::System::TimeZoneSettings::ChangeTimeZoneByDisplayName(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimeZoneSettings_get_CanChangeTimeZone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::System::TimeZoneSettings::CanChangeTimeZone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimeZoneSettings_get_CurrentTimeZoneDisplayName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::System::TimeZoneSettings::CurrentTimeZoneDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimeZoneSettings_get_SupportedTimeZoneDisplayNames(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::System::TimeZoneSettings::SupportedTimeZoneDisplayNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimeZoneSettings[] = {
        { "auto_update_time_zone_async", (PyCFunction)TimeZoneSettings_AutoUpdateTimeZoneAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "change_time_zone_by_display_name", (PyCFunction)TimeZoneSettings_ChangeTimeZoneByDisplayName, METH_VARARGS | METH_STATIC, nullptr },
        { "get_can_change_time_zone", (PyCFunction)TimeZoneSettings_get_CanChangeTimeZone, METH_NOARGS | METH_STATIC, nullptr },
        { "get_current_time_zone_display_name", (PyCFunction)TimeZoneSettings_get_CurrentTimeZoneDisplayName, METH_NOARGS | METH_STATIC, nullptr },
        { "get_supported_time_zone_display_names", (PyCFunction)TimeZoneSettings_get_SupportedTimeZoneDisplayNames, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TimeZoneSettings[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_TimeZoneSettings[] = 
    {
        { Py_tp_new, _new_TimeZoneSettings },
        { Py_tp_methods, _methods_TimeZoneSettings },
        { Py_tp_getset, _getset_TimeZoneSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimeZoneSettings =
    {
        "_winrt_Windows_System.TimeZoneSettings",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimeZoneSettings
    };

    // ----- User class --------------------
    constexpr const char* const _type_name_User = "User";

    static PyObject* _new_User(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_User);
        return nullptr;
    }

    static void _dealloc_User(py::wrapper::Windows::System::User* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* User_CheckUserAgeConsentGroupAsync(py::wrapper::Windows::System::User* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::UserAgeConsentGroup>(args, 0);

                return py::convert(self->obj.CheckUserAgeConsentGroupAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::System::User::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_FindAllAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::System::User::FindAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::UserType>(args, 0);

                return py::convert(winrt::Windows::System::User::FindAllAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::UserType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::System::UserAuthenticationStatus>(args, 1);

                return py::convert(winrt::Windows::System::User::FindAllAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::System::User::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_GetFromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::User::GetFromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_GetPictureAsync(py::wrapper::Windows::System::User* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::UserPictureSize>(args, 0);

                return py::convert(self->obj.GetPictureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_GetPropertiesAsync(py::wrapper::Windows::System::User* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetPropertiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_GetPropertyAsync(py::wrapper::Windows::System::User* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetPropertyAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* User_get_AuthenticationStatus(py::wrapper::Windows::System::User* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AuthenticationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* User_get_NonRoamableId(py::wrapper::Windows::System::User* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NonRoamableId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* User_get_Type(py::wrapper::Windows::System::User* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_User(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::User>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_User[] = {
        { "check_user_age_consent_group_async", (PyCFunction)User_CheckUserAgeConsentGroupAsync, METH_VARARGS, nullptr },
        { "create_watcher", (PyCFunction)User_CreateWatcher, METH_VARARGS | METH_STATIC, nullptr },
        { "find_all_async", (PyCFunction)User_FindAllAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_default", (PyCFunction)User_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "get_from_id", (PyCFunction)User_GetFromId, METH_VARARGS | METH_STATIC, nullptr },
        { "get_picture_async", (PyCFunction)User_GetPictureAsync, METH_VARARGS, nullptr },
        { "get_properties_async", (PyCFunction)User_GetPropertiesAsync, METH_VARARGS, nullptr },
        { "get_property_async", (PyCFunction)User_GetPropertyAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_User, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_User[] = {
        { const_cast<char*>("authentication_status"), (getter)User_get_AuthenticationStatus, nullptr, nullptr, nullptr },
        { const_cast<char*>("non_roamable_id"), (getter)User_get_NonRoamableId, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)User_get_Type, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_User[] = 
    {
        { Py_tp_new, _new_User },
        { Py_tp_dealloc, _dealloc_User },
        { Py_tp_methods, _methods_User },
        { Py_tp_getset, _getset_User },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_User =
    {
        "_winrt_Windows_System.User",
        sizeof(py::wrapper::Windows::System::User),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_User
    };

    // ----- UserAuthenticationStatusChangeDeferral class --------------------
    constexpr const char* const _type_name_UserAuthenticationStatusChangeDeferral = "UserAuthenticationStatusChangeDeferral";

    static PyObject* _new_UserAuthenticationStatusChangeDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UserAuthenticationStatusChangeDeferral);
        return nullptr;
    }

    static void _dealloc_UserAuthenticationStatusChangeDeferral(py::wrapper::Windows::System::UserAuthenticationStatusChangeDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UserAuthenticationStatusChangeDeferral_Complete(py::wrapper::Windows::System::UserAuthenticationStatusChangeDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_UserAuthenticationStatusChangeDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::UserAuthenticationStatusChangeDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserAuthenticationStatusChangeDeferral[] = {
        { "complete", (PyCFunction)UserAuthenticationStatusChangeDeferral_Complete, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_UserAuthenticationStatusChangeDeferral, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UserAuthenticationStatusChangeDeferral[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_UserAuthenticationStatusChangeDeferral[] = 
    {
        { Py_tp_new, _new_UserAuthenticationStatusChangeDeferral },
        { Py_tp_dealloc, _dealloc_UserAuthenticationStatusChangeDeferral },
        { Py_tp_methods, _methods_UserAuthenticationStatusChangeDeferral },
        { Py_tp_getset, _getset_UserAuthenticationStatusChangeDeferral },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UserAuthenticationStatusChangeDeferral =
    {
        "_winrt_Windows_System.UserAuthenticationStatusChangeDeferral",
        sizeof(py::wrapper::Windows::System::UserAuthenticationStatusChangeDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserAuthenticationStatusChangeDeferral
    };

    // ----- UserAuthenticationStatusChangingEventArgs class --------------------
    constexpr const char* const _type_name_UserAuthenticationStatusChangingEventArgs = "UserAuthenticationStatusChangingEventArgs";

    static PyObject* _new_UserAuthenticationStatusChangingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UserAuthenticationStatusChangingEventArgs);
        return nullptr;
    }

    static void _dealloc_UserAuthenticationStatusChangingEventArgs(py::wrapper::Windows::System::UserAuthenticationStatusChangingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UserAuthenticationStatusChangingEventArgs_GetDeferral(py::wrapper::Windows::System::UserAuthenticationStatusChangingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserAuthenticationStatusChangingEventArgs_get_CurrentStatus(py::wrapper::Windows::System::UserAuthenticationStatusChangingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserAuthenticationStatusChangingEventArgs_get_NewStatus(py::wrapper::Windows::System::UserAuthenticationStatusChangingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NewStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserAuthenticationStatusChangingEventArgs_get_User(py::wrapper::Windows::System::UserAuthenticationStatusChangingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UserAuthenticationStatusChangingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::UserAuthenticationStatusChangingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserAuthenticationStatusChangingEventArgs[] = {
        { "get_deferral", (PyCFunction)UserAuthenticationStatusChangingEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_UserAuthenticationStatusChangingEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UserAuthenticationStatusChangingEventArgs[] = {
        { const_cast<char*>("current_status"), (getter)UserAuthenticationStatusChangingEventArgs_get_CurrentStatus, nullptr, nullptr, nullptr },
        { const_cast<char*>("new_status"), (getter)UserAuthenticationStatusChangingEventArgs_get_NewStatus, nullptr, nullptr, nullptr },
        { const_cast<char*>("user"), (getter)UserAuthenticationStatusChangingEventArgs_get_User, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UserAuthenticationStatusChangingEventArgs[] = 
    {
        { Py_tp_new, _new_UserAuthenticationStatusChangingEventArgs },
        { Py_tp_dealloc, _dealloc_UserAuthenticationStatusChangingEventArgs },
        { Py_tp_methods, _methods_UserAuthenticationStatusChangingEventArgs },
        { Py_tp_getset, _getset_UserAuthenticationStatusChangingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UserAuthenticationStatusChangingEventArgs =
    {
        "_winrt_Windows_System.UserAuthenticationStatusChangingEventArgs",
        sizeof(py::wrapper::Windows::System::UserAuthenticationStatusChangingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserAuthenticationStatusChangingEventArgs
    };

    // ----- UserChangedEventArgs class --------------------
    constexpr const char* const _type_name_UserChangedEventArgs = "UserChangedEventArgs";

    static PyObject* _new_UserChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UserChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_UserChangedEventArgs(py::wrapper::Windows::System::UserChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UserChangedEventArgs_get_User(py::wrapper::Windows::System::UserChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserChangedEventArgs_get_ChangedPropertyKinds(py::wrapper::Windows::System::UserChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangedPropertyKinds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UserChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::UserChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_UserChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UserChangedEventArgs[] = {
        { const_cast<char*>("user"), (getter)UserChangedEventArgs_get_User, nullptr, nullptr, nullptr },
        { const_cast<char*>("changed_property_kinds"), (getter)UserChangedEventArgs_get_ChangedPropertyKinds, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UserChangedEventArgs[] = 
    {
        { Py_tp_new, _new_UserChangedEventArgs },
        { Py_tp_dealloc, _dealloc_UserChangedEventArgs },
        { Py_tp_methods, _methods_UserChangedEventArgs },
        { Py_tp_getset, _getset_UserChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UserChangedEventArgs =
    {
        "_winrt_Windows_System.UserChangedEventArgs",
        sizeof(py::wrapper::Windows::System::UserChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserChangedEventArgs
    };

    // ----- UserDeviceAssociation class --------------------
    constexpr const char* const _type_name_UserDeviceAssociation = "UserDeviceAssociation";

    static PyObject* _new_UserDeviceAssociation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UserDeviceAssociation);
        return nullptr;
    }

    static PyObject* UserDeviceAssociation_FindUserFromDeviceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::System::UserDeviceAssociation::FindUserFromDeviceId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserDeviceAssociation_add_UserDeviceAssociationChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::System::UserDeviceAssociationChangedEventArgs>>(arg);

            return py::convert(winrt::Windows::System::UserDeviceAssociation::UserDeviceAssociationChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDeviceAssociation_remove_UserDeviceAssociationChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::System::UserDeviceAssociation::UserDeviceAssociationChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserDeviceAssociation[] = {
        { "find_user_from_device_id", (PyCFunction)UserDeviceAssociation_FindUserFromDeviceId, METH_VARARGS | METH_STATIC, nullptr },
        { "add_user_device_association_changed", (PyCFunction)UserDeviceAssociation_add_UserDeviceAssociationChanged, METH_O | METH_STATIC, nullptr },
        { "remove_user_device_association_changed", (PyCFunction)UserDeviceAssociation_remove_UserDeviceAssociationChanged, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UserDeviceAssociation[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_UserDeviceAssociation[] = 
    {
        { Py_tp_new, _new_UserDeviceAssociation },
        { Py_tp_methods, _methods_UserDeviceAssociation },
        { Py_tp_getset, _getset_UserDeviceAssociation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UserDeviceAssociation =
    {
        "_winrt_Windows_System.UserDeviceAssociation",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserDeviceAssociation
    };

    // ----- UserDeviceAssociationChangedEventArgs class --------------------
    constexpr const char* const _type_name_UserDeviceAssociationChangedEventArgs = "UserDeviceAssociationChangedEventArgs";

    static PyObject* _new_UserDeviceAssociationChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UserDeviceAssociationChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_UserDeviceAssociationChangedEventArgs(py::wrapper::Windows::System::UserDeviceAssociationChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UserDeviceAssociationChangedEventArgs_get_DeviceId(py::wrapper::Windows::System::UserDeviceAssociationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDeviceAssociationChangedEventArgs_get_NewUser(py::wrapper::Windows::System::UserDeviceAssociationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NewUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDeviceAssociationChangedEventArgs_get_OldUser(py::wrapper::Windows::System::UserDeviceAssociationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OldUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UserDeviceAssociationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::UserDeviceAssociationChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserDeviceAssociationChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_UserDeviceAssociationChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UserDeviceAssociationChangedEventArgs[] = {
        { const_cast<char*>("device_id"), (getter)UserDeviceAssociationChangedEventArgs_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("new_user"), (getter)UserDeviceAssociationChangedEventArgs_get_NewUser, nullptr, nullptr, nullptr },
        { const_cast<char*>("old_user"), (getter)UserDeviceAssociationChangedEventArgs_get_OldUser, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UserDeviceAssociationChangedEventArgs[] = 
    {
        { Py_tp_new, _new_UserDeviceAssociationChangedEventArgs },
        { Py_tp_dealloc, _dealloc_UserDeviceAssociationChangedEventArgs },
        { Py_tp_methods, _methods_UserDeviceAssociationChangedEventArgs },
        { Py_tp_getset, _getset_UserDeviceAssociationChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UserDeviceAssociationChangedEventArgs =
    {
        "_winrt_Windows_System.UserDeviceAssociationChangedEventArgs",
        sizeof(py::wrapper::Windows::System::UserDeviceAssociationChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserDeviceAssociationChangedEventArgs
    };

    // ----- UserPicker class --------------------
    constexpr const char* const _type_name_UserPicker = "UserPicker";

    static PyObject* _new_UserPicker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::System::UserPicker instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UserPicker(py::wrapper::Windows::System::UserPicker* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UserPicker_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::System::UserPicker::IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserPicker_PickSingleUserAsync(py::wrapper::Windows::System::UserPicker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.PickSingleUserAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserPicker_get_SuggestedSelectedUser(py::wrapper::Windows::System::UserPicker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuggestedSelectedUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UserPicker_put_SuggestedSelectedUser(py::wrapper::Windows::System::UserPicker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::System::User>(arg);

            self->obj.SuggestedSelectedUser(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UserPicker_get_AllowGuestAccounts(py::wrapper::Windows::System::UserPicker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowGuestAccounts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UserPicker_put_AllowGuestAccounts(py::wrapper::Windows::System::UserPicker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowGuestAccounts(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_UserPicker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::UserPicker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserPicker[] = {
        { "is_supported", (PyCFunction)UserPicker_IsSupported, METH_VARARGS | METH_STATIC, nullptr },
        { "pick_single_user_async", (PyCFunction)UserPicker_PickSingleUserAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_UserPicker, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UserPicker[] = {
        { const_cast<char*>("suggested_selected_user"), (getter)UserPicker_get_SuggestedSelectedUser, (setter)UserPicker_put_SuggestedSelectedUser, nullptr, nullptr },
        { const_cast<char*>("allow_guest_accounts"), (getter)UserPicker_get_AllowGuestAccounts, (setter)UserPicker_put_AllowGuestAccounts, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UserPicker[] = 
    {
        { Py_tp_new, _new_UserPicker },
        { Py_tp_dealloc, _dealloc_UserPicker },
        { Py_tp_methods, _methods_UserPicker },
        { Py_tp_getset, _getset_UserPicker },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UserPicker =
    {
        "_winrt_Windows_System.UserPicker",
        sizeof(py::wrapper::Windows::System::UserPicker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserPicker
    };

    // ----- UserWatcher class --------------------
    constexpr const char* const _type_name_UserWatcher = "UserWatcher";

    static PyObject* _new_UserWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UserWatcher);
        return nullptr;
    }

    static void _dealloc_UserWatcher(py::wrapper::Windows::System::UserWatcher* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UserWatcher_Start(py::wrapper::Windows::System::UserWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserWatcher_Stop(py::wrapper::Windows::System::UserWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserWatcher_get_Status(py::wrapper::Windows::System::UserWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_add_Added(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::UserWatcher, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.Added(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_remove_Added(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Added(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_add_AuthenticationStatusChanged(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::UserWatcher, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.AuthenticationStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_remove_AuthenticationStatusChanged(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AuthenticationStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_add_AuthenticationStatusChanging(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::UserWatcher, winrt::Windows::System::UserAuthenticationStatusChangingEventArgs>>(arg);

            return py::convert(self->obj.AuthenticationStatusChanging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_remove_AuthenticationStatusChanging(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AuthenticationStatusChanging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_add_EnumerationCompleted(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::UserWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_remove_EnumerationCompleted(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_add_Removed(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::UserWatcher, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.Removed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_remove_Removed(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Removed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_add_Stopped(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::UserWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_remove_Stopped(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_add_Updated(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::System::UserWatcher, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.Updated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserWatcher_remove_Updated(py::wrapper::Windows::System::UserWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Updated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UserWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::UserWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserWatcher[] = {
        { "start", (PyCFunction)UserWatcher_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)UserWatcher_Stop, METH_VARARGS, nullptr },
        { "add_added", (PyCFunction)UserWatcher_add_Added, METH_O, nullptr },
        { "remove_added", (PyCFunction)UserWatcher_remove_Added, METH_O, nullptr },
        { "add_authentication_status_changed", (PyCFunction)UserWatcher_add_AuthenticationStatusChanged, METH_O, nullptr },
        { "remove_authentication_status_changed", (PyCFunction)UserWatcher_remove_AuthenticationStatusChanged, METH_O, nullptr },
        { "add_authentication_status_changing", (PyCFunction)UserWatcher_add_AuthenticationStatusChanging, METH_O, nullptr },
        { "remove_authentication_status_changing", (PyCFunction)UserWatcher_remove_AuthenticationStatusChanging, METH_O, nullptr },
        { "add_enumeration_completed", (PyCFunction)UserWatcher_add_EnumerationCompleted, METH_O, nullptr },
        { "remove_enumeration_completed", (PyCFunction)UserWatcher_remove_EnumerationCompleted, METH_O, nullptr },
        { "add_removed", (PyCFunction)UserWatcher_add_Removed, METH_O, nullptr },
        { "remove_removed", (PyCFunction)UserWatcher_remove_Removed, METH_O, nullptr },
        { "add_stopped", (PyCFunction)UserWatcher_add_Stopped, METH_O, nullptr },
        { "remove_stopped", (PyCFunction)UserWatcher_remove_Stopped, METH_O, nullptr },
        { "add_updated", (PyCFunction)UserWatcher_add_Updated, METH_O, nullptr },
        { "remove_updated", (PyCFunction)UserWatcher_remove_Updated, METH_O, nullptr },
        { "_from", (PyCFunction)_from_UserWatcher, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UserWatcher[] = {
        { const_cast<char*>("status"), (getter)UserWatcher_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UserWatcher[] = 
    {
        { Py_tp_new, _new_UserWatcher },
        { Py_tp_dealloc, _dealloc_UserWatcher },
        { Py_tp_methods, _methods_UserWatcher },
        { Py_tp_getset, _getset_UserWatcher },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UserWatcher =
    {
        "_winrt_Windows_System.UserWatcher",
        sizeof(py::wrapper::Windows::System::UserWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserWatcher
    };

    // ----- ILauncherViewOptions interface --------------------
    constexpr const char* const _type_name_ILauncherViewOptions = "ILauncherViewOptions";

    static PyObject* _new_ILauncherViewOptions(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ILauncherViewOptions);
        return nullptr;
    }

    static void _dealloc_ILauncherViewOptions(py::wrapper::Windows::System::ILauncherViewOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ILauncherViewOptions_get_DesiredRemainingView(py::wrapper::Windows::System::ILauncherViewOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredRemainingView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ILauncherViewOptions_put_DesiredRemainingView(py::wrapper::Windows::System::ILauncherViewOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(arg);

            self->obj.DesiredRemainingView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ILauncherViewOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::ILauncherViewOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILauncherViewOptions[] = {
        { "_from", (PyCFunction)_from_ILauncherViewOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ILauncherViewOptions[] = {
        { const_cast<char*>("desired_remaining_view"), (getter)ILauncherViewOptions_get_DesiredRemainingView, (setter)ILauncherViewOptions_put_DesiredRemainingView, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ILauncherViewOptions[] = 
    {
        { Py_tp_new, _new_ILauncherViewOptions },
        { Py_tp_dealloc, _dealloc_ILauncherViewOptions },
        { Py_tp_methods, _methods_ILauncherViewOptions },
        { Py_tp_getset, _getset_ILauncherViewOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ILauncherViewOptions =
    {
        "_winrt_Windows_System.ILauncherViewOptions",
        sizeof(py::wrapper::Windows::System::ILauncherViewOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILauncherViewOptions
    };

    // ----- Windows.System Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::System::AppActivationResult>::python_type = py::register_python_type(module, _type_name_AppActivationResult, &_type_spec_AppActivationResult, bases.get());
            py::winrt_type<winrt::Windows::System::AppDiagnosticInfo>::python_type = py::register_python_type(module, _type_name_AppDiagnosticInfo, &_type_spec_AppDiagnosticInfo, bases.get());
            py::winrt_type<winrt::Windows::System::AppDiagnosticInfoWatcher>::python_type = py::register_python_type(module, _type_name_AppDiagnosticInfoWatcher, &_type_spec_AppDiagnosticInfoWatcher, bases.get());
            py::winrt_type<winrt::Windows::System::AppDiagnosticInfoWatcherEventArgs>::python_type = py::register_python_type(module, _type_name_AppDiagnosticInfoWatcherEventArgs, &_type_spec_AppDiagnosticInfoWatcherEventArgs, bases.get());
            py::winrt_type<winrt::Windows::System::AppExecutionStateChangeResult>::python_type = py::register_python_type(module, _type_name_AppExecutionStateChangeResult, &_type_spec_AppExecutionStateChangeResult, bases.get());
            py::winrt_type<winrt::Windows::System::AppMemoryReport>::python_type = py::register_python_type(module, _type_name_AppMemoryReport, &_type_spec_AppMemoryReport, bases.get());
            py::winrt_type<winrt::Windows::System::AppMemoryUsageLimitChangingEventArgs>::python_type = py::register_python_type(module, _type_name_AppMemoryUsageLimitChangingEventArgs, &_type_spec_AppMemoryUsageLimitChangingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::System::AppResourceGroupBackgroundTaskReport>::python_type = py::register_python_type(module, _type_name_AppResourceGroupBackgroundTaskReport, &_type_spec_AppResourceGroupBackgroundTaskReport, bases.get());
            py::winrt_type<winrt::Windows::System::AppResourceGroupInfo>::python_type = py::register_python_type(module, _type_name_AppResourceGroupInfo, &_type_spec_AppResourceGroupInfo, bases.get());
            py::winrt_type<winrt::Windows::System::AppResourceGroupInfoWatcher>::python_type = py::register_python_type(module, _type_name_AppResourceGroupInfoWatcher, &_type_spec_AppResourceGroupInfoWatcher, bases.get());
            py::winrt_type<winrt::Windows::System::AppResourceGroupInfoWatcherEventArgs>::python_type = py::register_python_type(module, _type_name_AppResourceGroupInfoWatcherEventArgs, &_type_spec_AppResourceGroupInfoWatcherEventArgs, bases.get());
            py::winrt_type<winrt::Windows::System::AppResourceGroupInfoWatcherExecutionStateChangedEventArgs>::python_type = py::register_python_type(module, _type_name_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs, &_type_spec_AppResourceGroupInfoWatcherExecutionStateChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::System::AppResourceGroupMemoryReport>::python_type = py::register_python_type(module, _type_name_AppResourceGroupMemoryReport, &_type_spec_AppResourceGroupMemoryReport, bases.get());
            py::winrt_type<winrt::Windows::System::AppResourceGroupStateReport>::python_type = py::register_python_type(module, _type_name_AppResourceGroupStateReport, &_type_spec_AppResourceGroupStateReport, bases.get());
            py::winrt_type<winrt::Windows::System::AppUriHandlerHost>::python_type = py::register_python_type(module, _type_name_AppUriHandlerHost, &_type_spec_AppUriHandlerHost, bases.get());
            py::winrt_type<winrt::Windows::System::AppUriHandlerRegistration>::python_type = py::register_python_type(module, _type_name_AppUriHandlerRegistration, &_type_spec_AppUriHandlerRegistration, bases.get());
            py::winrt_type<winrt::Windows::System::AppUriHandlerRegistrationManager>::python_type = py::register_python_type(module, _type_name_AppUriHandlerRegistrationManager, &_type_spec_AppUriHandlerRegistrationManager, bases.get());
            py::winrt_type<winrt::Windows::System::DateTimeSettings>::python_type = py::register_python_type(module, _type_name_DateTimeSettings, &_type_spec_DateTimeSettings, nullptr);
            py::winrt_type<winrt::Windows::System::DispatcherQueue>::python_type = py::register_python_type(module, _type_name_DispatcherQueue, &_type_spec_DispatcherQueue, bases.get());
            py::winrt_type<winrt::Windows::System::DispatcherQueueController>::python_type = py::register_python_type(module, _type_name_DispatcherQueueController, &_type_spec_DispatcherQueueController, bases.get());
            py::winrt_type<winrt::Windows::System::DispatcherQueueShutdownStartingEventArgs>::python_type = py::register_python_type(module, _type_name_DispatcherQueueShutdownStartingEventArgs, &_type_spec_DispatcherQueueShutdownStartingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::System::DispatcherQueueTimer>::python_type = py::register_python_type(module, _type_name_DispatcherQueueTimer, &_type_spec_DispatcherQueueTimer, bases.get());
            py::winrt_type<winrt::Windows::System::FolderLauncherOptions>::python_type = py::register_python_type(module, _type_name_FolderLauncherOptions, &_type_spec_FolderLauncherOptions, bases.get());
            py::winrt_type<winrt::Windows::System::KnownUserProperties>::python_type = py::register_python_type(module, _type_name_KnownUserProperties, &_type_spec_KnownUserProperties, nullptr);
            py::winrt_type<winrt::Windows::System::LaunchUriResult>::python_type = py::register_python_type(module, _type_name_LaunchUriResult, &_type_spec_LaunchUriResult, bases.get());
            py::winrt_type<winrt::Windows::System::Launcher>::python_type = py::register_python_type(module, _type_name_Launcher, &_type_spec_Launcher, nullptr);
            py::winrt_type<winrt::Windows::System::LauncherOptions>::python_type = py::register_python_type(module, _type_name_LauncherOptions, &_type_spec_LauncherOptions, bases.get());
            py::winrt_type<winrt::Windows::System::LauncherUIOptions>::python_type = py::register_python_type(module, _type_name_LauncherUIOptions, &_type_spec_LauncherUIOptions, bases.get());
            py::winrt_type<winrt::Windows::System::MemoryManager>::python_type = py::register_python_type(module, _type_name_MemoryManager, &_type_spec_MemoryManager, nullptr);
            py::winrt_type<winrt::Windows::System::ProcessLauncher>::python_type = py::register_python_type(module, _type_name_ProcessLauncher, &_type_spec_ProcessLauncher, nullptr);
            py::winrt_type<winrt::Windows::System::ProcessLauncherOptions>::python_type = py::register_python_type(module, _type_name_ProcessLauncherOptions, &_type_spec_ProcessLauncherOptions, bases.get());
            py::winrt_type<winrt::Windows::System::ProcessLauncherResult>::python_type = py::register_python_type(module, _type_name_ProcessLauncherResult, &_type_spec_ProcessLauncherResult, bases.get());
            py::winrt_type<winrt::Windows::System::ProcessMemoryReport>::python_type = py::register_python_type(module, _type_name_ProcessMemoryReport, &_type_spec_ProcessMemoryReport, bases.get());
            py::winrt_type<winrt::Windows::System::ProtocolForResultsOperation>::python_type = py::register_python_type(module, _type_name_ProtocolForResultsOperation, &_type_spec_ProtocolForResultsOperation, bases.get());
            py::winrt_type<winrt::Windows::System::RemoteLauncher>::python_type = py::register_python_type(module, _type_name_RemoteLauncher, &_type_spec_RemoteLauncher, nullptr);
            py::winrt_type<winrt::Windows::System::RemoteLauncherOptions>::python_type = py::register_python_type(module, _type_name_RemoteLauncherOptions, &_type_spec_RemoteLauncherOptions, bases.get());
            py::winrt_type<winrt::Windows::System::ShutdownManager>::python_type = py::register_python_type(module, _type_name_ShutdownManager, &_type_spec_ShutdownManager, nullptr);
            py::winrt_type<winrt::Windows::System::TimeZoneSettings>::python_type = py::register_python_type(module, _type_name_TimeZoneSettings, &_type_spec_TimeZoneSettings, nullptr);
            py::winrt_type<winrt::Windows::System::User>::python_type = py::register_python_type(module, _type_name_User, &_type_spec_User, bases.get());
            py::winrt_type<winrt::Windows::System::UserAuthenticationStatusChangeDeferral>::python_type = py::register_python_type(module, _type_name_UserAuthenticationStatusChangeDeferral, &_type_spec_UserAuthenticationStatusChangeDeferral, bases.get());
            py::winrt_type<winrt::Windows::System::UserAuthenticationStatusChangingEventArgs>::python_type = py::register_python_type(module, _type_name_UserAuthenticationStatusChangingEventArgs, &_type_spec_UserAuthenticationStatusChangingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::System::UserChangedEventArgs>::python_type = py::register_python_type(module, _type_name_UserChangedEventArgs, &_type_spec_UserChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::System::UserDeviceAssociation>::python_type = py::register_python_type(module, _type_name_UserDeviceAssociation, &_type_spec_UserDeviceAssociation, nullptr);
            py::winrt_type<winrt::Windows::System::UserDeviceAssociationChangedEventArgs>::python_type = py::register_python_type(module, _type_name_UserDeviceAssociationChangedEventArgs, &_type_spec_UserDeviceAssociationChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::System::UserPicker>::python_type = py::register_python_type(module, _type_name_UserPicker, &_type_spec_UserPicker, bases.get());
            py::winrt_type<winrt::Windows::System::UserWatcher>::python_type = py::register_python_type(module, _type_name_UserWatcher, &_type_spec_UserWatcher, bases.get());
            py::winrt_type<winrt::Windows::System::ILauncherViewOptions>::python_type = py::register_python_type(module, _type_name_ILauncherViewOptions, &_type_spec_ILauncherViewOptions, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.System");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_System",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::System

PyMODINIT_FUNC
PyInit__winrt_Windows_System (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::System::module_def);
}
