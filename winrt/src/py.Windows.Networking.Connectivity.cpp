// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Networking.Connectivity.h"

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::AttributedNetworkUsage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::CellularApnContext>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectionCost>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectionProfile>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectionProfileFilter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectionSession>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectivityInterval>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectivityManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::DataPlanStatus>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::DataPlanUsage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::DataUsage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::IPInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::LanIdentifier>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::LanIdentifierData>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkAdapter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkItem>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkSecuritySettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkStateChangeEventDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkUsage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ProviderNetworkUsage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ProxyConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::RoutePolicy>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::WlanConnectionProfileDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::WwanConnectionProfileDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkUsageStates>::python_type;

PyObject* py::converter<winrt::Windows::Networking::Connectivity::NetworkUsageStates>::convert(winrt::Windows::Networking::Connectivity::NetworkUsageStates instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Networking::Connectivity::NetworkUsageStates>());
}
winrt::Windows::Networking::Connectivity::NetworkUsageStates py::converter<winrt::Windows::Networking::Connectivity::NetworkUsageStates>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Networking::Connectivity::NetworkUsageStates>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Networking::Connectivity::NetworkUsageStates>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Networking::Connectivity::NetworkUsageStates return_value{};

    PyObject* py_Roaming = PyDict_GetItemString(obj, "roaming");
    if (!py_Roaming) { throw winrt::hresult_invalid_argument(); }
    return_value.Roaming = converter<winrt::Windows::Networking::Connectivity::TriStates>::convert_to(py_Roaming);

    PyObject* py_Shared = PyDict_GetItemString(obj, "shared");
    if (!py_Shared) { throw winrt::hresult_invalid_argument(); }
    return_value.Shared = converter<winrt::Windows::Networking::Connectivity::TriStates>::convert_to(py_Shared);

    return return_value;
}

namespace py::cpp::Windows::Networking::Connectivity
{
    // ----- AttributedNetworkUsage class --------------------
    constexpr const char* const _type_name_AttributedNetworkUsage = "AttributedNetworkUsage";

    static PyObject* _new_AttributedNetworkUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AttributedNetworkUsage);
        return nullptr;
    }

    static void _dealloc_AttributedNetworkUsage(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AttributedNetworkUsage_get_AttributionId(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AttributionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AttributedNetworkUsage_get_AttributionName(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AttributionName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AttributedNetworkUsage_get_AttributionThumbnail(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AttributionThumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AttributedNetworkUsage_get_BytesReceived(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AttributedNetworkUsage_get_BytesSent(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesSent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AttributedNetworkUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::AttributedNetworkUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AttributedNetworkUsage[] = {
        { "_from", (PyCFunction)_from_AttributedNetworkUsage, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AttributedNetworkUsage[] = {
        { const_cast<char*>("attribution_id"), (getter)AttributedNetworkUsage_get_AttributionId, nullptr, nullptr, nullptr },
        { const_cast<char*>("attribution_name"), (getter)AttributedNetworkUsage_get_AttributionName, nullptr, nullptr, nullptr },
        { const_cast<char*>("attribution_thumbnail"), (getter)AttributedNetworkUsage_get_AttributionThumbnail, nullptr, nullptr, nullptr },
        { const_cast<char*>("bytes_received"), (getter)AttributedNetworkUsage_get_BytesReceived, nullptr, nullptr, nullptr },
        { const_cast<char*>("bytes_sent"), (getter)AttributedNetworkUsage_get_BytesSent, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AttributedNetworkUsage[] = 
    {
        { Py_tp_new, _new_AttributedNetworkUsage },
        { Py_tp_dealloc, _dealloc_AttributedNetworkUsage },
        { Py_tp_methods, _methods_AttributedNetworkUsage },
        { Py_tp_getset, _getset_AttributedNetworkUsage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AttributedNetworkUsage =
    {
        "_winrt_Windows_Networking_Connectivity.AttributedNetworkUsage",
        sizeof(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AttributedNetworkUsage
    };

    // ----- CellularApnContext class --------------------
    constexpr const char* const _type_name_CellularApnContext = "CellularApnContext";

    static PyObject* _new_CellularApnContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Connectivity::CellularApnContext instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CellularApnContext(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CellularApnContext_get_UserName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_UserName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.UserName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_ProviderId(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_ProviderId(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ProviderId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_Password(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Password());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_Password(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Password(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_IsCompressionEnabled(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCompressionEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_IsCompressionEnabled(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCompressionEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_AuthenticationType(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AuthenticationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_AuthenticationType(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::CellularApnAuthenticationType>(arg);

            self->obj.AuthenticationType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_AccessPointName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccessPointName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_AccessPointName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AccessPointName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_ProfileName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_ProfileName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ProfileName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_CellularApnContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::CellularApnContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CellularApnContext[] = {
        { "_from", (PyCFunction)_from_CellularApnContext, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CellularApnContext[] = {
        { const_cast<char*>("user_name"), (getter)CellularApnContext_get_UserName, (setter)CellularApnContext_put_UserName, nullptr, nullptr },
        { const_cast<char*>("provider_id"), (getter)CellularApnContext_get_ProviderId, (setter)CellularApnContext_put_ProviderId, nullptr, nullptr },
        { const_cast<char*>("password"), (getter)CellularApnContext_get_Password, (setter)CellularApnContext_put_Password, nullptr, nullptr },
        { const_cast<char*>("is_compression_enabled"), (getter)CellularApnContext_get_IsCompressionEnabled, (setter)CellularApnContext_put_IsCompressionEnabled, nullptr, nullptr },
        { const_cast<char*>("authentication_type"), (getter)CellularApnContext_get_AuthenticationType, (setter)CellularApnContext_put_AuthenticationType, nullptr, nullptr },
        { const_cast<char*>("access_point_name"), (getter)CellularApnContext_get_AccessPointName, (setter)CellularApnContext_put_AccessPointName, nullptr, nullptr },
        { const_cast<char*>("profile_name"), (getter)CellularApnContext_get_ProfileName, (setter)CellularApnContext_put_ProfileName, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CellularApnContext[] = 
    {
        { Py_tp_new, _new_CellularApnContext },
        { Py_tp_dealloc, _dealloc_CellularApnContext },
        { Py_tp_methods, _methods_CellularApnContext },
        { Py_tp_getset, _getset_CellularApnContext },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CellularApnContext =
    {
        "_winrt_Windows_Networking_Connectivity.CellularApnContext",
        sizeof(py::wrapper::Windows::Networking::Connectivity::CellularApnContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CellularApnContext
    };

    // ----- ConnectionCost class --------------------
    constexpr const char* const _type_name_ConnectionCost = "ConnectionCost";

    static PyObject* _new_ConnectionCost(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConnectionCost);
        return nullptr;
    }

    static void _dealloc_ConnectionCost(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ConnectionCost_get_ApproachingDataLimit(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ApproachingDataLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionCost_get_NetworkCostType(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkCostType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionCost_get_OverDataLimit(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OverDataLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionCost_get_Roaming(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Roaming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionCost_get_BackgroundDataUsageRestricted(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BackgroundDataUsageRestricted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConnectionCost(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ConnectionCost>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectionCost[] = {
        { "_from", (PyCFunction)_from_ConnectionCost, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ConnectionCost[] = {
        { const_cast<char*>("approaching_data_limit"), (getter)ConnectionCost_get_ApproachingDataLimit, nullptr, nullptr, nullptr },
        { const_cast<char*>("network_cost_type"), (getter)ConnectionCost_get_NetworkCostType, nullptr, nullptr, nullptr },
        { const_cast<char*>("over_data_limit"), (getter)ConnectionCost_get_OverDataLimit, nullptr, nullptr, nullptr },
        { const_cast<char*>("roaming"), (getter)ConnectionCost_get_Roaming, nullptr, nullptr, nullptr },
        { const_cast<char*>("background_data_usage_restricted"), (getter)ConnectionCost_get_BackgroundDataUsageRestricted, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ConnectionCost[] = 
    {
        { Py_tp_new, _new_ConnectionCost },
        { Py_tp_dealloc, _dealloc_ConnectionCost },
        { Py_tp_methods, _methods_ConnectionCost },
        { Py_tp_getset, _getset_ConnectionCost },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConnectionCost =
    {
        "_winrt_Windows_Networking_Connectivity.ConnectionCost",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ConnectionCost),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectionCost
    };

    // ----- ConnectionProfile class --------------------
    constexpr const char* const _type_name_ConnectionProfile = "ConnectionProfile";

    static PyObject* _new_ConnectionProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConnectionProfile);
        return nullptr;
    }

    static void _dealloc_ConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ConnectionProfile_GetAttributedNetworkUsageAsync(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkUsageStates>(args, 2);

                return py::convert(self->obj.GetAttributedNetworkUsageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetConnectionCost(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConnectionCost());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetConnectivityIntervalsAsync(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkUsageStates>(args, 2);

                return py::convert(self->obj.GetConnectivityIntervalsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetDataPlanStatus(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDataPlanStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetDomainConnectivityLevel(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDomainConnectivityLevel());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetLocalUsage(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                return py::convert(self->obj.GetLocalUsage(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::RoamingStates>(args, 2);

                return py::convert(self->obj.GetLocalUsage(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetNetworkConnectivityLevel(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetNetworkConnectivityLevel());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetNetworkNames(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetNetworkNames());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetNetworkUsageAsync(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::DataUsageGranularity>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkUsageStates>(args, 3);

                return py::convert(self->obj.GetNetworkUsageAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetProviderNetworkUsageAsync(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkUsageStates>(args, 2);

                return py::convert(self->obj.GetProviderNetworkUsageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetSignalBars(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSignalBars());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_TryDeleteAsync(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryDeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_NetworkAdapter(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAdapter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_NetworkSecuritySettings(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkSecuritySettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_ProfileName(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_IsWlanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWlanConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_IsWwanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWwanConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_ServiceProviderGuid(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceProviderGuid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_WlanConnectionProfileDetails(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WlanConnectionProfileDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_WwanConnectionProfileDetails(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WwanConnectionProfileDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_CanDelete(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanDelete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConnectionProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ConnectionProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectionProfile[] = {
        { "get_attributed_network_usage_async", (PyCFunction)ConnectionProfile_GetAttributedNetworkUsageAsync, METH_VARARGS, nullptr },
        { "get_connection_cost", (PyCFunction)ConnectionProfile_GetConnectionCost, METH_VARARGS, nullptr },
        { "get_connectivity_intervals_async", (PyCFunction)ConnectionProfile_GetConnectivityIntervalsAsync, METH_VARARGS, nullptr },
        { "get_data_plan_status", (PyCFunction)ConnectionProfile_GetDataPlanStatus, METH_VARARGS, nullptr },
        { "get_domain_connectivity_level", (PyCFunction)ConnectionProfile_GetDomainConnectivityLevel, METH_VARARGS, nullptr },
        { "get_local_usage", (PyCFunction)ConnectionProfile_GetLocalUsage, METH_VARARGS, nullptr },
        { "get_network_connectivity_level", (PyCFunction)ConnectionProfile_GetNetworkConnectivityLevel, METH_VARARGS, nullptr },
        { "get_network_names", (PyCFunction)ConnectionProfile_GetNetworkNames, METH_VARARGS, nullptr },
        { "get_network_usage_async", (PyCFunction)ConnectionProfile_GetNetworkUsageAsync, METH_VARARGS, nullptr },
        { "get_provider_network_usage_async", (PyCFunction)ConnectionProfile_GetProviderNetworkUsageAsync, METH_VARARGS, nullptr },
        { "get_signal_bars", (PyCFunction)ConnectionProfile_GetSignalBars, METH_VARARGS, nullptr },
        { "try_delete_async", (PyCFunction)ConnectionProfile_TryDeleteAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ConnectionProfile, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ConnectionProfile[] = {
        { const_cast<char*>("network_adapter"), (getter)ConnectionProfile_get_NetworkAdapter, nullptr, nullptr, nullptr },
        { const_cast<char*>("network_security_settings"), (getter)ConnectionProfile_get_NetworkSecuritySettings, nullptr, nullptr, nullptr },
        { const_cast<char*>("profile_name"), (getter)ConnectionProfile_get_ProfileName, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_wlan_connection_profile"), (getter)ConnectionProfile_get_IsWlanConnectionProfile, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_wwan_connection_profile"), (getter)ConnectionProfile_get_IsWwanConnectionProfile, nullptr, nullptr, nullptr },
        { const_cast<char*>("service_provider_guid"), (getter)ConnectionProfile_get_ServiceProviderGuid, nullptr, nullptr, nullptr },
        { const_cast<char*>("wlan_connection_profile_details"), (getter)ConnectionProfile_get_WlanConnectionProfileDetails, nullptr, nullptr, nullptr },
        { const_cast<char*>("wwan_connection_profile_details"), (getter)ConnectionProfile_get_WwanConnectionProfileDetails, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_delete"), (getter)ConnectionProfile_get_CanDelete, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ConnectionProfile[] = 
    {
        { Py_tp_new, _new_ConnectionProfile },
        { Py_tp_dealloc, _dealloc_ConnectionProfile },
        { Py_tp_methods, _methods_ConnectionProfile },
        { Py_tp_getset, _getset_ConnectionProfile },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConnectionProfile =
    {
        "_winrt_Windows_Networking_Connectivity.ConnectionProfile",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectionProfile
    };

    // ----- ConnectionProfileFilter class --------------------
    constexpr const char* const _type_name_ConnectionProfileFilter = "ConnectionProfileFilter";

    static PyObject* _new_ConnectionProfileFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Connectivity::ConnectionProfileFilter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ConnectionProfileFilter(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ConnectionProfileFilter_get_ServiceProviderGuid(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceProviderGuid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_ServiceProviderGuid(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::guid>>(arg);

            self->obj.ServiceProviderGuid(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_NetworkCostType(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkCostType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_NetworkCostType(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkCostType>(arg);

            self->obj.NetworkCostType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsWwanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWwanConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsWwanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsWwanConnectionProfile(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsWlanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWlanConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsWlanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsWlanConnectionProfile(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsConnected(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsConnected(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsConnected(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsRoaming(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRoaming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsRoaming(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.IsRoaming(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsOverDataLimit(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOverDataLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsOverDataLimit(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.IsOverDataLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsBackgroundDataUsageRestricted(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBackgroundDataUsageRestricted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsBackgroundDataUsageRestricted(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.IsBackgroundDataUsageRestricted(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_RawData(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfileFilter_get_PurposeGuid(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PurposeGuid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_PurposeGuid(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::guid>>(arg);

            self->obj.PurposeGuid(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ConnectionProfileFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ConnectionProfileFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectionProfileFilter[] = {
        { "_from", (PyCFunction)_from_ConnectionProfileFilter, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ConnectionProfileFilter[] = {
        { const_cast<char*>("service_provider_guid"), (getter)ConnectionProfileFilter_get_ServiceProviderGuid, (setter)ConnectionProfileFilter_put_ServiceProviderGuid, nullptr, nullptr },
        { const_cast<char*>("network_cost_type"), (getter)ConnectionProfileFilter_get_NetworkCostType, (setter)ConnectionProfileFilter_put_NetworkCostType, nullptr, nullptr },
        { const_cast<char*>("is_wwan_connection_profile"), (getter)ConnectionProfileFilter_get_IsWwanConnectionProfile, (setter)ConnectionProfileFilter_put_IsWwanConnectionProfile, nullptr, nullptr },
        { const_cast<char*>("is_wlan_connection_profile"), (getter)ConnectionProfileFilter_get_IsWlanConnectionProfile, (setter)ConnectionProfileFilter_put_IsWlanConnectionProfile, nullptr, nullptr },
        { const_cast<char*>("is_connected"), (getter)ConnectionProfileFilter_get_IsConnected, (setter)ConnectionProfileFilter_put_IsConnected, nullptr, nullptr },
        { const_cast<char*>("is_roaming"), (getter)ConnectionProfileFilter_get_IsRoaming, (setter)ConnectionProfileFilter_put_IsRoaming, nullptr, nullptr },
        { const_cast<char*>("is_over_data_limit"), (getter)ConnectionProfileFilter_get_IsOverDataLimit, (setter)ConnectionProfileFilter_put_IsOverDataLimit, nullptr, nullptr },
        { const_cast<char*>("is_background_data_usage_restricted"), (getter)ConnectionProfileFilter_get_IsBackgroundDataUsageRestricted, (setter)ConnectionProfileFilter_put_IsBackgroundDataUsageRestricted, nullptr, nullptr },
        { const_cast<char*>("raw_data"), (getter)ConnectionProfileFilter_get_RawData, nullptr, nullptr, nullptr },
        { const_cast<char*>("purpose_guid"), (getter)ConnectionProfileFilter_get_PurposeGuid, (setter)ConnectionProfileFilter_put_PurposeGuid, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ConnectionProfileFilter[] = 
    {
        { Py_tp_new, _new_ConnectionProfileFilter },
        { Py_tp_dealloc, _dealloc_ConnectionProfileFilter },
        { Py_tp_methods, _methods_ConnectionProfileFilter },
        { Py_tp_getset, _getset_ConnectionProfileFilter },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConnectionProfileFilter =
    {
        "_winrt_Windows_Networking_Connectivity.ConnectionProfileFilter",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectionProfileFilter
    };

    // ----- ConnectionSession class --------------------
    constexpr const char* const _type_name_ConnectionSession = "ConnectionSession";

    static PyObject* _new_ConnectionSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConnectionSession);
        return nullptr;
    }

    static void _dealloc_ConnectionSession(py::wrapper::Windows::Networking::Connectivity::ConnectionSession* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ConnectionSession_Close(py::wrapper::Windows::Networking::Connectivity::ConnectionSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionSession_get_ConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConnectionSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ConnectionSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ConnectionSession(py::wrapper::Windows::Networking::Connectivity::ConnectionSession* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_ConnectionSession(py::wrapper::Windows::Networking::Connectivity::ConnectionSession* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectionSession[] = {
        { "close", (PyCFunction)ConnectionSession_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ConnectionSession, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_ConnectionSession, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_ConnectionSession, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ConnectionSession[] = {
        { const_cast<char*>("connection_profile"), (getter)ConnectionSession_get_ConnectionProfile, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ConnectionSession[] = 
    {
        { Py_tp_new, _new_ConnectionSession },
        { Py_tp_dealloc, _dealloc_ConnectionSession },
        { Py_tp_methods, _methods_ConnectionSession },
        { Py_tp_getset, _getset_ConnectionSession },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConnectionSession =
    {
        "_winrt_Windows_Networking_Connectivity.ConnectionSession",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ConnectionSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectionSession
    };

    // ----- ConnectivityInterval class --------------------
    constexpr const char* const _type_name_ConnectivityInterval = "ConnectivityInterval";

    static PyObject* _new_ConnectivityInterval(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConnectivityInterval);
        return nullptr;
    }

    static void _dealloc_ConnectivityInterval(py::wrapper::Windows::Networking::Connectivity::ConnectivityInterval* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ConnectivityInterval_get_ConnectionDuration(py::wrapper::Windows::Networking::Connectivity::ConnectivityInterval* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectivityInterval_get_StartTime(py::wrapper::Windows::Networking::Connectivity::ConnectivityInterval* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConnectivityInterval(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ConnectivityInterval>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectivityInterval[] = {
        { "_from", (PyCFunction)_from_ConnectivityInterval, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ConnectivityInterval[] = {
        { const_cast<char*>("connection_duration"), (getter)ConnectivityInterval_get_ConnectionDuration, nullptr, nullptr, nullptr },
        { const_cast<char*>("start_time"), (getter)ConnectivityInterval_get_StartTime, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ConnectivityInterval[] = 
    {
        { Py_tp_new, _new_ConnectivityInterval },
        { Py_tp_dealloc, _dealloc_ConnectivityInterval },
        { Py_tp_methods, _methods_ConnectivityInterval },
        { Py_tp_getset, _getset_ConnectivityInterval },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConnectivityInterval =
    {
        "_winrt_Windows_Networking_Connectivity.ConnectivityInterval",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ConnectivityInterval),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectivityInterval
    };

    // ----- ConnectivityManager class --------------------
    constexpr const char* const _type_name_ConnectivityManager = "ConnectivityManager";

    static PyObject* _new_ConnectivityManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConnectivityManager);
        return nullptr;
    }

    static PyObject* ConnectivityManager_AcquireConnectionAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::CellularApnContext>(args, 0);

                return py::convert(winrt::Windows::Networking::Connectivity::ConnectivityManager::AcquireConnectionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectivityManager_AddHttpRoutePolicy(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::RoutePolicy>(args, 0);

                winrt::Windows::Networking::Connectivity::ConnectivityManager::AddHttpRoutePolicy(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectivityManager_RemoveHttpRoutePolicy(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::RoutePolicy>(args, 0);

                winrt::Windows::Networking::Connectivity::ConnectivityManager::RemoveHttpRoutePolicy(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectivityManager[] = {
        { "acquire_connection_async", (PyCFunction)ConnectivityManager_AcquireConnectionAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "add_http_route_policy", (PyCFunction)ConnectivityManager_AddHttpRoutePolicy, METH_VARARGS | METH_STATIC, nullptr },
        { "remove_http_route_policy", (PyCFunction)ConnectivityManager_RemoveHttpRoutePolicy, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ConnectivityManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ConnectivityManager[] = 
    {
        { Py_tp_new, _new_ConnectivityManager },
        { Py_tp_methods, _methods_ConnectivityManager },
        { Py_tp_getset, _getset_ConnectivityManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConnectivityManager =
    {
        "_winrt_Windows_Networking_Connectivity.ConnectivityManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectivityManager
    };

    // ----- DataPlanStatus class --------------------
    constexpr const char* const _type_name_DataPlanStatus = "DataPlanStatus";

    static PyObject* _new_DataPlanStatus(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DataPlanStatus);
        return nullptr;
    }

    static void _dealloc_DataPlanStatus(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataPlanStatus_get_DataLimitInMegabytes(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DataLimitInMegabytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanStatus_get_DataPlanUsage(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DataPlanUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanStatus_get_InboundBitsPerSecond(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundBitsPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanStatus_get_MaxTransferSizeInMegabytes(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxTransferSizeInMegabytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanStatus_get_NextBillingCycle(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NextBillingCycle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanStatus_get_OutboundBitsPerSecond(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBitsPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DataPlanStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::DataPlanStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataPlanStatus[] = {
        { "_from", (PyCFunction)_from_DataPlanStatus, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DataPlanStatus[] = {
        { const_cast<char*>("data_limit_in_megabytes"), (getter)DataPlanStatus_get_DataLimitInMegabytes, nullptr, nullptr, nullptr },
        { const_cast<char*>("data_plan_usage"), (getter)DataPlanStatus_get_DataPlanUsage, nullptr, nullptr, nullptr },
        { const_cast<char*>("inbound_bits_per_second"), (getter)DataPlanStatus_get_InboundBitsPerSecond, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_transfer_size_in_megabytes"), (getter)DataPlanStatus_get_MaxTransferSizeInMegabytes, nullptr, nullptr, nullptr },
        { const_cast<char*>("next_billing_cycle"), (getter)DataPlanStatus_get_NextBillingCycle, nullptr, nullptr, nullptr },
        { const_cast<char*>("outbound_bits_per_second"), (getter)DataPlanStatus_get_OutboundBitsPerSecond, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DataPlanStatus[] = 
    {
        { Py_tp_new, _new_DataPlanStatus },
        { Py_tp_dealloc, _dealloc_DataPlanStatus },
        { Py_tp_methods, _methods_DataPlanStatus },
        { Py_tp_getset, _getset_DataPlanStatus },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DataPlanStatus =
    {
        "_winrt_Windows_Networking_Connectivity.DataPlanStatus",
        sizeof(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataPlanStatus
    };

    // ----- DataPlanUsage class --------------------
    constexpr const char* const _type_name_DataPlanUsage = "DataPlanUsage";

    static PyObject* _new_DataPlanUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DataPlanUsage);
        return nullptr;
    }

    static void _dealloc_DataPlanUsage(py::wrapper::Windows::Networking::Connectivity::DataPlanUsage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataPlanUsage_get_LastSyncTime(py::wrapper::Windows::Networking::Connectivity::DataPlanUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastSyncTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanUsage_get_MegabytesUsed(py::wrapper::Windows::Networking::Connectivity::DataPlanUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MegabytesUsed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DataPlanUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::DataPlanUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataPlanUsage[] = {
        { "_from", (PyCFunction)_from_DataPlanUsage, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DataPlanUsage[] = {
        { const_cast<char*>("last_sync_time"), (getter)DataPlanUsage_get_LastSyncTime, nullptr, nullptr, nullptr },
        { const_cast<char*>("megabytes_used"), (getter)DataPlanUsage_get_MegabytesUsed, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DataPlanUsage[] = 
    {
        { Py_tp_new, _new_DataPlanUsage },
        { Py_tp_dealloc, _dealloc_DataPlanUsage },
        { Py_tp_methods, _methods_DataPlanUsage },
        { Py_tp_getset, _getset_DataPlanUsage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DataPlanUsage =
    {
        "_winrt_Windows_Networking_Connectivity.DataPlanUsage",
        sizeof(py::wrapper::Windows::Networking::Connectivity::DataPlanUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataPlanUsage
    };

    // ----- DataUsage class --------------------
    constexpr const char* const _type_name_DataUsage = "DataUsage";

    static PyObject* _new_DataUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DataUsage);
        return nullptr;
    }

    static void _dealloc_DataUsage(py::wrapper::Windows::Networking::Connectivity::DataUsage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataUsage_get_BytesReceived(py::wrapper::Windows::Networking::Connectivity::DataUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataUsage_get_BytesSent(py::wrapper::Windows::Networking::Connectivity::DataUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesSent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DataUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::DataUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataUsage[] = {
        { "_from", (PyCFunction)_from_DataUsage, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DataUsage[] = {
        { const_cast<char*>("bytes_received"), (getter)DataUsage_get_BytesReceived, nullptr, nullptr, nullptr },
        { const_cast<char*>("bytes_sent"), (getter)DataUsage_get_BytesSent, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DataUsage[] = 
    {
        { Py_tp_new, _new_DataUsage },
        { Py_tp_dealloc, _dealloc_DataUsage },
        { Py_tp_methods, _methods_DataUsage },
        { Py_tp_getset, _getset_DataUsage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DataUsage =
    {
        "_winrt_Windows_Networking_Connectivity.DataUsage",
        sizeof(py::wrapper::Windows::Networking::Connectivity::DataUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataUsage
    };

    // ----- IPInformation class --------------------
    constexpr const char* const _type_name_IPInformation = "IPInformation";

    static PyObject* _new_IPInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_IPInformation);
        return nullptr;
    }

    static void _dealloc_IPInformation(py::wrapper::Windows::Networking::Connectivity::IPInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IPInformation_get_NetworkAdapter(py::wrapper::Windows::Networking::Connectivity::IPInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAdapter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPInformation_get_PrefixLength(py::wrapper::Windows::Networking::Connectivity::IPInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrefixLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IPInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::IPInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPInformation[] = {
        { "_from", (PyCFunction)_from_IPInformation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IPInformation[] = {
        { const_cast<char*>("network_adapter"), (getter)IPInformation_get_NetworkAdapter, nullptr, nullptr, nullptr },
        { const_cast<char*>("prefix_length"), (getter)IPInformation_get_PrefixLength, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IPInformation[] = 
    {
        { Py_tp_new, _new_IPInformation },
        { Py_tp_dealloc, _dealloc_IPInformation },
        { Py_tp_methods, _methods_IPInformation },
        { Py_tp_getset, _getset_IPInformation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IPInformation =
    {
        "_winrt_Windows_Networking_Connectivity.IPInformation",
        sizeof(py::wrapper::Windows::Networking::Connectivity::IPInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPInformation
    };

    // ----- LanIdentifier class --------------------
    constexpr const char* const _type_name_LanIdentifier = "LanIdentifier";

    static PyObject* _new_LanIdentifier(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LanIdentifier);
        return nullptr;
    }

    static void _dealloc_LanIdentifier(py::wrapper::Windows::Networking::Connectivity::LanIdentifier* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LanIdentifier_get_InfrastructureId(py::wrapper::Windows::Networking::Connectivity::LanIdentifier* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InfrastructureId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LanIdentifier_get_NetworkAdapterId(py::wrapper::Windows::Networking::Connectivity::LanIdentifier* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAdapterId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LanIdentifier_get_PortId(py::wrapper::Windows::Networking::Connectivity::LanIdentifier* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PortId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LanIdentifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::LanIdentifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LanIdentifier[] = {
        { "_from", (PyCFunction)_from_LanIdentifier, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LanIdentifier[] = {
        { const_cast<char*>("infrastructure_id"), (getter)LanIdentifier_get_InfrastructureId, nullptr, nullptr, nullptr },
        { const_cast<char*>("network_adapter_id"), (getter)LanIdentifier_get_NetworkAdapterId, nullptr, nullptr, nullptr },
        { const_cast<char*>("port_id"), (getter)LanIdentifier_get_PortId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LanIdentifier[] = 
    {
        { Py_tp_new, _new_LanIdentifier },
        { Py_tp_dealloc, _dealloc_LanIdentifier },
        { Py_tp_methods, _methods_LanIdentifier },
        { Py_tp_getset, _getset_LanIdentifier },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LanIdentifier =
    {
        "_winrt_Windows_Networking_Connectivity.LanIdentifier",
        sizeof(py::wrapper::Windows::Networking::Connectivity::LanIdentifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LanIdentifier
    };

    // ----- LanIdentifierData class --------------------
    constexpr const char* const _type_name_LanIdentifierData = "LanIdentifierData";

    static PyObject* _new_LanIdentifierData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LanIdentifierData);
        return nullptr;
    }

    static void _dealloc_LanIdentifierData(py::wrapper::Windows::Networking::Connectivity::LanIdentifierData* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LanIdentifierData_get_Type(py::wrapper::Windows::Networking::Connectivity::LanIdentifierData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LanIdentifierData_get_Value(py::wrapper::Windows::Networking::Connectivity::LanIdentifierData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LanIdentifierData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::LanIdentifierData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LanIdentifierData[] = {
        { "_from", (PyCFunction)_from_LanIdentifierData, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LanIdentifierData[] = {
        { const_cast<char*>("type"), (getter)LanIdentifierData_get_Type, nullptr, nullptr, nullptr },
        { const_cast<char*>("value"), (getter)LanIdentifierData_get_Value, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LanIdentifierData[] = 
    {
        { Py_tp_new, _new_LanIdentifierData },
        { Py_tp_dealloc, _dealloc_LanIdentifierData },
        { Py_tp_methods, _methods_LanIdentifierData },
        { Py_tp_getset, _getset_LanIdentifierData },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LanIdentifierData =
    {
        "_winrt_Windows_Networking_Connectivity.LanIdentifierData",
        sizeof(py::wrapper::Windows::Networking::Connectivity::LanIdentifierData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LanIdentifierData
    };

    // ----- NetworkAdapter class --------------------
    constexpr const char* const _type_name_NetworkAdapter = "NetworkAdapter";

    static PyObject* _new_NetworkAdapter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_NetworkAdapter);
        return nullptr;
    }

    static void _dealloc_NetworkAdapter(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* NetworkAdapter_GetConnectedProfileAsync(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConnectedProfileAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkAdapter_get_IanaInterfaceType(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IanaInterfaceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkAdapter_get_InboundMaxBitsPerSecond(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundMaxBitsPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkAdapter_get_NetworkAdapterId(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAdapterId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkAdapter_get_NetworkItem(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkAdapter_get_OutboundMaxBitsPerSecond(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundMaxBitsPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NetworkAdapter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::NetworkAdapter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkAdapter[] = {
        { "get_connected_profile_async", (PyCFunction)NetworkAdapter_GetConnectedProfileAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_NetworkAdapter, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_NetworkAdapter[] = {
        { const_cast<char*>("iana_interface_type"), (getter)NetworkAdapter_get_IanaInterfaceType, nullptr, nullptr, nullptr },
        { const_cast<char*>("inbound_max_bits_per_second"), (getter)NetworkAdapter_get_InboundMaxBitsPerSecond, nullptr, nullptr, nullptr },
        { const_cast<char*>("network_adapter_id"), (getter)NetworkAdapter_get_NetworkAdapterId, nullptr, nullptr, nullptr },
        { const_cast<char*>("network_item"), (getter)NetworkAdapter_get_NetworkItem, nullptr, nullptr, nullptr },
        { const_cast<char*>("outbound_max_bits_per_second"), (getter)NetworkAdapter_get_OutboundMaxBitsPerSecond, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_NetworkAdapter[] = 
    {
        { Py_tp_new, _new_NetworkAdapter },
        { Py_tp_dealloc, _dealloc_NetworkAdapter },
        { Py_tp_methods, _methods_NetworkAdapter },
        { Py_tp_getset, _getset_NetworkAdapter },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NetworkAdapter =
    {
        "_winrt_Windows_Networking_Connectivity.NetworkAdapter",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkAdapter
    };

    // ----- NetworkInformation class --------------------
    constexpr const char* const _type_name_NetworkInformation = "NetworkInformation";

    static PyObject* _new_NetworkInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_NetworkInformation);
        return nullptr;
    }

    static PyObject* NetworkInformation_FindConnectionProfilesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::ConnectionProfileFilter>(args, 0);

                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::FindConnectionProfilesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetConnectionProfiles(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetConnectionProfiles());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetHostNames(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetHostNames());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetInternetConnectionProfile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetInternetConnectionProfile());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetLanIdentifiers(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetLanIdentifiers());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetProxyConfigurationAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetProxyConfigurationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetSortedEndpointPairs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::EndpointPair>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::HostNameSortOptions>(args, 1);

                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetSortedEndpointPairs(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_add_NetworkStatusChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkStatusChangedEventHandler>(arg);

            return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::NetworkStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_remove_NetworkStatusChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Networking::Connectivity::NetworkInformation::NetworkStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkInformation[] = {
        { "find_connection_profiles_async", (PyCFunction)NetworkInformation_FindConnectionProfilesAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_connection_profiles", (PyCFunction)NetworkInformation_GetConnectionProfiles, METH_VARARGS | METH_STATIC, nullptr },
        { "get_host_names", (PyCFunction)NetworkInformation_GetHostNames, METH_VARARGS | METH_STATIC, nullptr },
        { "get_internet_connection_profile", (PyCFunction)NetworkInformation_GetInternetConnectionProfile, METH_VARARGS | METH_STATIC, nullptr },
        { "get_lan_identifiers", (PyCFunction)NetworkInformation_GetLanIdentifiers, METH_VARARGS | METH_STATIC, nullptr },
        { "get_proxy_configuration_async", (PyCFunction)NetworkInformation_GetProxyConfigurationAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_sorted_endpoint_pairs", (PyCFunction)NetworkInformation_GetSortedEndpointPairs, METH_VARARGS | METH_STATIC, nullptr },
        { "add_network_status_changed", (PyCFunction)NetworkInformation_add_NetworkStatusChanged, METH_O | METH_STATIC, nullptr },
        { "remove_network_status_changed", (PyCFunction)NetworkInformation_remove_NetworkStatusChanged, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_NetworkInformation[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_NetworkInformation[] = 
    {
        { Py_tp_new, _new_NetworkInformation },
        { Py_tp_methods, _methods_NetworkInformation },
        { Py_tp_getset, _getset_NetworkInformation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NetworkInformation =
    {
        "_winrt_Windows_Networking_Connectivity.NetworkInformation",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkInformation
    };

    // ----- NetworkItem class --------------------
    constexpr const char* const _type_name_NetworkItem = "NetworkItem";

    static PyObject* _new_NetworkItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_NetworkItem);
        return nullptr;
    }

    static void _dealloc_NetworkItem(py::wrapper::Windows::Networking::Connectivity::NetworkItem* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* NetworkItem_GetNetworkTypes(py::wrapper::Windows::Networking::Connectivity::NetworkItem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetNetworkTypes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkItem_get_NetworkId(py::wrapper::Windows::Networking::Connectivity::NetworkItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NetworkItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::NetworkItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkItem[] = {
        { "get_network_types", (PyCFunction)NetworkItem_GetNetworkTypes, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_NetworkItem, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_NetworkItem[] = {
        { const_cast<char*>("network_id"), (getter)NetworkItem_get_NetworkId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_NetworkItem[] = 
    {
        { Py_tp_new, _new_NetworkItem },
        { Py_tp_dealloc, _dealloc_NetworkItem },
        { Py_tp_methods, _methods_NetworkItem },
        { Py_tp_getset, _getset_NetworkItem },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NetworkItem =
    {
        "_winrt_Windows_Networking_Connectivity.NetworkItem",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkItem
    };

    // ----- NetworkSecuritySettings class --------------------
    constexpr const char* const _type_name_NetworkSecuritySettings = "NetworkSecuritySettings";

    static PyObject* _new_NetworkSecuritySettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_NetworkSecuritySettings);
        return nullptr;
    }

    static void _dealloc_NetworkSecuritySettings(py::wrapper::Windows::Networking::Connectivity::NetworkSecuritySettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* NetworkSecuritySettings_get_NetworkAuthenticationType(py::wrapper::Windows::Networking::Connectivity::NetworkSecuritySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAuthenticationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkSecuritySettings_get_NetworkEncryptionType(py::wrapper::Windows::Networking::Connectivity::NetworkSecuritySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkEncryptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NetworkSecuritySettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::NetworkSecuritySettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkSecuritySettings[] = {
        { "_from", (PyCFunction)_from_NetworkSecuritySettings, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_NetworkSecuritySettings[] = {
        { const_cast<char*>("network_authentication_type"), (getter)NetworkSecuritySettings_get_NetworkAuthenticationType, nullptr, nullptr, nullptr },
        { const_cast<char*>("network_encryption_type"), (getter)NetworkSecuritySettings_get_NetworkEncryptionType, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_NetworkSecuritySettings[] = 
    {
        { Py_tp_new, _new_NetworkSecuritySettings },
        { Py_tp_dealloc, _dealloc_NetworkSecuritySettings },
        { Py_tp_methods, _methods_NetworkSecuritySettings },
        { Py_tp_getset, _getset_NetworkSecuritySettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NetworkSecuritySettings =
    {
        "_winrt_Windows_Networking_Connectivity.NetworkSecuritySettings",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkSecuritySettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkSecuritySettings
    };

    // ----- NetworkStateChangeEventDetails class --------------------
    constexpr const char* const _type_name_NetworkStateChangeEventDetails = "NetworkStateChangeEventDetails";

    static PyObject* _new_NetworkStateChangeEventDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_NetworkStateChangeEventDetails);
        return nullptr;
    }

    static void _dealloc_NetworkStateChangeEventDetails(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewConnectionCost(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewConnectionCost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewDomainConnectivityLevel(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewDomainConnectivityLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewHostNameList(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewHostNameList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewInternetConnectionProfile(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewInternetConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewNetworkConnectivityLevel(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewNetworkConnectivityLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewWwanRegistrationState(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewWwanRegistrationState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewTetheringClientCount(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewTetheringClientCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewTetheringOperationalState(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewTetheringOperationalState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NetworkStateChangeEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::NetworkStateChangeEventDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkStateChangeEventDetails[] = {
        { "_from", (PyCFunction)_from_NetworkStateChangeEventDetails, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_NetworkStateChangeEventDetails[] = {
        { const_cast<char*>("has_new_connection_cost"), (getter)NetworkStateChangeEventDetails_get_HasNewConnectionCost, nullptr, nullptr, nullptr },
        { const_cast<char*>("has_new_domain_connectivity_level"), (getter)NetworkStateChangeEventDetails_get_HasNewDomainConnectivityLevel, nullptr, nullptr, nullptr },
        { const_cast<char*>("has_new_host_name_list"), (getter)NetworkStateChangeEventDetails_get_HasNewHostNameList, nullptr, nullptr, nullptr },
        { const_cast<char*>("has_new_internet_connection_profile"), (getter)NetworkStateChangeEventDetails_get_HasNewInternetConnectionProfile, nullptr, nullptr, nullptr },
        { const_cast<char*>("has_new_network_connectivity_level"), (getter)NetworkStateChangeEventDetails_get_HasNewNetworkConnectivityLevel, nullptr, nullptr, nullptr },
        { const_cast<char*>("has_new_wwan_registration_state"), (getter)NetworkStateChangeEventDetails_get_HasNewWwanRegistrationState, nullptr, nullptr, nullptr },
        { const_cast<char*>("has_new_tethering_client_count"), (getter)NetworkStateChangeEventDetails_get_HasNewTetheringClientCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("has_new_tethering_operational_state"), (getter)NetworkStateChangeEventDetails_get_HasNewTetheringOperationalState, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_NetworkStateChangeEventDetails[] = 
    {
        { Py_tp_new, _new_NetworkStateChangeEventDetails },
        { Py_tp_dealloc, _dealloc_NetworkStateChangeEventDetails },
        { Py_tp_methods, _methods_NetworkStateChangeEventDetails },
        { Py_tp_getset, _getset_NetworkStateChangeEventDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NetworkStateChangeEventDetails =
    {
        "_winrt_Windows_Networking_Connectivity.NetworkStateChangeEventDetails",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkStateChangeEventDetails
    };

    // ----- NetworkUsage class --------------------
    constexpr const char* const _type_name_NetworkUsage = "NetworkUsage";

    static PyObject* _new_NetworkUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_NetworkUsage);
        return nullptr;
    }

    static void _dealloc_NetworkUsage(py::wrapper::Windows::Networking::Connectivity::NetworkUsage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* NetworkUsage_get_BytesReceived(py::wrapper::Windows::Networking::Connectivity::NetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkUsage_get_BytesSent(py::wrapper::Windows::Networking::Connectivity::NetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesSent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkUsage_get_ConnectionDuration(py::wrapper::Windows::Networking::Connectivity::NetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NetworkUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::NetworkUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkUsage[] = {
        { "_from", (PyCFunction)_from_NetworkUsage, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_NetworkUsage[] = {
        { const_cast<char*>("bytes_received"), (getter)NetworkUsage_get_BytesReceived, nullptr, nullptr, nullptr },
        { const_cast<char*>("bytes_sent"), (getter)NetworkUsage_get_BytesSent, nullptr, nullptr, nullptr },
        { const_cast<char*>("connection_duration"), (getter)NetworkUsage_get_ConnectionDuration, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_NetworkUsage[] = 
    {
        { Py_tp_new, _new_NetworkUsage },
        { Py_tp_dealloc, _dealloc_NetworkUsage },
        { Py_tp_methods, _methods_NetworkUsage },
        { Py_tp_getset, _getset_NetworkUsage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NetworkUsage =
    {
        "_winrt_Windows_Networking_Connectivity.NetworkUsage",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkUsage
    };

    // ----- ProviderNetworkUsage class --------------------
    constexpr const char* const _type_name_ProviderNetworkUsage = "ProviderNetworkUsage";

    static PyObject* _new_ProviderNetworkUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProviderNetworkUsage);
        return nullptr;
    }

    static void _dealloc_ProviderNetworkUsage(py::wrapper::Windows::Networking::Connectivity::ProviderNetworkUsage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProviderNetworkUsage_get_BytesReceived(py::wrapper::Windows::Networking::Connectivity::ProviderNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProviderNetworkUsage_get_BytesSent(py::wrapper::Windows::Networking::Connectivity::ProviderNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesSent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProviderNetworkUsage_get_ProviderId(py::wrapper::Windows::Networking::Connectivity::ProviderNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProviderNetworkUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ProviderNetworkUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProviderNetworkUsage[] = {
        { "_from", (PyCFunction)_from_ProviderNetworkUsage, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ProviderNetworkUsage[] = {
        { const_cast<char*>("bytes_received"), (getter)ProviderNetworkUsage_get_BytesReceived, nullptr, nullptr, nullptr },
        { const_cast<char*>("bytes_sent"), (getter)ProviderNetworkUsage_get_BytesSent, nullptr, nullptr, nullptr },
        { const_cast<char*>("provider_id"), (getter)ProviderNetworkUsage_get_ProviderId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ProviderNetworkUsage[] = 
    {
        { Py_tp_new, _new_ProviderNetworkUsage },
        { Py_tp_dealloc, _dealloc_ProviderNetworkUsage },
        { Py_tp_methods, _methods_ProviderNetworkUsage },
        { Py_tp_getset, _getset_ProviderNetworkUsage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProviderNetworkUsage =
    {
        "_winrt_Windows_Networking_Connectivity.ProviderNetworkUsage",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ProviderNetworkUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProviderNetworkUsage
    };

    // ----- ProxyConfiguration class --------------------
    constexpr const char* const _type_name_ProxyConfiguration = "ProxyConfiguration";

    static PyObject* _new_ProxyConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProxyConfiguration);
        return nullptr;
    }

    static void _dealloc_ProxyConfiguration(py::wrapper::Windows::Networking::Connectivity::ProxyConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProxyConfiguration_get_CanConnectDirectly(py::wrapper::Windows::Networking::Connectivity::ProxyConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanConnectDirectly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProxyConfiguration_get_ProxyUris(py::wrapper::Windows::Networking::Connectivity::ProxyConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProxyUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProxyConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ProxyConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProxyConfiguration[] = {
        { "_from", (PyCFunction)_from_ProxyConfiguration, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ProxyConfiguration[] = {
        { const_cast<char*>("can_connect_directly"), (getter)ProxyConfiguration_get_CanConnectDirectly, nullptr, nullptr, nullptr },
        { const_cast<char*>("proxy_uris"), (getter)ProxyConfiguration_get_ProxyUris, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ProxyConfiguration[] = 
    {
        { Py_tp_new, _new_ProxyConfiguration },
        { Py_tp_dealloc, _dealloc_ProxyConfiguration },
        { Py_tp_methods, _methods_ProxyConfiguration },
        { Py_tp_getset, _getset_ProxyConfiguration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProxyConfiguration =
    {
        "_winrt_Windows_Networking_Connectivity.ProxyConfiguration",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ProxyConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProxyConfiguration
    };

    // ----- RoutePolicy class --------------------
    constexpr const char* const _type_name_RoutePolicy = "RoutePolicy";

    static PyObject* _new_RoutePolicy(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::ConnectionProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::HostName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::DomainNameType>(args, 2);

                winrt::Windows::Networking::Connectivity::RoutePolicy instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RoutePolicy(py::wrapper::Windows::Networking::Connectivity::RoutePolicy* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RoutePolicy_get_ConnectionProfile(py::wrapper::Windows::Networking::Connectivity::RoutePolicy* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RoutePolicy_get_HostName(py::wrapper::Windows::Networking::Connectivity::RoutePolicy* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HostName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RoutePolicy_get_HostNameType(py::wrapper::Windows::Networking::Connectivity::RoutePolicy* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HostNameType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RoutePolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::RoutePolicy>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RoutePolicy[] = {
        { "_from", (PyCFunction)_from_RoutePolicy, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RoutePolicy[] = {
        { const_cast<char*>("connection_profile"), (getter)RoutePolicy_get_ConnectionProfile, nullptr, nullptr, nullptr },
        { const_cast<char*>("host_name"), (getter)RoutePolicy_get_HostName, nullptr, nullptr, nullptr },
        { const_cast<char*>("host_name_type"), (getter)RoutePolicy_get_HostNameType, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RoutePolicy[] = 
    {
        { Py_tp_new, _new_RoutePolicy },
        { Py_tp_dealloc, _dealloc_RoutePolicy },
        { Py_tp_methods, _methods_RoutePolicy },
        { Py_tp_getset, _getset_RoutePolicy },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RoutePolicy =
    {
        "_winrt_Windows_Networking_Connectivity.RoutePolicy",
        sizeof(py::wrapper::Windows::Networking::Connectivity::RoutePolicy),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RoutePolicy
    };

    // ----- WlanConnectionProfileDetails class --------------------
    constexpr const char* const _type_name_WlanConnectionProfileDetails = "WlanConnectionProfileDetails";

    static PyObject* _new_WlanConnectionProfileDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_WlanConnectionProfileDetails);
        return nullptr;
    }

    static void _dealloc_WlanConnectionProfileDetails(py::wrapper::Windows::Networking::Connectivity::WlanConnectionProfileDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* WlanConnectionProfileDetails_GetConnectedSsid(py::wrapper::Windows::Networking::Connectivity::WlanConnectionProfileDetails* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConnectedSsid());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_WlanConnectionProfileDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::WlanConnectionProfileDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WlanConnectionProfileDetails[] = {
        { "get_connected_ssid", (PyCFunction)WlanConnectionProfileDetails_GetConnectedSsid, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_WlanConnectionProfileDetails, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_WlanConnectionProfileDetails[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_WlanConnectionProfileDetails[] = 
    {
        { Py_tp_new, _new_WlanConnectionProfileDetails },
        { Py_tp_dealloc, _dealloc_WlanConnectionProfileDetails },
        { Py_tp_methods, _methods_WlanConnectionProfileDetails },
        { Py_tp_getset, _getset_WlanConnectionProfileDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_WlanConnectionProfileDetails =
    {
        "_winrt_Windows_Networking_Connectivity.WlanConnectionProfileDetails",
        sizeof(py::wrapper::Windows::Networking::Connectivity::WlanConnectionProfileDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WlanConnectionProfileDetails
    };

    // ----- WwanConnectionProfileDetails class --------------------
    constexpr const char* const _type_name_WwanConnectionProfileDetails = "WwanConnectionProfileDetails";

    static PyObject* _new_WwanConnectionProfileDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_WwanConnectionProfileDetails);
        return nullptr;
    }

    static void _dealloc_WwanConnectionProfileDetails(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* WwanConnectionProfileDetails_GetCurrentDataClass(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentDataClass());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwanConnectionProfileDetails_GetNetworkRegistrationState(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetNetworkRegistrationState());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwanConnectionProfileDetails_get_AccessPointName(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccessPointName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WwanConnectionProfileDetails_get_HomeProviderId(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HomeProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WwanConnectionProfileDetails_get_IPKind(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IPKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WwanConnectionProfileDetails_get_PurposeGuids(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PurposeGuids());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_WwanConnectionProfileDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::WwanConnectionProfileDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WwanConnectionProfileDetails[] = {
        { "get_current_data_class", (PyCFunction)WwanConnectionProfileDetails_GetCurrentDataClass, METH_VARARGS, nullptr },
        { "get_network_registration_state", (PyCFunction)WwanConnectionProfileDetails_GetNetworkRegistrationState, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_WwanConnectionProfileDetails, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_WwanConnectionProfileDetails[] = {
        { const_cast<char*>("access_point_name"), (getter)WwanConnectionProfileDetails_get_AccessPointName, nullptr, nullptr, nullptr },
        { const_cast<char*>("home_provider_id"), (getter)WwanConnectionProfileDetails_get_HomeProviderId, nullptr, nullptr, nullptr },
        { const_cast<char*>("i_p_kind"), (getter)WwanConnectionProfileDetails_get_IPKind, nullptr, nullptr, nullptr },
        { const_cast<char*>("purpose_guids"), (getter)WwanConnectionProfileDetails_get_PurposeGuids, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_WwanConnectionProfileDetails[] = 
    {
        { Py_tp_new, _new_WwanConnectionProfileDetails },
        { Py_tp_dealloc, _dealloc_WwanConnectionProfileDetails },
        { Py_tp_methods, _methods_WwanConnectionProfileDetails },
        { Py_tp_getset, _getset_WwanConnectionProfileDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_WwanConnectionProfileDetails =
    {
        "_winrt_Windows_Networking_Connectivity.WwanConnectionProfileDetails",
        sizeof(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WwanConnectionProfileDetails
    };

    // ----- NetworkUsageStates struct --------------------
    constexpr const char* const _type_name_NetworkUsageStates = "NetworkUsageStates";

    PyObject* _new_NetworkUsageStates(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Networking::Connectivity::NetworkUsageStates return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkUsageStates>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        int32_t _Roaming{};
        int32_t _Shared{};

        static const char* kwlist[] = {"roaming", "shared", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ii", const_cast<char**>(kwlist), &_Roaming, &_Shared))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Networking::Connectivity::NetworkUsageStates return_value{ static_cast<winrt::Windows::Networking::Connectivity::TriStates>(_Roaming), static_cast<winrt::Windows::Networking::Connectivity::TriStates>(_Shared) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_NetworkUsageStates(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates* self)
    {
    }

    static PyObject* NetworkUsageStates_get_Roaming(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Roaming);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NetworkUsageStates_set_Roaming(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Roaming = py::converter<winrt::Windows::Networking::Connectivity::TriStates>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NetworkUsageStates_get_Shared(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shared);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NetworkUsageStates_set_Shared(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Shared = py::converter<winrt::Windows::Networking::Connectivity::TriStates>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_NetworkUsageStates[] = {
        { const_cast<char*>("roaming"), (getter)NetworkUsageStates_get_Roaming, (setter)NetworkUsageStates_set_Roaming, nullptr, nullptr },
        { const_cast<char*>("shared"), (getter)NetworkUsageStates_get_Shared, (setter)NetworkUsageStates_set_Shared, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_NetworkUsageStates[] = 
    {
        { Py_tp_new, _new_NetworkUsageStates },
        { Py_tp_dealloc, _dealloc_NetworkUsageStates },
        { Py_tp_getset, _getset_NetworkUsageStates },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NetworkUsageStates =
    {
        "_winrt_Windows_Networking_Connectivity.NetworkUsageStates",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkUsageStates
    };

    // ----- Windows.Networking.Connectivity Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Networking::Connectivity::AttributedNetworkUsage>::python_type = py::register_python_type(module, _type_name_AttributedNetworkUsage, &_type_spec_AttributedNetworkUsage, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::CellularApnContext>::python_type = py::register_python_type(module, _type_name_CellularApnContext, &_type_spec_CellularApnContext, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectionCost>::python_type = py::register_python_type(module, _type_name_ConnectionCost, &_type_spec_ConnectionCost, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectionProfile>::python_type = py::register_python_type(module, _type_name_ConnectionProfile, &_type_spec_ConnectionProfile, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectionProfileFilter>::python_type = py::register_python_type(module, _type_name_ConnectionProfileFilter, &_type_spec_ConnectionProfileFilter, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectionSession>::python_type = py::register_python_type(module, _type_name_ConnectionSession, &_type_spec_ConnectionSession, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectivityInterval>::python_type = py::register_python_type(module, _type_name_ConnectivityInterval, &_type_spec_ConnectivityInterval, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectivityManager>::python_type = py::register_python_type(module, _type_name_ConnectivityManager, &_type_spec_ConnectivityManager, nullptr);
            py::winrt_type<winrt::Windows::Networking::Connectivity::DataPlanStatus>::python_type = py::register_python_type(module, _type_name_DataPlanStatus, &_type_spec_DataPlanStatus, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::DataPlanUsage>::python_type = py::register_python_type(module, _type_name_DataPlanUsage, &_type_spec_DataPlanUsage, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::DataUsage>::python_type = py::register_python_type(module, _type_name_DataUsage, &_type_spec_DataUsage, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::IPInformation>::python_type = py::register_python_type(module, _type_name_IPInformation, &_type_spec_IPInformation, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::LanIdentifier>::python_type = py::register_python_type(module, _type_name_LanIdentifier, &_type_spec_LanIdentifier, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::LanIdentifierData>::python_type = py::register_python_type(module, _type_name_LanIdentifierData, &_type_spec_LanIdentifierData, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkAdapter>::python_type = py::register_python_type(module, _type_name_NetworkAdapter, &_type_spec_NetworkAdapter, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkInformation>::python_type = py::register_python_type(module, _type_name_NetworkInformation, &_type_spec_NetworkInformation, nullptr);
            py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkItem>::python_type = py::register_python_type(module, _type_name_NetworkItem, &_type_spec_NetworkItem, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkSecuritySettings>::python_type = py::register_python_type(module, _type_name_NetworkSecuritySettings, &_type_spec_NetworkSecuritySettings, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkStateChangeEventDetails>::python_type = py::register_python_type(module, _type_name_NetworkStateChangeEventDetails, &_type_spec_NetworkStateChangeEventDetails, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkUsage>::python_type = py::register_python_type(module, _type_name_NetworkUsage, &_type_spec_NetworkUsage, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::ProviderNetworkUsage>::python_type = py::register_python_type(module, _type_name_ProviderNetworkUsage, &_type_spec_ProviderNetworkUsage, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::ProxyConfiguration>::python_type = py::register_python_type(module, _type_name_ProxyConfiguration, &_type_spec_ProxyConfiguration, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::RoutePolicy>::python_type = py::register_python_type(module, _type_name_RoutePolicy, &_type_spec_RoutePolicy, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::WlanConnectionProfileDetails>::python_type = py::register_python_type(module, _type_name_WlanConnectionProfileDetails, &_type_spec_WlanConnectionProfileDetails, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::WwanConnectionProfileDetails>::python_type = py::register_python_type(module, _type_name_WwanConnectionProfileDetails, &_type_spec_WwanConnectionProfileDetails, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkUsageStates>::python_type = py::register_python_type(module, _type_name_NetworkUsageStates, &_type_spec_NetworkUsageStates, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Networking.Connectivity");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Networking_Connectivity",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Networking::Connectivity

PyMODINIT_FUNC
PyInit__winrt_Windows_Networking_Connectivity (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Networking::Connectivity::module_def);
}
