// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Networking.Vpn.h"

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnAppId>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnChannel>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnChannelActivityEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnChannelConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnCredential>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnCustomCheckBox>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnCustomComboBox>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnCustomEditBox>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnCustomErrorBox>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnCustomPromptBooleanInput>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnCustomPromptOptionSelector>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnCustomPromptText>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnCustomPromptTextInput>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnCustomTextBox>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnDomainNameAssignment>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnDomainNameInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnForegroundActivationOperation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnInterfaceId>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnManagementAgent>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnNamespaceAssignment>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnNamespaceInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnNativeProfile>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnPacketBuffer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnPacketBufferList>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnPickedCredential>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnPlugInProfile>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnRoute>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnRouteAssignment>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnSystemHealth>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnTrafficFilter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::VpnTrafficFilterAssignment>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::IVpnChannelStatics>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::IVpnCredential>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::IVpnCustomPrompt>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::IVpnCustomPromptElement>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::IVpnDomainNameInfoFactory>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::IVpnInterfaceIdFactory>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::IVpnNamespaceInfoFactory>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::IVpnPacketBufferFactory>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::IVpnPlugIn>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::IVpnProfile>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Vpn::IVpnRouteFactory>::python_type;

namespace py::cpp::Windows::Networking::Vpn
{
    // ----- VpnAppId class --------------------
    constexpr const char* const _type_name_VpnAppId = "VpnAppId";

    static PyObject* _new_VpnAppId(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnAppIdType>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Networking::Vpn::VpnAppId instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnAppId(py::wrapper::Windows::Networking::Vpn::VpnAppId* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnAppId_get_Value(py::wrapper::Windows::Networking::Vpn::VpnAppId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnAppId_put_Value(py::wrapper::Windows::Networking::Vpn::VpnAppId* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnAppId_get_Type(py::wrapper::Windows::Networking::Vpn::VpnAppId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnAppId_put_Type(py::wrapper::Windows::Networking::Vpn::VpnAppId* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnAppIdType>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_VpnAppId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnAppId>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnAppId[] = {
        { "_from", (PyCFunction)_from_VpnAppId, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnAppId[] = {
        { const_cast<char*>("value"), (getter)VpnAppId_get_Value, (setter)VpnAppId_put_Value, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)VpnAppId_get_Type, (setter)VpnAppId_put_Type, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnAppId[] = 
    {
        { Py_tp_new, _new_VpnAppId },
        { Py_tp_dealloc, _dealloc_VpnAppId },
        { Py_tp_methods, _methods_VpnAppId },
        { Py_tp_getset, _getset_VpnAppId },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnAppId =
    {
        "_winrt_Windows_Networking_Vpn.VpnAppId",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnAppId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnAppId
    };

    // ----- VpnChannel class --------------------
    constexpr const char* const _type_name_VpnChannel = "VpnChannel";

    static PyObject* _new_VpnChannel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VpnChannel);
        return nullptr;
    }

    static void _dealloc_VpnChannel(py::wrapper::Windows::Networking::Vpn::VpnChannel* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnChannel_ActivateForeground(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 1);

                return py::convert(self->obj.ActivateForeground(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_AddAndAssociateTransport(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.AddAndAssociateTransport(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_AppendVpnReceivePacketBuffer(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(args, 0);

                self->obj.AppendVpnReceivePacketBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_AppendVpnSendPacketBuffer(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(args, 0);

                self->obj.AppendVpnSendPacketBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_AssociateTransport(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.AssociateTransport(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_FlushVpnReceivePacketBuffers(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.FlushVpnReceivePacketBuffers();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_FlushVpnSendPacketBuffers(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.FlushVpnSendPacketBuffers();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_GetSlotTypeForTransportContext(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.GetSlotTypeForTransportContext(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_GetVpnReceivePacketBuffer(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetVpnReceivePacketBuffer());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_GetVpnSendPacketBuffer(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetVpnSendPacketBuffer());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_LogDiagnosticMessage(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.LogDiagnosticMessage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_ProcessEventAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                winrt::Windows::Networking::Vpn::VpnChannel::ProcessEventAsync(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_ReplaceAndAssociateTransport(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.ReplaceAndAssociateTransport(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_RequestCredentials(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnCredentialType>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 3);

                return py::convert(self->obj.RequestCredentials(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_RequestCredentialsAsync(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnCredentialType>(args, 0);

                return py::convert(self->obj.RequestCredentialsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnCredentialType>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.RequestCredentialsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnCredentialType>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 2);

                return py::convert(self->obj.RequestCredentialsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_RequestCustomPrompt(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::Vpn::IVpnCustomPrompt>>(args, 0);

                self->obj.RequestCustomPrompt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_RequestCustomPromptAsync(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::Vpn::IVpnCustomPromptElement>>(args, 0);

                return py::convert(self->obj.RequestCustomPromptAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_RequestVpnPacketBuffer(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDataPathType>(args, 0);
                winrt::Windows::Networking::Vpn::VpnPacketBuffer param1 { nullptr };

                self->obj.RequestVpnPacketBuffer(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_SetAllowedSslTlsVersions(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.SetAllowedSslTlsVersions(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_SetErrorMessage(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetErrorMessage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_Start(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 10)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Vpn::VpnInterfaceId>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Vpn::VpnRouteAssignment>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Networking::Vpn::VpnNamespaceAssignment>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);
                auto param6 = py::convert_to<uint32_t>(args, 6);
                auto param7 = py::convert_to<bool>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 8);
                auto param9 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 9);

                self->obj.Start(param0, param1, param2, param3, param4, param5, param6, param7, param8, param9);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_StartExistingTransports(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 8)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Vpn::VpnInterfaceId>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Vpn::VpnRouteAssignment>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameAssignment>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);
                auto param6 = py::convert_to<uint32_t>(args, 6);
                auto param7 = py::convert_to<bool>(args, 7);

                self->obj.StartExistingTransports(param0, param1, param2, param3, param4, param5, param6, param7);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_StartReconnectingTransport(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.StartReconnectingTransport(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_StartWithMainTransport(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 9)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Vpn::VpnInterfaceId>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Vpn::VpnRouteAssignment>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameAssignment>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);
                auto param6 = py::convert_to<uint32_t>(args, 6);
                auto param7 = py::convert_to<bool>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 8);

                self->obj.StartWithMainTransport(param0, param1, param2, param3, param4, param5, param6, param7, param8);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_StartWithTrafficFilter(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 10)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::HostName>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::HostName>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Vpn::VpnInterfaceId>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Vpn::VpnRouteAssignment>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameAssignment>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);
                auto param6 = py::convert_to<uint32_t>(args, 6);
                auto param7 = py::convert_to<bool>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::IInspectable>>(args, 8);
                auto param9 = py::convert_to<winrt::Windows::Networking::Vpn::VpnTrafficFilterAssignment>(args, 9);

                self->obj.StartWithTrafficFilter(param0, param1, param2, param3, param4, param5, param6, param7, param8, param9);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 11)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Networking::HostName>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Vpn::VpnInterfaceId>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Vpn::VpnRouteAssignment>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameAssignment>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);
                auto param6 = py::convert_to<uint32_t>(args, 6);
                auto param7 = py::convert_to<bool>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 8);
                auto param9 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 9);
                auto param10 = py::convert_to<winrt::Windows::Networking::Vpn::VpnTrafficFilterAssignment>(args, 10);

                self->obj.StartWithTrafficFilter(param0, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_Stop(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_TerminateConnection(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.TerminateConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnChannel_get_PlugInContext(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlugInContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnChannel_put_PlugInContext(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.PlugInContext(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnChannel_get_Configuration(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannel_get_Id(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannel_get_SystemHealth(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemHealth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannel_get_CurrentRequestTransportContext(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentRequestTransportContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannel_add_ActivityChange(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Vpn::VpnChannel, winrt::Windows::Networking::Vpn::VpnChannelActivityEventArgs>>(arg);

            return py::convert(self->obj.ActivityChange(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannel_remove_ActivityChange(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActivityChange(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannel_add_ActivityStateChange(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Vpn::VpnChannel, winrt::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs>>(arg);

            return py::convert(self->obj.ActivityStateChange(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannel_remove_ActivityStateChange(py::wrapper::Windows::Networking::Vpn::VpnChannel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActivityStateChange(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VpnChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnChannel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnChannel[] = {
        { "activate_foreground", (PyCFunction)VpnChannel_ActivateForeground, METH_VARARGS, nullptr },
        { "add_and_associate_transport", (PyCFunction)VpnChannel_AddAndAssociateTransport, METH_VARARGS, nullptr },
        { "append_vpn_receive_packet_buffer", (PyCFunction)VpnChannel_AppendVpnReceivePacketBuffer, METH_VARARGS, nullptr },
        { "append_vpn_send_packet_buffer", (PyCFunction)VpnChannel_AppendVpnSendPacketBuffer, METH_VARARGS, nullptr },
        { "associate_transport", (PyCFunction)VpnChannel_AssociateTransport, METH_VARARGS, nullptr },
        { "flush_vpn_receive_packet_buffers", (PyCFunction)VpnChannel_FlushVpnReceivePacketBuffers, METH_VARARGS, nullptr },
        { "flush_vpn_send_packet_buffers", (PyCFunction)VpnChannel_FlushVpnSendPacketBuffers, METH_VARARGS, nullptr },
        { "get_slot_type_for_transport_context", (PyCFunction)VpnChannel_GetSlotTypeForTransportContext, METH_VARARGS, nullptr },
        { "get_vpn_receive_packet_buffer", (PyCFunction)VpnChannel_GetVpnReceivePacketBuffer, METH_VARARGS, nullptr },
        { "get_vpn_send_packet_buffer", (PyCFunction)VpnChannel_GetVpnSendPacketBuffer, METH_VARARGS, nullptr },
        { "log_diagnostic_message", (PyCFunction)VpnChannel_LogDiagnosticMessage, METH_VARARGS, nullptr },
        { "process_event_async", (PyCFunction)VpnChannel_ProcessEventAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "replace_and_associate_transport", (PyCFunction)VpnChannel_ReplaceAndAssociateTransport, METH_VARARGS, nullptr },
        { "request_credentials", (PyCFunction)VpnChannel_RequestCredentials, METH_VARARGS, nullptr },
        { "request_credentials_async", (PyCFunction)VpnChannel_RequestCredentialsAsync, METH_VARARGS, nullptr },
        { "request_custom_prompt", (PyCFunction)VpnChannel_RequestCustomPrompt, METH_VARARGS, nullptr },
        { "request_custom_prompt_async", (PyCFunction)VpnChannel_RequestCustomPromptAsync, METH_VARARGS, nullptr },
        { "request_vpn_packet_buffer", (PyCFunction)VpnChannel_RequestVpnPacketBuffer, METH_VARARGS, nullptr },
        { "set_allowed_ssl_tls_versions", (PyCFunction)VpnChannel_SetAllowedSslTlsVersions, METH_VARARGS, nullptr },
        { "set_error_message", (PyCFunction)VpnChannel_SetErrorMessage, METH_VARARGS, nullptr },
        { "start", (PyCFunction)VpnChannel_Start, METH_VARARGS, nullptr },
        { "start_existing_transports", (PyCFunction)VpnChannel_StartExistingTransports, METH_VARARGS, nullptr },
        { "start_reconnecting_transport", (PyCFunction)VpnChannel_StartReconnectingTransport, METH_VARARGS, nullptr },
        { "start_with_main_transport", (PyCFunction)VpnChannel_StartWithMainTransport, METH_VARARGS, nullptr },
        { "start_with_traffic_filter", (PyCFunction)VpnChannel_StartWithTrafficFilter, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)VpnChannel_Stop, METH_VARARGS, nullptr },
        { "terminate_connection", (PyCFunction)VpnChannel_TerminateConnection, METH_VARARGS, nullptr },
        { "add_activity_change", (PyCFunction)VpnChannel_add_ActivityChange, METH_O, nullptr },
        { "remove_activity_change", (PyCFunction)VpnChannel_remove_ActivityChange, METH_O, nullptr },
        { "add_activity_state_change", (PyCFunction)VpnChannel_add_ActivityStateChange, METH_O, nullptr },
        { "remove_activity_state_change", (PyCFunction)VpnChannel_remove_ActivityStateChange, METH_O, nullptr },
        { "_from", (PyCFunction)_from_VpnChannel, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnChannel[] = {
        { const_cast<char*>("plug_in_context"), (getter)VpnChannel_get_PlugInContext, (setter)VpnChannel_put_PlugInContext, nullptr, nullptr },
        { const_cast<char*>("configuration"), (getter)VpnChannel_get_Configuration, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)VpnChannel_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("system_health"), (getter)VpnChannel_get_SystemHealth, nullptr, nullptr, nullptr },
        { const_cast<char*>("current_request_transport_context"), (getter)VpnChannel_get_CurrentRequestTransportContext, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnChannel[] = 
    {
        { Py_tp_new, _new_VpnChannel },
        { Py_tp_dealloc, _dealloc_VpnChannel },
        { Py_tp_methods, _methods_VpnChannel },
        { Py_tp_getset, _getset_VpnChannel },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnChannel =
    {
        "_winrt_Windows_Networking_Vpn.VpnChannel",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnChannel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnChannel
    };

    // ----- VpnChannelActivityEventArgs class --------------------
    constexpr const char* const _type_name_VpnChannelActivityEventArgs = "VpnChannelActivityEventArgs";

    static PyObject* _new_VpnChannelActivityEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VpnChannelActivityEventArgs);
        return nullptr;
    }

    static void _dealloc_VpnChannelActivityEventArgs(py::wrapper::Windows::Networking::Vpn::VpnChannelActivityEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnChannelActivityEventArgs_get_Type(py::wrapper::Windows::Networking::Vpn::VpnChannelActivityEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VpnChannelActivityEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnChannelActivityEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnChannelActivityEventArgs[] = {
        { "_from", (PyCFunction)_from_VpnChannelActivityEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnChannelActivityEventArgs[] = {
        { const_cast<char*>("type"), (getter)VpnChannelActivityEventArgs_get_Type, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnChannelActivityEventArgs[] = 
    {
        { Py_tp_new, _new_VpnChannelActivityEventArgs },
        { Py_tp_dealloc, _dealloc_VpnChannelActivityEventArgs },
        { Py_tp_methods, _methods_VpnChannelActivityEventArgs },
        { Py_tp_getset, _getset_VpnChannelActivityEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnChannelActivityEventArgs =
    {
        "_winrt_Windows_Networking_Vpn.VpnChannelActivityEventArgs",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnChannelActivityEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnChannelActivityEventArgs
    };

    // ----- VpnChannelActivityStateChangedArgs class --------------------
    constexpr const char* const _type_name_VpnChannelActivityStateChangedArgs = "VpnChannelActivityStateChangedArgs";

    static PyObject* _new_VpnChannelActivityStateChangedArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VpnChannelActivityStateChangedArgs);
        return nullptr;
    }

    static void _dealloc_VpnChannelActivityStateChangedArgs(py::wrapper::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnChannelActivityStateChangedArgs_get_ActivityState(py::wrapper::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivityState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VpnChannelActivityStateChangedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnChannelActivityStateChangedArgs[] = {
        { "_from", (PyCFunction)_from_VpnChannelActivityStateChangedArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnChannelActivityStateChangedArgs[] = {
        { const_cast<char*>("activity_state"), (getter)VpnChannelActivityStateChangedArgs_get_ActivityState, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnChannelActivityStateChangedArgs[] = 
    {
        { Py_tp_new, _new_VpnChannelActivityStateChangedArgs },
        { Py_tp_dealloc, _dealloc_VpnChannelActivityStateChangedArgs },
        { Py_tp_methods, _methods_VpnChannelActivityStateChangedArgs },
        { Py_tp_getset, _getset_VpnChannelActivityStateChangedArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnChannelActivityStateChangedArgs =
    {
        "_winrt_Windows_Networking_Vpn.VpnChannelActivityStateChangedArgs",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnChannelActivityStateChangedArgs
    };

    // ----- VpnChannelConfiguration class --------------------
    constexpr const char* const _type_name_VpnChannelConfiguration = "VpnChannelConfiguration";

    static PyObject* _new_VpnChannelConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VpnChannelConfiguration);
        return nullptr;
    }

    static void _dealloc_VpnChannelConfiguration(py::wrapper::Windows::Networking::Vpn::VpnChannelConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnChannelConfiguration_get_CustomField(py::wrapper::Windows::Networking::Vpn::VpnChannelConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CustomField());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannelConfiguration_get_ServerHostNameList(py::wrapper::Windows::Networking::Vpn::VpnChannelConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerHostNameList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannelConfiguration_get_ServerServiceName(py::wrapper::Windows::Networking::Vpn::VpnChannelConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerServiceName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnChannelConfiguration_get_ServerUris(py::wrapper::Windows::Networking::Vpn::VpnChannelConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VpnChannelConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnChannelConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnChannelConfiguration[] = {
        { "_from", (PyCFunction)_from_VpnChannelConfiguration, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnChannelConfiguration[] = {
        { const_cast<char*>("custom_field"), (getter)VpnChannelConfiguration_get_CustomField, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_host_name_list"), (getter)VpnChannelConfiguration_get_ServerHostNameList, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_service_name"), (getter)VpnChannelConfiguration_get_ServerServiceName, nullptr, nullptr, nullptr },
        { const_cast<char*>("server_uris"), (getter)VpnChannelConfiguration_get_ServerUris, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnChannelConfiguration[] = 
    {
        { Py_tp_new, _new_VpnChannelConfiguration },
        { Py_tp_dealloc, _dealloc_VpnChannelConfiguration },
        { Py_tp_methods, _methods_VpnChannelConfiguration },
        { Py_tp_getset, _getset_VpnChannelConfiguration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnChannelConfiguration =
    {
        "_winrt_Windows_Networking_Vpn.VpnChannelConfiguration",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnChannelConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnChannelConfiguration
    };

    // ----- VpnCredential class --------------------
    constexpr const char* const _type_name_VpnCredential = "VpnCredential";

    static PyObject* _new_VpnCredential(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VpnCredential);
        return nullptr;
    }

    static void _dealloc_VpnCredential(py::wrapper::Windows::Networking::Vpn::VpnCredential* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnCredential_get_AdditionalPin(py::wrapper::Windows::Networking::Vpn::VpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdditionalPin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCredential_get_CertificateCredential(py::wrapper::Windows::Networking::Vpn::VpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CertificateCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCredential_get_OldPasswordCredential(py::wrapper::Windows::Networking::Vpn::VpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OldPasswordCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCredential_get_PasskeyCredential(py::wrapper::Windows::Networking::Vpn::VpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PasskeyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VpnCredential(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCredential>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCredential[] = {
        { "_from", (PyCFunction)_from_VpnCredential, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnCredential[] = {
        { const_cast<char*>("additional_pin"), (getter)VpnCredential_get_AdditionalPin, nullptr, nullptr, nullptr },
        { const_cast<char*>("certificate_credential"), (getter)VpnCredential_get_CertificateCredential, nullptr, nullptr, nullptr },
        { const_cast<char*>("old_password_credential"), (getter)VpnCredential_get_OldPasswordCredential, nullptr, nullptr, nullptr },
        { const_cast<char*>("passkey_credential"), (getter)VpnCredential_get_PasskeyCredential, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnCredential[] = 
    {
        { Py_tp_new, _new_VpnCredential },
        { Py_tp_dealloc, _dealloc_VpnCredential },
        { Py_tp_methods, _methods_VpnCredential },
        { Py_tp_getset, _getset_VpnCredential },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnCredential =
    {
        "_winrt_Windows_Networking_Vpn.VpnCredential",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCredential),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCredential
    };

    // ----- VpnCustomCheckBox class --------------------
    constexpr const char* const _type_name_VpnCustomCheckBox = "VpnCustomCheckBox";

    static PyObject* _new_VpnCustomCheckBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomCheckBox instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomCheckBox(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnCustomCheckBox_get_InitialCheckState(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InitialCheckState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomCheckBox_put_InitialCheckState(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.InitialCheckState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomCheckBox_get_Checked(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Checked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCustomCheckBox_get_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomCheckBox_put_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomCheckBox_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomCheckBox_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomCheckBox_get_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bordered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomCheckBox_put_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bordered(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_VpnCustomCheckBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomCheckBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomCheckBox[] = {
        { "_from", (PyCFunction)_from_VpnCustomCheckBox, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnCustomCheckBox[] = {
        { const_cast<char*>("initial_check_state"), (getter)VpnCustomCheckBox_get_InitialCheckState, (setter)VpnCustomCheckBox_put_InitialCheckState, nullptr, nullptr },
        { const_cast<char*>("checked"), (getter)VpnCustomCheckBox_get_Checked, nullptr, nullptr, nullptr },
        { const_cast<char*>("label"), (getter)VpnCustomCheckBox_get_Label, (setter)VpnCustomCheckBox_put_Label, nullptr, nullptr },
        { const_cast<char*>("compulsory"), (getter)VpnCustomCheckBox_get_Compulsory, (setter)VpnCustomCheckBox_put_Compulsory, nullptr, nullptr },
        { const_cast<char*>("bordered"), (getter)VpnCustomCheckBox_get_Bordered, (setter)VpnCustomCheckBox_put_Bordered, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnCustomCheckBox[] = 
    {
        { Py_tp_new, _new_VpnCustomCheckBox },
        { Py_tp_dealloc, _dealloc_VpnCustomCheckBox },
        { Py_tp_methods, _methods_VpnCustomCheckBox },
        { Py_tp_getset, _getset_VpnCustomCheckBox },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnCustomCheckBox =
    {
        "_winrt_Windows_Networking_Vpn.VpnCustomCheckBox",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomCheckBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomCheckBox
    };

    // ----- VpnCustomComboBox class --------------------
    constexpr const char* const _type_name_VpnCustomComboBox = "VpnCustomComboBox";

    static PyObject* _new_VpnCustomComboBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomComboBox instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomComboBox(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnCustomComboBox_get_OptionsText(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OptionsText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomComboBox_put_OptionsText(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>(arg);

            self->obj.OptionsText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomComboBox_get_Selected(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Selected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCustomComboBox_get_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomComboBox_put_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomComboBox_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomComboBox_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomComboBox_get_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bordered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomComboBox_put_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bordered(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_VpnCustomComboBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomComboBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomComboBox[] = {
        { "_from", (PyCFunction)_from_VpnCustomComboBox, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnCustomComboBox[] = {
        { const_cast<char*>("options_text"), (getter)VpnCustomComboBox_get_OptionsText, (setter)VpnCustomComboBox_put_OptionsText, nullptr, nullptr },
        { const_cast<char*>("selected"), (getter)VpnCustomComboBox_get_Selected, nullptr, nullptr, nullptr },
        { const_cast<char*>("label"), (getter)VpnCustomComboBox_get_Label, (setter)VpnCustomComboBox_put_Label, nullptr, nullptr },
        { const_cast<char*>("compulsory"), (getter)VpnCustomComboBox_get_Compulsory, (setter)VpnCustomComboBox_put_Compulsory, nullptr, nullptr },
        { const_cast<char*>("bordered"), (getter)VpnCustomComboBox_get_Bordered, (setter)VpnCustomComboBox_put_Bordered, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnCustomComboBox[] = 
    {
        { Py_tp_new, _new_VpnCustomComboBox },
        { Py_tp_dealloc, _dealloc_VpnCustomComboBox },
        { Py_tp_methods, _methods_VpnCustomComboBox },
        { Py_tp_getset, _getset_VpnCustomComboBox },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnCustomComboBox =
    {
        "_winrt_Windows_Networking_Vpn.VpnCustomComboBox",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomComboBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomComboBox
    };

    // ----- VpnCustomEditBox class --------------------
    constexpr const char* const _type_name_VpnCustomEditBox = "VpnCustomEditBox";

    static PyObject* _new_VpnCustomEditBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomEditBox instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomEditBox(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnCustomEditBox_get_NoEcho(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NoEcho());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomEditBox_put_NoEcho(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.NoEcho(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomEditBox_get_DefaultText(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DefaultText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomEditBox_put_DefaultText(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DefaultText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomEditBox_get_Text(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCustomEditBox_get_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomEditBox_put_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomEditBox_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomEditBox_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomEditBox_get_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bordered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomEditBox_put_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bordered(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_VpnCustomEditBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomEditBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomEditBox[] = {
        { "_from", (PyCFunction)_from_VpnCustomEditBox, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnCustomEditBox[] = {
        { const_cast<char*>("no_echo"), (getter)VpnCustomEditBox_get_NoEcho, (setter)VpnCustomEditBox_put_NoEcho, nullptr, nullptr },
        { const_cast<char*>("default_text"), (getter)VpnCustomEditBox_get_DefaultText, (setter)VpnCustomEditBox_put_DefaultText, nullptr, nullptr },
        { const_cast<char*>("text"), (getter)VpnCustomEditBox_get_Text, nullptr, nullptr, nullptr },
        { const_cast<char*>("label"), (getter)VpnCustomEditBox_get_Label, (setter)VpnCustomEditBox_put_Label, nullptr, nullptr },
        { const_cast<char*>("compulsory"), (getter)VpnCustomEditBox_get_Compulsory, (setter)VpnCustomEditBox_put_Compulsory, nullptr, nullptr },
        { const_cast<char*>("bordered"), (getter)VpnCustomEditBox_get_Bordered, (setter)VpnCustomEditBox_put_Bordered, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnCustomEditBox[] = 
    {
        { Py_tp_new, _new_VpnCustomEditBox },
        { Py_tp_dealloc, _dealloc_VpnCustomEditBox },
        { Py_tp_methods, _methods_VpnCustomEditBox },
        { Py_tp_getset, _getset_VpnCustomEditBox },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnCustomEditBox =
    {
        "_winrt_Windows_Networking_Vpn.VpnCustomEditBox",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomEditBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomEditBox
    };

    // ----- VpnCustomErrorBox class --------------------
    constexpr const char* const _type_name_VpnCustomErrorBox = "VpnCustomErrorBox";

    static PyObject* _new_VpnCustomErrorBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomErrorBox instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomErrorBox(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnCustomErrorBox_get_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomErrorBox_put_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomErrorBox_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomErrorBox_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomErrorBox_get_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bordered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomErrorBox_put_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bordered(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_VpnCustomErrorBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomErrorBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomErrorBox[] = {
        { "_from", (PyCFunction)_from_VpnCustomErrorBox, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnCustomErrorBox[] = {
        { const_cast<char*>("label"), (getter)VpnCustomErrorBox_get_Label, (setter)VpnCustomErrorBox_put_Label, nullptr, nullptr },
        { const_cast<char*>("compulsory"), (getter)VpnCustomErrorBox_get_Compulsory, (setter)VpnCustomErrorBox_put_Compulsory, nullptr, nullptr },
        { const_cast<char*>("bordered"), (getter)VpnCustomErrorBox_get_Bordered, (setter)VpnCustomErrorBox_put_Bordered, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnCustomErrorBox[] = 
    {
        { Py_tp_new, _new_VpnCustomErrorBox },
        { Py_tp_dealloc, _dealloc_VpnCustomErrorBox },
        { Py_tp_methods, _methods_VpnCustomErrorBox },
        { Py_tp_getset, _getset_VpnCustomErrorBox },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnCustomErrorBox =
    {
        "_winrt_Windows_Networking_Vpn.VpnCustomErrorBox",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomErrorBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomErrorBox
    };

    // ----- VpnCustomPromptBooleanInput class --------------------
    constexpr const char* const _type_name_VpnCustomPromptBooleanInput = "VpnCustomPromptBooleanInput";

    static PyObject* _new_VpnCustomPromptBooleanInput(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomPromptBooleanInput instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomPromptBooleanInput(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnCustomPromptBooleanInput_get_InitialValue(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InitialValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptBooleanInput_put_InitialValue(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.InitialValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptBooleanInput_get_Value(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCustomPromptBooleanInput_get_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Emphasized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptBooleanInput_put_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Emphasized(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptBooleanInput_get_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptBooleanInput_put_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptBooleanInput_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptBooleanInput_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_VpnCustomPromptBooleanInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomPromptBooleanInput>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomPromptBooleanInput[] = {
        { "_from", (PyCFunction)_from_VpnCustomPromptBooleanInput, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnCustomPromptBooleanInput[] = {
        { const_cast<char*>("initial_value"), (getter)VpnCustomPromptBooleanInput_get_InitialValue, (setter)VpnCustomPromptBooleanInput_put_InitialValue, nullptr, nullptr },
        { const_cast<char*>("value"), (getter)VpnCustomPromptBooleanInput_get_Value, nullptr, nullptr, nullptr },
        { const_cast<char*>("emphasized"), (getter)VpnCustomPromptBooleanInput_get_Emphasized, (setter)VpnCustomPromptBooleanInput_put_Emphasized, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)VpnCustomPromptBooleanInput_get_DisplayName, (setter)VpnCustomPromptBooleanInput_put_DisplayName, nullptr, nullptr },
        { const_cast<char*>("compulsory"), (getter)VpnCustomPromptBooleanInput_get_Compulsory, (setter)VpnCustomPromptBooleanInput_put_Compulsory, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnCustomPromptBooleanInput[] = 
    {
        { Py_tp_new, _new_VpnCustomPromptBooleanInput },
        { Py_tp_dealloc, _dealloc_VpnCustomPromptBooleanInput },
        { Py_tp_methods, _methods_VpnCustomPromptBooleanInput },
        { Py_tp_getset, _getset_VpnCustomPromptBooleanInput },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnCustomPromptBooleanInput =
    {
        "_winrt_Windows_Networking_Vpn.VpnCustomPromptBooleanInput",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptBooleanInput),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomPromptBooleanInput
    };

    // ----- VpnCustomPromptOptionSelector class --------------------
    constexpr const char* const _type_name_VpnCustomPromptOptionSelector = "VpnCustomPromptOptionSelector";

    static PyObject* _new_VpnCustomPromptOptionSelector(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomPromptOptionSelector instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomPromptOptionSelector(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnCustomPromptOptionSelector_get_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Emphasized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptOptionSelector_put_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Emphasized(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptOptionSelector_get_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptOptionSelector_put_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptOptionSelector_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptOptionSelector_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptOptionSelector_get_Options(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Options());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnCustomPromptOptionSelector_get_SelectedIndex(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SelectedIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VpnCustomPromptOptionSelector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomPromptOptionSelector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomPromptOptionSelector[] = {
        { "_from", (PyCFunction)_from_VpnCustomPromptOptionSelector, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnCustomPromptOptionSelector[] = {
        { const_cast<char*>("emphasized"), (getter)VpnCustomPromptOptionSelector_get_Emphasized, (setter)VpnCustomPromptOptionSelector_put_Emphasized, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)VpnCustomPromptOptionSelector_get_DisplayName, (setter)VpnCustomPromptOptionSelector_put_DisplayName, nullptr, nullptr },
        { const_cast<char*>("compulsory"), (getter)VpnCustomPromptOptionSelector_get_Compulsory, (setter)VpnCustomPromptOptionSelector_put_Compulsory, nullptr, nullptr },
        { const_cast<char*>("options"), (getter)VpnCustomPromptOptionSelector_get_Options, nullptr, nullptr, nullptr },
        { const_cast<char*>("selected_index"), (getter)VpnCustomPromptOptionSelector_get_SelectedIndex, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnCustomPromptOptionSelector[] = 
    {
        { Py_tp_new, _new_VpnCustomPromptOptionSelector },
        { Py_tp_dealloc, _dealloc_VpnCustomPromptOptionSelector },
        { Py_tp_methods, _methods_VpnCustomPromptOptionSelector },
        { Py_tp_getset, _getset_VpnCustomPromptOptionSelector },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnCustomPromptOptionSelector =
    {
        "_winrt_Windows_Networking_Vpn.VpnCustomPromptOptionSelector",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptOptionSelector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomPromptOptionSelector
    };

    // ----- VpnCustomPromptText class --------------------
    constexpr const char* const _type_name_VpnCustomPromptText = "VpnCustomPromptText";

    static PyObject* _new_VpnCustomPromptText(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomPromptText instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomPromptText(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnCustomPromptText_get_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Emphasized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptText_put_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Emphasized(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptText_get_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptText_put_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptText_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptText_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptText_get_Text(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptText_put_Text(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_VpnCustomPromptText(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomPromptText>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomPromptText[] = {
        { "_from", (PyCFunction)_from_VpnCustomPromptText, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnCustomPromptText[] = {
        { const_cast<char*>("emphasized"), (getter)VpnCustomPromptText_get_Emphasized, (setter)VpnCustomPromptText_put_Emphasized, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)VpnCustomPromptText_get_DisplayName, (setter)VpnCustomPromptText_put_DisplayName, nullptr, nullptr },
        { const_cast<char*>("compulsory"), (getter)VpnCustomPromptText_get_Compulsory, (setter)VpnCustomPromptText_put_Compulsory, nullptr, nullptr },
        { const_cast<char*>("text"), (getter)VpnCustomPromptText_get_Text, (setter)VpnCustomPromptText_put_Text, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnCustomPromptText[] = 
    {
        { Py_tp_new, _new_VpnCustomPromptText },
        { Py_tp_dealloc, _dealloc_VpnCustomPromptText },
        { Py_tp_methods, _methods_VpnCustomPromptText },
        { Py_tp_getset, _getset_VpnCustomPromptText },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnCustomPromptText =
    {
        "_winrt_Windows_Networking_Vpn.VpnCustomPromptText",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptText),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomPromptText
    };

    // ----- VpnCustomPromptTextInput class --------------------
    constexpr const char* const _type_name_VpnCustomPromptTextInput = "VpnCustomPromptTextInput";

    static PyObject* _new_VpnCustomPromptTextInput(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomPromptTextInput instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomPromptTextInput(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnCustomPromptTextInput_get_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Emphasized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptTextInput_put_Emphasized(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Emphasized(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptTextInput_get_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptTextInput_put_DisplayName(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptTextInput_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptTextInput_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptTextInput_get_PlaceholderText(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaceholderText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptTextInput_put_PlaceholderText(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PlaceholderText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptTextInput_get_IsTextHidden(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTextHidden());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomPromptTextInput_put_IsTextHidden(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTextHidden(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomPromptTextInput_get_Text(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VpnCustomPromptTextInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomPromptTextInput>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomPromptTextInput[] = {
        { "_from", (PyCFunction)_from_VpnCustomPromptTextInput, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnCustomPromptTextInput[] = {
        { const_cast<char*>("emphasized"), (getter)VpnCustomPromptTextInput_get_Emphasized, (setter)VpnCustomPromptTextInput_put_Emphasized, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)VpnCustomPromptTextInput_get_DisplayName, (setter)VpnCustomPromptTextInput_put_DisplayName, nullptr, nullptr },
        { const_cast<char*>("compulsory"), (getter)VpnCustomPromptTextInput_get_Compulsory, (setter)VpnCustomPromptTextInput_put_Compulsory, nullptr, nullptr },
        { const_cast<char*>("placeholder_text"), (getter)VpnCustomPromptTextInput_get_PlaceholderText, (setter)VpnCustomPromptTextInput_put_PlaceholderText, nullptr, nullptr },
        { const_cast<char*>("is_text_hidden"), (getter)VpnCustomPromptTextInput_get_IsTextHidden, (setter)VpnCustomPromptTextInput_put_IsTextHidden, nullptr, nullptr },
        { const_cast<char*>("text"), (getter)VpnCustomPromptTextInput_get_Text, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnCustomPromptTextInput[] = 
    {
        { Py_tp_new, _new_VpnCustomPromptTextInput },
        { Py_tp_dealloc, _dealloc_VpnCustomPromptTextInput },
        { Py_tp_methods, _methods_VpnCustomPromptTextInput },
        { Py_tp_getset, _getset_VpnCustomPromptTextInput },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnCustomPromptTextInput =
    {
        "_winrt_Windows_Networking_Vpn.VpnCustomPromptTextInput",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomPromptTextInput),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomPromptTextInput
    };

    // ----- VpnCustomTextBox class --------------------
    constexpr const char* const _type_name_VpnCustomTextBox = "VpnCustomTextBox";

    static PyObject* _new_VpnCustomTextBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnCustomTextBox instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnCustomTextBox(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnCustomTextBox_get_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomTextBox_put_Label(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomTextBox_get_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomTextBox_put_Compulsory(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomTextBox_get_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bordered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomTextBox_put_Bordered(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bordered(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnCustomTextBox_get_DisplayText(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnCustomTextBox_put_DisplayText(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_VpnCustomTextBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnCustomTextBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnCustomTextBox[] = {
        { "_from", (PyCFunction)_from_VpnCustomTextBox, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnCustomTextBox[] = {
        { const_cast<char*>("label"), (getter)VpnCustomTextBox_get_Label, (setter)VpnCustomTextBox_put_Label, nullptr, nullptr },
        { const_cast<char*>("compulsory"), (getter)VpnCustomTextBox_get_Compulsory, (setter)VpnCustomTextBox_put_Compulsory, nullptr, nullptr },
        { const_cast<char*>("bordered"), (getter)VpnCustomTextBox_get_Bordered, (setter)VpnCustomTextBox_put_Bordered, nullptr, nullptr },
        { const_cast<char*>("display_text"), (getter)VpnCustomTextBox_get_DisplayText, (setter)VpnCustomTextBox_put_DisplayText, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnCustomTextBox[] = 
    {
        { Py_tp_new, _new_VpnCustomTextBox },
        { Py_tp_dealloc, _dealloc_VpnCustomTextBox },
        { Py_tp_methods, _methods_VpnCustomTextBox },
        { Py_tp_getset, _getset_VpnCustomTextBox },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnCustomTextBox =
    {
        "_winrt_Windows_Networking_Vpn.VpnCustomTextBox",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnCustomTextBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnCustomTextBox
    };

    // ----- VpnDomainNameAssignment class --------------------
    constexpr const char* const _type_name_VpnDomainNameAssignment = "VpnDomainNameAssignment";

    static PyObject* _new_VpnDomainNameAssignment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnDomainNameAssignment instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnDomainNameAssignment(py::wrapper::Windows::Networking::Vpn::VpnDomainNameAssignment* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnDomainNameAssignment_get_ProxyAutoConfigurationUri(py::wrapper::Windows::Networking::Vpn::VpnDomainNameAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProxyAutoConfigurationUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnDomainNameAssignment_put_ProxyAutoConfigurationUri(py::wrapper::Windows::Networking::Vpn::VpnDomainNameAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ProxyAutoConfigurationUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnDomainNameAssignment_get_DomainNameList(py::wrapper::Windows::Networking::Vpn::VpnDomainNameAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DomainNameList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VpnDomainNameAssignment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnDomainNameAssignment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnDomainNameAssignment[] = {
        { "_from", (PyCFunction)_from_VpnDomainNameAssignment, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnDomainNameAssignment[] = {
        { const_cast<char*>("proxy_auto_configuration_uri"), (getter)VpnDomainNameAssignment_get_ProxyAutoConfigurationUri, (setter)VpnDomainNameAssignment_put_ProxyAutoConfigurationUri, nullptr, nullptr },
        { const_cast<char*>("domain_name_list"), (getter)VpnDomainNameAssignment_get_DomainNameList, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnDomainNameAssignment[] = 
    {
        { Py_tp_new, _new_VpnDomainNameAssignment },
        { Py_tp_dealloc, _dealloc_VpnDomainNameAssignment },
        { Py_tp_methods, _methods_VpnDomainNameAssignment },
        { Py_tp_getset, _getset_VpnDomainNameAssignment },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnDomainNameAssignment =
    {
        "_winrt_Windows_Networking_Vpn.VpnDomainNameAssignment",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnDomainNameAssignment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnDomainNameAssignment
    };

    // ----- VpnDomainNameInfo class --------------------
    constexpr const char* const _type_name_VpnDomainNameInfo = "VpnDomainNameInfo";

    static PyObject* _new_VpnDomainNameInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::HostName>>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::HostName>>(args, 3);

                winrt::Windows::Networking::Vpn::VpnDomainNameInfo instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnDomainNameInfo(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnDomainNameInfo_get_DomainNameType(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DomainNameType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnDomainNameInfo_put_DomainNameType(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameType>(arg);

            self->obj.DomainNameType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnDomainNameInfo_get_DomainName(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DomainName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnDomainNameInfo_put_DomainName(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(arg);

            self->obj.DomainName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnDomainNameInfo_get_DnsServers(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DnsServers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnDomainNameInfo_get_WebProxyServers(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WebProxyServers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnDomainNameInfo_get_WebProxyUris(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WebProxyUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VpnDomainNameInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnDomainNameInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnDomainNameInfo[] = {
        { "_from", (PyCFunction)_from_VpnDomainNameInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnDomainNameInfo[] = {
        { const_cast<char*>("domain_name_type"), (getter)VpnDomainNameInfo_get_DomainNameType, (setter)VpnDomainNameInfo_put_DomainNameType, nullptr, nullptr },
        { const_cast<char*>("domain_name"), (getter)VpnDomainNameInfo_get_DomainName, (setter)VpnDomainNameInfo_put_DomainName, nullptr, nullptr },
        { const_cast<char*>("dns_servers"), (getter)VpnDomainNameInfo_get_DnsServers, nullptr, nullptr, nullptr },
        { const_cast<char*>("web_proxy_servers"), (getter)VpnDomainNameInfo_get_WebProxyServers, nullptr, nullptr, nullptr },
        { const_cast<char*>("web_proxy_uris"), (getter)VpnDomainNameInfo_get_WebProxyUris, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnDomainNameInfo[] = 
    {
        { Py_tp_new, _new_VpnDomainNameInfo },
        { Py_tp_dealloc, _dealloc_VpnDomainNameInfo },
        { Py_tp_methods, _methods_VpnDomainNameInfo },
        { Py_tp_getset, _getset_VpnDomainNameInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnDomainNameInfo =
    {
        "_winrt_Windows_Networking_Vpn.VpnDomainNameInfo",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnDomainNameInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnDomainNameInfo
    };

    // ----- VpnForegroundActivatedEventArgs class --------------------
    constexpr const char* const _type_name_VpnForegroundActivatedEventArgs = "VpnForegroundActivatedEventArgs";

    static PyObject* _new_VpnForegroundActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VpnForegroundActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_VpnForegroundActivatedEventArgs(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnForegroundActivatedEventArgs_get_Kind(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnForegroundActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnForegroundActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnForegroundActivatedEventArgs_get_User(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnForegroundActivatedEventArgs_get_ActivationOperation(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivationOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnForegroundActivatedEventArgs_get_ProfileName(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnForegroundActivatedEventArgs_get_SharedContext(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SharedContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VpnForegroundActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnForegroundActivatedEventArgs[] = {
        { "_from", (PyCFunction)_from_VpnForegroundActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnForegroundActivatedEventArgs[] = {
        { const_cast<char*>("kind"), (getter)VpnForegroundActivatedEventArgs_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("previous_execution_state"), (getter)VpnForegroundActivatedEventArgs_get_PreviousExecutionState, nullptr, nullptr, nullptr },
        { const_cast<char*>("splash_screen"), (getter)VpnForegroundActivatedEventArgs_get_SplashScreen, nullptr, nullptr, nullptr },
        { const_cast<char*>("user"), (getter)VpnForegroundActivatedEventArgs_get_User, nullptr, nullptr, nullptr },
        { const_cast<char*>("activation_operation"), (getter)VpnForegroundActivatedEventArgs_get_ActivationOperation, nullptr, nullptr, nullptr },
        { const_cast<char*>("profile_name"), (getter)VpnForegroundActivatedEventArgs_get_ProfileName, nullptr, nullptr, nullptr },
        { const_cast<char*>("shared_context"), (getter)VpnForegroundActivatedEventArgs_get_SharedContext, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnForegroundActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_VpnForegroundActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_VpnForegroundActivatedEventArgs },
        { Py_tp_methods, _methods_VpnForegroundActivatedEventArgs },
        { Py_tp_getset, _getset_VpnForegroundActivatedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnForegroundActivatedEventArgs =
    {
        "_winrt_Windows_Networking_Vpn.VpnForegroundActivatedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnForegroundActivatedEventArgs
    };

    // ----- VpnForegroundActivationOperation class --------------------
    constexpr const char* const _type_name_VpnForegroundActivationOperation = "VpnForegroundActivationOperation";

    static PyObject* _new_VpnForegroundActivationOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VpnForegroundActivationOperation);
        return nullptr;
    }

    static void _dealloc_VpnForegroundActivationOperation(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivationOperation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnForegroundActivationOperation_Complete(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivationOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);

                self->obj.Complete(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_VpnForegroundActivationOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnForegroundActivationOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnForegroundActivationOperation[] = {
        { "complete", (PyCFunction)VpnForegroundActivationOperation_Complete, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_VpnForegroundActivationOperation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnForegroundActivationOperation[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnForegroundActivationOperation[] = 
    {
        { Py_tp_new, _new_VpnForegroundActivationOperation },
        { Py_tp_dealloc, _dealloc_VpnForegroundActivationOperation },
        { Py_tp_methods, _methods_VpnForegroundActivationOperation },
        { Py_tp_getset, _getset_VpnForegroundActivationOperation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnForegroundActivationOperation =
    {
        "_winrt_Windows_Networking_Vpn.VpnForegroundActivationOperation",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnForegroundActivationOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnForegroundActivationOperation
    };

    // ----- VpnInterfaceId class --------------------
    constexpr const char* const _type_name_VpnInterfaceId = "VpnInterfaceId";

    static PyObject* _new_VpnInterfaceId(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                winrt::Windows::Networking::Vpn::VpnInterfaceId instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnInterfaceId(py::wrapper::Windows::Networking::Vpn::VpnInterfaceId* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnInterfaceId_GetAddressInfo(py::wrapper::Windows::Networking::Vpn::VpnInterfaceId* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetAddressInfo(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_VpnInterfaceId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnInterfaceId>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnInterfaceId[] = {
        { "get_address_info", (PyCFunction)VpnInterfaceId_GetAddressInfo, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_VpnInterfaceId, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnInterfaceId[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnInterfaceId[] = 
    {
        { Py_tp_new, _new_VpnInterfaceId },
        { Py_tp_dealloc, _dealloc_VpnInterfaceId },
        { Py_tp_methods, _methods_VpnInterfaceId },
        { Py_tp_getset, _getset_VpnInterfaceId },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnInterfaceId =
    {
        "_winrt_Windows_Networking_Vpn.VpnInterfaceId",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnInterfaceId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnInterfaceId
    };

    // ----- VpnManagementAgent class --------------------
    constexpr const char* const _type_name_VpnManagementAgent = "VpnManagementAgent";

    static PyObject* _new_VpnManagementAgent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnManagementAgent instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnManagementAgent(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnManagementAgent_AddProfileFromObjectAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::IVpnProfile>(args, 0);

                return py::convert(self->obj.AddProfileFromObjectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_AddProfileFromXmlAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.AddProfileFromXmlAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_ConnectProfileAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::IVpnProfile>(args, 0);

                return py::convert(self->obj.ConnectProfileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_ConnectProfileWithPasswordCredentialAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::IVpnProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(args, 1);

                return py::convert(self->obj.ConnectProfileWithPasswordCredentialAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_DeleteProfileAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::IVpnProfile>(args, 0);

                return py::convert(self->obj.DeleteProfileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_DisconnectProfileAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::IVpnProfile>(args, 0);

                return py::convert(self->obj.DisconnectProfileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_GetProfilesAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetProfilesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_UpdateProfileFromObjectAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::IVpnProfile>(args, 0);

                return py::convert(self->obj.UpdateProfileFromObjectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnManagementAgent_UpdateProfileFromXmlAsync(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.UpdateProfileFromXmlAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_VpnManagementAgent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnManagementAgent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnManagementAgent[] = {
        { "add_profile_from_object_async", (PyCFunction)VpnManagementAgent_AddProfileFromObjectAsync, METH_VARARGS, nullptr },
        { "add_profile_from_xml_async", (PyCFunction)VpnManagementAgent_AddProfileFromXmlAsync, METH_VARARGS, nullptr },
        { "connect_profile_async", (PyCFunction)VpnManagementAgent_ConnectProfileAsync, METH_VARARGS, nullptr },
        { "connect_profile_with_password_credential_async", (PyCFunction)VpnManagementAgent_ConnectProfileWithPasswordCredentialAsync, METH_VARARGS, nullptr },
        { "delete_profile_async", (PyCFunction)VpnManagementAgent_DeleteProfileAsync, METH_VARARGS, nullptr },
        { "disconnect_profile_async", (PyCFunction)VpnManagementAgent_DisconnectProfileAsync, METH_VARARGS, nullptr },
        { "get_profiles_async", (PyCFunction)VpnManagementAgent_GetProfilesAsync, METH_VARARGS, nullptr },
        { "update_profile_from_object_async", (PyCFunction)VpnManagementAgent_UpdateProfileFromObjectAsync, METH_VARARGS, nullptr },
        { "update_profile_from_xml_async", (PyCFunction)VpnManagementAgent_UpdateProfileFromXmlAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_VpnManagementAgent, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnManagementAgent[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnManagementAgent[] = 
    {
        { Py_tp_new, _new_VpnManagementAgent },
        { Py_tp_dealloc, _dealloc_VpnManagementAgent },
        { Py_tp_methods, _methods_VpnManagementAgent },
        { Py_tp_getset, _getset_VpnManagementAgent },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnManagementAgent =
    {
        "_winrt_Windows_Networking_Vpn.VpnManagementAgent",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnManagementAgent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnManagementAgent
    };

    // ----- VpnNamespaceAssignment class --------------------
    constexpr const char* const _type_name_VpnNamespaceAssignment = "VpnNamespaceAssignment";

    static PyObject* _new_VpnNamespaceAssignment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnNamespaceAssignment instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnNamespaceAssignment(py::wrapper::Windows::Networking::Vpn::VpnNamespaceAssignment* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnNamespaceAssignment_get_ProxyAutoConfigUri(py::wrapper::Windows::Networking::Vpn::VpnNamespaceAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProxyAutoConfigUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNamespaceAssignment_put_ProxyAutoConfigUri(py::wrapper::Windows::Networking::Vpn::VpnNamespaceAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ProxyAutoConfigUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNamespaceAssignment_get_NamespaceList(py::wrapper::Windows::Networking::Vpn::VpnNamespaceAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NamespaceList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNamespaceAssignment_put_NamespaceList(py::wrapper::Windows::Networking::Vpn::VpnNamespaceAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::Vpn::VpnNamespaceInfo>>(arg);

            self->obj.NamespaceList(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_VpnNamespaceAssignment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnNamespaceAssignment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnNamespaceAssignment[] = {
        { "_from", (PyCFunction)_from_VpnNamespaceAssignment, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnNamespaceAssignment[] = {
        { const_cast<char*>("proxy_auto_config_uri"), (getter)VpnNamespaceAssignment_get_ProxyAutoConfigUri, (setter)VpnNamespaceAssignment_put_ProxyAutoConfigUri, nullptr, nullptr },
        { const_cast<char*>("namespace_list"), (getter)VpnNamespaceAssignment_get_NamespaceList, (setter)VpnNamespaceAssignment_put_NamespaceList, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnNamespaceAssignment[] = 
    {
        { Py_tp_new, _new_VpnNamespaceAssignment },
        { Py_tp_dealloc, _dealloc_VpnNamespaceAssignment },
        { Py_tp_methods, _methods_VpnNamespaceAssignment },
        { Py_tp_getset, _getset_VpnNamespaceAssignment },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnNamespaceAssignment =
    {
        "_winrt_Windows_Networking_Vpn.VpnNamespaceAssignment",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnNamespaceAssignment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnNamespaceAssignment
    };

    // ----- VpnNamespaceInfo class --------------------
    constexpr const char* const _type_name_VpnNamespaceInfo = "VpnNamespaceInfo";

    static PyObject* _new_VpnNamespaceInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::HostName>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::HostName>>(args, 2);

                winrt::Windows::Networking::Vpn::VpnNamespaceInfo instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnNamespaceInfo(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnNamespaceInfo_get_WebProxyServers(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WebProxyServers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNamespaceInfo_put_WebProxyServers(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::HostName>>(arg);

            self->obj.WebProxyServers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNamespaceInfo_get_Namespace(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Namespace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNamespaceInfo_put_Namespace(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Namespace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNamespaceInfo_get_DnsServers(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DnsServers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNamespaceInfo_put_DnsServers(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::HostName>>(arg);

            self->obj.DnsServers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_VpnNamespaceInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnNamespaceInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnNamespaceInfo[] = {
        { "_from", (PyCFunction)_from_VpnNamespaceInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnNamespaceInfo[] = {
        { const_cast<char*>("web_proxy_servers"), (getter)VpnNamespaceInfo_get_WebProxyServers, (setter)VpnNamespaceInfo_put_WebProxyServers, nullptr, nullptr },
        { const_cast<char*>("namespace"), (getter)VpnNamespaceInfo_get_Namespace, (setter)VpnNamespaceInfo_put_Namespace, nullptr, nullptr },
        { const_cast<char*>("dns_servers"), (getter)VpnNamespaceInfo_get_DnsServers, (setter)VpnNamespaceInfo_put_DnsServers, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnNamespaceInfo[] = 
    {
        { Py_tp_new, _new_VpnNamespaceInfo },
        { Py_tp_dealloc, _dealloc_VpnNamespaceInfo },
        { Py_tp_methods, _methods_VpnNamespaceInfo },
        { Py_tp_getset, _getset_VpnNamespaceInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnNamespaceInfo =
    {
        "_winrt_Windows_Networking_Vpn.VpnNamespaceInfo",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnNamespaceInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnNamespaceInfo
    };

    // ----- VpnNativeProfile class --------------------
    constexpr const char* const _type_name_VpnNativeProfile = "VpnNativeProfile";

    static PyObject* _new_VpnNativeProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnNativeProfile instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnNativeProfile(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnNativeProfile_get_UserAuthenticationMethod(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserAuthenticationMethod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_UserAuthenticationMethod(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnAuthenticationMethod>(arg);

            self->obj.UserAuthenticationMethod(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_TunnelAuthenticationMethod(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TunnelAuthenticationMethod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_TunnelAuthenticationMethod(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnAuthenticationMethod>(arg);

            self->obj.TunnelAuthenticationMethod(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_RoutingPolicyType(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoutingPolicyType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_RoutingPolicyType(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnRoutingPolicyType>(arg);

            self->obj.RoutingPolicyType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_EapConfiguration(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EapConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_EapConfiguration(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.EapConfiguration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_NativeProtocolType(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NativeProtocolType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_NativeProtocolType(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnNativeProtocolType>(arg);

            self->obj.NativeProtocolType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_Servers(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Servers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnNativeProfile_get_RequireVpnClientAppUI(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequireVpnClientAppUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_RequireVpnClientAppUI(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RequireVpnClientAppUI(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_ConnectionStatus(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnNativeProfile_get_ProfileName(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_ProfileName(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ProfileName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_RememberCredentials(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RememberCredentials());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_RememberCredentials(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RememberCredentials(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_AlwaysOn(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlwaysOn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnNativeProfile_put_AlwaysOn(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AlwaysOn(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnNativeProfile_get_Routes(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Routes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnNativeProfile_get_AppTriggers(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppTriggers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnNativeProfile_get_TrafficFilters(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrafficFilters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnNativeProfile_get_DomainNameInfoList(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DomainNameInfoList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VpnNativeProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnNativeProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnNativeProfile[] = {
        { "_from", (PyCFunction)_from_VpnNativeProfile, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnNativeProfile[] = {
        { const_cast<char*>("user_authentication_method"), (getter)VpnNativeProfile_get_UserAuthenticationMethod, (setter)VpnNativeProfile_put_UserAuthenticationMethod, nullptr, nullptr },
        { const_cast<char*>("tunnel_authentication_method"), (getter)VpnNativeProfile_get_TunnelAuthenticationMethod, (setter)VpnNativeProfile_put_TunnelAuthenticationMethod, nullptr, nullptr },
        { const_cast<char*>("routing_policy_type"), (getter)VpnNativeProfile_get_RoutingPolicyType, (setter)VpnNativeProfile_put_RoutingPolicyType, nullptr, nullptr },
        { const_cast<char*>("eap_configuration"), (getter)VpnNativeProfile_get_EapConfiguration, (setter)VpnNativeProfile_put_EapConfiguration, nullptr, nullptr },
        { const_cast<char*>("native_protocol_type"), (getter)VpnNativeProfile_get_NativeProtocolType, (setter)VpnNativeProfile_put_NativeProtocolType, nullptr, nullptr },
        { const_cast<char*>("servers"), (getter)VpnNativeProfile_get_Servers, nullptr, nullptr, nullptr },
        { const_cast<char*>("require_vpn_client_app_u_i"), (getter)VpnNativeProfile_get_RequireVpnClientAppUI, (setter)VpnNativeProfile_put_RequireVpnClientAppUI, nullptr, nullptr },
        { const_cast<char*>("connection_status"), (getter)VpnNativeProfile_get_ConnectionStatus, nullptr, nullptr, nullptr },
        { const_cast<char*>("profile_name"), (getter)VpnNativeProfile_get_ProfileName, (setter)VpnNativeProfile_put_ProfileName, nullptr, nullptr },
        { const_cast<char*>("remember_credentials"), (getter)VpnNativeProfile_get_RememberCredentials, (setter)VpnNativeProfile_put_RememberCredentials, nullptr, nullptr },
        { const_cast<char*>("always_on"), (getter)VpnNativeProfile_get_AlwaysOn, (setter)VpnNativeProfile_put_AlwaysOn, nullptr, nullptr },
        { const_cast<char*>("routes"), (getter)VpnNativeProfile_get_Routes, nullptr, nullptr, nullptr },
        { const_cast<char*>("app_triggers"), (getter)VpnNativeProfile_get_AppTriggers, nullptr, nullptr, nullptr },
        { const_cast<char*>("traffic_filters"), (getter)VpnNativeProfile_get_TrafficFilters, nullptr, nullptr, nullptr },
        { const_cast<char*>("domain_name_info_list"), (getter)VpnNativeProfile_get_DomainNameInfoList, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnNativeProfile[] = 
    {
        { Py_tp_new, _new_VpnNativeProfile },
        { Py_tp_dealloc, _dealloc_VpnNativeProfile },
        { Py_tp_methods, _methods_VpnNativeProfile },
        { Py_tp_getset, _getset_VpnNativeProfile },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnNativeProfile =
    {
        "_winrt_Windows_Networking_Vpn.VpnNativeProfile",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnNativeProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnNativeProfile
    };

    // ----- VpnPacketBuffer class --------------------
    constexpr const char* const _type_name_VpnPacketBuffer = "VpnPacketBuffer";

    static PyObject* _new_VpnPacketBuffer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                winrt::Windows::Networking::Vpn::VpnPacketBuffer instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnPacketBuffer(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnPacketBuffer_get_TransportAffinity(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportAffinity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPacketBuffer_put_TransportAffinity(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.TransportAffinity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPacketBuffer_get_Status(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPacketBuffer_put_Status(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBufferStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPacketBuffer_get_Buffer(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buffer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPacketBuffer_get_AppId(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPacketBuffer_get_TransportContext(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPacketBuffer_put_TransportContext(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.TransportContext(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_VpnPacketBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnPacketBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnPacketBuffer[] = {
        { "_from", (PyCFunction)_from_VpnPacketBuffer, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnPacketBuffer[] = {
        { const_cast<char*>("transport_affinity"), (getter)VpnPacketBuffer_get_TransportAffinity, (setter)VpnPacketBuffer_put_TransportAffinity, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)VpnPacketBuffer_get_Status, (setter)VpnPacketBuffer_put_Status, nullptr, nullptr },
        { const_cast<char*>("buffer"), (getter)VpnPacketBuffer_get_Buffer, nullptr, nullptr, nullptr },
        { const_cast<char*>("app_id"), (getter)VpnPacketBuffer_get_AppId, nullptr, nullptr, nullptr },
        { const_cast<char*>("transport_context"), (getter)VpnPacketBuffer_get_TransportContext, (setter)VpnPacketBuffer_put_TransportContext, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnPacketBuffer[] = 
    {
        { Py_tp_new, _new_VpnPacketBuffer },
        { Py_tp_dealloc, _dealloc_VpnPacketBuffer },
        { Py_tp_methods, _methods_VpnPacketBuffer },
        { Py_tp_getset, _getset_VpnPacketBuffer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnPacketBuffer =
    {
        "_winrt_Windows_Networking_Vpn.VpnPacketBuffer",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnPacketBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnPacketBuffer
    };

    // ----- VpnPacketBufferList class --------------------
    constexpr const char* const _type_name_VpnPacketBufferList = "VpnPacketBufferList";

    static PyObject* _new_VpnPacketBufferList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VpnPacketBufferList);
        return nullptr;
    }

    static void _dealloc_VpnPacketBufferList(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnPacketBufferList_AddAtBegin(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(args, 0);

                self->obj.AddAtBegin(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnPacketBufferList_Append(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnPacketBufferList_Clear(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnPacketBufferList_First(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnPacketBufferList_RemoveAtBegin(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RemoveAtBegin());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnPacketBufferList_RemoveAtEnd(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RemoveAtEnd());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VpnPacketBufferList_get_Status(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPacketBufferList_put_Status(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBufferStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPacketBufferList_get_Size(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VpnPacketBufferList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnPacketBufferList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_VpnPacketBufferList(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnPacketBufferList[] = {
        { "add_at_begin", (PyCFunction)VpnPacketBufferList_AddAtBegin, METH_VARARGS, nullptr },
        { "append", (PyCFunction)VpnPacketBufferList_Append, METH_VARARGS, nullptr },
        { "clear", (PyCFunction)VpnPacketBufferList_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)VpnPacketBufferList_First, METH_VARARGS, nullptr },
        { "remove_at_begin", (PyCFunction)VpnPacketBufferList_RemoveAtBegin, METH_VARARGS, nullptr },
        { "remove_at_end", (PyCFunction)VpnPacketBufferList_RemoveAtEnd, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_VpnPacketBufferList, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnPacketBufferList[] = {
        { const_cast<char*>("status"), (getter)VpnPacketBufferList_get_Status, (setter)VpnPacketBufferList_put_Status, nullptr, nullptr },
        { const_cast<char*>("size"), (getter)VpnPacketBufferList_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnPacketBufferList[] = 
    {
        { Py_tp_new, _new_VpnPacketBufferList },
        { Py_tp_dealloc, _dealloc_VpnPacketBufferList },
        { Py_tp_methods, _methods_VpnPacketBufferList },
        { Py_tp_getset, _getset_VpnPacketBufferList },
        { Py_tp_iter, _iterator_VpnPacketBufferList },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnPacketBufferList =
    {
        "_winrt_Windows_Networking_Vpn.VpnPacketBufferList",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnPacketBufferList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnPacketBufferList
    };

    // ----- VpnPickedCredential class --------------------
    constexpr const char* const _type_name_VpnPickedCredential = "VpnPickedCredential";

    static PyObject* _new_VpnPickedCredential(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VpnPickedCredential);
        return nullptr;
    }

    static void _dealloc_VpnPickedCredential(py::wrapper::Windows::Networking::Vpn::VpnPickedCredential* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnPickedCredential_get_AdditionalPin(py::wrapper::Windows::Networking::Vpn::VpnPickedCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdditionalPin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPickedCredential_get_OldPasswordCredential(py::wrapper::Windows::Networking::Vpn::VpnPickedCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OldPasswordCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPickedCredential_get_PasskeyCredential(py::wrapper::Windows::Networking::Vpn::VpnPickedCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PasskeyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VpnPickedCredential(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnPickedCredential>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnPickedCredential[] = {
        { "_from", (PyCFunction)_from_VpnPickedCredential, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnPickedCredential[] = {
        { const_cast<char*>("additional_pin"), (getter)VpnPickedCredential_get_AdditionalPin, nullptr, nullptr, nullptr },
        { const_cast<char*>("old_password_credential"), (getter)VpnPickedCredential_get_OldPasswordCredential, nullptr, nullptr, nullptr },
        { const_cast<char*>("passkey_credential"), (getter)VpnPickedCredential_get_PasskeyCredential, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnPickedCredential[] = 
    {
        { Py_tp_new, _new_VpnPickedCredential },
        { Py_tp_dealloc, _dealloc_VpnPickedCredential },
        { Py_tp_methods, _methods_VpnPickedCredential },
        { Py_tp_getset, _getset_VpnPickedCredential },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnPickedCredential =
    {
        "_winrt_Windows_Networking_Vpn.VpnPickedCredential",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnPickedCredential),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnPickedCredential
    };

    // ----- VpnPlugInProfile class --------------------
    constexpr const char* const _type_name_VpnPlugInProfile = "VpnPlugInProfile";

    static PyObject* _new_VpnPlugInProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnPlugInProfile instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnPlugInProfile(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnPlugInProfile_get_VpnPluginPackageFamilyName(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VpnPluginPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPlugInProfile_put_VpnPluginPackageFamilyName(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.VpnPluginPackageFamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPlugInProfile_get_CustomConfiguration(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CustomConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPlugInProfile_put_CustomConfiguration(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CustomConfiguration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPlugInProfile_get_ServerUris(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPlugInProfile_get_RequireVpnClientAppUI(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequireVpnClientAppUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPlugInProfile_put_RequireVpnClientAppUI(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RequireVpnClientAppUI(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPlugInProfile_get_ConnectionStatus(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPlugInProfile_get_ProfileName(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPlugInProfile_put_ProfileName(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ProfileName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPlugInProfile_get_RememberCredentials(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RememberCredentials());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPlugInProfile_put_RememberCredentials(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RememberCredentials(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPlugInProfile_get_AlwaysOn(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlwaysOn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnPlugInProfile_put_AlwaysOn(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AlwaysOn(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnPlugInProfile_get_AppTriggers(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppTriggers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPlugInProfile_get_DomainNameInfoList(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DomainNameInfoList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPlugInProfile_get_Routes(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Routes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnPlugInProfile_get_TrafficFilters(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrafficFilters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VpnPlugInProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnPlugInProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnPlugInProfile[] = {
        { "_from", (PyCFunction)_from_VpnPlugInProfile, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnPlugInProfile[] = {
        { const_cast<char*>("vpn_plugin_package_family_name"), (getter)VpnPlugInProfile_get_VpnPluginPackageFamilyName, (setter)VpnPlugInProfile_put_VpnPluginPackageFamilyName, nullptr, nullptr },
        { const_cast<char*>("custom_configuration"), (getter)VpnPlugInProfile_get_CustomConfiguration, (setter)VpnPlugInProfile_put_CustomConfiguration, nullptr, nullptr },
        { const_cast<char*>("server_uris"), (getter)VpnPlugInProfile_get_ServerUris, nullptr, nullptr, nullptr },
        { const_cast<char*>("require_vpn_client_app_u_i"), (getter)VpnPlugInProfile_get_RequireVpnClientAppUI, (setter)VpnPlugInProfile_put_RequireVpnClientAppUI, nullptr, nullptr },
        { const_cast<char*>("connection_status"), (getter)VpnPlugInProfile_get_ConnectionStatus, nullptr, nullptr, nullptr },
        { const_cast<char*>("profile_name"), (getter)VpnPlugInProfile_get_ProfileName, (setter)VpnPlugInProfile_put_ProfileName, nullptr, nullptr },
        { const_cast<char*>("remember_credentials"), (getter)VpnPlugInProfile_get_RememberCredentials, (setter)VpnPlugInProfile_put_RememberCredentials, nullptr, nullptr },
        { const_cast<char*>("always_on"), (getter)VpnPlugInProfile_get_AlwaysOn, (setter)VpnPlugInProfile_put_AlwaysOn, nullptr, nullptr },
        { const_cast<char*>("app_triggers"), (getter)VpnPlugInProfile_get_AppTriggers, nullptr, nullptr, nullptr },
        { const_cast<char*>("domain_name_info_list"), (getter)VpnPlugInProfile_get_DomainNameInfoList, nullptr, nullptr, nullptr },
        { const_cast<char*>("routes"), (getter)VpnPlugInProfile_get_Routes, nullptr, nullptr, nullptr },
        { const_cast<char*>("traffic_filters"), (getter)VpnPlugInProfile_get_TrafficFilters, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnPlugInProfile[] = 
    {
        { Py_tp_new, _new_VpnPlugInProfile },
        { Py_tp_dealloc, _dealloc_VpnPlugInProfile },
        { Py_tp_methods, _methods_VpnPlugInProfile },
        { Py_tp_getset, _getset_VpnPlugInProfile },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnPlugInProfile =
    {
        "_winrt_Windows_Networking_Vpn.VpnPlugInProfile",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnPlugInProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnPlugInProfile
    };

    // ----- VpnRoute class --------------------
    constexpr const char* const _type_name_VpnRoute = "VpnRoute";

    static PyObject* _new_VpnRoute(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);

                winrt::Windows::Networking::Vpn::VpnRoute instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnRoute(py::wrapper::Windows::Networking::Vpn::VpnRoute* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnRoute_get_PrefixSize(py::wrapper::Windows::Networking::Vpn::VpnRoute* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrefixSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnRoute_put_PrefixSize(py::wrapper::Windows::Networking::Vpn::VpnRoute* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.PrefixSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnRoute_get_Address(py::wrapper::Windows::Networking::Vpn::VpnRoute* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnRoute_put_Address(py::wrapper::Windows::Networking::Vpn::VpnRoute* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(arg);

            self->obj.Address(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_VpnRoute(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnRoute>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnRoute[] = {
        { "_from", (PyCFunction)_from_VpnRoute, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnRoute[] = {
        { const_cast<char*>("prefix_size"), (getter)VpnRoute_get_PrefixSize, (setter)VpnRoute_put_PrefixSize, nullptr, nullptr },
        { const_cast<char*>("address"), (getter)VpnRoute_get_Address, (setter)VpnRoute_put_Address, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnRoute[] = 
    {
        { Py_tp_new, _new_VpnRoute },
        { Py_tp_dealloc, _dealloc_VpnRoute },
        { Py_tp_methods, _methods_VpnRoute },
        { Py_tp_getset, _getset_VpnRoute },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnRoute =
    {
        "_winrt_Windows_Networking_Vpn.VpnRoute",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnRoute),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnRoute
    };

    // ----- VpnRouteAssignment class --------------------
    constexpr const char* const _type_name_VpnRouteAssignment = "VpnRouteAssignment";

    static PyObject* _new_VpnRouteAssignment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnRouteAssignment instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnRouteAssignment(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnRouteAssignment_get_Ipv6InclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Ipv6InclusionRoutes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnRouteAssignment_put_Ipv6InclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::Vpn::VpnRoute>>(arg);

            self->obj.Ipv6InclusionRoutes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnRouteAssignment_get_Ipv6ExclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Ipv6ExclusionRoutes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnRouteAssignment_put_Ipv6ExclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::Vpn::VpnRoute>>(arg);

            self->obj.Ipv6ExclusionRoutes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnRouteAssignment_get_Ipv4InclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Ipv4InclusionRoutes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnRouteAssignment_put_Ipv4InclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::Vpn::VpnRoute>>(arg);

            self->obj.Ipv4InclusionRoutes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnRouteAssignment_get_Ipv4ExclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Ipv4ExclusionRoutes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnRouteAssignment_put_Ipv4ExclusionRoutes(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::Vpn::VpnRoute>>(arg);

            self->obj.Ipv4ExclusionRoutes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnRouteAssignment_get_ExcludeLocalSubnets(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExcludeLocalSubnets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnRouteAssignment_put_ExcludeLocalSubnets(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ExcludeLocalSubnets(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_VpnRouteAssignment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnRouteAssignment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnRouteAssignment[] = {
        { "_from", (PyCFunction)_from_VpnRouteAssignment, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnRouteAssignment[] = {
        { const_cast<char*>("ipv6_inclusion_routes"), (getter)VpnRouteAssignment_get_Ipv6InclusionRoutes, (setter)VpnRouteAssignment_put_Ipv6InclusionRoutes, nullptr, nullptr },
        { const_cast<char*>("ipv6_exclusion_routes"), (getter)VpnRouteAssignment_get_Ipv6ExclusionRoutes, (setter)VpnRouteAssignment_put_Ipv6ExclusionRoutes, nullptr, nullptr },
        { const_cast<char*>("ipv4_inclusion_routes"), (getter)VpnRouteAssignment_get_Ipv4InclusionRoutes, (setter)VpnRouteAssignment_put_Ipv4InclusionRoutes, nullptr, nullptr },
        { const_cast<char*>("ipv4_exclusion_routes"), (getter)VpnRouteAssignment_get_Ipv4ExclusionRoutes, (setter)VpnRouteAssignment_put_Ipv4ExclusionRoutes, nullptr, nullptr },
        { const_cast<char*>("exclude_local_subnets"), (getter)VpnRouteAssignment_get_ExcludeLocalSubnets, (setter)VpnRouteAssignment_put_ExcludeLocalSubnets, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnRouteAssignment[] = 
    {
        { Py_tp_new, _new_VpnRouteAssignment },
        { Py_tp_dealloc, _dealloc_VpnRouteAssignment },
        { Py_tp_methods, _methods_VpnRouteAssignment },
        { Py_tp_getset, _getset_VpnRouteAssignment },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnRouteAssignment =
    {
        "_winrt_Windows_Networking_Vpn.VpnRouteAssignment",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnRouteAssignment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnRouteAssignment
    };

    // ----- VpnSystemHealth class --------------------
    constexpr const char* const _type_name_VpnSystemHealth = "VpnSystemHealth";

    static PyObject* _new_VpnSystemHealth(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VpnSystemHealth);
        return nullptr;
    }

    static void _dealloc_VpnSystemHealth(py::wrapper::Windows::Networking::Vpn::VpnSystemHealth* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnSystemHealth_get_StatementOfHealth(py::wrapper::Windows::Networking::Vpn::VpnSystemHealth* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StatementOfHealth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VpnSystemHealth(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnSystemHealth>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnSystemHealth[] = {
        { "_from", (PyCFunction)_from_VpnSystemHealth, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnSystemHealth[] = {
        { const_cast<char*>("statement_of_health"), (getter)VpnSystemHealth_get_StatementOfHealth, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnSystemHealth[] = 
    {
        { Py_tp_new, _new_VpnSystemHealth },
        { Py_tp_dealloc, _dealloc_VpnSystemHealth },
        { Py_tp_methods, _methods_VpnSystemHealth },
        { Py_tp_getset, _getset_VpnSystemHealth },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnSystemHealth =
    {
        "_winrt_Windows_Networking_Vpn.VpnSystemHealth",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnSystemHealth),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnSystemHealth
    };

    // ----- VpnTrafficFilter class --------------------
    constexpr const char* const _type_name_VpnTrafficFilter = "VpnTrafficFilter";

    static PyObject* _new_VpnTrafficFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnAppId>(args, 0);

                winrt::Windows::Networking::Vpn::VpnTrafficFilter instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnTrafficFilter(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnTrafficFilter_get_RoutingPolicyType(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoutingPolicyType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnTrafficFilter_put_RoutingPolicyType(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnRoutingPolicyType>(arg);

            self->obj.RoutingPolicyType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnTrafficFilter_get_Protocol(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnTrafficFilter_put_Protocol(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnIPProtocol>(arg);

            self->obj.Protocol(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnTrafficFilter_get_AppId(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnTrafficFilter_put_AppId(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnAppId>(arg);

            self->obj.AppId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnTrafficFilter_get_AppClaims(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppClaims());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnTrafficFilter_get_LocalAddressRanges(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAddressRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnTrafficFilter_get_LocalPortRanges(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalPortRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnTrafficFilter_get_RemoteAddressRanges(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteAddressRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VpnTrafficFilter_get_RemotePortRanges(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemotePortRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VpnTrafficFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnTrafficFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnTrafficFilter[] = {
        { "_from", (PyCFunction)_from_VpnTrafficFilter, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnTrafficFilter[] = {
        { const_cast<char*>("routing_policy_type"), (getter)VpnTrafficFilter_get_RoutingPolicyType, (setter)VpnTrafficFilter_put_RoutingPolicyType, nullptr, nullptr },
        { const_cast<char*>("protocol"), (getter)VpnTrafficFilter_get_Protocol, (setter)VpnTrafficFilter_put_Protocol, nullptr, nullptr },
        { const_cast<char*>("app_id"), (getter)VpnTrafficFilter_get_AppId, (setter)VpnTrafficFilter_put_AppId, nullptr, nullptr },
        { const_cast<char*>("app_claims"), (getter)VpnTrafficFilter_get_AppClaims, nullptr, nullptr, nullptr },
        { const_cast<char*>("local_address_ranges"), (getter)VpnTrafficFilter_get_LocalAddressRanges, nullptr, nullptr, nullptr },
        { const_cast<char*>("local_port_ranges"), (getter)VpnTrafficFilter_get_LocalPortRanges, nullptr, nullptr, nullptr },
        { const_cast<char*>("remote_address_ranges"), (getter)VpnTrafficFilter_get_RemoteAddressRanges, nullptr, nullptr, nullptr },
        { const_cast<char*>("remote_port_ranges"), (getter)VpnTrafficFilter_get_RemotePortRanges, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnTrafficFilter[] = 
    {
        { Py_tp_new, _new_VpnTrafficFilter },
        { Py_tp_dealloc, _dealloc_VpnTrafficFilter },
        { Py_tp_methods, _methods_VpnTrafficFilter },
        { Py_tp_getset, _getset_VpnTrafficFilter },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnTrafficFilter =
    {
        "_winrt_Windows_Networking_Vpn.VpnTrafficFilter",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnTrafficFilter
    };

    // ----- VpnTrafficFilterAssignment class --------------------
    constexpr const char* const _type_name_VpnTrafficFilterAssignment = "VpnTrafficFilterAssignment";

    static PyObject* _new_VpnTrafficFilterAssignment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Vpn::VpnTrafficFilterAssignment instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VpnTrafficFilterAssignment(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilterAssignment* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VpnTrafficFilterAssignment_get_AllowOutbound(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilterAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowOutbound());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnTrafficFilterAssignment_put_AllowOutbound(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilterAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowOutbound(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnTrafficFilterAssignment_get_AllowInbound(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilterAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowInbound());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VpnTrafficFilterAssignment_put_AllowInbound(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilterAssignment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowInbound(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VpnTrafficFilterAssignment_get_TrafficFilterList(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilterAssignment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrafficFilterList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VpnTrafficFilterAssignment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::VpnTrafficFilterAssignment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VpnTrafficFilterAssignment[] = {
        { "_from", (PyCFunction)_from_VpnTrafficFilterAssignment, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VpnTrafficFilterAssignment[] = {
        { const_cast<char*>("allow_outbound"), (getter)VpnTrafficFilterAssignment_get_AllowOutbound, (setter)VpnTrafficFilterAssignment_put_AllowOutbound, nullptr, nullptr },
        { const_cast<char*>("allow_inbound"), (getter)VpnTrafficFilterAssignment_get_AllowInbound, (setter)VpnTrafficFilterAssignment_put_AllowInbound, nullptr, nullptr },
        { const_cast<char*>("traffic_filter_list"), (getter)VpnTrafficFilterAssignment_get_TrafficFilterList, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VpnTrafficFilterAssignment[] = 
    {
        { Py_tp_new, _new_VpnTrafficFilterAssignment },
        { Py_tp_dealloc, _dealloc_VpnTrafficFilterAssignment },
        { Py_tp_methods, _methods_VpnTrafficFilterAssignment },
        { Py_tp_getset, _getset_VpnTrafficFilterAssignment },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VpnTrafficFilterAssignment =
    {
        "_winrt_Windows_Networking_Vpn.VpnTrafficFilterAssignment",
        sizeof(py::wrapper::Windows::Networking::Vpn::VpnTrafficFilterAssignment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VpnTrafficFilterAssignment
    };

    // ----- IVpnChannelStatics interface --------------------
    constexpr const char* const _type_name_IVpnChannelStatics = "IVpnChannelStatics";

    static PyObject* _new_IVpnChannelStatics(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IVpnChannelStatics);
        return nullptr;
    }

    static void _dealloc_IVpnChannelStatics(py::wrapper::Windows::Networking::Vpn::IVpnChannelStatics* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IVpnChannelStatics_ProcessEventAsync(py::wrapper::Windows::Networking::Vpn::IVpnChannelStatics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.ProcessEventAsync(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IVpnChannelStatics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnChannelStatics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnChannelStatics[] = {
        { "process_event_async", (PyCFunction)IVpnChannelStatics_ProcessEventAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IVpnChannelStatics, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IVpnChannelStatics[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IVpnChannelStatics[] = 
    {
        { Py_tp_new, _new_IVpnChannelStatics },
        { Py_tp_dealloc, _dealloc_IVpnChannelStatics },
        { Py_tp_methods, _methods_IVpnChannelStatics },
        { Py_tp_getset, _getset_IVpnChannelStatics },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IVpnChannelStatics =
    {
        "_winrt_Windows_Networking_Vpn.IVpnChannelStatics",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnChannelStatics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnChannelStatics
    };

    // ----- IVpnCredential interface --------------------
    constexpr const char* const _type_name_IVpnCredential = "IVpnCredential";

    static PyObject* _new_IVpnCredential(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IVpnCredential);
        return nullptr;
    }

    static void _dealloc_IVpnCredential(py::wrapper::Windows::Networking::Vpn::IVpnCredential* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IVpnCredential_get_AdditionalPin(py::wrapper::Windows::Networking::Vpn::IVpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdditionalPin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVpnCredential_get_CertificateCredential(py::wrapper::Windows::Networking::Vpn::IVpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CertificateCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVpnCredential_get_OldPasswordCredential(py::wrapper::Windows::Networking::Vpn::IVpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OldPasswordCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVpnCredential_get_PasskeyCredential(py::wrapper::Windows::Networking::Vpn::IVpnCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PasskeyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IVpnCredential(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnCredential>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnCredential[] = {
        { "_from", (PyCFunction)_from_IVpnCredential, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IVpnCredential[] = {
        { const_cast<char*>("additional_pin"), (getter)IVpnCredential_get_AdditionalPin, nullptr, nullptr, nullptr },
        { const_cast<char*>("certificate_credential"), (getter)IVpnCredential_get_CertificateCredential, nullptr, nullptr, nullptr },
        { const_cast<char*>("old_password_credential"), (getter)IVpnCredential_get_OldPasswordCredential, nullptr, nullptr, nullptr },
        { const_cast<char*>("passkey_credential"), (getter)IVpnCredential_get_PasskeyCredential, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IVpnCredential[] = 
    {
        { Py_tp_new, _new_IVpnCredential },
        { Py_tp_dealloc, _dealloc_IVpnCredential },
        { Py_tp_methods, _methods_IVpnCredential },
        { Py_tp_getset, _getset_IVpnCredential },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IVpnCredential =
    {
        "_winrt_Windows_Networking_Vpn.IVpnCredential",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnCredential),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnCredential
    };

    // ----- IVpnCustomPrompt interface --------------------
    constexpr const char* const _type_name_IVpnCustomPrompt = "IVpnCustomPrompt";

    static PyObject* _new_IVpnCustomPrompt(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IVpnCustomPrompt);
        return nullptr;
    }

    static void _dealloc_IVpnCustomPrompt(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IVpnCustomPrompt_get_Bordered(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bordered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnCustomPrompt_put_Bordered(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bordered(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IVpnCustomPrompt_get_Compulsory(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnCustomPrompt_put_Compulsory(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IVpnCustomPrompt_get_Label(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnCustomPrompt_put_Label(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IVpnCustomPrompt(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnCustomPrompt>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnCustomPrompt[] = {
        { "_from", (PyCFunction)_from_IVpnCustomPrompt, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IVpnCustomPrompt[] = {
        { const_cast<char*>("bordered"), (getter)IVpnCustomPrompt_get_Bordered, (setter)IVpnCustomPrompt_put_Bordered, nullptr, nullptr },
        { const_cast<char*>("compulsory"), (getter)IVpnCustomPrompt_get_Compulsory, (setter)IVpnCustomPrompt_put_Compulsory, nullptr, nullptr },
        { const_cast<char*>("label"), (getter)IVpnCustomPrompt_get_Label, (setter)IVpnCustomPrompt_put_Label, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IVpnCustomPrompt[] = 
    {
        { Py_tp_new, _new_IVpnCustomPrompt },
        { Py_tp_dealloc, _dealloc_IVpnCustomPrompt },
        { Py_tp_methods, _methods_IVpnCustomPrompt },
        { Py_tp_getset, _getset_IVpnCustomPrompt },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IVpnCustomPrompt =
    {
        "_winrt_Windows_Networking_Vpn.IVpnCustomPrompt",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnCustomPrompt),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnCustomPrompt
    };

    // ----- IVpnCustomPromptElement interface --------------------
    constexpr const char* const _type_name_IVpnCustomPromptElement = "IVpnCustomPromptElement";

    static PyObject* _new_IVpnCustomPromptElement(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IVpnCustomPromptElement);
        return nullptr;
    }

    static void _dealloc_IVpnCustomPromptElement(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IVpnCustomPromptElement_get_Compulsory(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Compulsory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnCustomPromptElement_put_Compulsory(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Compulsory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IVpnCustomPromptElement_get_DisplayName(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnCustomPromptElement_put_DisplayName(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IVpnCustomPromptElement_get_Emphasized(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Emphasized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnCustomPromptElement_put_Emphasized(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Emphasized(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IVpnCustomPromptElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnCustomPromptElement>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnCustomPromptElement[] = {
        { "_from", (PyCFunction)_from_IVpnCustomPromptElement, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IVpnCustomPromptElement[] = {
        { const_cast<char*>("compulsory"), (getter)IVpnCustomPromptElement_get_Compulsory, (setter)IVpnCustomPromptElement_put_Compulsory, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)IVpnCustomPromptElement_get_DisplayName, (setter)IVpnCustomPromptElement_put_DisplayName, nullptr, nullptr },
        { const_cast<char*>("emphasized"), (getter)IVpnCustomPromptElement_get_Emphasized, (setter)IVpnCustomPromptElement_put_Emphasized, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IVpnCustomPromptElement[] = 
    {
        { Py_tp_new, _new_IVpnCustomPromptElement },
        { Py_tp_dealloc, _dealloc_IVpnCustomPromptElement },
        { Py_tp_methods, _methods_IVpnCustomPromptElement },
        { Py_tp_getset, _getset_IVpnCustomPromptElement },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IVpnCustomPromptElement =
    {
        "_winrt_Windows_Networking_Vpn.IVpnCustomPromptElement",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnCustomPromptElement),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnCustomPromptElement
    };

    // ----- IVpnDomainNameInfoFactory interface --------------------
    constexpr const char* const _type_name_IVpnDomainNameInfoFactory = "IVpnDomainNameInfoFactory";

    static PyObject* _new_IVpnDomainNameInfoFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IVpnDomainNameInfoFactory);
        return nullptr;
    }

    static void _dealloc_IVpnDomainNameInfoFactory(py::wrapper::Windows::Networking::Vpn::IVpnDomainNameInfoFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IVpnDomainNameInfoFactory_CreateVpnDomainNameInfo(py::wrapper::Windows::Networking::Vpn::IVpnDomainNameInfoFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Vpn::VpnDomainNameType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::HostName>>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::HostName>>(args, 3);

                return py::convert(self->obj.CreateVpnDomainNameInfo(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IVpnDomainNameInfoFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnDomainNameInfoFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnDomainNameInfoFactory[] = {
        { "create_vpn_domain_name_info", (PyCFunction)IVpnDomainNameInfoFactory_CreateVpnDomainNameInfo, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IVpnDomainNameInfoFactory, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IVpnDomainNameInfoFactory[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IVpnDomainNameInfoFactory[] = 
    {
        { Py_tp_new, _new_IVpnDomainNameInfoFactory },
        { Py_tp_dealloc, _dealloc_IVpnDomainNameInfoFactory },
        { Py_tp_methods, _methods_IVpnDomainNameInfoFactory },
        { Py_tp_getset, _getset_IVpnDomainNameInfoFactory },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IVpnDomainNameInfoFactory =
    {
        "_winrt_Windows_Networking_Vpn.IVpnDomainNameInfoFactory",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnDomainNameInfoFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnDomainNameInfoFactory
    };

    // ----- IVpnInterfaceIdFactory interface --------------------
    constexpr const char* const _type_name_IVpnInterfaceIdFactory = "IVpnInterfaceIdFactory";

    static PyObject* _new_IVpnInterfaceIdFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IVpnInterfaceIdFactory);
        return nullptr;
    }

    static void _dealloc_IVpnInterfaceIdFactory(py::wrapper::Windows::Networking::Vpn::IVpnInterfaceIdFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IVpnInterfaceIdFactory_CreateVpnInterfaceId(py::wrapper::Windows::Networking::Vpn::IVpnInterfaceIdFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(self->obj.CreateVpnInterfaceId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IVpnInterfaceIdFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnInterfaceIdFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnInterfaceIdFactory[] = {
        { "create_vpn_interface_id", (PyCFunction)IVpnInterfaceIdFactory_CreateVpnInterfaceId, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IVpnInterfaceIdFactory, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IVpnInterfaceIdFactory[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IVpnInterfaceIdFactory[] = 
    {
        { Py_tp_new, _new_IVpnInterfaceIdFactory },
        { Py_tp_dealloc, _dealloc_IVpnInterfaceIdFactory },
        { Py_tp_methods, _methods_IVpnInterfaceIdFactory },
        { Py_tp_getset, _getset_IVpnInterfaceIdFactory },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IVpnInterfaceIdFactory =
    {
        "_winrt_Windows_Networking_Vpn.IVpnInterfaceIdFactory",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnInterfaceIdFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnInterfaceIdFactory
    };

    // ----- IVpnNamespaceInfoFactory interface --------------------
    constexpr const char* const _type_name_IVpnNamespaceInfoFactory = "IVpnNamespaceInfoFactory";

    static PyObject* _new_IVpnNamespaceInfoFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IVpnNamespaceInfoFactory);
        return nullptr;
    }

    static void _dealloc_IVpnNamespaceInfoFactory(py::wrapper::Windows::Networking::Vpn::IVpnNamespaceInfoFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IVpnNamespaceInfoFactory_CreateVpnNamespaceInfo(py::wrapper::Windows::Networking::Vpn::IVpnNamespaceInfoFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::HostName>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Networking::HostName>>(args, 2);

                return py::convert(self->obj.CreateVpnNamespaceInfo(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IVpnNamespaceInfoFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnNamespaceInfoFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnNamespaceInfoFactory[] = {
        { "create_vpn_namespace_info", (PyCFunction)IVpnNamespaceInfoFactory_CreateVpnNamespaceInfo, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IVpnNamespaceInfoFactory, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IVpnNamespaceInfoFactory[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IVpnNamespaceInfoFactory[] = 
    {
        { Py_tp_new, _new_IVpnNamespaceInfoFactory },
        { Py_tp_dealloc, _dealloc_IVpnNamespaceInfoFactory },
        { Py_tp_methods, _methods_IVpnNamespaceInfoFactory },
        { Py_tp_getset, _getset_IVpnNamespaceInfoFactory },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IVpnNamespaceInfoFactory =
    {
        "_winrt_Windows_Networking_Vpn.IVpnNamespaceInfoFactory",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnNamespaceInfoFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnNamespaceInfoFactory
    };

    // ----- IVpnPacketBufferFactory interface --------------------
    constexpr const char* const _type_name_IVpnPacketBufferFactory = "IVpnPacketBufferFactory";

    static PyObject* _new_IVpnPacketBufferFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IVpnPacketBufferFactory);
        return nullptr;
    }

    static void _dealloc_IVpnPacketBufferFactory(py::wrapper::Windows::Networking::Vpn::IVpnPacketBufferFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IVpnPacketBufferFactory_CreateVpnPacketBuffer(py::wrapper::Windows::Networking::Vpn::IVpnPacketBufferFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(self->obj.CreateVpnPacketBuffer(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IVpnPacketBufferFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnPacketBufferFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnPacketBufferFactory[] = {
        { "create_vpn_packet_buffer", (PyCFunction)IVpnPacketBufferFactory_CreateVpnPacketBuffer, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IVpnPacketBufferFactory, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IVpnPacketBufferFactory[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IVpnPacketBufferFactory[] = 
    {
        { Py_tp_new, _new_IVpnPacketBufferFactory },
        { Py_tp_dealloc, _dealloc_IVpnPacketBufferFactory },
        { Py_tp_methods, _methods_IVpnPacketBufferFactory },
        { Py_tp_getset, _getset_IVpnPacketBufferFactory },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IVpnPacketBufferFactory =
    {
        "_winrt_Windows_Networking_Vpn.IVpnPacketBufferFactory",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnPacketBufferFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnPacketBufferFactory
    };

    // ----- IVpnPlugIn interface --------------------
    constexpr const char* const _type_name_IVpnPlugIn = "IVpnPlugIn";

    static PyObject* _new_IVpnPlugIn(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IVpnPlugIn);
        return nullptr;
    }

    static void _dealloc_IVpnPlugIn(py::wrapper::Windows::Networking::Vpn::IVpnPlugIn* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IVpnPlugIn_Connect(py::wrapper::Windows::Networking::Vpn::IVpnPlugIn* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnChannel>(args, 0);

                self->obj.Connect(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVpnPlugIn_Decapsulate(py::wrapper::Windows::Networking::Vpn::IVpnPlugIn* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnChannel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBufferList>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBufferList>(args, 3);

                self->obj.Decapsulate(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVpnPlugIn_Disconnect(py::wrapper::Windows::Networking::Vpn::IVpnPlugIn* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnChannel>(args, 0);

                self->obj.Disconnect(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVpnPlugIn_Encapsulate(py::wrapper::Windows::Networking::Vpn::IVpnPlugIn* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnChannel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBufferList>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Vpn::VpnPacketBufferList>(args, 2);

                self->obj.Encapsulate(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVpnPlugIn_GetKeepAlivePayload(py::wrapper::Windows::Networking::Vpn::IVpnPlugIn* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Vpn::VpnChannel>(args, 0);
                winrt::Windows::Networking::Vpn::VpnPacketBuffer param1 { nullptr };

                self->obj.GetKeepAlivePayload(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IVpnPlugIn(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnPlugIn>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnPlugIn[] = {
        { "connect", (PyCFunction)IVpnPlugIn_Connect, METH_VARARGS, nullptr },
        { "decapsulate", (PyCFunction)IVpnPlugIn_Decapsulate, METH_VARARGS, nullptr },
        { "disconnect", (PyCFunction)IVpnPlugIn_Disconnect, METH_VARARGS, nullptr },
        { "encapsulate", (PyCFunction)IVpnPlugIn_Encapsulate, METH_VARARGS, nullptr },
        { "get_keep_alive_payload", (PyCFunction)IVpnPlugIn_GetKeepAlivePayload, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IVpnPlugIn, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IVpnPlugIn[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IVpnPlugIn[] = 
    {
        { Py_tp_new, _new_IVpnPlugIn },
        { Py_tp_dealloc, _dealloc_IVpnPlugIn },
        { Py_tp_methods, _methods_IVpnPlugIn },
        { Py_tp_getset, _getset_IVpnPlugIn },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IVpnPlugIn =
    {
        "_winrt_Windows_Networking_Vpn.IVpnPlugIn",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnPlugIn),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnPlugIn
    };

    // ----- IVpnProfile interface --------------------
    constexpr const char* const _type_name_IVpnProfile = "IVpnProfile";

    static PyObject* _new_IVpnProfile(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IVpnProfile);
        return nullptr;
    }

    static void _dealloc_IVpnProfile(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IVpnProfile_get_AlwaysOn(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlwaysOn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnProfile_put_AlwaysOn(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AlwaysOn(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IVpnProfile_get_AppTriggers(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppTriggers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVpnProfile_get_DomainNameInfoList(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DomainNameInfoList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVpnProfile_get_ProfileName(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnProfile_put_ProfileName(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ProfileName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IVpnProfile_get_RememberCredentials(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RememberCredentials());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IVpnProfile_put_RememberCredentials(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RememberCredentials(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IVpnProfile_get_Routes(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Routes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVpnProfile_get_TrafficFilters(py::wrapper::Windows::Networking::Vpn::IVpnProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrafficFilters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IVpnProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnProfile[] = {
        { "_from", (PyCFunction)_from_IVpnProfile, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IVpnProfile[] = {
        { const_cast<char*>("always_on"), (getter)IVpnProfile_get_AlwaysOn, (setter)IVpnProfile_put_AlwaysOn, nullptr, nullptr },
        { const_cast<char*>("app_triggers"), (getter)IVpnProfile_get_AppTriggers, nullptr, nullptr, nullptr },
        { const_cast<char*>("domain_name_info_list"), (getter)IVpnProfile_get_DomainNameInfoList, nullptr, nullptr, nullptr },
        { const_cast<char*>("profile_name"), (getter)IVpnProfile_get_ProfileName, (setter)IVpnProfile_put_ProfileName, nullptr, nullptr },
        { const_cast<char*>("remember_credentials"), (getter)IVpnProfile_get_RememberCredentials, (setter)IVpnProfile_put_RememberCredentials, nullptr, nullptr },
        { const_cast<char*>("routes"), (getter)IVpnProfile_get_Routes, nullptr, nullptr, nullptr },
        { const_cast<char*>("traffic_filters"), (getter)IVpnProfile_get_TrafficFilters, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IVpnProfile[] = 
    {
        { Py_tp_new, _new_IVpnProfile },
        { Py_tp_dealloc, _dealloc_IVpnProfile },
        { Py_tp_methods, _methods_IVpnProfile },
        { Py_tp_getset, _getset_IVpnProfile },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IVpnProfile =
    {
        "_winrt_Windows_Networking_Vpn.IVpnProfile",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnProfile
    };

    // ----- IVpnRouteFactory interface --------------------
    constexpr const char* const _type_name_IVpnRouteFactory = "IVpnRouteFactory";

    static PyObject* _new_IVpnRouteFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IVpnRouteFactory);
        return nullptr;
    }

    static void _dealloc_IVpnRouteFactory(py::wrapper::Windows::Networking::Vpn::IVpnRouteFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IVpnRouteFactory_CreateVpnRoute(py::wrapper::Windows::Networking::Vpn::IVpnRouteFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);

                return py::convert(self->obj.CreateVpnRoute(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IVpnRouteFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Vpn::IVpnRouteFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVpnRouteFactory[] = {
        { "create_vpn_route", (PyCFunction)IVpnRouteFactory_CreateVpnRoute, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IVpnRouteFactory, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IVpnRouteFactory[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IVpnRouteFactory[] = 
    {
        { Py_tp_new, _new_IVpnRouteFactory },
        { Py_tp_dealloc, _dealloc_IVpnRouteFactory },
        { Py_tp_methods, _methods_IVpnRouteFactory },
        { Py_tp_getset, _getset_IVpnRouteFactory },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IVpnRouteFactory =
    {
        "_winrt_Windows_Networking_Vpn.IVpnRouteFactory",
        sizeof(py::wrapper::Windows::Networking::Vpn::IVpnRouteFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVpnRouteFactory
    };

    // ----- Windows.Networking.Vpn Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Networking::Vpn::VpnAppId>::python_type = py::register_python_type(module, _type_name_VpnAppId, &_type_spec_VpnAppId, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnChannel>::python_type = py::register_python_type(module, _type_name_VpnChannel, &_type_spec_VpnChannel, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnChannelActivityEventArgs>::python_type = py::register_python_type(module, _type_name_VpnChannelActivityEventArgs, &_type_spec_VpnChannelActivityEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnChannelActivityStateChangedArgs>::python_type = py::register_python_type(module, _type_name_VpnChannelActivityStateChangedArgs, &_type_spec_VpnChannelActivityStateChangedArgs, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnChannelConfiguration>::python_type = py::register_python_type(module, _type_name_VpnChannelConfiguration, &_type_spec_VpnChannelConfiguration, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnCredential>::python_type = py::register_python_type(module, _type_name_VpnCredential, &_type_spec_VpnCredential, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnCustomCheckBox>::python_type = py::register_python_type(module, _type_name_VpnCustomCheckBox, &_type_spec_VpnCustomCheckBox, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnCustomComboBox>::python_type = py::register_python_type(module, _type_name_VpnCustomComboBox, &_type_spec_VpnCustomComboBox, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnCustomEditBox>::python_type = py::register_python_type(module, _type_name_VpnCustomEditBox, &_type_spec_VpnCustomEditBox, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnCustomErrorBox>::python_type = py::register_python_type(module, _type_name_VpnCustomErrorBox, &_type_spec_VpnCustomErrorBox, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnCustomPromptBooleanInput>::python_type = py::register_python_type(module, _type_name_VpnCustomPromptBooleanInput, &_type_spec_VpnCustomPromptBooleanInput, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnCustomPromptOptionSelector>::python_type = py::register_python_type(module, _type_name_VpnCustomPromptOptionSelector, &_type_spec_VpnCustomPromptOptionSelector, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnCustomPromptText>::python_type = py::register_python_type(module, _type_name_VpnCustomPromptText, &_type_spec_VpnCustomPromptText, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnCustomPromptTextInput>::python_type = py::register_python_type(module, _type_name_VpnCustomPromptTextInput, &_type_spec_VpnCustomPromptTextInput, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnCustomTextBox>::python_type = py::register_python_type(module, _type_name_VpnCustomTextBox, &_type_spec_VpnCustomTextBox, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnDomainNameAssignment>::python_type = py::register_python_type(module, _type_name_VpnDomainNameAssignment, &_type_spec_VpnDomainNameAssignment, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnDomainNameInfo>::python_type = py::register_python_type(module, _type_name_VpnDomainNameInfo, &_type_spec_VpnDomainNameInfo, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnForegroundActivatedEventArgs>::python_type = py::register_python_type(module, _type_name_VpnForegroundActivatedEventArgs, &_type_spec_VpnForegroundActivatedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnForegroundActivationOperation>::python_type = py::register_python_type(module, _type_name_VpnForegroundActivationOperation, &_type_spec_VpnForegroundActivationOperation, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnInterfaceId>::python_type = py::register_python_type(module, _type_name_VpnInterfaceId, &_type_spec_VpnInterfaceId, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnManagementAgent>::python_type = py::register_python_type(module, _type_name_VpnManagementAgent, &_type_spec_VpnManagementAgent, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnNamespaceAssignment>::python_type = py::register_python_type(module, _type_name_VpnNamespaceAssignment, &_type_spec_VpnNamespaceAssignment, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnNamespaceInfo>::python_type = py::register_python_type(module, _type_name_VpnNamespaceInfo, &_type_spec_VpnNamespaceInfo, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnNativeProfile>::python_type = py::register_python_type(module, _type_name_VpnNativeProfile, &_type_spec_VpnNativeProfile, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnPacketBuffer>::python_type = py::register_python_type(module, _type_name_VpnPacketBuffer, &_type_spec_VpnPacketBuffer, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnPacketBufferList>::python_type = py::register_python_type(module, _type_name_VpnPacketBufferList, &_type_spec_VpnPacketBufferList, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnPickedCredential>::python_type = py::register_python_type(module, _type_name_VpnPickedCredential, &_type_spec_VpnPickedCredential, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnPlugInProfile>::python_type = py::register_python_type(module, _type_name_VpnPlugInProfile, &_type_spec_VpnPlugInProfile, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnRoute>::python_type = py::register_python_type(module, _type_name_VpnRoute, &_type_spec_VpnRoute, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnRouteAssignment>::python_type = py::register_python_type(module, _type_name_VpnRouteAssignment, &_type_spec_VpnRouteAssignment, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnSystemHealth>::python_type = py::register_python_type(module, _type_name_VpnSystemHealth, &_type_spec_VpnSystemHealth, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnTrafficFilter>::python_type = py::register_python_type(module, _type_name_VpnTrafficFilter, &_type_spec_VpnTrafficFilter, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::VpnTrafficFilterAssignment>::python_type = py::register_python_type(module, _type_name_VpnTrafficFilterAssignment, &_type_spec_VpnTrafficFilterAssignment, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::IVpnChannelStatics>::python_type = py::register_python_type(module, _type_name_IVpnChannelStatics, &_type_spec_IVpnChannelStatics, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::IVpnCredential>::python_type = py::register_python_type(module, _type_name_IVpnCredential, &_type_spec_IVpnCredential, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::IVpnCustomPrompt>::python_type = py::register_python_type(module, _type_name_IVpnCustomPrompt, &_type_spec_IVpnCustomPrompt, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::IVpnCustomPromptElement>::python_type = py::register_python_type(module, _type_name_IVpnCustomPromptElement, &_type_spec_IVpnCustomPromptElement, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::IVpnDomainNameInfoFactory>::python_type = py::register_python_type(module, _type_name_IVpnDomainNameInfoFactory, &_type_spec_IVpnDomainNameInfoFactory, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::IVpnInterfaceIdFactory>::python_type = py::register_python_type(module, _type_name_IVpnInterfaceIdFactory, &_type_spec_IVpnInterfaceIdFactory, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::IVpnNamespaceInfoFactory>::python_type = py::register_python_type(module, _type_name_IVpnNamespaceInfoFactory, &_type_spec_IVpnNamespaceInfoFactory, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::IVpnPacketBufferFactory>::python_type = py::register_python_type(module, _type_name_IVpnPacketBufferFactory, &_type_spec_IVpnPacketBufferFactory, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::IVpnPlugIn>::python_type = py::register_python_type(module, _type_name_IVpnPlugIn, &_type_spec_IVpnPlugIn, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::IVpnProfile>::python_type = py::register_python_type(module, _type_name_IVpnProfile, &_type_spec_IVpnProfile, bases.get());
            py::winrt_type<winrt::Windows::Networking::Vpn::IVpnRouteFactory>::python_type = py::register_python_type(module, _type_name_IVpnRouteFactory, &_type_spec_IVpnRouteFactory, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Networking.Vpn");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Networking_Vpn",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Networking::Vpn

PyMODINIT_FUNC
PyInit__winrt_Windows_Networking_Vpn (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Networking::Vpn::module_def);
}
