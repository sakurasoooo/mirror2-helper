// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Devices.Lights.Effects.h"

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayBitmapEffect>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayBlinkEffect>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayColorRampEffect>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayCustomEffect>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArraySolidEffect>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect>::python_type;

namespace py::cpp::Windows::Devices::Lights::Effects
{
    // ----- LampArrayBitmapEffect class --------------------
    constexpr const char* const _type_name_LampArrayBitmapEffect = "LampArrayBitmapEffect";

    static PyObject* _new_LampArrayBitmapEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Lights::LampArray>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);

                winrt::Windows::Devices::Lights::Effects::LampArrayBitmapEffect instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LampArrayBitmapEffect(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LampArrayBitmapEffect_get_UpdateInterval(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBitmapEffect_put_UpdateInterval(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.UpdateInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBitmapEffect_get_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBitmapEffect_put_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBitmapEffect_get_Duration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBitmapEffect_put_Duration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBitmapEffect_get_SuggestedBitmapSize(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuggestedBitmapSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LampArrayBitmapEffect_get_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBitmapEffect_put_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBitmapEffect_add_BitmapRequested(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Lights::Effects::LampArrayBitmapEffect, winrt::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs>>(arg);

            return py::convert(self->obj.BitmapRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LampArrayBitmapEffect_remove_BitmapRequested(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BitmapRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LampArrayBitmapEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArrayBitmapEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArrayBitmapEffect[] = {
        { "add_bitmap_requested", (PyCFunction)LampArrayBitmapEffect_add_BitmapRequested, METH_O, nullptr },
        { "remove_bitmap_requested", (PyCFunction)LampArrayBitmapEffect_remove_BitmapRequested, METH_O, nullptr },
        { "_from", (PyCFunction)_from_LampArrayBitmapEffect, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LampArrayBitmapEffect[] = {
        { const_cast<char*>("update_interval"), (getter)LampArrayBitmapEffect_get_UpdateInterval, (setter)LampArrayBitmapEffect_put_UpdateInterval, nullptr, nullptr },
        { const_cast<char*>("start_delay"), (getter)LampArrayBitmapEffect_get_StartDelay, (setter)LampArrayBitmapEffect_put_StartDelay, nullptr, nullptr },
        { const_cast<char*>("duration"), (getter)LampArrayBitmapEffect_get_Duration, (setter)LampArrayBitmapEffect_put_Duration, nullptr, nullptr },
        { const_cast<char*>("suggested_bitmap_size"), (getter)LampArrayBitmapEffect_get_SuggestedBitmapSize, nullptr, nullptr, nullptr },
        { const_cast<char*>("z_index"), (getter)LampArrayBitmapEffect_get_ZIndex, (setter)LampArrayBitmapEffect_put_ZIndex, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LampArrayBitmapEffect[] = 
    {
        { Py_tp_new, _new_LampArrayBitmapEffect },
        { Py_tp_dealloc, _dealloc_LampArrayBitmapEffect },
        { Py_tp_methods, _methods_LampArrayBitmapEffect },
        { Py_tp_getset, _getset_LampArrayBitmapEffect },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LampArrayBitmapEffect =
    {
        "_winrt_Windows_Devices_Lights_Effects.LampArrayBitmapEffect",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArrayBitmapEffect
    };

    // ----- LampArrayBitmapRequestedEventArgs class --------------------
    constexpr const char* const _type_name_LampArrayBitmapRequestedEventArgs = "LampArrayBitmapRequestedEventArgs";

    static PyObject* _new_LampArrayBitmapRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LampArrayBitmapRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_LampArrayBitmapRequestedEventArgs(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LampArrayBitmapRequestedEventArgs_UpdateBitmap(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);

                self->obj.UpdateBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayBitmapRequestedEventArgs_get_SinceStarted(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SinceStarted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LampArrayBitmapRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArrayBitmapRequestedEventArgs[] = {
        { "update_bitmap", (PyCFunction)LampArrayBitmapRequestedEventArgs_UpdateBitmap, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_LampArrayBitmapRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LampArrayBitmapRequestedEventArgs[] = {
        { const_cast<char*>("since_started"), (getter)LampArrayBitmapRequestedEventArgs_get_SinceStarted, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LampArrayBitmapRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_LampArrayBitmapRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_LampArrayBitmapRequestedEventArgs },
        { Py_tp_methods, _methods_LampArrayBitmapRequestedEventArgs },
        { Py_tp_getset, _getset_LampArrayBitmapRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LampArrayBitmapRequestedEventArgs =
    {
        "_winrt_Windows_Devices_Lights_Effects.LampArrayBitmapRequestedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArrayBitmapRequestedEventArgs
    };

    // ----- LampArrayBlinkEffect class --------------------
    constexpr const char* const _type_name_LampArrayBlinkEffect = "LampArrayBlinkEffect";

    static PyObject* _new_LampArrayBlinkEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Lights::LampArray>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);

                winrt::Windows::Devices::Lights::Effects::LampArrayBlinkEffect instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LampArrayBlinkEffect(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LampArrayBlinkEffect_get_SustainDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SustainDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_SustainDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.SustainDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_RepetitionMode(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RepetitionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_RepetitionMode(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Lights::Effects::LampArrayRepetitionMode>(arg);

            self->obj.RepetitionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_RepetitionDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RepetitionDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_RepetitionDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.RepetitionDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_Occurrences(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Occurrences());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_Occurrences(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Occurrences(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_DecayDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecayDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_DecayDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DecayDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_Color(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_Color(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_AttackDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AttackDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_AttackDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.AttackDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_LampArrayBlinkEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArrayBlinkEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArrayBlinkEffect[] = {
        { "_from", (PyCFunction)_from_LampArrayBlinkEffect, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LampArrayBlinkEffect[] = {
        { const_cast<char*>("sustain_duration"), (getter)LampArrayBlinkEffect_get_SustainDuration, (setter)LampArrayBlinkEffect_put_SustainDuration, nullptr, nullptr },
        { const_cast<char*>("start_delay"), (getter)LampArrayBlinkEffect_get_StartDelay, (setter)LampArrayBlinkEffect_put_StartDelay, nullptr, nullptr },
        { const_cast<char*>("repetition_mode"), (getter)LampArrayBlinkEffect_get_RepetitionMode, (setter)LampArrayBlinkEffect_put_RepetitionMode, nullptr, nullptr },
        { const_cast<char*>("repetition_delay"), (getter)LampArrayBlinkEffect_get_RepetitionDelay, (setter)LampArrayBlinkEffect_put_RepetitionDelay, nullptr, nullptr },
        { const_cast<char*>("occurrences"), (getter)LampArrayBlinkEffect_get_Occurrences, (setter)LampArrayBlinkEffect_put_Occurrences, nullptr, nullptr },
        { const_cast<char*>("decay_duration"), (getter)LampArrayBlinkEffect_get_DecayDuration, (setter)LampArrayBlinkEffect_put_DecayDuration, nullptr, nullptr },
        { const_cast<char*>("color"), (getter)LampArrayBlinkEffect_get_Color, (setter)LampArrayBlinkEffect_put_Color, nullptr, nullptr },
        { const_cast<char*>("attack_duration"), (getter)LampArrayBlinkEffect_get_AttackDuration, (setter)LampArrayBlinkEffect_put_AttackDuration, nullptr, nullptr },
        { const_cast<char*>("z_index"), (getter)LampArrayBlinkEffect_get_ZIndex, (setter)LampArrayBlinkEffect_put_ZIndex, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LampArrayBlinkEffect[] = 
    {
        { Py_tp_new, _new_LampArrayBlinkEffect },
        { Py_tp_dealloc, _dealloc_LampArrayBlinkEffect },
        { Py_tp_methods, _methods_LampArrayBlinkEffect },
        { Py_tp_getset, _getset_LampArrayBlinkEffect },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LampArrayBlinkEffect =
    {
        "_winrt_Windows_Devices_Lights_Effects.LampArrayBlinkEffect",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArrayBlinkEffect
    };

    // ----- LampArrayColorRampEffect class --------------------
    constexpr const char* const _type_name_LampArrayColorRampEffect = "LampArrayColorRampEffect";

    static PyObject* _new_LampArrayColorRampEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Lights::LampArray>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);

                winrt::Windows::Devices::Lights::Effects::LampArrayColorRampEffect instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LampArrayColorRampEffect(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LampArrayColorRampEffect_get_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayColorRampEffect_put_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayColorRampEffect_get_RampDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RampDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayColorRampEffect_put_RampDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.RampDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayColorRampEffect_get_CompletionBehavior(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CompletionBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayColorRampEffect_put_CompletionBehavior(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Lights::Effects::LampArrayEffectCompletionBehavior>(arg);

            self->obj.CompletionBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayColorRampEffect_get_Color(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayColorRampEffect_put_Color(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayColorRampEffect_get_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayColorRampEffect_put_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_LampArrayColorRampEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArrayColorRampEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArrayColorRampEffect[] = {
        { "_from", (PyCFunction)_from_LampArrayColorRampEffect, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LampArrayColorRampEffect[] = {
        { const_cast<char*>("start_delay"), (getter)LampArrayColorRampEffect_get_StartDelay, (setter)LampArrayColorRampEffect_put_StartDelay, nullptr, nullptr },
        { const_cast<char*>("ramp_duration"), (getter)LampArrayColorRampEffect_get_RampDuration, (setter)LampArrayColorRampEffect_put_RampDuration, nullptr, nullptr },
        { const_cast<char*>("completion_behavior"), (getter)LampArrayColorRampEffect_get_CompletionBehavior, (setter)LampArrayColorRampEffect_put_CompletionBehavior, nullptr, nullptr },
        { const_cast<char*>("color"), (getter)LampArrayColorRampEffect_get_Color, (setter)LampArrayColorRampEffect_put_Color, nullptr, nullptr },
        { const_cast<char*>("z_index"), (getter)LampArrayColorRampEffect_get_ZIndex, (setter)LampArrayColorRampEffect_put_ZIndex, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LampArrayColorRampEffect[] = 
    {
        { Py_tp_new, _new_LampArrayColorRampEffect },
        { Py_tp_dealloc, _dealloc_LampArrayColorRampEffect },
        { Py_tp_methods, _methods_LampArrayColorRampEffect },
        { Py_tp_getset, _getset_LampArrayColorRampEffect },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LampArrayColorRampEffect =
    {
        "_winrt_Windows_Devices_Lights_Effects.LampArrayColorRampEffect",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArrayColorRampEffect
    };

    // ----- LampArrayCustomEffect class --------------------
    constexpr const char* const _type_name_LampArrayCustomEffect = "LampArrayCustomEffect";

    static PyObject* _new_LampArrayCustomEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Lights::LampArray>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);

                winrt::Windows::Devices::Lights::Effects::LampArrayCustomEffect instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LampArrayCustomEffect(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LampArrayCustomEffect_get_UpdateInterval(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayCustomEffect_put_UpdateInterval(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.UpdateInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayCustomEffect_get_Duration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayCustomEffect_put_Duration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayCustomEffect_get_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayCustomEffect_put_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayCustomEffect_add_UpdateRequested(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Lights::Effects::LampArrayCustomEffect, winrt::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs>>(arg);

            return py::convert(self->obj.UpdateRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LampArrayCustomEffect_remove_UpdateRequested(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UpdateRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LampArrayCustomEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArrayCustomEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArrayCustomEffect[] = {
        { "add_update_requested", (PyCFunction)LampArrayCustomEffect_add_UpdateRequested, METH_O, nullptr },
        { "remove_update_requested", (PyCFunction)LampArrayCustomEffect_remove_UpdateRequested, METH_O, nullptr },
        { "_from", (PyCFunction)_from_LampArrayCustomEffect, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LampArrayCustomEffect[] = {
        { const_cast<char*>("update_interval"), (getter)LampArrayCustomEffect_get_UpdateInterval, (setter)LampArrayCustomEffect_put_UpdateInterval, nullptr, nullptr },
        { const_cast<char*>("duration"), (getter)LampArrayCustomEffect_get_Duration, (setter)LampArrayCustomEffect_put_Duration, nullptr, nullptr },
        { const_cast<char*>("z_index"), (getter)LampArrayCustomEffect_get_ZIndex, (setter)LampArrayCustomEffect_put_ZIndex, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LampArrayCustomEffect[] = 
    {
        { Py_tp_new, _new_LampArrayCustomEffect },
        { Py_tp_dealloc, _dealloc_LampArrayCustomEffect },
        { Py_tp_methods, _methods_LampArrayCustomEffect },
        { Py_tp_getset, _getset_LampArrayCustomEffect },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LampArrayCustomEffect =
    {
        "_winrt_Windows_Devices_Lights_Effects.LampArrayCustomEffect",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArrayCustomEffect
    };

    // ----- LampArrayEffectPlaylist class --------------------
    constexpr const char* const _type_name_LampArrayEffectPlaylist = "LampArrayEffectPlaylist";

    static PyObject* _new_LampArrayEffectPlaylist(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LampArrayEffectPlaylist(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LampArrayEffectPlaylist_Append(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_First(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_GetAt(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_GetMany(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect> param1 ( param1_count, py::empty_instance<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect>::get() );

                auto return_value = self->obj.GetMany(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_IndexOf(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_OverrideZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.OverrideZIndex(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_Pause(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Pause();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_PauseAll(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist>>(args, 0);

                winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist::PauseAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_Start(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_StartAll(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist>>(args, 0);

                winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist::StartAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_Stop(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_StopAll(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist>>(args, 0);

                winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist::StopAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_get_RepetitionMode(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RepetitionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayEffectPlaylist_put_RepetitionMode(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Lights::Effects::LampArrayRepetitionMode>(arg);

            self->obj.RepetitionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayEffectPlaylist_get_Occurrences(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Occurrences());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayEffectPlaylist_put_Occurrences(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Occurrences(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayEffectPlaylist_get_EffectStartMode(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectStartMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayEffectPlaylist_put_EffectStartMode(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Lights::Effects::LampArrayEffectStartMode>(arg);

            self->obj.EffectStartMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayEffectPlaylist_get_Size(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LampArrayEffectPlaylist(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_LampArrayEffectPlaylist(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_LampArrayEffectPlaylist(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_LampArrayEffectPlaylist(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArrayEffectPlaylist[] = {
        { "append", (PyCFunction)LampArrayEffectPlaylist_Append, METH_VARARGS, nullptr },
        { "first", (PyCFunction)LampArrayEffectPlaylist_First, METH_VARARGS, nullptr },
        { "get_at", (PyCFunction)LampArrayEffectPlaylist_GetAt, METH_VARARGS, nullptr },
        { "get_many", (PyCFunction)LampArrayEffectPlaylist_GetMany, METH_VARARGS, nullptr },
        { "index_of", (PyCFunction)LampArrayEffectPlaylist_IndexOf, METH_VARARGS, nullptr },
        { "override_z_index", (PyCFunction)LampArrayEffectPlaylist_OverrideZIndex, METH_VARARGS, nullptr },
        { "pause", (PyCFunction)LampArrayEffectPlaylist_Pause, METH_VARARGS, nullptr },
        { "pause_all", (PyCFunction)LampArrayEffectPlaylist_PauseAll, METH_VARARGS | METH_STATIC, nullptr },
        { "start", (PyCFunction)LampArrayEffectPlaylist_Start, METH_VARARGS, nullptr },
        { "start_all", (PyCFunction)LampArrayEffectPlaylist_StartAll, METH_VARARGS | METH_STATIC, nullptr },
        { "stop", (PyCFunction)LampArrayEffectPlaylist_Stop, METH_VARARGS, nullptr },
        { "stop_all", (PyCFunction)LampArrayEffectPlaylist_StopAll, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_LampArrayEffectPlaylist, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LampArrayEffectPlaylist[] = {
        { const_cast<char*>("repetition_mode"), (getter)LampArrayEffectPlaylist_get_RepetitionMode, (setter)LampArrayEffectPlaylist_put_RepetitionMode, nullptr, nullptr },
        { const_cast<char*>("occurrences"), (getter)LampArrayEffectPlaylist_get_Occurrences, (setter)LampArrayEffectPlaylist_put_Occurrences, nullptr, nullptr },
        { const_cast<char*>("effect_start_mode"), (getter)LampArrayEffectPlaylist_get_EffectStartMode, (setter)LampArrayEffectPlaylist_put_EffectStartMode, nullptr, nullptr },
        { const_cast<char*>("size"), (getter)LampArrayEffectPlaylist_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LampArrayEffectPlaylist[] = 
    {
        { Py_tp_new, _new_LampArrayEffectPlaylist },
        { Py_tp_dealloc, _dealloc_LampArrayEffectPlaylist },
        { Py_tp_methods, _methods_LampArrayEffectPlaylist },
        { Py_tp_getset, _getset_LampArrayEffectPlaylist },
        { Py_tp_iter, _iterator_LampArrayEffectPlaylist },
        { Py_sq_length, _seq_length_LampArrayEffectPlaylist },
        { Py_sq_item, _seq_item_LampArrayEffectPlaylist },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LampArrayEffectPlaylist =
    {
        "_winrt_Windows_Devices_Lights_Effects.LampArrayEffectPlaylist",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArrayEffectPlaylist
    };

    // ----- LampArraySolidEffect class --------------------
    constexpr const char* const _type_name_LampArraySolidEffect = "LampArraySolidEffect";

    static PyObject* _new_LampArraySolidEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Lights::LampArray>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);

                winrt::Windows::Devices::Lights::Effects::LampArraySolidEffect instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LampArraySolidEffect(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LampArraySolidEffect_get_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArraySolidEffect_put_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArraySolidEffect_get_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArraySolidEffect_put_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArraySolidEffect_get_Duration(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArraySolidEffect_put_Duration(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArraySolidEffect_get_CompletionBehavior(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CompletionBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArraySolidEffect_put_CompletionBehavior(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Lights::Effects::LampArrayEffectCompletionBehavior>(arg);

            self->obj.CompletionBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArraySolidEffect_get_Color(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArraySolidEffect_put_Color(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_LampArraySolidEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArraySolidEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArraySolidEffect[] = {
        { "_from", (PyCFunction)_from_LampArraySolidEffect, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LampArraySolidEffect[] = {
        { const_cast<char*>("z_index"), (getter)LampArraySolidEffect_get_ZIndex, (setter)LampArraySolidEffect_put_ZIndex, nullptr, nullptr },
        { const_cast<char*>("start_delay"), (getter)LampArraySolidEffect_get_StartDelay, (setter)LampArraySolidEffect_put_StartDelay, nullptr, nullptr },
        { const_cast<char*>("duration"), (getter)LampArraySolidEffect_get_Duration, (setter)LampArraySolidEffect_put_Duration, nullptr, nullptr },
        { const_cast<char*>("completion_behavior"), (getter)LampArraySolidEffect_get_CompletionBehavior, (setter)LampArraySolidEffect_put_CompletionBehavior, nullptr, nullptr },
        { const_cast<char*>("color"), (getter)LampArraySolidEffect_get_Color, (setter)LampArraySolidEffect_put_Color, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LampArraySolidEffect[] = 
    {
        { Py_tp_new, _new_LampArraySolidEffect },
        { Py_tp_dealloc, _dealloc_LampArraySolidEffect },
        { Py_tp_methods, _methods_LampArraySolidEffect },
        { Py_tp_getset, _getset_LampArraySolidEffect },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LampArraySolidEffect =
    {
        "_winrt_Windows_Devices_Lights_Effects.LampArraySolidEffect",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArraySolidEffect
    };

    // ----- LampArrayUpdateRequestedEventArgs class --------------------
    constexpr const char* const _type_name_LampArrayUpdateRequestedEventArgs = "LampArrayUpdateRequestedEventArgs";

    static PyObject* _new_LampArrayUpdateRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LampArrayUpdateRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_LampArrayUpdateRequestedEventArgs(py::wrapper::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LampArrayUpdateRequestedEventArgs_SetColor(py::wrapper::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Color>(args, 0);

                self->obj.SetColor(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayUpdateRequestedEventArgs_SetColorForIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Color>(args, 1);

                self->obj.SetColorForIndex(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayUpdateRequestedEventArgs_SetColorsForIndices(py::wrapper::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::UI::Color>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);

                self->obj.SetColorsForIndices(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayUpdateRequestedEventArgs_SetSingleColorForIndices(py::wrapper::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Color>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);

                self->obj.SetSingleColorForIndices(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayUpdateRequestedEventArgs_get_SinceStarted(py::wrapper::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SinceStarted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LampArrayUpdateRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArrayUpdateRequestedEventArgs[] = {
        { "set_color", (PyCFunction)LampArrayUpdateRequestedEventArgs_SetColor, METH_VARARGS, nullptr },
        { "set_color_for_index", (PyCFunction)LampArrayUpdateRequestedEventArgs_SetColorForIndex, METH_VARARGS, nullptr },
        { "set_colors_for_indices", (PyCFunction)LampArrayUpdateRequestedEventArgs_SetColorsForIndices, METH_VARARGS, nullptr },
        { "set_single_color_for_indices", (PyCFunction)LampArrayUpdateRequestedEventArgs_SetSingleColorForIndices, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_LampArrayUpdateRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LampArrayUpdateRequestedEventArgs[] = {
        { const_cast<char*>("since_started"), (getter)LampArrayUpdateRequestedEventArgs_get_SinceStarted, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LampArrayUpdateRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_LampArrayUpdateRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_LampArrayUpdateRequestedEventArgs },
        { Py_tp_methods, _methods_LampArrayUpdateRequestedEventArgs },
        { Py_tp_getset, _getset_LampArrayUpdateRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LampArrayUpdateRequestedEventArgs =
    {
        "_winrt_Windows_Devices_Lights_Effects.LampArrayUpdateRequestedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArrayUpdateRequestedEventArgs
    };

    // ----- ILampArrayEffect interface --------------------
    constexpr const char* const _type_name_ILampArrayEffect = "ILampArrayEffect";

    static PyObject* _new_ILampArrayEffect(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ILampArrayEffect);
        return nullptr;
    }

    static void _dealloc_ILampArrayEffect(py::wrapper::Windows::Devices::Lights::Effects::ILampArrayEffect* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ILampArrayEffect_get_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::ILampArrayEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ILampArrayEffect_put_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::ILampArrayEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ILampArrayEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILampArrayEffect[] = {
        { "_from", (PyCFunction)_from_ILampArrayEffect, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ILampArrayEffect[] = {
        { const_cast<char*>("z_index"), (getter)ILampArrayEffect_get_ZIndex, (setter)ILampArrayEffect_put_ZIndex, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ILampArrayEffect[] = 
    {
        { Py_tp_new, _new_ILampArrayEffect },
        { Py_tp_dealloc, _dealloc_ILampArrayEffect },
        { Py_tp_methods, _methods_ILampArrayEffect },
        { Py_tp_getset, _getset_ILampArrayEffect },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ILampArrayEffect =
    {
        "_winrt_Windows_Devices_Lights_Effects.ILampArrayEffect",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::ILampArrayEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILampArrayEffect
    };

    // ----- Windows.Devices.Lights.Effects Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayBitmapEffect>::python_type = py::register_python_type(module, _type_name_LampArrayBitmapEffect, &_type_spec_LampArrayBitmapEffect, bases.get());
            py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_LampArrayBitmapRequestedEventArgs, &_type_spec_LampArrayBitmapRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayBlinkEffect>::python_type = py::register_python_type(module, _type_name_LampArrayBlinkEffect, &_type_spec_LampArrayBlinkEffect, bases.get());
            py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayColorRampEffect>::python_type = py::register_python_type(module, _type_name_LampArrayColorRampEffect, &_type_spec_LampArrayColorRampEffect, bases.get());
            py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayCustomEffect>::python_type = py::register_python_type(module, _type_name_LampArrayCustomEffect, &_type_spec_LampArrayCustomEffect, bases.get());
            py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist>::python_type = py::register_python_type(module, _type_name_LampArrayEffectPlaylist, &_type_spec_LampArrayEffectPlaylist, bases.get());
            py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArraySolidEffect>::python_type = py::register_python_type(module, _type_name_LampArraySolidEffect, &_type_spec_LampArraySolidEffect, bases.get());
            py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_LampArrayUpdateRequestedEventArgs, &_type_spec_LampArrayUpdateRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect>::python_type = py::register_python_type(module, _type_name_ILampArrayEffect, &_type_spec_ILampArrayEffect, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Devices.Lights.Effects");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Devices_Lights_Effects",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Devices::Lights::Effects

PyMODINIT_FUNC
PyInit__winrt_Windows_Devices_Lights_Effects (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Devices::Lights::Effects::module_def);
}
