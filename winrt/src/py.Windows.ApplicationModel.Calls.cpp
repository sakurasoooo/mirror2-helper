// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.ApplicationModel.Calls.h"

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::CallAnswerEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::CallRejectEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::MuteChangeEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCall>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStore>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallStore>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilitiesManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallsResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneDialOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLine>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineCellularDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineDialResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneVoicemail>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall>::python_type;

namespace py::cpp::Windows::ApplicationModel::Calls
{
    // ----- CallAnswerEventArgs class --------------------
    constexpr const char* const _type_name_CallAnswerEventArgs = "CallAnswerEventArgs";

    static PyObject* _new_CallAnswerEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CallAnswerEventArgs);
        return nullptr;
    }

    static void _dealloc_CallAnswerEventArgs(py::wrapper::Windows::ApplicationModel::Calls::CallAnswerEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CallAnswerEventArgs_get_AcceptedMedia(py::wrapper::Windows::ApplicationModel::Calls::CallAnswerEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AcceptedMedia());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CallAnswerEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::CallAnswerEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CallAnswerEventArgs[] = {
        { "_from", (PyCFunction)_from_CallAnswerEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CallAnswerEventArgs[] = {
        { const_cast<char*>("accepted_media"), (getter)CallAnswerEventArgs_get_AcceptedMedia, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CallAnswerEventArgs[] = 
    {
        { Py_tp_new, _new_CallAnswerEventArgs },
        { Py_tp_dealloc, _dealloc_CallAnswerEventArgs },
        { Py_tp_methods, _methods_CallAnswerEventArgs },
        { Py_tp_getset, _getset_CallAnswerEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CallAnswerEventArgs =
    {
        "_winrt_Windows_ApplicationModel_Calls.CallAnswerEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::CallAnswerEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CallAnswerEventArgs
    };

    // ----- CallRejectEventArgs class --------------------
    constexpr const char* const _type_name_CallRejectEventArgs = "CallRejectEventArgs";

    static PyObject* _new_CallRejectEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CallRejectEventArgs);
        return nullptr;
    }

    static void _dealloc_CallRejectEventArgs(py::wrapper::Windows::ApplicationModel::Calls::CallRejectEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CallRejectEventArgs_get_RejectReason(py::wrapper::Windows::ApplicationModel::Calls::CallRejectEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RejectReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CallRejectEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::CallRejectEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CallRejectEventArgs[] = {
        { "_from", (PyCFunction)_from_CallRejectEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CallRejectEventArgs[] = {
        { const_cast<char*>("reject_reason"), (getter)CallRejectEventArgs_get_RejectReason, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CallRejectEventArgs[] = 
    {
        { Py_tp_new, _new_CallRejectEventArgs },
        { Py_tp_dealloc, _dealloc_CallRejectEventArgs },
        { Py_tp_methods, _methods_CallRejectEventArgs },
        { Py_tp_getset, _getset_CallRejectEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CallRejectEventArgs =
    {
        "_winrt_Windows_ApplicationModel_Calls.CallRejectEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::CallRejectEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CallRejectEventArgs
    };

    // ----- CallStateChangeEventArgs class --------------------
    constexpr const char* const _type_name_CallStateChangeEventArgs = "CallStateChangeEventArgs";

    static PyObject* _new_CallStateChangeEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CallStateChangeEventArgs);
        return nullptr;
    }

    static void _dealloc_CallStateChangeEventArgs(py::wrapper::Windows::ApplicationModel::Calls::CallStateChangeEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CallStateChangeEventArgs_get_State(py::wrapper::Windows::ApplicationModel::Calls::CallStateChangeEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CallStateChangeEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CallStateChangeEventArgs[] = {
        { "_from", (PyCFunction)_from_CallStateChangeEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CallStateChangeEventArgs[] = {
        { const_cast<char*>("state"), (getter)CallStateChangeEventArgs_get_State, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CallStateChangeEventArgs[] = 
    {
        { Py_tp_new, _new_CallStateChangeEventArgs },
        { Py_tp_dealloc, _dealloc_CallStateChangeEventArgs },
        { Py_tp_methods, _methods_CallStateChangeEventArgs },
        { Py_tp_getset, _getset_CallStateChangeEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CallStateChangeEventArgs =
    {
        "_winrt_Windows_ApplicationModel_Calls.CallStateChangeEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::CallStateChangeEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CallStateChangeEventArgs
    };

    // ----- MuteChangeEventArgs class --------------------
    constexpr const char* const _type_name_MuteChangeEventArgs = "MuteChangeEventArgs";

    static PyObject* _new_MuteChangeEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MuteChangeEventArgs);
        return nullptr;
    }

    static void _dealloc_MuteChangeEventArgs(py::wrapper::Windows::ApplicationModel::Calls::MuteChangeEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MuteChangeEventArgs_get_Muted(py::wrapper::Windows::ApplicationModel::Calls::MuteChangeEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Muted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MuteChangeEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::MuteChangeEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MuteChangeEventArgs[] = {
        { "_from", (PyCFunction)_from_MuteChangeEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MuteChangeEventArgs[] = {
        { const_cast<char*>("muted"), (getter)MuteChangeEventArgs_get_Muted, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MuteChangeEventArgs[] = 
    {
        { Py_tp_new, _new_MuteChangeEventArgs },
        { Py_tp_dealloc, _dealloc_MuteChangeEventArgs },
        { Py_tp_methods, _methods_MuteChangeEventArgs },
        { Py_tp_getset, _getset_MuteChangeEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MuteChangeEventArgs =
    {
        "_winrt_Windows_ApplicationModel_Calls.MuteChangeEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::MuteChangeEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MuteChangeEventArgs
    };

    // ----- PhoneCall class --------------------
    constexpr const char* const _type_name_PhoneCall = "PhoneCall";

    static PyObject* _new_PhoneCall(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCall);
        return nullptr;
    }

    static void _dealloc_PhoneCall(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCall_AcceptIncoming(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.AcceptIncoming());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_AcceptIncomingAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.AcceptIncomingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_ChangeAudioDevice(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallAudioDevice>(args, 0);

                return py::convert(self->obj.ChangeAudioDevice(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_ChangeAudioDeviceAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallAudioDevice>(args, 0);

                return py::convert(self->obj.ChangeAudioDeviceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_End(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.End());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_EndAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.EndAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_GetFromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCall::GetFromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_GetPhoneCallInfo(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPhoneCallInfo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_GetPhoneCallInfoAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPhoneCallInfoAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_Hold(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Hold());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_HoldAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.HoldAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_Mute(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Mute());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_MuteAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.MuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_RejectIncoming(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RejectIncoming());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_RejectIncomingAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RejectIncomingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_ResumeFromHold(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ResumeFromHold());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_ResumeFromHoldAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ResumeFromHoldAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_SendDtmfKey(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::DtmfKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Calls::DtmfToneAudioPlayback>(args, 1);

                return py::convert(self->obj.SendDtmfKey(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_SendDtmfKeyAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::DtmfKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Calls::DtmfToneAudioPlayback>(args, 1);

                return py::convert(self->obj.SendDtmfKeyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_Unmute(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Unmute());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_UnmuteAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.UnmuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_get_AudioDevice(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_get_CallId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CallId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_get_IsMuted(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsMuted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_get_Status(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_add_AudioDeviceChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneCall, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AudioDeviceChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_remove_AudioDeviceChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioDeviceChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_add_IsMutedChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneCall, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsMutedChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_remove_IsMutedChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsMutedChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_add_StatusChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneCall, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_remove_StatusChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneCall(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCall>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCall[] = {
        { "accept_incoming", (PyCFunction)PhoneCall_AcceptIncoming, METH_VARARGS, nullptr },
        { "accept_incoming_async", (PyCFunction)PhoneCall_AcceptIncomingAsync, METH_VARARGS, nullptr },
        { "change_audio_device", (PyCFunction)PhoneCall_ChangeAudioDevice, METH_VARARGS, nullptr },
        { "change_audio_device_async", (PyCFunction)PhoneCall_ChangeAudioDeviceAsync, METH_VARARGS, nullptr },
        { "end", (PyCFunction)PhoneCall_End, METH_VARARGS, nullptr },
        { "end_async", (PyCFunction)PhoneCall_EndAsync, METH_VARARGS, nullptr },
        { "get_from_id", (PyCFunction)PhoneCall_GetFromId, METH_VARARGS | METH_STATIC, nullptr },
        { "get_phone_call_info", (PyCFunction)PhoneCall_GetPhoneCallInfo, METH_VARARGS, nullptr },
        { "get_phone_call_info_async", (PyCFunction)PhoneCall_GetPhoneCallInfoAsync, METH_VARARGS, nullptr },
        { "hold", (PyCFunction)PhoneCall_Hold, METH_VARARGS, nullptr },
        { "hold_async", (PyCFunction)PhoneCall_HoldAsync, METH_VARARGS, nullptr },
        { "mute", (PyCFunction)PhoneCall_Mute, METH_VARARGS, nullptr },
        { "mute_async", (PyCFunction)PhoneCall_MuteAsync, METH_VARARGS, nullptr },
        { "reject_incoming", (PyCFunction)PhoneCall_RejectIncoming, METH_VARARGS, nullptr },
        { "reject_incoming_async", (PyCFunction)PhoneCall_RejectIncomingAsync, METH_VARARGS, nullptr },
        { "resume_from_hold", (PyCFunction)PhoneCall_ResumeFromHold, METH_VARARGS, nullptr },
        { "resume_from_hold_async", (PyCFunction)PhoneCall_ResumeFromHoldAsync, METH_VARARGS, nullptr },
        { "send_dtmf_key", (PyCFunction)PhoneCall_SendDtmfKey, METH_VARARGS, nullptr },
        { "send_dtmf_key_async", (PyCFunction)PhoneCall_SendDtmfKeyAsync, METH_VARARGS, nullptr },
        { "unmute", (PyCFunction)PhoneCall_Unmute, METH_VARARGS, nullptr },
        { "unmute_async", (PyCFunction)PhoneCall_UnmuteAsync, METH_VARARGS, nullptr },
        { "add_audio_device_changed", (PyCFunction)PhoneCall_add_AudioDeviceChanged, METH_O, nullptr },
        { "remove_audio_device_changed", (PyCFunction)PhoneCall_remove_AudioDeviceChanged, METH_O, nullptr },
        { "add_is_muted_changed", (PyCFunction)PhoneCall_add_IsMutedChanged, METH_O, nullptr },
        { "remove_is_muted_changed", (PyCFunction)PhoneCall_remove_IsMutedChanged, METH_O, nullptr },
        { "add_status_changed", (PyCFunction)PhoneCall_add_StatusChanged, METH_O, nullptr },
        { "remove_status_changed", (PyCFunction)PhoneCall_remove_StatusChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_PhoneCall, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneCall[] = {
        { const_cast<char*>("audio_device"), (getter)PhoneCall_get_AudioDevice, nullptr, nullptr, nullptr },
        { const_cast<char*>("call_id"), (getter)PhoneCall_get_CallId, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_muted"), (getter)PhoneCall_get_IsMuted, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)PhoneCall_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneCall[] = 
    {
        { Py_tp_new, _new_PhoneCall },
        { Py_tp_dealloc, _dealloc_PhoneCall },
        { Py_tp_methods, _methods_PhoneCall },
        { Py_tp_getset, _getset_PhoneCall },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCall =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneCall",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCall
    };

    // ----- PhoneCallBlocking class --------------------
    constexpr const char* const _type_name_PhoneCallBlocking = "PhoneCallBlocking";

    static PyObject* _new_PhoneCallBlocking(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallBlocking);
        return nullptr;
    }

    static PyObject* PhoneCallBlocking_SetCallBlockingListAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking::SetCallBlockingListAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallBlocking_get_BlockUnknownNumbers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking::BlockUnknownNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallBlocking_put_BlockUnknownNumbers(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        try
        {
            auto param0 = py::convert_to<bool>(arg);

            winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking::BlockUnknownNumbers(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallBlocking_get_BlockPrivateNumbers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking::BlockPrivateNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallBlocking_put_BlockPrivateNumbers(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        try
        {
            auto param0 = py::convert_to<bool>(arg);

            winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking::BlockPrivateNumbers(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallBlocking[] = {
        { "set_call_blocking_list_async", (PyCFunction)PhoneCallBlocking_SetCallBlockingListAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_block_unknown_numbers", (PyCFunction)PhoneCallBlocking_get_BlockUnknownNumbers, METH_NOARGS | METH_STATIC, nullptr },
        { "put_block_unknown_numbers", (PyCFunction)PhoneCallBlocking_put_BlockUnknownNumbers, METH_O | METH_STATIC, nullptr },
        { "get_block_private_numbers", (PyCFunction)PhoneCallBlocking_get_BlockPrivateNumbers, METH_NOARGS | METH_STATIC, nullptr },
        { "put_block_private_numbers", (PyCFunction)PhoneCallBlocking_put_BlockPrivateNumbers, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneCallBlocking[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneCallBlocking[] = 
    {
        { Py_tp_new, _new_PhoneCallBlocking },
        { Py_tp_methods, _methods_PhoneCallBlocking },
        { Py_tp_getset, _getset_PhoneCallBlocking },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallBlocking =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneCallBlocking",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallBlocking
    };

    // ----- PhoneCallHistoryEntry class --------------------
    constexpr const char* const _type_name_PhoneCallHistoryEntry = "PhoneCallHistoryEntry";

    static PyObject* _new_PhoneCallHistoryEntry(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PhoneCallHistoryEntry(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCallHistoryEntry_get_Media(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Media());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_Media(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryMedia>(arg);

            self->obj.Media(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsMissed(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsMissed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsMissed(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMissed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsIncoming(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsIncoming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsIncoming(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsIncoming(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsCallerIdBlocked(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCallerIdBlocked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsCallerIdBlocked(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCallerIdBlocked(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsSeen(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSeen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsSeen(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSeen(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_Duration(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_Duration(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsEmergency(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEmergency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsEmergency(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEmergency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsSuppressed(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSuppressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsSuppressed(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSuppressed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_StartTime(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_StartTime(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_SourceIdKind(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceIdKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_SourceIdKind(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistorySourceIdKind>(arg);

            self->obj.SourceIdKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_Address(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_Address(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress>(arg);

            self->obj.Address(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_SourceId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_SourceId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SourceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_RemoteId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_RemoteId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OtherAppReadAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryOtherAppReadAccess>(arg);

            self->obj.OtherAppReadAccess(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsRinging(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRinging());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsRinging(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRinging(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsVoicemail(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVoicemail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsVoicemail(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsVoicemail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_Id(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_SourceDisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneCallHistoryEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryEntry[] = {
        { "_from", (PyCFunction)_from_PhoneCallHistoryEntry, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneCallHistoryEntry[] = {
        { const_cast<char*>("media"), (getter)PhoneCallHistoryEntry_get_Media, (setter)PhoneCallHistoryEntry_put_Media, nullptr, nullptr },
        { const_cast<char*>("is_missed"), (getter)PhoneCallHistoryEntry_get_IsMissed, (setter)PhoneCallHistoryEntry_put_IsMissed, nullptr, nullptr },
        { const_cast<char*>("is_incoming"), (getter)PhoneCallHistoryEntry_get_IsIncoming, (setter)PhoneCallHistoryEntry_put_IsIncoming, nullptr, nullptr },
        { const_cast<char*>("is_caller_id_blocked"), (getter)PhoneCallHistoryEntry_get_IsCallerIdBlocked, (setter)PhoneCallHistoryEntry_put_IsCallerIdBlocked, nullptr, nullptr },
        { const_cast<char*>("is_seen"), (getter)PhoneCallHistoryEntry_get_IsSeen, (setter)PhoneCallHistoryEntry_put_IsSeen, nullptr, nullptr },
        { const_cast<char*>("duration"), (getter)PhoneCallHistoryEntry_get_Duration, (setter)PhoneCallHistoryEntry_put_Duration, nullptr, nullptr },
        { const_cast<char*>("is_emergency"), (getter)PhoneCallHistoryEntry_get_IsEmergency, (setter)PhoneCallHistoryEntry_put_IsEmergency, nullptr, nullptr },
        { const_cast<char*>("is_suppressed"), (getter)PhoneCallHistoryEntry_get_IsSuppressed, (setter)PhoneCallHistoryEntry_put_IsSuppressed, nullptr, nullptr },
        { const_cast<char*>("start_time"), (getter)PhoneCallHistoryEntry_get_StartTime, (setter)PhoneCallHistoryEntry_put_StartTime, nullptr, nullptr },
        { const_cast<char*>("source_id_kind"), (getter)PhoneCallHistoryEntry_get_SourceIdKind, (setter)PhoneCallHistoryEntry_put_SourceIdKind, nullptr, nullptr },
        { const_cast<char*>("address"), (getter)PhoneCallHistoryEntry_get_Address, (setter)PhoneCallHistoryEntry_put_Address, nullptr, nullptr },
        { const_cast<char*>("source_id"), (getter)PhoneCallHistoryEntry_get_SourceId, (setter)PhoneCallHistoryEntry_put_SourceId, nullptr, nullptr },
        { const_cast<char*>("remote_id"), (getter)PhoneCallHistoryEntry_get_RemoteId, (setter)PhoneCallHistoryEntry_put_RemoteId, nullptr, nullptr },
        { const_cast<char*>("other_app_read_access"), (getter)PhoneCallHistoryEntry_get_OtherAppReadAccess, (setter)PhoneCallHistoryEntry_put_OtherAppReadAccess, nullptr, nullptr },
        { const_cast<char*>("is_ringing"), (getter)PhoneCallHistoryEntry_get_IsRinging, (setter)PhoneCallHistoryEntry_put_IsRinging, nullptr, nullptr },
        { const_cast<char*>("is_voicemail"), (getter)PhoneCallHistoryEntry_get_IsVoicemail, (setter)PhoneCallHistoryEntry_put_IsVoicemail, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)PhoneCallHistoryEntry_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("source_display_name"), (getter)PhoneCallHistoryEntry_get_SourceDisplayName, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryEntry[] = 
    {
        { Py_tp_new, _new_PhoneCallHistoryEntry },
        { Py_tp_dealloc, _dealloc_PhoneCallHistoryEntry },
        { Py_tp_methods, _methods_PhoneCallHistoryEntry },
        { Py_tp_getset, _getset_PhoneCallHistoryEntry },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallHistoryEntry =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneCallHistoryEntry",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryEntry
    };

    // ----- PhoneCallHistoryEntryAddress class --------------------
    constexpr const char* const _type_name_PhoneCallHistoryEntryAddress = "PhoneCallHistoryEntryAddress";

    static PyObject* _new_PhoneCallHistoryEntryAddress(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryRawAddressKind>(args, 1);

                winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PhoneCallHistoryEntryAddress(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCallHistoryEntryAddress_get_RawAddressKind(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawAddressKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntryAddress_put_RawAddressKind(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryRawAddressKind>(arg);

            self->obj.RawAddressKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntryAddress_get_RawAddress(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntryAddress_put_RawAddress(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RawAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntryAddress_get_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntryAddress_put_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntryAddress_get_ContactId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntryAddress_put_ContactId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContactId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_PhoneCallHistoryEntryAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryEntryAddress[] = {
        { "_from", (PyCFunction)_from_PhoneCallHistoryEntryAddress, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneCallHistoryEntryAddress[] = {
        { const_cast<char*>("raw_address_kind"), (getter)PhoneCallHistoryEntryAddress_get_RawAddressKind, (setter)PhoneCallHistoryEntryAddress_put_RawAddressKind, nullptr, nullptr },
        { const_cast<char*>("raw_address"), (getter)PhoneCallHistoryEntryAddress_get_RawAddress, (setter)PhoneCallHistoryEntryAddress_put_RawAddress, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)PhoneCallHistoryEntryAddress_get_DisplayName, (setter)PhoneCallHistoryEntryAddress_put_DisplayName, nullptr, nullptr },
        { const_cast<char*>("contact_id"), (getter)PhoneCallHistoryEntryAddress_get_ContactId, (setter)PhoneCallHistoryEntryAddress_put_ContactId, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryEntryAddress[] = 
    {
        { Py_tp_new, _new_PhoneCallHistoryEntryAddress },
        { Py_tp_dealloc, _dealloc_PhoneCallHistoryEntryAddress },
        { Py_tp_methods, _methods_PhoneCallHistoryEntryAddress },
        { Py_tp_getset, _getset_PhoneCallHistoryEntryAddress },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallHistoryEntryAddress =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneCallHistoryEntryAddress",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryEntryAddress
    };

    // ----- PhoneCallHistoryEntryQueryOptions class --------------------
    constexpr const char* const _type_name_PhoneCallHistoryEntryQueryOptions = "PhoneCallHistoryEntryQueryOptions";

    static PyObject* _new_PhoneCallHistoryEntryQueryOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PhoneCallHistoryEntryQueryOptions(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCallHistoryEntryQueryOptions_get_DesiredMedia(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredMedia());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntryQueryOptions_put_DesiredMedia(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryDesiredMedia>(arg);

            self->obj.DesiredMedia(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntryQueryOptions_get_SourceIds(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneCallHistoryEntryQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryEntryQueryOptions[] = {
        { "_from", (PyCFunction)_from_PhoneCallHistoryEntryQueryOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneCallHistoryEntryQueryOptions[] = {
        { const_cast<char*>("desired_media"), (getter)PhoneCallHistoryEntryQueryOptions_get_DesiredMedia, (setter)PhoneCallHistoryEntryQueryOptions_put_DesiredMedia, nullptr, nullptr },
        { const_cast<char*>("source_ids"), (getter)PhoneCallHistoryEntryQueryOptions_get_SourceIds, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryEntryQueryOptions[] = 
    {
        { Py_tp_new, _new_PhoneCallHistoryEntryQueryOptions },
        { Py_tp_dealloc, _dealloc_PhoneCallHistoryEntryQueryOptions },
        { Py_tp_methods, _methods_PhoneCallHistoryEntryQueryOptions },
        { Py_tp_getset, _getset_PhoneCallHistoryEntryQueryOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallHistoryEntryQueryOptions =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneCallHistoryEntryQueryOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryEntryQueryOptions
    };

    // ----- PhoneCallHistoryEntryReader class --------------------
    constexpr const char* const _type_name_PhoneCallHistoryEntryReader = "PhoneCallHistoryEntryReader";

    static PyObject* _new_PhoneCallHistoryEntryReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallHistoryEntryReader);
        return nullptr;
    }

    static void _dealloc_PhoneCallHistoryEntryReader(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCallHistoryEntryReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_PhoneCallHistoryEntryReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryEntryReader[] = {
        { "read_batch_async", (PyCFunction)PhoneCallHistoryEntryReader_ReadBatchAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PhoneCallHistoryEntryReader, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneCallHistoryEntryReader[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryEntryReader[] = 
    {
        { Py_tp_new, _new_PhoneCallHistoryEntryReader },
        { Py_tp_dealloc, _dealloc_PhoneCallHistoryEntryReader },
        { Py_tp_methods, _methods_PhoneCallHistoryEntryReader },
        { Py_tp_getset, _getset_PhoneCallHistoryEntryReader },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallHistoryEntryReader =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneCallHistoryEntryReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryEntryReader
    };

    // ----- PhoneCallHistoryManager class --------------------
    constexpr const char* const _type_name_PhoneCallHistoryManager = "PhoneCallHistoryManager";

    static PyObject* _new_PhoneCallHistoryManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallHistoryManager);
        return nullptr;
    }

    static PyObject* PhoneCallHistoryManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStoreAccessType>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManager::RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryManager[] = {
        { "get_for_user", (PyCFunction)PhoneCallHistoryManager_GetForUser, METH_VARARGS | METH_STATIC, nullptr },
        { "request_store_async", (PyCFunction)PhoneCallHistoryManager_RequestStoreAsync, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneCallHistoryManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryManager[] = 
    {
        { Py_tp_new, _new_PhoneCallHistoryManager },
        { Py_tp_methods, _methods_PhoneCallHistoryManager },
        { Py_tp_getset, _getset_PhoneCallHistoryManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallHistoryManager =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneCallHistoryManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryManager
    };

    // ----- PhoneCallHistoryManagerForUser class --------------------
    constexpr const char* const _type_name_PhoneCallHistoryManagerForUser = "PhoneCallHistoryManagerForUser";

    static PyObject* _new_PhoneCallHistoryManagerForUser(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallHistoryManagerForUser);
        return nullptr;
    }

    static void _dealloc_PhoneCallHistoryManagerForUser(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCallHistoryManagerForUser_RequestStoreAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStoreAccessType>(args, 0);

                return py::convert(self->obj.RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryManagerForUser_get_User(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneCallHistoryManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryManagerForUser[] = {
        { "request_store_async", (PyCFunction)PhoneCallHistoryManagerForUser_RequestStoreAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PhoneCallHistoryManagerForUser, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneCallHistoryManagerForUser[] = {
        { const_cast<char*>("user"), (getter)PhoneCallHistoryManagerForUser_get_User, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryManagerForUser[] = 
    {
        { Py_tp_new, _new_PhoneCallHistoryManagerForUser },
        { Py_tp_dealloc, _dealloc_PhoneCallHistoryManagerForUser },
        { Py_tp_methods, _methods_PhoneCallHistoryManagerForUser },
        { Py_tp_getset, _getset_PhoneCallHistoryManagerForUser },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallHistoryManagerForUser =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneCallHistoryManagerForUser",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryManagerForUser
    };

    // ----- PhoneCallHistoryStore class --------------------
    constexpr const char* const _type_name_PhoneCallHistoryStore = "PhoneCallHistoryStore";

    static PyObject* _new_PhoneCallHistoryStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallHistoryStore);
        return nullptr;
    }

    static void _dealloc_PhoneCallHistoryStore(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCallHistoryStore_DeleteEntriesAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>>(args, 0);

                return py::convert(self->obj.DeleteEntriesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_DeleteEntryAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>(args, 0);

                return py::convert(self->obj.DeleteEntryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_GetEntryAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetEntryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_GetEntryReader(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetEntryReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions>(args, 0);

                return py::convert(self->obj.GetEntryReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_GetSourcesUnseenCountAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetSourcesUnseenCountAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_GetUnseenCountAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetUnseenCountAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_MarkAllAsSeenAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.MarkAllAsSeenAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_MarkEntriesAsSeenAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>>(args, 0);

                return py::convert(self->obj.MarkEntriesAsSeenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_MarkEntryAsSeenAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>(args, 0);

                return py::convert(self->obj.MarkEntryAsSeenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_MarkSourcesAsSeenAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.MarkSourcesAsSeenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_SaveEntryAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>(args, 0);

                return py::convert(self->obj.SaveEntryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_PhoneCallHistoryStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryStore[] = {
        { "delete_entries_async", (PyCFunction)PhoneCallHistoryStore_DeleteEntriesAsync, METH_VARARGS, nullptr },
        { "delete_entry_async", (PyCFunction)PhoneCallHistoryStore_DeleteEntryAsync, METH_VARARGS, nullptr },
        { "get_entry_async", (PyCFunction)PhoneCallHistoryStore_GetEntryAsync, METH_VARARGS, nullptr },
        { "get_entry_reader", (PyCFunction)PhoneCallHistoryStore_GetEntryReader, METH_VARARGS, nullptr },
        { "get_sources_unseen_count_async", (PyCFunction)PhoneCallHistoryStore_GetSourcesUnseenCountAsync, METH_VARARGS, nullptr },
        { "get_unseen_count_async", (PyCFunction)PhoneCallHistoryStore_GetUnseenCountAsync, METH_VARARGS, nullptr },
        { "mark_all_as_seen_async", (PyCFunction)PhoneCallHistoryStore_MarkAllAsSeenAsync, METH_VARARGS, nullptr },
        { "mark_entries_as_seen_async", (PyCFunction)PhoneCallHistoryStore_MarkEntriesAsSeenAsync, METH_VARARGS, nullptr },
        { "mark_entry_as_seen_async", (PyCFunction)PhoneCallHistoryStore_MarkEntryAsSeenAsync, METH_VARARGS, nullptr },
        { "mark_sources_as_seen_async", (PyCFunction)PhoneCallHistoryStore_MarkSourcesAsSeenAsync, METH_VARARGS, nullptr },
        { "save_entry_async", (PyCFunction)PhoneCallHistoryStore_SaveEntryAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PhoneCallHistoryStore, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneCallHistoryStore[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryStore[] = 
    {
        { Py_tp_new, _new_PhoneCallHistoryStore },
        { Py_tp_dealloc, _dealloc_PhoneCallHistoryStore },
        { Py_tp_methods, _methods_PhoneCallHistoryStore },
        { Py_tp_getset, _getset_PhoneCallHistoryStore },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallHistoryStore =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneCallHistoryStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryStore
    };

    // ----- PhoneCallInfo class --------------------
    constexpr const char* const _type_name_PhoneCallInfo = "PhoneCallInfo";

    static PyObject* _new_PhoneCallInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallInfo);
        return nullptr;
    }

    static void _dealloc_PhoneCallInfo(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCallInfo_get_CallDirection(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CallDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallInfo_get_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallInfo_get_IsHoldSupported(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallInfo_get_LineId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallInfo_get_PhoneNumber(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallInfo_get_StartTime(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneCallInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallInfo[] = {
        { "_from", (PyCFunction)_from_PhoneCallInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneCallInfo[] = {
        { const_cast<char*>("call_direction"), (getter)PhoneCallInfo_get_CallDirection, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)PhoneCallInfo_get_DisplayName, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_hold_supported"), (getter)PhoneCallInfo_get_IsHoldSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("line_id"), (getter)PhoneCallInfo_get_LineId, nullptr, nullptr, nullptr },
        { const_cast<char*>("phone_number"), (getter)PhoneCallInfo_get_PhoneNumber, nullptr, nullptr, nullptr },
        { const_cast<char*>("start_time"), (getter)PhoneCallInfo_get_StartTime, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneCallInfo[] = 
    {
        { Py_tp_new, _new_PhoneCallInfo },
        { Py_tp_dealloc, _dealloc_PhoneCallInfo },
        { Py_tp_methods, _methods_PhoneCallInfo },
        { Py_tp_getset, _getset_PhoneCallInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallInfo =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneCallInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallInfo
    };

    // ----- PhoneCallManager class --------------------
    constexpr const char* const _type_name_PhoneCallManager = "PhoneCallManager";

    static PyObject* _new_PhoneCallManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallManager);
        return nullptr;
    }

    static PyObject* PhoneCallManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallManager::RequestStoreAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_ShowPhoneCallSettingsUI(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Calls::PhoneCallManager::ShowPhoneCallSettingsUI();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_ShowPhoneCallUI(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Calls::PhoneCallManager::ShowPhoneCallUI(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_get_IsCallActive(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallManager::IsCallActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_get_IsCallIncoming(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallManager::IsCallIncoming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_add_CallStateChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallManager::CallStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_remove_CallStateChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::ApplicationModel::Calls::PhoneCallManager::CallStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallManager[] = {
        { "request_store_async", (PyCFunction)PhoneCallManager_RequestStoreAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "show_phone_call_settings_u_i", (PyCFunction)PhoneCallManager_ShowPhoneCallSettingsUI, METH_VARARGS | METH_STATIC, nullptr },
        { "show_phone_call_u_i", (PyCFunction)PhoneCallManager_ShowPhoneCallUI, METH_VARARGS | METH_STATIC, nullptr },
        { "get_is_call_active", (PyCFunction)PhoneCallManager_get_IsCallActive, METH_NOARGS | METH_STATIC, nullptr },
        { "get_is_call_incoming", (PyCFunction)PhoneCallManager_get_IsCallIncoming, METH_NOARGS | METH_STATIC, nullptr },
        { "add_call_state_changed", (PyCFunction)PhoneCallManager_add_CallStateChanged, METH_O | METH_STATIC, nullptr },
        { "remove_call_state_changed", (PyCFunction)PhoneCallManager_remove_CallStateChanged, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneCallManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneCallManager[] = 
    {
        { Py_tp_new, _new_PhoneCallManager },
        { Py_tp_methods, _methods_PhoneCallManager },
        { Py_tp_getset, _getset_PhoneCallManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallManager =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneCallManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallManager
    };

    // ----- PhoneCallStore class --------------------
    constexpr const char* const _type_name_PhoneCallStore = "PhoneCallStore";

    static PyObject* _new_PhoneCallStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallStore);
        return nullptr;
    }

    static void _dealloc_PhoneCallStore(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallStore* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCallStore_GetDefaultLineAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDefaultLineAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallStore_IsEmergencyPhoneNumberAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsEmergencyPhoneNumberAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallStore_RequestLineWatcher(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestLineWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_PhoneCallStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallStore[] = {
        { "get_default_line_async", (PyCFunction)PhoneCallStore_GetDefaultLineAsync, METH_VARARGS, nullptr },
        { "is_emergency_phone_number_async", (PyCFunction)PhoneCallStore_IsEmergencyPhoneNumberAsync, METH_VARARGS, nullptr },
        { "request_line_watcher", (PyCFunction)PhoneCallStore_RequestLineWatcher, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PhoneCallStore, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneCallStore[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneCallStore[] = 
    {
        { Py_tp_new, _new_PhoneCallStore },
        { Py_tp_dealloc, _dealloc_PhoneCallStore },
        { Py_tp_methods, _methods_PhoneCallStore },
        { Py_tp_getset, _getset_PhoneCallStore },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallStore =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneCallStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallStore
    };

    // ----- PhoneCallVideoCapabilities class --------------------
    constexpr const char* const _type_name_PhoneCallVideoCapabilities = "PhoneCallVideoCapabilities";

    static PyObject* _new_PhoneCallVideoCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallVideoCapabilities);
        return nullptr;
    }

    static void _dealloc_PhoneCallVideoCapabilities(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCallVideoCapabilities_get_IsVideoCallingCapable(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVideoCallingCapable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneCallVideoCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallVideoCapabilities[] = {
        { "_from", (PyCFunction)_from_PhoneCallVideoCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneCallVideoCapabilities[] = {
        { const_cast<char*>("is_video_calling_capable"), (getter)PhoneCallVideoCapabilities_get_IsVideoCallingCapable, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneCallVideoCapabilities[] = 
    {
        { Py_tp_new, _new_PhoneCallVideoCapabilities },
        { Py_tp_dealloc, _dealloc_PhoneCallVideoCapabilities },
        { Py_tp_methods, _methods_PhoneCallVideoCapabilities },
        { Py_tp_getset, _getset_PhoneCallVideoCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallVideoCapabilities =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneCallVideoCapabilities",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallVideoCapabilities
    };

    // ----- PhoneCallVideoCapabilitiesManager class --------------------
    constexpr const char* const _type_name_PhoneCallVideoCapabilitiesManager = "PhoneCallVideoCapabilitiesManager";

    static PyObject* _new_PhoneCallVideoCapabilitiesManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallVideoCapabilitiesManager);
        return nullptr;
    }

    static PyObject* PhoneCallVideoCapabilitiesManager_GetCapabilitiesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilitiesManager::GetCapabilitiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallVideoCapabilitiesManager[] = {
        { "get_capabilities_async", (PyCFunction)PhoneCallVideoCapabilitiesManager_GetCapabilitiesAsync, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneCallVideoCapabilitiesManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneCallVideoCapabilitiesManager[] = 
    {
        { Py_tp_new, _new_PhoneCallVideoCapabilitiesManager },
        { Py_tp_methods, _methods_PhoneCallVideoCapabilitiesManager },
        { Py_tp_getset, _getset_PhoneCallVideoCapabilitiesManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallVideoCapabilitiesManager =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneCallVideoCapabilitiesManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallVideoCapabilitiesManager
    };

    // ----- PhoneCallsResult class --------------------
    constexpr const char* const _type_name_PhoneCallsResult = "PhoneCallsResult";

    static PyObject* _new_PhoneCallsResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallsResult);
        return nullptr;
    }

    static void _dealloc_PhoneCallsResult(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallsResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCallsResult_get_AllActivePhoneCalls(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllActivePhoneCalls());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallsResult_get_OperationStatus(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OperationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneCallsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallsResult[] = {
        { "_from", (PyCFunction)_from_PhoneCallsResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneCallsResult[] = {
        { const_cast<char*>("all_active_phone_calls"), (getter)PhoneCallsResult_get_AllActivePhoneCalls, nullptr, nullptr, nullptr },
        { const_cast<char*>("operation_status"), (getter)PhoneCallsResult_get_OperationStatus, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneCallsResult[] = 
    {
        { Py_tp_new, _new_PhoneCallsResult },
        { Py_tp_dealloc, _dealloc_PhoneCallsResult },
        { Py_tp_methods, _methods_PhoneCallsResult },
        { Py_tp_getset, _getset_PhoneCallsResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallsResult =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneCallsResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallsResult
    };

    // ----- PhoneDialOptions class --------------------
    constexpr const char* const _type_name_PhoneDialOptions = "PhoneDialOptions";

    static PyObject* _new_PhoneDialOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Calls::PhoneDialOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PhoneDialOptions(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneDialOptions_get_Number(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Number());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_Number(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Number(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneDialOptions_get_Media(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Media());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_Media(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallMedia>(arg);

            self->obj.Media(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneDialOptions_get_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneDialOptions_get_ContactPhone(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactPhone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_ContactPhone(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactPhone>(arg);

            self->obj.ContactPhone(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneDialOptions_get_Contact(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_Contact(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(arg);

            self->obj.Contact(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneDialOptions_get_AudioEndpoint(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioEndpoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_AudioEndpoint(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneAudioRoutingEndpoint>(arg);

            self->obj.AudioEndpoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_PhoneDialOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneDialOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneDialOptions[] = {
        { "_from", (PyCFunction)_from_PhoneDialOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneDialOptions[] = {
        { const_cast<char*>("number"), (getter)PhoneDialOptions_get_Number, (setter)PhoneDialOptions_put_Number, nullptr, nullptr },
        { const_cast<char*>("media"), (getter)PhoneDialOptions_get_Media, (setter)PhoneDialOptions_put_Media, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)PhoneDialOptions_get_DisplayName, (setter)PhoneDialOptions_put_DisplayName, nullptr, nullptr },
        { const_cast<char*>("contact_phone"), (getter)PhoneDialOptions_get_ContactPhone, (setter)PhoneDialOptions_put_ContactPhone, nullptr, nullptr },
        { const_cast<char*>("contact"), (getter)PhoneDialOptions_get_Contact, (setter)PhoneDialOptions_put_Contact, nullptr, nullptr },
        { const_cast<char*>("audio_endpoint"), (getter)PhoneDialOptions_get_AudioEndpoint, (setter)PhoneDialOptions_put_AudioEndpoint, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneDialOptions[] = 
    {
        { Py_tp_new, _new_PhoneDialOptions },
        { Py_tp_dealloc, _dealloc_PhoneDialOptions },
        { Py_tp_methods, _methods_PhoneDialOptions },
        { Py_tp_getset, _getset_PhoneDialOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneDialOptions =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneDialOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneDialOptions
    };

    // ----- PhoneLine class --------------------
    constexpr const char* const _type_name_PhoneLine = "PhoneLine";

    static PyObject* _new_PhoneLine(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneLine);
        return nullptr;
    }

    static void _dealloc_PhoneLine(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneLine_Dial(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Dial(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_DialWithOptions(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneDialOptions>(args, 0);

                self->obj.DialWithOptions(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_DialWithResult(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.DialWithResult(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_DialWithResultAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.DialWithResultAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_EnableTextReply(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.EnableTextReply(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneLine::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_GetAllActivePhoneCalls(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAllActivePhoneCalls());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_GetAllActivePhoneCallsAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAllActivePhoneCallsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_IsImmediateDialNumberAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsImmediateDialNumberAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_CanDial(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanDial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_CellularDetails(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_DisplayColor(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_Id(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_LineConfiguration(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_NetworkName(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_NetworkState(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_SupportsTile(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportsTile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_Transport(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Transport());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_VideoCallingCapabilities(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoCallingCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_Voicemail(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Voicemail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_TransportDeviceId(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_add_LineChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLine, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.LineChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_remove_LineChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LineChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneLine(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLine>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLine[] = {
        { "dial", (PyCFunction)PhoneLine_Dial, METH_VARARGS, nullptr },
        { "dial_with_options", (PyCFunction)PhoneLine_DialWithOptions, METH_VARARGS, nullptr },
        { "dial_with_result", (PyCFunction)PhoneLine_DialWithResult, METH_VARARGS, nullptr },
        { "dial_with_result_async", (PyCFunction)PhoneLine_DialWithResultAsync, METH_VARARGS, nullptr },
        { "enable_text_reply", (PyCFunction)PhoneLine_EnableTextReply, METH_VARARGS, nullptr },
        { "from_id_async", (PyCFunction)PhoneLine_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_all_active_phone_calls", (PyCFunction)PhoneLine_GetAllActivePhoneCalls, METH_VARARGS, nullptr },
        { "get_all_active_phone_calls_async", (PyCFunction)PhoneLine_GetAllActivePhoneCallsAsync, METH_VARARGS, nullptr },
        { "is_immediate_dial_number_async", (PyCFunction)PhoneLine_IsImmediateDialNumberAsync, METH_VARARGS, nullptr },
        { "add_line_changed", (PyCFunction)PhoneLine_add_LineChanged, METH_O, nullptr },
        { "remove_line_changed", (PyCFunction)PhoneLine_remove_LineChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_PhoneLine, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneLine[] = {
        { const_cast<char*>("can_dial"), (getter)PhoneLine_get_CanDial, nullptr, nullptr, nullptr },
        { const_cast<char*>("cellular_details"), (getter)PhoneLine_get_CellularDetails, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_color"), (getter)PhoneLine_get_DisplayColor, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)PhoneLine_get_DisplayName, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)PhoneLine_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("line_configuration"), (getter)PhoneLine_get_LineConfiguration, nullptr, nullptr, nullptr },
        { const_cast<char*>("network_name"), (getter)PhoneLine_get_NetworkName, nullptr, nullptr, nullptr },
        { const_cast<char*>("network_state"), (getter)PhoneLine_get_NetworkState, nullptr, nullptr, nullptr },
        { const_cast<char*>("supports_tile"), (getter)PhoneLine_get_SupportsTile, nullptr, nullptr, nullptr },
        { const_cast<char*>("transport"), (getter)PhoneLine_get_Transport, nullptr, nullptr, nullptr },
        { const_cast<char*>("video_calling_capabilities"), (getter)PhoneLine_get_VideoCallingCapabilities, nullptr, nullptr, nullptr },
        { const_cast<char*>("voicemail"), (getter)PhoneLine_get_Voicemail, nullptr, nullptr, nullptr },
        { const_cast<char*>("transport_device_id"), (getter)PhoneLine_get_TransportDeviceId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneLine[] = 
    {
        { Py_tp_new, _new_PhoneLine },
        { Py_tp_dealloc, _dealloc_PhoneLine },
        { Py_tp_methods, _methods_PhoneLine },
        { Py_tp_getset, _getset_PhoneLine },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneLine =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneLine",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLine
    };

    // ----- PhoneLineCellularDetails class --------------------
    constexpr const char* const _type_name_PhoneLineCellularDetails = "PhoneLineCellularDetails";

    static PyObject* _new_PhoneLineCellularDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneLineCellularDetails);
        return nullptr;
    }

    static void _dealloc_PhoneLineCellularDetails(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneLineCellularDetails_GetNetworkOperatorDisplayText(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneLineNetworkOperatorDisplayTextLocation>(args, 0);

                return py::convert(self->obj.GetNetworkOperatorDisplayText(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineCellularDetails_get_IsModemOn(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsModemOn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineCellularDetails_get_RegistrationRejectCode(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RegistrationRejectCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineCellularDetails_get_SimSlotIndex(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimSlotIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineCellularDetails_get_SimState(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneLineCellularDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineCellularDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineCellularDetails[] = {
        { "get_network_operator_display_text", (PyCFunction)PhoneLineCellularDetails_GetNetworkOperatorDisplayText, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PhoneLineCellularDetails, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneLineCellularDetails[] = {
        { const_cast<char*>("is_modem_on"), (getter)PhoneLineCellularDetails_get_IsModemOn, nullptr, nullptr, nullptr },
        { const_cast<char*>("registration_reject_code"), (getter)PhoneLineCellularDetails_get_RegistrationRejectCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("sim_slot_index"), (getter)PhoneLineCellularDetails_get_SimSlotIndex, nullptr, nullptr, nullptr },
        { const_cast<char*>("sim_state"), (getter)PhoneLineCellularDetails_get_SimState, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneLineCellularDetails[] = 
    {
        { Py_tp_new, _new_PhoneLineCellularDetails },
        { Py_tp_dealloc, _dealloc_PhoneLineCellularDetails },
        { Py_tp_methods, _methods_PhoneLineCellularDetails },
        { Py_tp_getset, _getset_PhoneLineCellularDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneLineCellularDetails =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneLineCellularDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineCellularDetails
    };

    // ----- PhoneLineConfiguration class --------------------
    constexpr const char* const _type_name_PhoneLineConfiguration = "PhoneLineConfiguration";

    static PyObject* _new_PhoneLineConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneLineConfiguration);
        return nullptr;
    }

    static void _dealloc_PhoneLineConfiguration(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneLineConfiguration_get_ExtendedProperties(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineConfiguration_get_IsVideoCallingEnabled(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVideoCallingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneLineConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineConfiguration[] = {
        { "_from", (PyCFunction)_from_PhoneLineConfiguration, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneLineConfiguration[] = {
        { const_cast<char*>("extended_properties"), (getter)PhoneLineConfiguration_get_ExtendedProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_video_calling_enabled"), (getter)PhoneLineConfiguration_get_IsVideoCallingEnabled, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneLineConfiguration[] = 
    {
        { Py_tp_new, _new_PhoneLineConfiguration },
        { Py_tp_dealloc, _dealloc_PhoneLineConfiguration },
        { Py_tp_methods, _methods_PhoneLineConfiguration },
        { Py_tp_getset, _getset_PhoneLineConfiguration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneLineConfiguration =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneLineConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineConfiguration
    };

    // ----- PhoneLineDialResult class --------------------
    constexpr const char* const _type_name_PhoneLineDialResult = "PhoneLineDialResult";

    static PyObject* _new_PhoneLineDialResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneLineDialResult);
        return nullptr;
    }

    static void _dealloc_PhoneLineDialResult(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineDialResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneLineDialResult_get_DialCallStatus(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineDialResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DialCallStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineDialResult_get_DialedCall(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineDialResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DialedCall());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneLineDialResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineDialResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineDialResult[] = {
        { "_from", (PyCFunction)_from_PhoneLineDialResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneLineDialResult[] = {
        { const_cast<char*>("dial_call_status"), (getter)PhoneLineDialResult_get_DialCallStatus, nullptr, nullptr, nullptr },
        { const_cast<char*>("dialed_call"), (getter)PhoneLineDialResult_get_DialedCall, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneLineDialResult[] = 
    {
        { Py_tp_new, _new_PhoneLineDialResult },
        { Py_tp_dealloc, _dealloc_PhoneLineDialResult },
        { Py_tp_methods, _methods_PhoneLineDialResult },
        { Py_tp_getset, _getset_PhoneLineDialResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneLineDialResult =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneLineDialResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineDialResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineDialResult
    };

    // ----- PhoneLineTransportDevice class --------------------
    constexpr const char* const _type_name_PhoneLineTransportDevice = "PhoneLineTransportDevice";

    static PyObject* _new_PhoneLineTransportDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneLineTransportDevice);
        return nullptr;
    }

    static void _dealloc_PhoneLineTransportDevice(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneLineTransportDevice_Connect(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Connect());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_ConnectAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ConnectAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneLineTransport>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_IsRegistered(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.IsRegistered());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_RegisterApp(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RegisterApp();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_RegisterAppForUser(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                self->obj.RegisterAppForUser(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_RequestAccessAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_UnregisterApp(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.UnregisterApp();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_UnregisterAppForUser(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                self->obj.UnregisterAppForUser(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_get_DeviceId(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_get_Transport(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Transport());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_get_AudioRoutingStatus(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioRoutingStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_get_InBandRingingEnabled(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InBandRingingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_add_AudioRoutingStatusChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AudioRoutingStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_remove_AudioRoutingStatusChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioRoutingStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_add_InBandRingingEnabledChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.InBandRingingEnabledChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_remove_InBandRingingEnabledChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InBandRingingEnabledChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneLineTransportDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineTransportDevice[] = {
        { "connect", (PyCFunction)PhoneLineTransportDevice_Connect, METH_VARARGS, nullptr },
        { "connect_async", (PyCFunction)PhoneLineTransportDevice_ConnectAsync, METH_VARARGS, nullptr },
        { "from_id", (PyCFunction)PhoneLineTransportDevice_FromId, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)PhoneLineTransportDevice_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "is_registered", (PyCFunction)PhoneLineTransportDevice_IsRegistered, METH_VARARGS, nullptr },
        { "register_app", (PyCFunction)PhoneLineTransportDevice_RegisterApp, METH_VARARGS, nullptr },
        { "register_app_for_user", (PyCFunction)PhoneLineTransportDevice_RegisterAppForUser, METH_VARARGS, nullptr },
        { "request_access_async", (PyCFunction)PhoneLineTransportDevice_RequestAccessAsync, METH_VARARGS, nullptr },
        { "unregister_app", (PyCFunction)PhoneLineTransportDevice_UnregisterApp, METH_VARARGS, nullptr },
        { "unregister_app_for_user", (PyCFunction)PhoneLineTransportDevice_UnregisterAppForUser, METH_VARARGS, nullptr },
        { "add_audio_routing_status_changed", (PyCFunction)PhoneLineTransportDevice_add_AudioRoutingStatusChanged, METH_O, nullptr },
        { "remove_audio_routing_status_changed", (PyCFunction)PhoneLineTransportDevice_remove_AudioRoutingStatusChanged, METH_O, nullptr },
        { "add_in_band_ringing_enabled_changed", (PyCFunction)PhoneLineTransportDevice_add_InBandRingingEnabledChanged, METH_O, nullptr },
        { "remove_in_band_ringing_enabled_changed", (PyCFunction)PhoneLineTransportDevice_remove_InBandRingingEnabledChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_PhoneLineTransportDevice, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneLineTransportDevice[] = {
        { const_cast<char*>("device_id"), (getter)PhoneLineTransportDevice_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("transport"), (getter)PhoneLineTransportDevice_get_Transport, nullptr, nullptr, nullptr },
        { const_cast<char*>("audio_routing_status"), (getter)PhoneLineTransportDevice_get_AudioRoutingStatus, nullptr, nullptr, nullptr },
        { const_cast<char*>("in_band_ringing_enabled"), (getter)PhoneLineTransportDevice_get_InBandRingingEnabled, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneLineTransportDevice[] = 
    {
        { Py_tp_new, _new_PhoneLineTransportDevice },
        { Py_tp_dealloc, _dealloc_PhoneLineTransportDevice },
        { Py_tp_methods, _methods_PhoneLineTransportDevice },
        { Py_tp_getset, _getset_PhoneLineTransportDevice },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneLineTransportDevice =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneLineTransportDevice",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineTransportDevice
    };

    // ----- PhoneLineWatcher class --------------------
    constexpr const char* const _type_name_PhoneLineWatcher = "PhoneLineWatcher";

    static PyObject* _new_PhoneLineWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneLineWatcher);
        return nullptr;
    }

    static void _dealloc_PhoneLineWatcher(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneLineWatcher_Start(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_Stop(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_get_Status(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_add_EnumerationCompleted(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_remove_EnumerationCompleted(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_add_LineAdded(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher, winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>>(arg);

            return py::convert(self->obj.LineAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_remove_LineAdded(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LineAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_add_LineRemoved(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher, winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>>(arg);

            return py::convert(self->obj.LineRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_remove_LineRemoved(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LineRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_add_LineUpdated(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher, winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>>(arg);

            return py::convert(self->obj.LineUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_remove_LineUpdated(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LineUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_add_Stopped(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_remove_Stopped(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneLineWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineWatcher[] = {
        { "start", (PyCFunction)PhoneLineWatcher_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)PhoneLineWatcher_Stop, METH_VARARGS, nullptr },
        { "add_enumeration_completed", (PyCFunction)PhoneLineWatcher_add_EnumerationCompleted, METH_O, nullptr },
        { "remove_enumeration_completed", (PyCFunction)PhoneLineWatcher_remove_EnumerationCompleted, METH_O, nullptr },
        { "add_line_added", (PyCFunction)PhoneLineWatcher_add_LineAdded, METH_O, nullptr },
        { "remove_line_added", (PyCFunction)PhoneLineWatcher_remove_LineAdded, METH_O, nullptr },
        { "add_line_removed", (PyCFunction)PhoneLineWatcher_add_LineRemoved, METH_O, nullptr },
        { "remove_line_removed", (PyCFunction)PhoneLineWatcher_remove_LineRemoved, METH_O, nullptr },
        { "add_line_updated", (PyCFunction)PhoneLineWatcher_add_LineUpdated, METH_O, nullptr },
        { "remove_line_updated", (PyCFunction)PhoneLineWatcher_remove_LineUpdated, METH_O, nullptr },
        { "add_stopped", (PyCFunction)PhoneLineWatcher_add_Stopped, METH_O, nullptr },
        { "remove_stopped", (PyCFunction)PhoneLineWatcher_remove_Stopped, METH_O, nullptr },
        { "_from", (PyCFunction)_from_PhoneLineWatcher, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneLineWatcher[] = {
        { const_cast<char*>("status"), (getter)PhoneLineWatcher_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneLineWatcher[] = 
    {
        { Py_tp_new, _new_PhoneLineWatcher },
        { Py_tp_dealloc, _dealloc_PhoneLineWatcher },
        { Py_tp_methods, _methods_PhoneLineWatcher },
        { Py_tp_getset, _getset_PhoneLineWatcher },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneLineWatcher =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneLineWatcher",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineWatcher
    };

    // ----- PhoneLineWatcherEventArgs class --------------------
    constexpr const char* const _type_name_PhoneLineWatcherEventArgs = "PhoneLineWatcherEventArgs";

    static PyObject* _new_PhoneLineWatcherEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneLineWatcherEventArgs);
        return nullptr;
    }

    static void _dealloc_PhoneLineWatcherEventArgs(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneLineWatcherEventArgs_get_LineId(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneLineWatcherEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineWatcherEventArgs[] = {
        { "_from", (PyCFunction)_from_PhoneLineWatcherEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneLineWatcherEventArgs[] = {
        { const_cast<char*>("line_id"), (getter)PhoneLineWatcherEventArgs_get_LineId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneLineWatcherEventArgs[] = 
    {
        { Py_tp_new, _new_PhoneLineWatcherEventArgs },
        { Py_tp_dealloc, _dealloc_PhoneLineWatcherEventArgs },
        { Py_tp_methods, _methods_PhoneLineWatcherEventArgs },
        { Py_tp_getset, _getset_PhoneLineWatcherEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneLineWatcherEventArgs =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneLineWatcherEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineWatcherEventArgs
    };

    // ----- PhoneVoicemail class --------------------
    constexpr const char* const _type_name_PhoneVoicemail = "PhoneVoicemail";

    static PyObject* _new_PhoneVoicemail(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneVoicemail);
        return nullptr;
    }

    static void _dealloc_PhoneVoicemail(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneVoicemail_DialVoicemailAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DialVoicemailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneVoicemail_get_MessageCount(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneVoicemail_get_Number(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Number());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneVoicemail_get_Type(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneVoicemail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneVoicemail>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneVoicemail[] = {
        { "dial_voicemail_async", (PyCFunction)PhoneVoicemail_DialVoicemailAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PhoneVoicemail, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneVoicemail[] = {
        { const_cast<char*>("message_count"), (getter)PhoneVoicemail_get_MessageCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("number"), (getter)PhoneVoicemail_get_Number, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)PhoneVoicemail_get_Type, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneVoicemail[] = 
    {
        { Py_tp_new, _new_PhoneVoicemail },
        { Py_tp_dealloc, _dealloc_PhoneVoicemail },
        { Py_tp_methods, _methods_PhoneVoicemail },
        { Py_tp_getset, _getset_PhoneVoicemail },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneVoicemail =
    {
        "_winrt_Windows_ApplicationModel_Calls.PhoneVoicemail",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneVoicemail
    };

    // ----- VoipCallCoordinator class --------------------
    constexpr const char* const _type_name_VoipCallCoordinator = "VoipCallCoordinator";

    static PyObject* _new_VoipCallCoordinator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VoipCallCoordinator);
        return nullptr;
    }

    static void _dealloc_VoipCallCoordinator(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VoipCallCoordinator_CancelUpgrade(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.CancelUpgrade(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_NotifyMuted(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyMuted();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_NotifyUnmuted(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyUnmuted();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_RequestIncomingUpgradeToVideoCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 9)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);
                auto param7 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 8);

                return py::convert(self->obj.RequestIncomingUpgradeToVideoCall(param0, param1, param2, param3, param4, param5, param6, param7, param8));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_RequestNewAppInitiatedCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 4);

                return py::convert(self->obj.RequestNewAppInitiatedCall(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_RequestNewIncomingCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 10)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);
                auto param7 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 8);
                auto param9 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 9);

                return py::convert(self->obj.RequestNewIncomingCall(param0, param1, param2, param3, param4, param5, param6, param7, param8, param9));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 11)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);
                auto param7 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 8);
                auto param9 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 9);
                auto param10 = py::convert_to<winrt::hstring>(args, 10);

                return py::convert(self->obj.RequestNewIncomingCall(param0, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_RequestNewOutgoingCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 3);

                return py::convert(self->obj.RequestNewOutgoingCall(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_RequestOutgoingUpgradeToVideoCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.RequestOutgoingUpgradeToVideoCall(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_ReserveCallResourcesAsync(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReserveCallResourcesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ReserveCallResourcesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_SetupNewAcceptedCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 4);

                return py::convert(self->obj.SetupNewAcceptedCall(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_TerminateCellularCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.TerminateCellularCall(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_add_MuteStateChanged(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator, winrt::Windows::ApplicationModel::Calls::MuteChangeEventArgs>>(arg);

            return py::convert(self->obj.MuteStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_remove_MuteStateChanged(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MuteStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VoipCallCoordinator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VoipCallCoordinator[] = {
        { "cancel_upgrade", (PyCFunction)VoipCallCoordinator_CancelUpgrade, METH_VARARGS, nullptr },
        { "get_default", (PyCFunction)VoipCallCoordinator_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "notify_muted", (PyCFunction)VoipCallCoordinator_NotifyMuted, METH_VARARGS, nullptr },
        { "notify_unmuted", (PyCFunction)VoipCallCoordinator_NotifyUnmuted, METH_VARARGS, nullptr },
        { "request_incoming_upgrade_to_video_call", (PyCFunction)VoipCallCoordinator_RequestIncomingUpgradeToVideoCall, METH_VARARGS, nullptr },
        { "request_new_app_initiated_call", (PyCFunction)VoipCallCoordinator_RequestNewAppInitiatedCall, METH_VARARGS, nullptr },
        { "request_new_incoming_call", (PyCFunction)VoipCallCoordinator_RequestNewIncomingCall, METH_VARARGS, nullptr },
        { "request_new_outgoing_call", (PyCFunction)VoipCallCoordinator_RequestNewOutgoingCall, METH_VARARGS, nullptr },
        { "request_outgoing_upgrade_to_video_call", (PyCFunction)VoipCallCoordinator_RequestOutgoingUpgradeToVideoCall, METH_VARARGS, nullptr },
        { "reserve_call_resources_async", (PyCFunction)VoipCallCoordinator_ReserveCallResourcesAsync, METH_VARARGS, nullptr },
        { "setup_new_accepted_call", (PyCFunction)VoipCallCoordinator_SetupNewAcceptedCall, METH_VARARGS, nullptr },
        { "terminate_cellular_call", (PyCFunction)VoipCallCoordinator_TerminateCellularCall, METH_VARARGS, nullptr },
        { "add_mute_state_changed", (PyCFunction)VoipCallCoordinator_add_MuteStateChanged, METH_O, nullptr },
        { "remove_mute_state_changed", (PyCFunction)VoipCallCoordinator_remove_MuteStateChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_VoipCallCoordinator, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VoipCallCoordinator[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_VoipCallCoordinator[] = 
    {
        { Py_tp_new, _new_VoipCallCoordinator },
        { Py_tp_dealloc, _dealloc_VoipCallCoordinator },
        { Py_tp_methods, _methods_VoipCallCoordinator },
        { Py_tp_getset, _getset_VoipCallCoordinator },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VoipCallCoordinator =
    {
        "_winrt_Windows_ApplicationModel_Calls.VoipCallCoordinator",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VoipCallCoordinator
    };

    // ----- VoipPhoneCall class --------------------
    constexpr const char* const _type_name_VoipPhoneCall = "VoipPhoneCall";

    static PyObject* _new_VoipPhoneCall(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VoipPhoneCall);
        return nullptr;
    }

    static void _dealloc_VoipPhoneCall(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VoipPhoneCall_NotifyCallAccepted(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 0);

                self->obj.NotifyCallAccepted(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_NotifyCallActive(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyCallActive();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_NotifyCallEnded(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyCallEnded();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_NotifyCallHeld(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyCallHeld();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_NotifyCallReady(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyCallReady();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_TryShowAppUI(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.TryShowAppUI();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_get_StartTime(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VoipPhoneCall_put_StartTime(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VoipPhoneCall_get_ContactName(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VoipPhoneCall_put_ContactName(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContactName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VoipPhoneCall_get_CallMedia(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CallMedia());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VoipPhoneCall_put_CallMedia(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(arg);

            self->obj.CallMedia(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VoipPhoneCall_add_AnswerRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall, winrt::Windows::ApplicationModel::Calls::CallAnswerEventArgs>>(arg);

            return py::convert(self->obj.AnswerRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_remove_AnswerRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AnswerRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_add_EndRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall, winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>>(arg);

            return py::convert(self->obj.EndRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_remove_EndRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EndRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_add_HoldRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall, winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>>(arg);

            return py::convert(self->obj.HoldRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_remove_HoldRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HoldRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_add_RejectRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall, winrt::Windows::ApplicationModel::Calls::CallRejectEventArgs>>(arg);

            return py::convert(self->obj.RejectRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_remove_RejectRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RejectRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_add_ResumeRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall, winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>>(arg);

            return py::convert(self->obj.ResumeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_remove_ResumeRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ResumeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VoipPhoneCall(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VoipPhoneCall[] = {
        { "notify_call_accepted", (PyCFunction)VoipPhoneCall_NotifyCallAccepted, METH_VARARGS, nullptr },
        { "notify_call_active", (PyCFunction)VoipPhoneCall_NotifyCallActive, METH_VARARGS, nullptr },
        { "notify_call_ended", (PyCFunction)VoipPhoneCall_NotifyCallEnded, METH_VARARGS, nullptr },
        { "notify_call_held", (PyCFunction)VoipPhoneCall_NotifyCallHeld, METH_VARARGS, nullptr },
        { "notify_call_ready", (PyCFunction)VoipPhoneCall_NotifyCallReady, METH_VARARGS, nullptr },
        { "try_show_app_u_i", (PyCFunction)VoipPhoneCall_TryShowAppUI, METH_VARARGS, nullptr },
        { "add_answer_requested", (PyCFunction)VoipPhoneCall_add_AnswerRequested, METH_O, nullptr },
        { "remove_answer_requested", (PyCFunction)VoipPhoneCall_remove_AnswerRequested, METH_O, nullptr },
        { "add_end_requested", (PyCFunction)VoipPhoneCall_add_EndRequested, METH_O, nullptr },
        { "remove_end_requested", (PyCFunction)VoipPhoneCall_remove_EndRequested, METH_O, nullptr },
        { "add_hold_requested", (PyCFunction)VoipPhoneCall_add_HoldRequested, METH_O, nullptr },
        { "remove_hold_requested", (PyCFunction)VoipPhoneCall_remove_HoldRequested, METH_O, nullptr },
        { "add_reject_requested", (PyCFunction)VoipPhoneCall_add_RejectRequested, METH_O, nullptr },
        { "remove_reject_requested", (PyCFunction)VoipPhoneCall_remove_RejectRequested, METH_O, nullptr },
        { "add_resume_requested", (PyCFunction)VoipPhoneCall_add_ResumeRequested, METH_O, nullptr },
        { "remove_resume_requested", (PyCFunction)VoipPhoneCall_remove_ResumeRequested, METH_O, nullptr },
        { "_from", (PyCFunction)_from_VoipPhoneCall, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VoipPhoneCall[] = {
        { const_cast<char*>("start_time"), (getter)VoipPhoneCall_get_StartTime, (setter)VoipPhoneCall_put_StartTime, nullptr, nullptr },
        { const_cast<char*>("contact_name"), (getter)VoipPhoneCall_get_ContactName, (setter)VoipPhoneCall_put_ContactName, nullptr, nullptr },
        { const_cast<char*>("call_media"), (getter)VoipPhoneCall_get_CallMedia, (setter)VoipPhoneCall_put_CallMedia, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VoipPhoneCall[] = 
    {
        { Py_tp_new, _new_VoipPhoneCall },
        { Py_tp_dealloc, _dealloc_VoipPhoneCall },
        { Py_tp_methods, _methods_VoipPhoneCall },
        { Py_tp_getset, _getset_VoipPhoneCall },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VoipPhoneCall =
    {
        "_winrt_Windows_ApplicationModel_Calls.VoipPhoneCall",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VoipPhoneCall
    };

    // ----- Windows.ApplicationModel.Calls Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::ApplicationModel::Calls::CallAnswerEventArgs>::python_type = py::register_python_type(module, _type_name_CallAnswerEventArgs, &_type_spec_CallAnswerEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::CallRejectEventArgs>::python_type = py::register_python_type(module, _type_name_CallRejectEventArgs, &_type_spec_CallRejectEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>::python_type = py::register_python_type(module, _type_name_CallStateChangeEventArgs, &_type_spec_CallStateChangeEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::MuteChangeEventArgs>::python_type = py::register_python_type(module, _type_name_MuteChangeEventArgs, &_type_spec_MuteChangeEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCall>::python_type = py::register_python_type(module, _type_name_PhoneCall, &_type_spec_PhoneCall, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking>::python_type = py::register_python_type(module, _type_name_PhoneCallBlocking, &_type_spec_PhoneCallBlocking, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>::python_type = py::register_python_type(module, _type_name_PhoneCallHistoryEntry, &_type_spec_PhoneCallHistoryEntry, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress>::python_type = py::register_python_type(module, _type_name_PhoneCallHistoryEntryAddress, &_type_spec_PhoneCallHistoryEntryAddress, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions>::python_type = py::register_python_type(module, _type_name_PhoneCallHistoryEntryQueryOptions, &_type_spec_PhoneCallHistoryEntryQueryOptions, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader>::python_type = py::register_python_type(module, _type_name_PhoneCallHistoryEntryReader, &_type_spec_PhoneCallHistoryEntryReader, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManager>::python_type = py::register_python_type(module, _type_name_PhoneCallHistoryManager, &_type_spec_PhoneCallHistoryManager, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser>::python_type = py::register_python_type(module, _type_name_PhoneCallHistoryManagerForUser, &_type_spec_PhoneCallHistoryManagerForUser, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStore>::python_type = py::register_python_type(module, _type_name_PhoneCallHistoryStore, &_type_spec_PhoneCallHistoryStore, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallInfo>::python_type = py::register_python_type(module, _type_name_PhoneCallInfo, &_type_spec_PhoneCallInfo, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallManager>::python_type = py::register_python_type(module, _type_name_PhoneCallManager, &_type_spec_PhoneCallManager, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallStore>::python_type = py::register_python_type(module, _type_name_PhoneCallStore, &_type_spec_PhoneCallStore, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities>::python_type = py::register_python_type(module, _type_name_PhoneCallVideoCapabilities, &_type_spec_PhoneCallVideoCapabilities, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilitiesManager>::python_type = py::register_python_type(module, _type_name_PhoneCallVideoCapabilitiesManager, &_type_spec_PhoneCallVideoCapabilitiesManager, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallsResult>::python_type = py::register_python_type(module, _type_name_PhoneCallsResult, &_type_spec_PhoneCallsResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneDialOptions>::python_type = py::register_python_type(module, _type_name_PhoneDialOptions, &_type_spec_PhoneDialOptions, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLine>::python_type = py::register_python_type(module, _type_name_PhoneLine, &_type_spec_PhoneLine, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineCellularDetails>::python_type = py::register_python_type(module, _type_name_PhoneLineCellularDetails, &_type_spec_PhoneLineCellularDetails, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineConfiguration>::python_type = py::register_python_type(module, _type_name_PhoneLineConfiguration, &_type_spec_PhoneLineConfiguration, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineDialResult>::python_type = py::register_python_type(module, _type_name_PhoneLineDialResult, &_type_spec_PhoneLineDialResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice>::python_type = py::register_python_type(module, _type_name_PhoneLineTransportDevice, &_type_spec_PhoneLineTransportDevice, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher>::python_type = py::register_python_type(module, _type_name_PhoneLineWatcher, &_type_spec_PhoneLineWatcher, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>::python_type = py::register_python_type(module, _type_name_PhoneLineWatcherEventArgs, &_type_spec_PhoneLineWatcherEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneVoicemail>::python_type = py::register_python_type(module, _type_name_PhoneVoicemail, &_type_spec_PhoneVoicemail, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator>::python_type = py::register_python_type(module, _type_name_VoipCallCoordinator, &_type_spec_VoipCallCoordinator, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall>::python_type = py::register_python_type(module, _type_name_VoipPhoneCall, &_type_spec_VoipPhoneCall, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.Calls");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_ApplicationModel_Calls",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::ApplicationModel::Calls

PyMODINIT_FUNC
PyInit__winrt_Windows_ApplicationModel_Calls (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::ApplicationModel::Calls::module_def);
}
