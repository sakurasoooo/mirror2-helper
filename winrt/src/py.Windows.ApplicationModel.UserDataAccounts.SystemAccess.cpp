// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.ApplicationModel.UserDataAccounts.SystemAccess.h"

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::UserDataAccountSystemAccessManager>::python_type;

namespace py::cpp::Windows::ApplicationModel::UserDataAccounts::SystemAccess
{
    // ----- DeviceAccountConfiguration class --------------------
    constexpr const char* const _type_name_DeviceAccountConfiguration = "DeviceAccountConfiguration";

    static PyObject* _new_DeviceAccountConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DeviceAccountConfiguration(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeviceAccountConfiguration_get_EmailAddress(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EmailAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_EmailAddress(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.EmailAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_Domain(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Domain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_Domain(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Domain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_DeviceAccountTypeId(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceAccountTypeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_DeviceAccountTypeId(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DeviceAccountTypeId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_OutgoingServerAddress(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingServerAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_OutgoingServerAddress(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.OutgoingServerAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_ContactsSyncEnabled(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactsSyncEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_ContactsSyncEnabled(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ContactsSyncEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_CalendarSyncEnabled(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CalendarSyncEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_CalendarSyncEnabled(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CalendarSyncEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_AccountName(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccountName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_AccountName(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AccountName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IncomingServerUsername(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IncomingServerUsername());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IncomingServerUsername(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.IncomingServerUsername(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IncomingServerRequiresSsl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IncomingServerRequiresSsl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IncomingServerRequiresSsl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncomingServerRequiresSsl(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IncomingServerPort(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IncomingServerPort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IncomingServerPort(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.IncomingServerPort(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IncomingServerAddress(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IncomingServerAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IncomingServerAddress(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.IncomingServerAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_EmailSyncEnabled(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EmailSyncEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_EmailSyncEnabled(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.EmailSyncEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_ServerType(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_ServerType(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountServerType>(arg);

            self->obj.ServerType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_OutgoingServerUsername(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingServerUsername());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_OutgoingServerUsername(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.OutgoingServerUsername(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_OutgoingServerRequiresSsl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingServerRequiresSsl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_OutgoingServerRequiresSsl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.OutgoingServerRequiresSsl(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_OutgoingServerPort(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingServerPort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_OutgoingServerPort(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.OutgoingServerPort(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_AccountIconId(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccountIconId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_AccountIconId(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountIconId>(arg);

            self->obj.AccountIconId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_CalDavServerUrl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CalDavServerUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_CalDavServerUrl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.CalDavServerUrl(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_CalDavRequiresSsl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CalDavRequiresSsl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_CalDavRequiresSsl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CalDavRequiresSsl(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_AutoSelectAuthenticationCertificate(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoSelectAuthenticationCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_AutoSelectAuthenticationCertificate(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoSelectAuthenticationCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_AuthenticationType(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AuthenticationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_AuthenticationType(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountAuthenticationType>(arg);

            self->obj.AuthenticationType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_AuthenticationCertificateId(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AuthenticationCertificateId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_AuthenticationCertificateId(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AuthenticationCertificateId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IsOutgoingServerAuthenticationEnabled(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOutgoingServerAuthenticationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IsOutgoingServerAuthenticationEnabled(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsOutgoingServerAuthenticationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IsClientAuthenticationCertificateRequired(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsClientAuthenticationCertificateRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IsClientAuthenticationCertificateRequired(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsClientAuthenticationCertificateRequired(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IncomingServerCredential(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IncomingServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IncomingServerCredential(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.IncomingServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IsOutgoingServerAuthenticationRequired(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOutgoingServerAuthenticationRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IsOutgoingServerAuthenticationRequired(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsOutgoingServerAuthenticationRequired(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_CardDavSyncScheduleKind(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CardDavSyncScheduleKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_CardDavSyncScheduleKind(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountSyncScheduleKind>(arg);

            self->obj.CardDavSyncScheduleKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_AlwaysDownloadFullMessage(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlwaysDownloadFullMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_AlwaysDownloadFullMessage(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AlwaysDownloadFullMessage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_CardDavServerUrl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CardDavServerUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_CardDavServerUrl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.CardDavServerUrl(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_CardDavRequiresSsl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CardDavRequiresSsl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_CardDavRequiresSsl(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CardDavRequiresSsl(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_CalDavSyncScheduleKind(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CalDavSyncScheduleKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_CalDavSyncScheduleKind(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountSyncScheduleKind>(arg);

            self->obj.CalDavSyncScheduleKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IncomingServerCertificateHash(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IncomingServerCertificateHash());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IncomingServerCertificateHash(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.IncomingServerCertificateHash(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_WasOutgoingServerCertificateHashConfirmed(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WasOutgoingServerCertificateHashConfirmed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_WasOutgoingServerCertificateHashConfirmed(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.WasOutgoingServerCertificateHashConfirmed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_WasModifiedByUser(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WasModifiedByUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_WasModifiedByUser(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.WasModifiedByUser(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_SyncScheduleKind(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SyncScheduleKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_SyncScheduleKind(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountSyncScheduleKind>(arg);

            self->obj.SyncScheduleKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_SsoAccountId(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SsoAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_SsoAccountId(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SsoAccountId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_WasIncomingServerCertificateHashConfirmed(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WasIncomingServerCertificateHashConfirmed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_WasIncomingServerCertificateHashConfirmed(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.WasIncomingServerCertificateHashConfirmed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_OAuthRefreshToken(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OAuthRefreshToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_OAuthRefreshToken(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.OAuthRefreshToken(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IsExternallyManaged(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsExternallyManaged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IsExternallyManaged(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsExternallyManaged(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_MailAgeFilter(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MailAgeFilter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_MailAgeFilter(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountMailAgeFilter>(arg);

            self->obj.MailAgeFilter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IsSyncScheduleManagedBySystem(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSyncScheduleManagedBySystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_IsSyncScheduleManagedBySystem(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSyncScheduleManagedBySystem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_OutgoingServerCertificateHash(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingServerCertificateHash());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_OutgoingServerCertificateHash(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.OutgoingServerCertificateHash(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_OutgoingServerCredential(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceAccountConfiguration_put_OutgoingServerCredential(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.OutgoingServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_DoesPolicyAllowMailSync(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DoesPolicyAllowMailSync());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceAccountConfiguration_get_IsSsoAuthenticationSupported(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSsoAuthenticationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DeviceAccountConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceAccountConfiguration[] = {
        { "_from", (PyCFunction)_from_DeviceAccountConfiguration, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeviceAccountConfiguration[] = {
        { const_cast<char*>("email_address"), (getter)DeviceAccountConfiguration_get_EmailAddress, (setter)DeviceAccountConfiguration_put_EmailAddress, nullptr, nullptr },
        { const_cast<char*>("domain"), (getter)DeviceAccountConfiguration_get_Domain, (setter)DeviceAccountConfiguration_put_Domain, nullptr, nullptr },
        { const_cast<char*>("device_account_type_id"), (getter)DeviceAccountConfiguration_get_DeviceAccountTypeId, (setter)DeviceAccountConfiguration_put_DeviceAccountTypeId, nullptr, nullptr },
        { const_cast<char*>("outgoing_server_address"), (getter)DeviceAccountConfiguration_get_OutgoingServerAddress, (setter)DeviceAccountConfiguration_put_OutgoingServerAddress, nullptr, nullptr },
        { const_cast<char*>("contacts_sync_enabled"), (getter)DeviceAccountConfiguration_get_ContactsSyncEnabled, (setter)DeviceAccountConfiguration_put_ContactsSyncEnabled, nullptr, nullptr },
        { const_cast<char*>("calendar_sync_enabled"), (getter)DeviceAccountConfiguration_get_CalendarSyncEnabled, (setter)DeviceAccountConfiguration_put_CalendarSyncEnabled, nullptr, nullptr },
        { const_cast<char*>("account_name"), (getter)DeviceAccountConfiguration_get_AccountName, (setter)DeviceAccountConfiguration_put_AccountName, nullptr, nullptr },
        { const_cast<char*>("incoming_server_username"), (getter)DeviceAccountConfiguration_get_IncomingServerUsername, (setter)DeviceAccountConfiguration_put_IncomingServerUsername, nullptr, nullptr },
        { const_cast<char*>("incoming_server_requires_ssl"), (getter)DeviceAccountConfiguration_get_IncomingServerRequiresSsl, (setter)DeviceAccountConfiguration_put_IncomingServerRequiresSsl, nullptr, nullptr },
        { const_cast<char*>("incoming_server_port"), (getter)DeviceAccountConfiguration_get_IncomingServerPort, (setter)DeviceAccountConfiguration_put_IncomingServerPort, nullptr, nullptr },
        { const_cast<char*>("incoming_server_address"), (getter)DeviceAccountConfiguration_get_IncomingServerAddress, (setter)DeviceAccountConfiguration_put_IncomingServerAddress, nullptr, nullptr },
        { const_cast<char*>("email_sync_enabled"), (getter)DeviceAccountConfiguration_get_EmailSyncEnabled, (setter)DeviceAccountConfiguration_put_EmailSyncEnabled, nullptr, nullptr },
        { const_cast<char*>("server_type"), (getter)DeviceAccountConfiguration_get_ServerType, (setter)DeviceAccountConfiguration_put_ServerType, nullptr, nullptr },
        { const_cast<char*>("outgoing_server_username"), (getter)DeviceAccountConfiguration_get_OutgoingServerUsername, (setter)DeviceAccountConfiguration_put_OutgoingServerUsername, nullptr, nullptr },
        { const_cast<char*>("outgoing_server_requires_ssl"), (getter)DeviceAccountConfiguration_get_OutgoingServerRequiresSsl, (setter)DeviceAccountConfiguration_put_OutgoingServerRequiresSsl, nullptr, nullptr },
        { const_cast<char*>("outgoing_server_port"), (getter)DeviceAccountConfiguration_get_OutgoingServerPort, (setter)DeviceAccountConfiguration_put_OutgoingServerPort, nullptr, nullptr },
        { const_cast<char*>("account_icon_id"), (getter)DeviceAccountConfiguration_get_AccountIconId, (setter)DeviceAccountConfiguration_put_AccountIconId, nullptr, nullptr },
        { const_cast<char*>("cal_dav_server_url"), (getter)DeviceAccountConfiguration_get_CalDavServerUrl, (setter)DeviceAccountConfiguration_put_CalDavServerUrl, nullptr, nullptr },
        { const_cast<char*>("cal_dav_requires_ssl"), (getter)DeviceAccountConfiguration_get_CalDavRequiresSsl, (setter)DeviceAccountConfiguration_put_CalDavRequiresSsl, nullptr, nullptr },
        { const_cast<char*>("auto_select_authentication_certificate"), (getter)DeviceAccountConfiguration_get_AutoSelectAuthenticationCertificate, (setter)DeviceAccountConfiguration_put_AutoSelectAuthenticationCertificate, nullptr, nullptr },
        { const_cast<char*>("authentication_type"), (getter)DeviceAccountConfiguration_get_AuthenticationType, (setter)DeviceAccountConfiguration_put_AuthenticationType, nullptr, nullptr },
        { const_cast<char*>("authentication_certificate_id"), (getter)DeviceAccountConfiguration_get_AuthenticationCertificateId, (setter)DeviceAccountConfiguration_put_AuthenticationCertificateId, nullptr, nullptr },
        { const_cast<char*>("is_outgoing_server_authentication_enabled"), (getter)DeviceAccountConfiguration_get_IsOutgoingServerAuthenticationEnabled, (setter)DeviceAccountConfiguration_put_IsOutgoingServerAuthenticationEnabled, nullptr, nullptr },
        { const_cast<char*>("is_client_authentication_certificate_required"), (getter)DeviceAccountConfiguration_get_IsClientAuthenticationCertificateRequired, (setter)DeviceAccountConfiguration_put_IsClientAuthenticationCertificateRequired, nullptr, nullptr },
        { const_cast<char*>("incoming_server_credential"), (getter)DeviceAccountConfiguration_get_IncomingServerCredential, (setter)DeviceAccountConfiguration_put_IncomingServerCredential, nullptr, nullptr },
        { const_cast<char*>("is_outgoing_server_authentication_required"), (getter)DeviceAccountConfiguration_get_IsOutgoingServerAuthenticationRequired, (setter)DeviceAccountConfiguration_put_IsOutgoingServerAuthenticationRequired, nullptr, nullptr },
        { const_cast<char*>("card_dav_sync_schedule_kind"), (getter)DeviceAccountConfiguration_get_CardDavSyncScheduleKind, (setter)DeviceAccountConfiguration_put_CardDavSyncScheduleKind, nullptr, nullptr },
        { const_cast<char*>("always_download_full_message"), (getter)DeviceAccountConfiguration_get_AlwaysDownloadFullMessage, (setter)DeviceAccountConfiguration_put_AlwaysDownloadFullMessage, nullptr, nullptr },
        { const_cast<char*>("card_dav_server_url"), (getter)DeviceAccountConfiguration_get_CardDavServerUrl, (setter)DeviceAccountConfiguration_put_CardDavServerUrl, nullptr, nullptr },
        { const_cast<char*>("card_dav_requires_ssl"), (getter)DeviceAccountConfiguration_get_CardDavRequiresSsl, (setter)DeviceAccountConfiguration_put_CardDavRequiresSsl, nullptr, nullptr },
        { const_cast<char*>("cal_dav_sync_schedule_kind"), (getter)DeviceAccountConfiguration_get_CalDavSyncScheduleKind, (setter)DeviceAccountConfiguration_put_CalDavSyncScheduleKind, nullptr, nullptr },
        { const_cast<char*>("incoming_server_certificate_hash"), (getter)DeviceAccountConfiguration_get_IncomingServerCertificateHash, (setter)DeviceAccountConfiguration_put_IncomingServerCertificateHash, nullptr, nullptr },
        { const_cast<char*>("was_outgoing_server_certificate_hash_confirmed"), (getter)DeviceAccountConfiguration_get_WasOutgoingServerCertificateHashConfirmed, (setter)DeviceAccountConfiguration_put_WasOutgoingServerCertificateHashConfirmed, nullptr, nullptr },
        { const_cast<char*>("was_modified_by_user"), (getter)DeviceAccountConfiguration_get_WasModifiedByUser, (setter)DeviceAccountConfiguration_put_WasModifiedByUser, nullptr, nullptr },
        { const_cast<char*>("sync_schedule_kind"), (getter)DeviceAccountConfiguration_get_SyncScheduleKind, (setter)DeviceAccountConfiguration_put_SyncScheduleKind, nullptr, nullptr },
        { const_cast<char*>("sso_account_id"), (getter)DeviceAccountConfiguration_get_SsoAccountId, (setter)DeviceAccountConfiguration_put_SsoAccountId, nullptr, nullptr },
        { const_cast<char*>("was_incoming_server_certificate_hash_confirmed"), (getter)DeviceAccountConfiguration_get_WasIncomingServerCertificateHashConfirmed, (setter)DeviceAccountConfiguration_put_WasIncomingServerCertificateHashConfirmed, nullptr, nullptr },
        { const_cast<char*>("o_auth_refresh_token"), (getter)DeviceAccountConfiguration_get_OAuthRefreshToken, (setter)DeviceAccountConfiguration_put_OAuthRefreshToken, nullptr, nullptr },
        { const_cast<char*>("is_externally_managed"), (getter)DeviceAccountConfiguration_get_IsExternallyManaged, (setter)DeviceAccountConfiguration_put_IsExternallyManaged, nullptr, nullptr },
        { const_cast<char*>("mail_age_filter"), (getter)DeviceAccountConfiguration_get_MailAgeFilter, (setter)DeviceAccountConfiguration_put_MailAgeFilter, nullptr, nullptr },
        { const_cast<char*>("is_sync_schedule_managed_by_system"), (getter)DeviceAccountConfiguration_get_IsSyncScheduleManagedBySystem, (setter)DeviceAccountConfiguration_put_IsSyncScheduleManagedBySystem, nullptr, nullptr },
        { const_cast<char*>("outgoing_server_certificate_hash"), (getter)DeviceAccountConfiguration_get_OutgoingServerCertificateHash, (setter)DeviceAccountConfiguration_put_OutgoingServerCertificateHash, nullptr, nullptr },
        { const_cast<char*>("outgoing_server_credential"), (getter)DeviceAccountConfiguration_get_OutgoingServerCredential, (setter)DeviceAccountConfiguration_put_OutgoingServerCredential, nullptr, nullptr },
        { const_cast<char*>("does_policy_allow_mail_sync"), (getter)DeviceAccountConfiguration_get_DoesPolicyAllowMailSync, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_sso_authentication_supported"), (getter)DeviceAccountConfiguration_get_IsSsoAuthenticationSupported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DeviceAccountConfiguration[] = 
    {
        { Py_tp_new, _new_DeviceAccountConfiguration },
        { Py_tp_dealloc, _dealloc_DeviceAccountConfiguration },
        { Py_tp_methods, _methods_DeviceAccountConfiguration },
        { Py_tp_getset, _getset_DeviceAccountConfiguration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeviceAccountConfiguration =
    {
        "_winrt_Windows_ApplicationModel_UserDataAccounts_SystemAccess.DeviceAccountConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceAccountConfiguration
    };

    // ----- UserDataAccountSystemAccessManager class --------------------
    constexpr const char* const _type_name_UserDataAccountSystemAccessManager = "UserDataAccountSystemAccessManager";

    static PyObject* _new_UserDataAccountSystemAccessManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UserDataAccountSystemAccessManager);
        return nullptr;
    }

    static PyObject* UserDataAccountSystemAccessManager_AddAndShowDeviceAccountsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration>>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::UserDataAccountSystemAccessManager::AddAndShowDeviceAccountsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserDataAccountSystemAccessManager_CreateDeviceAccountAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::UserDataAccountSystemAccessManager::CreateDeviceAccountAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserDataAccountSystemAccessManager_DeleteDeviceAccountAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::UserDataAccountSystemAccessManager::DeleteDeviceAccountAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserDataAccountSystemAccessManager_GetDeviceAccountConfigurationAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::UserDataAccountSystemAccessManager::GetDeviceAccountConfigurationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserDataAccountSystemAccessManager_SuppressLocalAccountWithAccountAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::UserDataAccountSystemAccessManager::SuppressLocalAccountWithAccountAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserDataAccountSystemAccessManager[] = {
        { "add_and_show_device_accounts_async", (PyCFunction)UserDataAccountSystemAccessManager_AddAndShowDeviceAccountsAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "create_device_account_async", (PyCFunction)UserDataAccountSystemAccessManager_CreateDeviceAccountAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "delete_device_account_async", (PyCFunction)UserDataAccountSystemAccessManager_DeleteDeviceAccountAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_account_configuration_async", (PyCFunction)UserDataAccountSystemAccessManager_GetDeviceAccountConfigurationAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "suppress_local_account_with_account_async", (PyCFunction)UserDataAccountSystemAccessManager_SuppressLocalAccountWithAccountAsync, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UserDataAccountSystemAccessManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_UserDataAccountSystemAccessManager[] = 
    {
        { Py_tp_new, _new_UserDataAccountSystemAccessManager },
        { Py_tp_methods, _methods_UserDataAccountSystemAccessManager },
        { Py_tp_getset, _getset_UserDataAccountSystemAccessManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UserDataAccountSystemAccessManager =
    {
        "_winrt_Windows_ApplicationModel_UserDataAccounts_SystemAccess.UserDataAccountSystemAccessManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserDataAccountSystemAccessManager
    };

    // ----- Windows.ApplicationModel.UserDataAccounts.SystemAccess Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::DeviceAccountConfiguration>::python_type = py::register_python_type(module, _type_name_DeviceAccountConfiguration, &_type_spec_DeviceAccountConfiguration, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::UserDataAccounts::SystemAccess::UserDataAccountSystemAccessManager>::python_type = py::register_python_type(module, _type_name_UserDataAccountSystemAccessManager, &_type_spec_UserDataAccountSystemAccessManager, nullptr);

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.UserDataAccounts.SystemAccess");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_ApplicationModel_UserDataAccounts_SystemAccess",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::ApplicationModel::UserDataAccounts::SystemAccess

PyMODINIT_FUNC
PyInit__winrt_Windows_ApplicationModel_UserDataAccounts_SystemAccess (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::ApplicationModel::UserDataAccounts::SystemAccess::module_def);
}
