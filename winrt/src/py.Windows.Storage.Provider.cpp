// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Storage.Provider.h"

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::CachedFileUpdater>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::CachedFileUpdaterUI>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::FileUpdateRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::FileUpdateRequestDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderError>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderErrorCommand>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderItemProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderItemProperty>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderItemPropertyDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderStatus>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderSyncRootManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderHandlerFactory>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderStatusSource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderUriSource>::python_type;

namespace py::cpp::Windows::Storage::Provider
{
    // ----- CachedFileUpdater class --------------------
    constexpr const char* const _type_name_CachedFileUpdater = "CachedFileUpdater";

    static PyObject* _new_CachedFileUpdater(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CachedFileUpdater);
        return nullptr;
    }

    static PyObject* CachedFileUpdater_SetUpdateInformation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Provider::ReadActivationMode>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Provider::WriteActivationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Storage::Provider::CachedFileOptions>(args, 4);

                winrt::Windows::Storage::Provider::CachedFileUpdater::SetUpdateInformation(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileUpdater[] = {
        { "set_update_information", (PyCFunction)CachedFileUpdater_SetUpdateInformation, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CachedFileUpdater[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_CachedFileUpdater[] = 
    {
        { Py_tp_new, _new_CachedFileUpdater },
        { Py_tp_methods, _methods_CachedFileUpdater },
        { Py_tp_getset, _getset_CachedFileUpdater },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CachedFileUpdater =
    {
        "_winrt_Windows_Storage_Provider.CachedFileUpdater",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileUpdater
    };

    // ----- CachedFileUpdaterUI class --------------------
    constexpr const char* const _type_name_CachedFileUpdaterUI = "CachedFileUpdaterUI";

    static PyObject* _new_CachedFileUpdaterUI(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CachedFileUpdaterUI);
        return nullptr;
    }

    static void _dealloc_CachedFileUpdaterUI(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CachedFileUpdaterUI_GetDeferral(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_get_Title(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CachedFileUpdaterUI_put_Title(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CachedFileUpdaterUI_get_UIStatus(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UIStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_get_UpdateTarget(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_get_UpdateRequest(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateRequest());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_add_FileUpdateRequested(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::CachedFileUpdaterUI, winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs>>(arg);

            return py::convert(self->obj.FileUpdateRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_remove_FileUpdateRequested(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FileUpdateRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_add_UIRequested(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::CachedFileUpdaterUI, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.UIRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_remove_UIRequested(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UIRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CachedFileUpdaterUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::CachedFileUpdaterUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileUpdaterUI[] = {
        { "get_deferral", (PyCFunction)CachedFileUpdaterUI_GetDeferral, METH_VARARGS, nullptr },
        { "add_file_update_requested", (PyCFunction)CachedFileUpdaterUI_add_FileUpdateRequested, METH_O, nullptr },
        { "remove_file_update_requested", (PyCFunction)CachedFileUpdaterUI_remove_FileUpdateRequested, METH_O, nullptr },
        { "add_u_i_requested", (PyCFunction)CachedFileUpdaterUI_add_UIRequested, METH_O, nullptr },
        { "remove_u_i_requested", (PyCFunction)CachedFileUpdaterUI_remove_UIRequested, METH_O, nullptr },
        { "_from", (PyCFunction)_from_CachedFileUpdaterUI, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CachedFileUpdaterUI[] = {
        { const_cast<char*>("title"), (getter)CachedFileUpdaterUI_get_Title, (setter)CachedFileUpdaterUI_put_Title, nullptr, nullptr },
        { const_cast<char*>("u_i_status"), (getter)CachedFileUpdaterUI_get_UIStatus, nullptr, nullptr, nullptr },
        { const_cast<char*>("update_target"), (getter)CachedFileUpdaterUI_get_UpdateTarget, nullptr, nullptr, nullptr },
        { const_cast<char*>("update_request"), (getter)CachedFileUpdaterUI_get_UpdateRequest, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CachedFileUpdaterUI[] = 
    {
        { Py_tp_new, _new_CachedFileUpdaterUI },
        { Py_tp_dealloc, _dealloc_CachedFileUpdaterUI },
        { Py_tp_methods, _methods_CachedFileUpdaterUI },
        { Py_tp_getset, _getset_CachedFileUpdaterUI },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CachedFileUpdaterUI =
    {
        "_winrt_Windows_Storage_Provider.CachedFileUpdaterUI",
        sizeof(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileUpdaterUI
    };

    // ----- FileUpdateRequest class --------------------
    constexpr const char* const _type_name_FileUpdateRequest = "FileUpdateRequest";

    static PyObject* _new_FileUpdateRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FileUpdateRequest);
        return nullptr;
    }

    static void _dealloc_FileUpdateRequest(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FileUpdateRequest_GetDeferral(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileUpdateRequest_UpdateLocalFile(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                self->obj.UpdateLocalFile(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileUpdateRequest_get_Status(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FileUpdateRequest_put_Status(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::FileUpdateStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FileUpdateRequest_get_ContentId(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileUpdateRequest_get_File(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileUpdateRequest_get_UserInputNeededMessage(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserInputNeededMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FileUpdateRequest_put_UserInputNeededMessage(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.UserInputNeededMessage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_FileUpdateRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::FileUpdateRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileUpdateRequest[] = {
        { "get_deferral", (PyCFunction)FileUpdateRequest_GetDeferral, METH_VARARGS, nullptr },
        { "update_local_file", (PyCFunction)FileUpdateRequest_UpdateLocalFile, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_FileUpdateRequest, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FileUpdateRequest[] = {
        { const_cast<char*>("status"), (getter)FileUpdateRequest_get_Status, (setter)FileUpdateRequest_put_Status, nullptr, nullptr },
        { const_cast<char*>("content_id"), (getter)FileUpdateRequest_get_ContentId, nullptr, nullptr, nullptr },
        { const_cast<char*>("file"), (getter)FileUpdateRequest_get_File, nullptr, nullptr, nullptr },
        { const_cast<char*>("user_input_needed_message"), (getter)FileUpdateRequest_get_UserInputNeededMessage, (setter)FileUpdateRequest_put_UserInputNeededMessage, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FileUpdateRequest[] = 
    {
        { Py_tp_new, _new_FileUpdateRequest },
        { Py_tp_dealloc, _dealloc_FileUpdateRequest },
        { Py_tp_methods, _methods_FileUpdateRequest },
        { Py_tp_getset, _getset_FileUpdateRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FileUpdateRequest =
    {
        "_winrt_Windows_Storage_Provider.FileUpdateRequest",
        sizeof(py::wrapper::Windows::Storage::Provider::FileUpdateRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileUpdateRequest
    };

    // ----- FileUpdateRequestDeferral class --------------------
    constexpr const char* const _type_name_FileUpdateRequestDeferral = "FileUpdateRequestDeferral";

    static PyObject* _new_FileUpdateRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FileUpdateRequestDeferral);
        return nullptr;
    }

    static void _dealloc_FileUpdateRequestDeferral(py::wrapper::Windows::Storage::Provider::FileUpdateRequestDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FileUpdateRequestDeferral_Complete(py::wrapper::Windows::Storage::Provider::FileUpdateRequestDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_FileUpdateRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::FileUpdateRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileUpdateRequestDeferral[] = {
        { "complete", (PyCFunction)FileUpdateRequestDeferral_Complete, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_FileUpdateRequestDeferral, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FileUpdateRequestDeferral[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_FileUpdateRequestDeferral[] = 
    {
        { Py_tp_new, _new_FileUpdateRequestDeferral },
        { Py_tp_dealloc, _dealloc_FileUpdateRequestDeferral },
        { Py_tp_methods, _methods_FileUpdateRequestDeferral },
        { Py_tp_getset, _getset_FileUpdateRequestDeferral },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FileUpdateRequestDeferral =
    {
        "_winrt_Windows_Storage_Provider.FileUpdateRequestDeferral",
        sizeof(py::wrapper::Windows::Storage::Provider::FileUpdateRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileUpdateRequestDeferral
    };

    // ----- FileUpdateRequestedEventArgs class --------------------
    constexpr const char* const _type_name_FileUpdateRequestedEventArgs = "FileUpdateRequestedEventArgs";

    static PyObject* _new_FileUpdateRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FileUpdateRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_FileUpdateRequestedEventArgs(py::wrapper::Windows::Storage::Provider::FileUpdateRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FileUpdateRequestedEventArgs_get_Request(py::wrapper::Windows::Storage::Provider::FileUpdateRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FileUpdateRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileUpdateRequestedEventArgs[] = {
        { "_from", (PyCFunction)_from_FileUpdateRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FileUpdateRequestedEventArgs[] = {
        { const_cast<char*>("request"), (getter)FileUpdateRequestedEventArgs_get_Request, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FileUpdateRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_FileUpdateRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_FileUpdateRequestedEventArgs },
        { Py_tp_methods, _methods_FileUpdateRequestedEventArgs },
        { Py_tp_getset, _getset_FileUpdateRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FileUpdateRequestedEventArgs =
    {
        "_winrt_Windows_Storage_Provider.FileUpdateRequestedEventArgs",
        sizeof(py::wrapper::Windows::Storage::Provider::FileUpdateRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileUpdateRequestedEventArgs
    };

    // ----- StorageProviderError class --------------------
    constexpr const char* const _type_name_StorageProviderError = "StorageProviderError";

    static PyObject* _new_StorageProviderError(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::Storage::Provider::StorageProviderError instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderError(py::wrapper::Windows::Storage::Provider::StorageProviderError* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageProviderError_get_SecondaryAction(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SecondaryAction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderError_put_SecondaryAction(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderErrorCommand>(arg);

            self->obj.SecondaryAction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderError_get_PrimaryAction(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrimaryAction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderError_put_PrimaryAction(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderErrorCommand>(arg);

            self->obj.PrimaryAction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderError_get_InformationalLink(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InformationalLink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderError_put_InformationalLink(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderErrorCommand>(arg);

            self->obj.InformationalLink(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderError_get_FilePath(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FilePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderError_put_FilePath(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FilePath(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderError_get_Id(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderError_get_Message(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderError_get_Title(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageProviderError(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderError>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderError[] = {
        { "_from", (PyCFunction)_from_StorageProviderError, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageProviderError[] = {
        { const_cast<char*>("secondary_action"), (getter)StorageProviderError_get_SecondaryAction, (setter)StorageProviderError_put_SecondaryAction, nullptr, nullptr },
        { const_cast<char*>("primary_action"), (getter)StorageProviderError_get_PrimaryAction, (setter)StorageProviderError_put_PrimaryAction, nullptr, nullptr },
        { const_cast<char*>("informational_link"), (getter)StorageProviderError_get_InformationalLink, (setter)StorageProviderError_put_InformationalLink, nullptr, nullptr },
        { const_cast<char*>("file_path"), (getter)StorageProviderError_get_FilePath, (setter)StorageProviderError_put_FilePath, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)StorageProviderError_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("message"), (getter)StorageProviderError_get_Message, nullptr, nullptr, nullptr },
        { const_cast<char*>("title"), (getter)StorageProviderError_get_Title, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageProviderError[] = 
    {
        { Py_tp_new, _new_StorageProviderError },
        { Py_tp_dealloc, _dealloc_StorageProviderError },
        { Py_tp_methods, _methods_StorageProviderError },
        { Py_tp_getset, _getset_StorageProviderError },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderError =
    {
        "_winrt_Windows_Storage_Provider.StorageProviderError",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderError),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderError
    };

    // ----- StorageProviderErrorCommand class --------------------
    constexpr const char* const _type_name_StorageProviderErrorCommand = "StorageProviderErrorCommand";

    static PyObject* _new_StorageProviderErrorCommand(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);

                winrt::Windows::Storage::Provider::StorageProviderErrorCommand instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderErrorCommand(py::wrapper::Windows::Storage::Provider::StorageProviderErrorCommand* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageProviderErrorCommand_get_ActionUri(py::wrapper::Windows::Storage::Provider::StorageProviderErrorCommand* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActionUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderErrorCommand_get_Label(py::wrapper::Windows::Storage::Provider::StorageProviderErrorCommand* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageProviderErrorCommand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderErrorCommand>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderErrorCommand[] = {
        { "_from", (PyCFunction)_from_StorageProviderErrorCommand, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageProviderErrorCommand[] = {
        { const_cast<char*>("action_uri"), (getter)StorageProviderErrorCommand_get_ActionUri, nullptr, nullptr, nullptr },
        { const_cast<char*>("label"), (getter)StorageProviderErrorCommand_get_Label, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageProviderErrorCommand[] = 
    {
        { Py_tp_new, _new_StorageProviderErrorCommand },
        { Py_tp_dealloc, _dealloc_StorageProviderErrorCommand },
        { Py_tp_methods, _methods_StorageProviderErrorCommand },
        { Py_tp_getset, _getset_StorageProviderErrorCommand },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderErrorCommand =
    {
        "_winrt_Windows_Storage_Provider.StorageProviderErrorCommand",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderErrorCommand),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderErrorCommand
    };

    // ----- StorageProviderFileTypeInfo class --------------------
    constexpr const char* const _type_name_StorageProviderFileTypeInfo = "StorageProviderFileTypeInfo";

    static PyObject* _new_StorageProviderFileTypeInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderFileTypeInfo(py::wrapper::Windows::Storage::Provider::StorageProviderFileTypeInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageProviderFileTypeInfo_get_FileExtension(py::wrapper::Windows::Storage::Provider::StorageProviderFileTypeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileExtension());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderFileTypeInfo_get_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderFileTypeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IconResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageProviderFileTypeInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderFileTypeInfo[] = {
        { "_from", (PyCFunction)_from_StorageProviderFileTypeInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageProviderFileTypeInfo[] = {
        { const_cast<char*>("file_extension"), (getter)StorageProviderFileTypeInfo_get_FileExtension, nullptr, nullptr, nullptr },
        { const_cast<char*>("icon_resource"), (getter)StorageProviderFileTypeInfo_get_IconResource, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageProviderFileTypeInfo[] = 
    {
        { Py_tp_new, _new_StorageProviderFileTypeInfo },
        { Py_tp_dealloc, _dealloc_StorageProviderFileTypeInfo },
        { Py_tp_methods, _methods_StorageProviderFileTypeInfo },
        { Py_tp_getset, _getset_StorageProviderFileTypeInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderFileTypeInfo =
    {
        "_winrt_Windows_Storage_Provider.StorageProviderFileTypeInfo",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderFileTypeInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderFileTypeInfo
    };

    // ----- StorageProviderGetContentInfoForPathResult class --------------------
    constexpr const char* const _type_name_StorageProviderGetContentInfoForPathResult = "StorageProviderGetContentInfoForPathResult";

    static PyObject* _new_StorageProviderGetContentInfoForPathResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderGetContentInfoForPathResult(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageProviderGetContentInfoForPathResult_get_Status(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetContentInfoForPathResult_put_Status(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderUriSourceStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderGetContentInfoForPathResult_get_ContentUri(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetContentInfoForPathResult_put_ContentUri(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContentUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderGetContentInfoForPathResult_get_ContentId(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetContentInfoForPathResult_put_ContentId(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContentId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StorageProviderGetContentInfoForPathResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderGetContentInfoForPathResult[] = {
        { "_from", (PyCFunction)_from_StorageProviderGetContentInfoForPathResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageProviderGetContentInfoForPathResult[] = {
        { const_cast<char*>("status"), (getter)StorageProviderGetContentInfoForPathResult_get_Status, (setter)StorageProviderGetContentInfoForPathResult_put_Status, nullptr, nullptr },
        { const_cast<char*>("content_uri"), (getter)StorageProviderGetContentInfoForPathResult_get_ContentUri, (setter)StorageProviderGetContentInfoForPathResult_put_ContentUri, nullptr, nullptr },
        { const_cast<char*>("content_id"), (getter)StorageProviderGetContentInfoForPathResult_get_ContentId, (setter)StorageProviderGetContentInfoForPathResult_put_ContentId, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageProviderGetContentInfoForPathResult[] = 
    {
        { Py_tp_new, _new_StorageProviderGetContentInfoForPathResult },
        { Py_tp_dealloc, _dealloc_StorageProviderGetContentInfoForPathResult },
        { Py_tp_methods, _methods_StorageProviderGetContentInfoForPathResult },
        { Py_tp_getset, _getset_StorageProviderGetContentInfoForPathResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderGetContentInfoForPathResult =
    {
        "_winrt_Windows_Storage_Provider.StorageProviderGetContentInfoForPathResult",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderGetContentInfoForPathResult
    };

    // ----- StorageProviderGetPathForContentUriResult class --------------------
    constexpr const char* const _type_name_StorageProviderGetPathForContentUriResult = "StorageProviderGetPathForContentUriResult";

    static PyObject* _new_StorageProviderGetPathForContentUriResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderGetPathForContentUriResult(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageProviderGetPathForContentUriResult_get_Status(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetPathForContentUriResult_put_Status(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderUriSourceStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderGetPathForContentUriResult_get_Path(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetPathForContentUriResult_put_Path(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Path(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StorageProviderGetPathForContentUriResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderGetPathForContentUriResult[] = {
        { "_from", (PyCFunction)_from_StorageProviderGetPathForContentUriResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageProviderGetPathForContentUriResult[] = {
        { const_cast<char*>("status"), (getter)StorageProviderGetPathForContentUriResult_get_Status, (setter)StorageProviderGetPathForContentUriResult_put_Status, nullptr, nullptr },
        { const_cast<char*>("path"), (getter)StorageProviderGetPathForContentUriResult_get_Path, (setter)StorageProviderGetPathForContentUriResult_put_Path, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageProviderGetPathForContentUriResult[] = 
    {
        { Py_tp_new, _new_StorageProviderGetPathForContentUriResult },
        { Py_tp_dealloc, _dealloc_StorageProviderGetPathForContentUriResult },
        { Py_tp_methods, _methods_StorageProviderGetPathForContentUriResult },
        { Py_tp_getset, _getset_StorageProviderGetPathForContentUriResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderGetPathForContentUriResult =
    {
        "_winrt_Windows_Storage_Provider.StorageProviderGetPathForContentUriResult",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderGetPathForContentUriResult
    };

    // ----- StorageProviderItemProperties class --------------------
    constexpr const char* const _type_name_StorageProviderItemProperties = "StorageProviderItemProperties";

    static PyObject* _new_StorageProviderItemProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageProviderItemProperties);
        return nullptr;
    }

    static PyObject* StorageProviderItemProperties_SetAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::Provider::StorageProviderItemProperty>>(args, 1);

                return py::convert(winrt::Windows::Storage::Provider::StorageProviderItemProperties::SetAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderItemProperties[] = {
        { "set_async", (PyCFunction)StorageProviderItemProperties_SetAsync, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageProviderItemProperties[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageProviderItemProperties[] = 
    {
        { Py_tp_new, _new_StorageProviderItemProperties },
        { Py_tp_methods, _methods_StorageProviderItemProperties },
        { Py_tp_getset, _getset_StorageProviderItemProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderItemProperties =
    {
        "_winrt_Windows_Storage_Provider.StorageProviderItemProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderItemProperties
    };

    // ----- StorageProviderItemProperty class --------------------
    constexpr const char* const _type_name_StorageProviderItemProperty = "StorageProviderItemProperty";

    static PyObject* _new_StorageProviderItemProperty(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderItemProperty instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderItemProperty(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageProviderItemProperty_get_Value(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemProperty_put_Value(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderItemProperty_get_Id(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemProperty_put_Id(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderItemProperty_get_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IconResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemProperty_put_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.IconResource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StorageProviderItemProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderItemProperty>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderItemProperty[] = {
        { "_from", (PyCFunction)_from_StorageProviderItemProperty, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageProviderItemProperty[] = {
        { const_cast<char*>("value"), (getter)StorageProviderItemProperty_get_Value, (setter)StorageProviderItemProperty_put_Value, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)StorageProviderItemProperty_get_Id, (setter)StorageProviderItemProperty_put_Id, nullptr, nullptr },
        { const_cast<char*>("icon_resource"), (getter)StorageProviderItemProperty_get_IconResource, (setter)StorageProviderItemProperty_put_IconResource, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageProviderItemProperty[] = 
    {
        { Py_tp_new, _new_StorageProviderItemProperty },
        { Py_tp_dealloc, _dealloc_StorageProviderItemProperty },
        { Py_tp_methods, _methods_StorageProviderItemProperty },
        { Py_tp_getset, _getset_StorageProviderItemProperty },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderItemProperty =
    {
        "_winrt_Windows_Storage_Provider.StorageProviderItemProperty",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderItemProperty
    };

    // ----- StorageProviderItemPropertyDefinition class --------------------
    constexpr const char* const _type_name_StorageProviderItemPropertyDefinition = "StorageProviderItemPropertyDefinition";

    static PyObject* _new_StorageProviderItemPropertyDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderItemPropertyDefinition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderItemPropertyDefinition(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageProviderItemPropertyDefinition_get_Id(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemPropertyDefinition_put_Id(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderItemPropertyDefinition_get_DisplayNameResource(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayNameResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemPropertyDefinition_put_DisplayNameResource(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayNameResource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StorageProviderItemPropertyDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderItemPropertyDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderItemPropertyDefinition[] = {
        { "_from", (PyCFunction)_from_StorageProviderItemPropertyDefinition, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageProviderItemPropertyDefinition[] = {
        { const_cast<char*>("id"), (getter)StorageProviderItemPropertyDefinition_get_Id, (setter)StorageProviderItemPropertyDefinition_put_Id, nullptr, nullptr },
        { const_cast<char*>("display_name_resource"), (getter)StorageProviderItemPropertyDefinition_get_DisplayNameResource, (setter)StorageProviderItemPropertyDefinition_put_DisplayNameResource, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageProviderItemPropertyDefinition[] = 
    {
        { Py_tp_new, _new_StorageProviderItemPropertyDefinition },
        { Py_tp_dealloc, _dealloc_StorageProviderItemPropertyDefinition },
        { Py_tp_methods, _methods_StorageProviderItemPropertyDefinition },
        { Py_tp_getset, _getset_StorageProviderItemPropertyDefinition },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderItemPropertyDefinition =
    {
        "_winrt_Windows_Storage_Provider.StorageProviderItemPropertyDefinition",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderItemPropertyDefinition
    };

    // ----- StorageProviderStatus class --------------------
    constexpr const char* const _type_name_StorageProviderStatus = "StorageProviderStatus";

    static PyObject* _new_StorageProviderStatus(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderState>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Storage::Provider::StorageProviderStatus instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderState>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::Provider::StorageProviderError>>(args, 2);

                winrt::Windows::Storage::Provider::StorageProviderStatus instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderStatus(py::wrapper::Windows::Storage::Provider::StorageProviderStatus* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageProviderStatus_get_ErrorMessages(py::wrapper::Windows::Storage::Provider::StorageProviderStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorMessages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderStatus_get_Message(py::wrapper::Windows::Storage::Provider::StorageProviderStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderStatus_get_State(py::wrapper::Windows::Storage::Provider::StorageProviderStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageProviderStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderStatus[] = {
        { "_from", (PyCFunction)_from_StorageProviderStatus, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageProviderStatus[] = {
        { const_cast<char*>("error_messages"), (getter)StorageProviderStatus_get_ErrorMessages, nullptr, nullptr, nullptr },
        { const_cast<char*>("message"), (getter)StorageProviderStatus_get_Message, nullptr, nullptr, nullptr },
        { const_cast<char*>("state"), (getter)StorageProviderStatus_get_State, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageProviderStatus[] = 
    {
        { Py_tp_new, _new_StorageProviderStatus },
        { Py_tp_dealloc, _dealloc_StorageProviderStatus },
        { Py_tp_methods, _methods_StorageProviderStatus },
        { Py_tp_getset, _getset_StorageProviderStatus },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderStatus =
    {
        "_winrt_Windows_Storage_Provider.StorageProviderStatus",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderStatus
    };

    // ----- StorageProviderSyncRootInfo class --------------------
    constexpr const char* const _type_name_StorageProviderSyncRootInfo = "StorageProviderSyncRootInfo";

    static PyObject* _new_StorageProviderSyncRootInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderSyncRootInfo(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageProviderSyncRootInfo_get_Version(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_Version(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Version(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_ShowSiblingsAsGroup(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShowSiblingsAsGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_ShowSiblingsAsGroup(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowSiblingsAsGroup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_RecycleBinUri(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RecycleBinUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_RecycleBinUri(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.RecycleBinUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_ProtectionMode(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_ProtectionMode(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderProtectionMode>(arg);

            self->obj.ProtectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_PopulationPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PopulationPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_PopulationPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderPopulationPolicy>(arg);

            self->obj.PopulationPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_Path(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_Path(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(arg);

            self->obj.Path(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_InSyncPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InSyncPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_InSyncPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderInSyncPolicy>(arg);

            self->obj.InSyncPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_Id(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_Id(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IconResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.IconResource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_HydrationPolicyModifier(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HydrationPolicyModifier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_HydrationPolicyModifier(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderHydrationPolicyModifier>(arg);

            self->obj.HydrationPolicyModifier(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_HydrationPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HydrationPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_HydrationPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderHydrationPolicy>(arg);

            self->obj.HydrationPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_HardlinkPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardlinkPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_HardlinkPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderHardlinkPolicy>(arg);

            self->obj.HardlinkPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_DisplayNameResource(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayNameResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_DisplayNameResource(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayNameResource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_Context(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Context());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_Context(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.Context(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_AllowPinning(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowPinning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_AllowPinning(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowPinning(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_StorageProviderItemPropertyDefinitions(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StorageProviderItemPropertyDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_ProviderId(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_ProviderId(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.ProviderId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_FallbackFileTypeInfo(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FallbackFileTypeInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageProviderSyncRootInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderSyncRootInfo[] = {
        { "_from", (PyCFunction)_from_StorageProviderSyncRootInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageProviderSyncRootInfo[] = {
        { const_cast<char*>("version"), (getter)StorageProviderSyncRootInfo_get_Version, (setter)StorageProviderSyncRootInfo_put_Version, nullptr, nullptr },
        { const_cast<char*>("show_siblings_as_group"), (getter)StorageProviderSyncRootInfo_get_ShowSiblingsAsGroup, (setter)StorageProviderSyncRootInfo_put_ShowSiblingsAsGroup, nullptr, nullptr },
        { const_cast<char*>("recycle_bin_uri"), (getter)StorageProviderSyncRootInfo_get_RecycleBinUri, (setter)StorageProviderSyncRootInfo_put_RecycleBinUri, nullptr, nullptr },
        { const_cast<char*>("protection_mode"), (getter)StorageProviderSyncRootInfo_get_ProtectionMode, (setter)StorageProviderSyncRootInfo_put_ProtectionMode, nullptr, nullptr },
        { const_cast<char*>("population_policy"), (getter)StorageProviderSyncRootInfo_get_PopulationPolicy, (setter)StorageProviderSyncRootInfo_put_PopulationPolicy, nullptr, nullptr },
        { const_cast<char*>("path"), (getter)StorageProviderSyncRootInfo_get_Path, (setter)StorageProviderSyncRootInfo_put_Path, nullptr, nullptr },
        { const_cast<char*>("in_sync_policy"), (getter)StorageProviderSyncRootInfo_get_InSyncPolicy, (setter)StorageProviderSyncRootInfo_put_InSyncPolicy, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)StorageProviderSyncRootInfo_get_Id, (setter)StorageProviderSyncRootInfo_put_Id, nullptr, nullptr },
        { const_cast<char*>("icon_resource"), (getter)StorageProviderSyncRootInfo_get_IconResource, (setter)StorageProviderSyncRootInfo_put_IconResource, nullptr, nullptr },
        { const_cast<char*>("hydration_policy_modifier"), (getter)StorageProviderSyncRootInfo_get_HydrationPolicyModifier, (setter)StorageProviderSyncRootInfo_put_HydrationPolicyModifier, nullptr, nullptr },
        { const_cast<char*>("hydration_policy"), (getter)StorageProviderSyncRootInfo_get_HydrationPolicy, (setter)StorageProviderSyncRootInfo_put_HydrationPolicy, nullptr, nullptr },
        { const_cast<char*>("hardlink_policy"), (getter)StorageProviderSyncRootInfo_get_HardlinkPolicy, (setter)StorageProviderSyncRootInfo_put_HardlinkPolicy, nullptr, nullptr },
        { const_cast<char*>("display_name_resource"), (getter)StorageProviderSyncRootInfo_get_DisplayNameResource, (setter)StorageProviderSyncRootInfo_put_DisplayNameResource, nullptr, nullptr },
        { const_cast<char*>("context"), (getter)StorageProviderSyncRootInfo_get_Context, (setter)StorageProviderSyncRootInfo_put_Context, nullptr, nullptr },
        { const_cast<char*>("allow_pinning"), (getter)StorageProviderSyncRootInfo_get_AllowPinning, (setter)StorageProviderSyncRootInfo_put_AllowPinning, nullptr, nullptr },
        { const_cast<char*>("storage_provider_item_property_definitions"), (getter)StorageProviderSyncRootInfo_get_StorageProviderItemPropertyDefinitions, nullptr, nullptr, nullptr },
        { const_cast<char*>("provider_id"), (getter)StorageProviderSyncRootInfo_get_ProviderId, (setter)StorageProviderSyncRootInfo_put_ProviderId, nullptr, nullptr },
        { const_cast<char*>("fallback_file_type_info"), (getter)StorageProviderSyncRootInfo_get_FallbackFileTypeInfo, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageProviderSyncRootInfo[] = 
    {
        { Py_tp_new, _new_StorageProviderSyncRootInfo },
        { Py_tp_dealloc, _dealloc_StorageProviderSyncRootInfo },
        { Py_tp_methods, _methods_StorageProviderSyncRootInfo },
        { Py_tp_getset, _getset_StorageProviderSyncRootInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderSyncRootInfo =
    {
        "_winrt_Windows_Storage_Provider.StorageProviderSyncRootInfo",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderSyncRootInfo
    };

    // ----- StorageProviderSyncRootManager class --------------------
    constexpr const char* const _type_name_StorageProviderSyncRootManager = "StorageProviderSyncRootManager";

    static PyObject* _new_StorageProviderSyncRootManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageProviderSyncRootManager);
        return nullptr;
    }

    static PyObject* StorageProviderSyncRootManager_GetCurrentSyncRoots(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::GetCurrentSyncRoots());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_GetSyncRootInformationForFolder(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert(winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::GetSyncRootInformationForFolder(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_GetSyncRootInformationForId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::GetSyncRootInformationForId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_Register(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>(args, 0);

                winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::Register(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_Unregister(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::Unregister(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderSyncRootManager[] = {
        { "get_current_sync_roots", (PyCFunction)StorageProviderSyncRootManager_GetCurrentSyncRoots, METH_VARARGS | METH_STATIC, nullptr },
        { "get_sync_root_information_for_folder", (PyCFunction)StorageProviderSyncRootManager_GetSyncRootInformationForFolder, METH_VARARGS | METH_STATIC, nullptr },
        { "get_sync_root_information_for_id", (PyCFunction)StorageProviderSyncRootManager_GetSyncRootInformationForId, METH_VARARGS | METH_STATIC, nullptr },
        { "is_supported", (PyCFunction)StorageProviderSyncRootManager_IsSupported, METH_VARARGS | METH_STATIC, nullptr },
        { "register", (PyCFunction)StorageProviderSyncRootManager_Register, METH_VARARGS | METH_STATIC, nullptr },
        { "unregister", (PyCFunction)StorageProviderSyncRootManager_Unregister, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageProviderSyncRootManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageProviderSyncRootManager[] = 
    {
        { Py_tp_new, _new_StorageProviderSyncRootManager },
        { Py_tp_methods, _methods_StorageProviderSyncRootManager },
        { Py_tp_getset, _getset_StorageProviderSyncRootManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderSyncRootManager =
    {
        "_winrt_Windows_Storage_Provider.StorageProviderSyncRootManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderSyncRootManager
    };

    // ----- IStorageProviderHandlerFactory interface --------------------
    constexpr const char* const _type_name_IStorageProviderHandlerFactory = "IStorageProviderHandlerFactory";

    static PyObject* _new_IStorageProviderHandlerFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageProviderHandlerFactory);
        return nullptr;
    }

    static void _dealloc_IStorageProviderHandlerFactory(py::wrapper::Windows::Storage::Provider::IStorageProviderHandlerFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageProviderHandlerFactory_GetStatusSource(py::wrapper::Windows::Storage::Provider::IStorageProviderHandlerFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetStatusSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IStorageProviderHandlerFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderHandlerFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderHandlerFactory[] = {
        { "get_status_source", (PyCFunction)IStorageProviderHandlerFactory_GetStatusSource, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IStorageProviderHandlerFactory, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IStorageProviderHandlerFactory[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IStorageProviderHandlerFactory[] = 
    {
        { Py_tp_new, _new_IStorageProviderHandlerFactory },
        { Py_tp_dealloc, _dealloc_IStorageProviderHandlerFactory },
        { Py_tp_methods, _methods_IStorageProviderHandlerFactory },
        { Py_tp_getset, _getset_IStorageProviderHandlerFactory },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStorageProviderHandlerFactory =
    {
        "_winrt_Windows_Storage_Provider.IStorageProviderHandlerFactory",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderHandlerFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderHandlerFactory
    };

    // ----- IStorageProviderItemPropertySource interface --------------------
    constexpr const char* const _type_name_IStorageProviderItemPropertySource = "IStorageProviderItemPropertySource";

    static PyObject* _new_IStorageProviderItemPropertySource(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageProviderItemPropertySource);
        return nullptr;
    }

    static void _dealloc_IStorageProviderItemPropertySource(py::wrapper::Windows::Storage::Provider::IStorageProviderItemPropertySource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageProviderItemPropertySource_GetItemProperties(py::wrapper::Windows::Storage::Provider::IStorageProviderItemPropertySource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetItemProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IStorageProviderItemPropertySource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderItemPropertySource[] = {
        { "get_item_properties", (PyCFunction)IStorageProviderItemPropertySource_GetItemProperties, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IStorageProviderItemPropertySource, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IStorageProviderItemPropertySource[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IStorageProviderItemPropertySource[] = 
    {
        { Py_tp_new, _new_IStorageProviderItemPropertySource },
        { Py_tp_dealloc, _dealloc_IStorageProviderItemPropertySource },
        { Py_tp_methods, _methods_IStorageProviderItemPropertySource },
        { Py_tp_getset, _getset_IStorageProviderItemPropertySource },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStorageProviderItemPropertySource =
    {
        "_winrt_Windows_Storage_Provider.IStorageProviderItemPropertySource",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderItemPropertySource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderItemPropertySource
    };

    // ----- IStorageProviderPropertyCapabilities interface --------------------
    constexpr const char* const _type_name_IStorageProviderPropertyCapabilities = "IStorageProviderPropertyCapabilities";

    static PyObject* _new_IStorageProviderPropertyCapabilities(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageProviderPropertyCapabilities);
        return nullptr;
    }

    static void _dealloc_IStorageProviderPropertyCapabilities(py::wrapper::Windows::Storage::Provider::IStorageProviderPropertyCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageProviderPropertyCapabilities_IsPropertySupported(py::wrapper::Windows::Storage::Provider::IStorageProviderPropertyCapabilities* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsPropertySupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IStorageProviderPropertyCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderPropertyCapabilities[] = {
        { "is_property_supported", (PyCFunction)IStorageProviderPropertyCapabilities_IsPropertySupported, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IStorageProviderPropertyCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IStorageProviderPropertyCapabilities[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IStorageProviderPropertyCapabilities[] = 
    {
        { Py_tp_new, _new_IStorageProviderPropertyCapabilities },
        { Py_tp_dealloc, _dealloc_IStorageProviderPropertyCapabilities },
        { Py_tp_methods, _methods_IStorageProviderPropertyCapabilities },
        { Py_tp_getset, _getset_IStorageProviderPropertyCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStorageProviderPropertyCapabilities =
    {
        "_winrt_Windows_Storage_Provider.IStorageProviderPropertyCapabilities",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderPropertyCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderPropertyCapabilities
    };

    // ----- IStorageProviderStatusSource interface --------------------
    constexpr const char* const _type_name_IStorageProviderStatusSource = "IStorageProviderStatusSource";

    static PyObject* _new_IStorageProviderStatusSource(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageProviderStatusSource);
        return nullptr;
    }

    static void _dealloc_IStorageProviderStatusSource(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusSource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageProviderStatusSource_GetStatus(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageProviderStatusSource_add_Changed(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::IStorageProviderStatusSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Changed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageProviderStatusSource_remove_Changed(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Changed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IStorageProviderStatusSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderStatusSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderStatusSource[] = {
        { "get_status", (PyCFunction)IStorageProviderStatusSource_GetStatus, METH_VARARGS, nullptr },
        { "add_changed", (PyCFunction)IStorageProviderStatusSource_add_Changed, METH_O, nullptr },
        { "remove_changed", (PyCFunction)IStorageProviderStatusSource_remove_Changed, METH_O, nullptr },
        { "_from", (PyCFunction)_from_IStorageProviderStatusSource, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IStorageProviderStatusSource[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IStorageProviderStatusSource[] = 
    {
        { Py_tp_new, _new_IStorageProviderStatusSource },
        { Py_tp_dealloc, _dealloc_IStorageProviderStatusSource },
        { Py_tp_methods, _methods_IStorageProviderStatusSource },
        { Py_tp_getset, _getset_IStorageProviderStatusSource },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStorageProviderStatusSource =
    {
        "_winrt_Windows_Storage_Provider.IStorageProviderStatusSource",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderStatusSource
    };

    // ----- IStorageProviderUriSource interface --------------------
    constexpr const char* const _type_name_IStorageProviderUriSource = "IStorageProviderUriSource";

    static PyObject* _new_IStorageProviderUriSource(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageProviderUriSource);
        return nullptr;
    }

    static void _dealloc_IStorageProviderUriSource(py::wrapper::Windows::Storage::Provider::IStorageProviderUriSource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageProviderUriSource_GetContentInfoForPath(py::wrapper::Windows::Storage::Provider::IStorageProviderUriSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult>(args, 1);

                self->obj.GetContentInfoForPath(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageProviderUriSource_GetPathForContentUri(py::wrapper::Windows::Storage::Provider::IStorageProviderUriSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult>(args, 1);

                self->obj.GetPathForContentUri(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IStorageProviderUriSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderUriSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderUriSource[] = {
        { "get_content_info_for_path", (PyCFunction)IStorageProviderUriSource_GetContentInfoForPath, METH_VARARGS, nullptr },
        { "get_path_for_content_uri", (PyCFunction)IStorageProviderUriSource_GetPathForContentUri, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IStorageProviderUriSource, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IStorageProviderUriSource[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IStorageProviderUriSource[] = 
    {
        { Py_tp_new, _new_IStorageProviderUriSource },
        { Py_tp_dealloc, _dealloc_IStorageProviderUriSource },
        { Py_tp_methods, _methods_IStorageProviderUriSource },
        { Py_tp_getset, _getset_IStorageProviderUriSource },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStorageProviderUriSource =
    {
        "_winrt_Windows_Storage_Provider.IStorageProviderUriSource",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderUriSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderUriSource
    };

    // ----- Windows.Storage.Provider Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Storage::Provider::CachedFileUpdater>::python_type = py::register_python_type(module, _type_name_CachedFileUpdater, &_type_spec_CachedFileUpdater, nullptr);
            py::winrt_type<winrt::Windows::Storage::Provider::CachedFileUpdaterUI>::python_type = py::register_python_type(module, _type_name_CachedFileUpdaterUI, &_type_spec_CachedFileUpdaterUI, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::FileUpdateRequest>::python_type = py::register_python_type(module, _type_name_FileUpdateRequest, &_type_spec_FileUpdateRequest, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::FileUpdateRequestDeferral>::python_type = py::register_python_type(module, _type_name_FileUpdateRequestDeferral, &_type_spec_FileUpdateRequestDeferral, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_FileUpdateRequestedEventArgs, &_type_spec_FileUpdateRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderError>::python_type = py::register_python_type(module, _type_name_StorageProviderError, &_type_spec_StorageProviderError, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderErrorCommand>::python_type = py::register_python_type(module, _type_name_StorageProviderErrorCommand, &_type_spec_StorageProviderErrorCommand, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo>::python_type = py::register_python_type(module, _type_name_StorageProviderFileTypeInfo, &_type_spec_StorageProviderFileTypeInfo, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult>::python_type = py::register_python_type(module, _type_name_StorageProviderGetContentInfoForPathResult, &_type_spec_StorageProviderGetContentInfoForPathResult, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult>::python_type = py::register_python_type(module, _type_name_StorageProviderGetPathForContentUriResult, &_type_spec_StorageProviderGetPathForContentUriResult, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderItemProperties>::python_type = py::register_python_type(module, _type_name_StorageProviderItemProperties, &_type_spec_StorageProviderItemProperties, nullptr);
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderItemProperty>::python_type = py::register_python_type(module, _type_name_StorageProviderItemProperty, &_type_spec_StorageProviderItemProperty, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderItemPropertyDefinition>::python_type = py::register_python_type(module, _type_name_StorageProviderItemPropertyDefinition, &_type_spec_StorageProviderItemPropertyDefinition, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderStatus>::python_type = py::register_python_type(module, _type_name_StorageProviderStatus, &_type_spec_StorageProviderStatus, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>::python_type = py::register_python_type(module, _type_name_StorageProviderSyncRootInfo, &_type_spec_StorageProviderSyncRootInfo, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderSyncRootManager>::python_type = py::register_python_type(module, _type_name_StorageProviderSyncRootManager, &_type_spec_StorageProviderSyncRootManager, nullptr);
            py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderHandlerFactory>::python_type = py::register_python_type(module, _type_name_IStorageProviderHandlerFactory, &_type_spec_IStorageProviderHandlerFactory, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>::python_type = py::register_python_type(module, _type_name_IStorageProviderItemPropertySource, &_type_spec_IStorageProviderItemPropertySource, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>::python_type = py::register_python_type(module, _type_name_IStorageProviderPropertyCapabilities, &_type_spec_IStorageProviderPropertyCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderStatusSource>::python_type = py::register_python_type(module, _type_name_IStorageProviderStatusSource, &_type_spec_IStorageProviderStatusSource, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderUriSource>::python_type = py::register_python_type(module, _type_name_IStorageProviderUriSource, &_type_spec_IStorageProviderUriSource, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Storage.Provider");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Storage_Provider",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Storage::Provider

PyMODINIT_FUNC
PyInit__winrt_Windows_Storage_Provider (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Storage::Provider::module_def);
}
