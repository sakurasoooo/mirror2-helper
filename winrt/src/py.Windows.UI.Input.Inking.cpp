// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.UI.Input.Inking.h"

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkDrawingAttributes>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkInputConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkInputProcessingConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkModelerAttributes>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkPoint>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkPresenter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkPresenterProtractor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkPresenterRuler>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkRecognitionResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkRecognizer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkRecognizerContainer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkStroke>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokeBuilder>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokeContainer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokeInput>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokeRenderingSegment>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokesErasedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkSynchronizer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkUnprocessedInput>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::PenAndInkSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::IInkPointFactory>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::IInkPresenterRulerFactory>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::IInkPresenterStencil>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::IInkRecognizerContainer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::IInkStrokeContainer>::python_type;

namespace py::cpp::Windows::UI::Input::Inking
{
    // ----- InkDrawingAttributes class --------------------
    constexpr const char* const _type_name_InkDrawingAttributes = "InkDrawingAttributes";

    static PyObject* _new_InkDrawingAttributes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Inking::InkDrawingAttributes instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkDrawingAttributes(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkDrawingAttributes_CreateForPencil(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::Input::Inking::InkDrawingAttributes::CreateForPencil());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkDrawingAttributes_get_Size(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_Size(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_PenTip(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PenTip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_PenTip(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::PenTipShape>(arg);

            self->obj.PenTip(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_IgnorePressure(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IgnorePressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_IgnorePressure(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IgnorePressure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_FitToCurve(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FitToCurve());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_FitToCurve(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.FitToCurve(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_Color(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_Color(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_PenTipTransform(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PenTipTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_PenTipTransform(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);

            self->obj.PenTipTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_DrawAsHighlighter(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DrawAsHighlighter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_DrawAsHighlighter(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DrawAsHighlighter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_Kind(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkDrawingAttributes_get_PencilProperties(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PencilProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkDrawingAttributes_get_IgnoreTilt(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IgnoreTilt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_IgnoreTilt(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IgnoreTilt(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_ModelerAttributes(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ModelerAttributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkDrawingAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkDrawingAttributes>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkDrawingAttributes[] = {
        { "create_for_pencil", (PyCFunction)InkDrawingAttributes_CreateForPencil, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_InkDrawingAttributes, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkDrawingAttributes[] = {
        { const_cast<char*>("size"), (getter)InkDrawingAttributes_get_Size, (setter)InkDrawingAttributes_put_Size, nullptr, nullptr },
        { const_cast<char*>("pen_tip"), (getter)InkDrawingAttributes_get_PenTip, (setter)InkDrawingAttributes_put_PenTip, nullptr, nullptr },
        { const_cast<char*>("ignore_pressure"), (getter)InkDrawingAttributes_get_IgnorePressure, (setter)InkDrawingAttributes_put_IgnorePressure, nullptr, nullptr },
        { const_cast<char*>("fit_to_curve"), (getter)InkDrawingAttributes_get_FitToCurve, (setter)InkDrawingAttributes_put_FitToCurve, nullptr, nullptr },
        { const_cast<char*>("color"), (getter)InkDrawingAttributes_get_Color, (setter)InkDrawingAttributes_put_Color, nullptr, nullptr },
        { const_cast<char*>("pen_tip_transform"), (getter)InkDrawingAttributes_get_PenTipTransform, (setter)InkDrawingAttributes_put_PenTipTransform, nullptr, nullptr },
        { const_cast<char*>("draw_as_highlighter"), (getter)InkDrawingAttributes_get_DrawAsHighlighter, (setter)InkDrawingAttributes_put_DrawAsHighlighter, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)InkDrawingAttributes_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("pencil_properties"), (getter)InkDrawingAttributes_get_PencilProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("ignore_tilt"), (getter)InkDrawingAttributes_get_IgnoreTilt, (setter)InkDrawingAttributes_put_IgnoreTilt, nullptr, nullptr },
        { const_cast<char*>("modeler_attributes"), (getter)InkDrawingAttributes_get_ModelerAttributes, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InkDrawingAttributes[] = 
    {
        { Py_tp_new, _new_InkDrawingAttributes },
        { Py_tp_dealloc, _dealloc_InkDrawingAttributes },
        { Py_tp_methods, _methods_InkDrawingAttributes },
        { Py_tp_getset, _getset_InkDrawingAttributes },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkDrawingAttributes =
    {
        "_winrt_Windows_UI_Input_Inking.InkDrawingAttributes",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkDrawingAttributes
    };

    // ----- InkDrawingAttributesPencilProperties class --------------------
    constexpr const char* const _type_name_InkDrawingAttributesPencilProperties = "InkDrawingAttributesPencilProperties";

    static PyObject* _new_InkDrawingAttributesPencilProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkDrawingAttributesPencilProperties);
        return nullptr;
    }

    static void _dealloc_InkDrawingAttributesPencilProperties(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkDrawingAttributesPencilProperties_get_Opacity(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Opacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributesPencilProperties_put_Opacity(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Opacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_InkDrawingAttributesPencilProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkDrawingAttributesPencilProperties[] = {
        { "_from", (PyCFunction)_from_InkDrawingAttributesPencilProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkDrawingAttributesPencilProperties[] = {
        { const_cast<char*>("opacity"), (getter)InkDrawingAttributesPencilProperties_get_Opacity, (setter)InkDrawingAttributesPencilProperties_put_Opacity, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InkDrawingAttributesPencilProperties[] = 
    {
        { Py_tp_new, _new_InkDrawingAttributesPencilProperties },
        { Py_tp_dealloc, _dealloc_InkDrawingAttributesPencilProperties },
        { Py_tp_methods, _methods_InkDrawingAttributesPencilProperties },
        { Py_tp_getset, _getset_InkDrawingAttributesPencilProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkDrawingAttributesPencilProperties =
    {
        "_winrt_Windows_UI_Input_Inking.InkDrawingAttributesPencilProperties",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkDrawingAttributesPencilProperties
    };

    // ----- InkInputConfiguration class --------------------
    constexpr const char* const _type_name_InkInputConfiguration = "InkInputConfiguration";

    static PyObject* _new_InkInputConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkInputConfiguration);
        return nullptr;
    }

    static void _dealloc_InkInputConfiguration(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkInputConfiguration_get_IsPrimaryBarrelButtonInputEnabled(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPrimaryBarrelButtonInputEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkInputConfiguration_put_IsPrimaryBarrelButtonInputEnabled(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPrimaryBarrelButtonInputEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkInputConfiguration_get_IsEraserInputEnabled(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEraserInputEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkInputConfiguration_put_IsEraserInputEnabled(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEraserInputEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkInputConfiguration_get_IsPenHapticFeedbackEnabled(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPenHapticFeedbackEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkInputConfiguration_put_IsPenHapticFeedbackEnabled(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPenHapticFeedbackEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_InkInputConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkInputConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkInputConfiguration[] = {
        { "_from", (PyCFunction)_from_InkInputConfiguration, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkInputConfiguration[] = {
        { const_cast<char*>("is_primary_barrel_button_input_enabled"), (getter)InkInputConfiguration_get_IsPrimaryBarrelButtonInputEnabled, (setter)InkInputConfiguration_put_IsPrimaryBarrelButtonInputEnabled, nullptr, nullptr },
        { const_cast<char*>("is_eraser_input_enabled"), (getter)InkInputConfiguration_get_IsEraserInputEnabled, (setter)InkInputConfiguration_put_IsEraserInputEnabled, nullptr, nullptr },
        { const_cast<char*>("is_pen_haptic_feedback_enabled"), (getter)InkInputConfiguration_get_IsPenHapticFeedbackEnabled, (setter)InkInputConfiguration_put_IsPenHapticFeedbackEnabled, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InkInputConfiguration[] = 
    {
        { Py_tp_new, _new_InkInputConfiguration },
        { Py_tp_dealloc, _dealloc_InkInputConfiguration },
        { Py_tp_methods, _methods_InkInputConfiguration },
        { Py_tp_getset, _getset_InkInputConfiguration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkInputConfiguration =
    {
        "_winrt_Windows_UI_Input_Inking.InkInputConfiguration",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkInputConfiguration
    };

    // ----- InkInputProcessingConfiguration class --------------------
    constexpr const char* const _type_name_InkInputProcessingConfiguration = "InkInputProcessingConfiguration";

    static PyObject* _new_InkInputProcessingConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkInputProcessingConfiguration);
        return nullptr;
    }

    static void _dealloc_InkInputProcessingConfiguration(py::wrapper::Windows::UI::Input::Inking::InkInputProcessingConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkInputProcessingConfiguration_get_RightDragAction(py::wrapper::Windows::UI::Input::Inking::InkInputProcessingConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightDragAction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkInputProcessingConfiguration_put_RightDragAction(py::wrapper::Windows::UI::Input::Inking::InkInputProcessingConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkInputRightDragAction>(arg);

            self->obj.RightDragAction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkInputProcessingConfiguration_get_Mode(py::wrapper::Windows::UI::Input::Inking::InkInputProcessingConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkInputProcessingConfiguration_put_Mode(py::wrapper::Windows::UI::Input::Inking::InkInputProcessingConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkInputProcessingMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_InkInputProcessingConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkInputProcessingConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkInputProcessingConfiguration[] = {
        { "_from", (PyCFunction)_from_InkInputProcessingConfiguration, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkInputProcessingConfiguration[] = {
        { const_cast<char*>("right_drag_action"), (getter)InkInputProcessingConfiguration_get_RightDragAction, (setter)InkInputProcessingConfiguration_put_RightDragAction, nullptr, nullptr },
        { const_cast<char*>("mode"), (getter)InkInputProcessingConfiguration_get_Mode, (setter)InkInputProcessingConfiguration_put_Mode, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InkInputProcessingConfiguration[] = 
    {
        { Py_tp_new, _new_InkInputProcessingConfiguration },
        { Py_tp_dealloc, _dealloc_InkInputProcessingConfiguration },
        { Py_tp_methods, _methods_InkInputProcessingConfiguration },
        { Py_tp_getset, _getset_InkInputProcessingConfiguration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkInputProcessingConfiguration =
    {
        "_winrt_Windows_UI_Input_Inking.InkInputProcessingConfiguration",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkInputProcessingConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkInputProcessingConfiguration
    };

    // ----- InkManager class --------------------
    constexpr const char* const _type_name_InkManager = "InkManager";

    static PyObject* _new_InkManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Inking::InkManager instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkManager(py::wrapper::Windows::UI::Input::Inking::InkManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkManager_AddStroke(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkStroke>(args, 0);

                self->obj.AddStroke(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_CanPasteFromClipboard(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CanPasteFromClipboard());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_CopySelectedToClipboard(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.CopySelectedToClipboard();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_DeleteSelected(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteSelected());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_GetRecognitionResults(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRecognitionResults());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_GetRecognizers(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRecognizers());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_GetStrokes(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetStrokes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_LoadAsync(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.LoadAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_MoveSelected(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.MoveSelected(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_PasteFromClipboard(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.PasteFromClipboard(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_ProcessPointerDown(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                self->obj.ProcessPointerDown(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_ProcessPointerUp(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                return py::convert(self->obj.ProcessPointerUp(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_ProcessPointerUpdate(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                return py::convert(self->obj.ProcessPointerUpdate(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_RecognizeAsync(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkRecognitionTarget>(args, 0);

                return py::convert(self->obj.RecognizeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkStrokeContainer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Input::Inking::InkRecognitionTarget>(args, 1);

                return py::convert(self->obj.RecognizeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_SaveAsync(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.SaveAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_SelectWithLine(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                return py::convert(self->obj.SelectWithLine(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_SelectWithPolyLine(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Point>>(args, 0);

                return py::convert(self->obj.SelectWithPolyLine(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_SetDefaultDrawingAttributes(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkDrawingAttributes>(args, 0);

                self->obj.SetDefaultDrawingAttributes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_SetDefaultRecognizer(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkRecognizer>(args, 0);

                self->obj.SetDefaultRecognizer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_UpdateRecognitionResults(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::UI::Input::Inking::InkRecognitionResult>>(args, 0);

                self->obj.UpdateRecognitionResults(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_get_Mode(py::wrapper::Windows::UI::Input::Inking::InkManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkManager_put_Mode(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkManipulationMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkManager_get_BoundingRect(py::wrapper::Windows::UI::Input::Inking::InkManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BoundingRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkManager[] = {
        { "add_stroke", (PyCFunction)InkManager_AddStroke, METH_VARARGS, nullptr },
        { "can_paste_from_clipboard", (PyCFunction)InkManager_CanPasteFromClipboard, METH_VARARGS, nullptr },
        { "copy_selected_to_clipboard", (PyCFunction)InkManager_CopySelectedToClipboard, METH_VARARGS, nullptr },
        { "delete_selected", (PyCFunction)InkManager_DeleteSelected, METH_VARARGS, nullptr },
        { "get_recognition_results", (PyCFunction)InkManager_GetRecognitionResults, METH_VARARGS, nullptr },
        { "get_recognizers", (PyCFunction)InkManager_GetRecognizers, METH_VARARGS, nullptr },
        { "get_strokes", (PyCFunction)InkManager_GetStrokes, METH_VARARGS, nullptr },
        { "load_async", (PyCFunction)InkManager_LoadAsync, METH_VARARGS, nullptr },
        { "move_selected", (PyCFunction)InkManager_MoveSelected, METH_VARARGS, nullptr },
        { "paste_from_clipboard", (PyCFunction)InkManager_PasteFromClipboard, METH_VARARGS, nullptr },
        { "process_pointer_down", (PyCFunction)InkManager_ProcessPointerDown, METH_VARARGS, nullptr },
        { "process_pointer_up", (PyCFunction)InkManager_ProcessPointerUp, METH_VARARGS, nullptr },
        { "process_pointer_update", (PyCFunction)InkManager_ProcessPointerUpdate, METH_VARARGS, nullptr },
        { "recognize_async", (PyCFunction)InkManager_RecognizeAsync, METH_VARARGS, nullptr },
        { "save_async", (PyCFunction)InkManager_SaveAsync, METH_VARARGS, nullptr },
        { "select_with_line", (PyCFunction)InkManager_SelectWithLine, METH_VARARGS, nullptr },
        { "select_with_poly_line", (PyCFunction)InkManager_SelectWithPolyLine, METH_VARARGS, nullptr },
        { "set_default_drawing_attributes", (PyCFunction)InkManager_SetDefaultDrawingAttributes, METH_VARARGS, nullptr },
        { "set_default_recognizer", (PyCFunction)InkManager_SetDefaultRecognizer, METH_VARARGS, nullptr },
        { "update_recognition_results", (PyCFunction)InkManager_UpdateRecognitionResults, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_InkManager, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkManager[] = {
        { const_cast<char*>("mode"), (getter)InkManager_get_Mode, (setter)InkManager_put_Mode, nullptr, nullptr },
        { const_cast<char*>("bounding_rect"), (getter)InkManager_get_BoundingRect, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InkManager[] = 
    {
        { Py_tp_new, _new_InkManager },
        { Py_tp_dealloc, _dealloc_InkManager },
        { Py_tp_methods, _methods_InkManager },
        { Py_tp_getset, _getset_InkManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkManager =
    {
        "_winrt_Windows_UI_Input_Inking.InkManager",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkManager
    };

    // ----- InkModelerAttributes class --------------------
    constexpr const char* const _type_name_InkModelerAttributes = "InkModelerAttributes";

    static PyObject* _new_InkModelerAttributes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkModelerAttributes);
        return nullptr;
    }

    static void _dealloc_InkModelerAttributes(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkModelerAttributes_get_ScalingFactor(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScalingFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkModelerAttributes_put_ScalingFactor(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.ScalingFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkModelerAttributes_get_PredictionTime(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PredictionTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkModelerAttributes_put_PredictionTime(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.PredictionTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkModelerAttributes_get_UseVelocityBasedPressure(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UseVelocityBasedPressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkModelerAttributes_put_UseVelocityBasedPressure(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.UseVelocityBasedPressure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_InkModelerAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkModelerAttributes>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkModelerAttributes[] = {
        { "_from", (PyCFunction)_from_InkModelerAttributes, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkModelerAttributes[] = {
        { const_cast<char*>("scaling_factor"), (getter)InkModelerAttributes_get_ScalingFactor, (setter)InkModelerAttributes_put_ScalingFactor, nullptr, nullptr },
        { const_cast<char*>("prediction_time"), (getter)InkModelerAttributes_get_PredictionTime, (setter)InkModelerAttributes_put_PredictionTime, nullptr, nullptr },
        { const_cast<char*>("use_velocity_based_pressure"), (getter)InkModelerAttributes_get_UseVelocityBasedPressure, (setter)InkModelerAttributes_put_UseVelocityBasedPressure, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InkModelerAttributes[] = 
    {
        { Py_tp_new, _new_InkModelerAttributes },
        { Py_tp_dealloc, _dealloc_InkModelerAttributes },
        { Py_tp_methods, _methods_InkModelerAttributes },
        { Py_tp_getset, _getset_InkModelerAttributes },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkModelerAttributes =
    {
        "_winrt_Windows_UI_Input_Inking.InkModelerAttributes",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkModelerAttributes
    };

    // ----- InkPoint class --------------------
    constexpr const char* const _type_name_InkPoint = "InkPoint";

    static PyObject* _new_InkPoint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);
                auto param2 = py::convert_to<float>(args, 2);
                auto param3 = py::convert_to<float>(args, 3);
                auto param4 = py::convert_to<uint64_t>(args, 4);

                winrt::Windows::UI::Input::Inking::InkPoint instance{ param0, param1, param2, param3, param4 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                winrt::Windows::UI::Input::Inking::InkPoint instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkPoint(py::wrapper::Windows::UI::Input::Inking::InkPoint* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkPoint_get_Position(py::wrapper::Windows::UI::Input::Inking::InkPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPoint_get_Pressure(py::wrapper::Windows::UI::Input::Inking::InkPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPoint_get_TiltX(py::wrapper::Windows::UI::Input::Inking::InkPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TiltX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPoint_get_TiltY(py::wrapper::Windows::UI::Input::Inking::InkPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TiltY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPoint_get_Timestamp(py::wrapper::Windows::UI::Input::Inking::InkPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkPoint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkPoint[] = {
        { "_from", (PyCFunction)_from_InkPoint, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkPoint[] = {
        { const_cast<char*>("position"), (getter)InkPoint_get_Position, nullptr, nullptr, nullptr },
        { const_cast<char*>("pressure"), (getter)InkPoint_get_Pressure, nullptr, nullptr, nullptr },
        { const_cast<char*>("tilt_x"), (getter)InkPoint_get_TiltX, nullptr, nullptr, nullptr },
        { const_cast<char*>("tilt_y"), (getter)InkPoint_get_TiltY, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)InkPoint_get_Timestamp, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InkPoint[] = 
    {
        { Py_tp_new, _new_InkPoint },
        { Py_tp_dealloc, _dealloc_InkPoint },
        { Py_tp_methods, _methods_InkPoint },
        { Py_tp_getset, _getset_InkPoint },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkPoint =
    {
        "_winrt_Windows_UI_Input_Inking.InkPoint",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkPoint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkPoint
    };

    // ----- InkPresenter class --------------------
    constexpr const char* const _type_name_InkPresenter = "InkPresenter";

    static PyObject* _new_InkPresenter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkPresenter);
        return nullptr;
    }

    static void _dealloc_InkPresenter(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkPresenter_ActivateCustomDrying(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ActivateCustomDrying());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkPresenter_CopyDefaultDrawingAttributes(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CopyDefaultDrawingAttributes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkPresenter_SetPredefinedConfiguration(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkPresenterPredefinedConfiguration>(args, 0);

                self->obj.SetPredefinedConfiguration(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkPresenter_UpdateDefaultDrawingAttributes(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkDrawingAttributes>(args, 0);

                self->obj.UpdateDefaultDrawingAttributes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkPresenter_get_StrokeContainer(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StrokeContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenter_put_StrokeContainer(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkStrokeContainer>(arg);

            self->obj.StrokeContainer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenter_get_IsInputEnabled(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInputEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenter_put_IsInputEnabled(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsInputEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenter_get_InputDeviceTypes(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputDeviceTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenter_put_InputDeviceTypes(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreInputDeviceTypes>(arg);

            self->obj.InputDeviceTypes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenter_get_InputProcessingConfiguration(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputProcessingConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPresenter_get_StrokeInput(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StrokeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPresenter_get_UnprocessedInput(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UnprocessedInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPresenter_get_HighContrastAdjustment(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HighContrastAdjustment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenter_put_HighContrastAdjustment(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkHighContrastAdjustment>(arg);

            self->obj.HighContrastAdjustment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenter_get_InputConfiguration(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPresenter_add_StrokesCollected(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkPresenter, winrt::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs>>(arg);

            return py::convert(self->obj.StrokesCollected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPresenter_remove_StrokesCollected(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StrokesCollected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPresenter_add_StrokesErased(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkPresenter, winrt::Windows::UI::Input::Inking::InkStrokesErasedEventArgs>>(arg);

            return py::convert(self->obj.StrokesErased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPresenter_remove_StrokesErased(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StrokesErased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkPresenter[] = {
        { "activate_custom_drying", (PyCFunction)InkPresenter_ActivateCustomDrying, METH_VARARGS, nullptr },
        { "copy_default_drawing_attributes", (PyCFunction)InkPresenter_CopyDefaultDrawingAttributes, METH_VARARGS, nullptr },
        { "set_predefined_configuration", (PyCFunction)InkPresenter_SetPredefinedConfiguration, METH_VARARGS, nullptr },
        { "update_default_drawing_attributes", (PyCFunction)InkPresenter_UpdateDefaultDrawingAttributes, METH_VARARGS, nullptr },
        { "add_strokes_collected", (PyCFunction)InkPresenter_add_StrokesCollected, METH_O, nullptr },
        { "remove_strokes_collected", (PyCFunction)InkPresenter_remove_StrokesCollected, METH_O, nullptr },
        { "add_strokes_erased", (PyCFunction)InkPresenter_add_StrokesErased, METH_O, nullptr },
        { "remove_strokes_erased", (PyCFunction)InkPresenter_remove_StrokesErased, METH_O, nullptr },
        { "_from", (PyCFunction)_from_InkPresenter, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkPresenter[] = {
        { const_cast<char*>("stroke_container"), (getter)InkPresenter_get_StrokeContainer, (setter)InkPresenter_put_StrokeContainer, nullptr, nullptr },
        { const_cast<char*>("is_input_enabled"), (getter)InkPresenter_get_IsInputEnabled, (setter)InkPresenter_put_IsInputEnabled, nullptr, nullptr },
        { const_cast<char*>("input_device_types"), (getter)InkPresenter_get_InputDeviceTypes, (setter)InkPresenter_put_InputDeviceTypes, nullptr, nullptr },
        { const_cast<char*>("input_processing_configuration"), (getter)InkPresenter_get_InputProcessingConfiguration, nullptr, nullptr, nullptr },
        { const_cast<char*>("stroke_input"), (getter)InkPresenter_get_StrokeInput, nullptr, nullptr, nullptr },
        { const_cast<char*>("unprocessed_input"), (getter)InkPresenter_get_UnprocessedInput, nullptr, nullptr, nullptr },
        { const_cast<char*>("high_contrast_adjustment"), (getter)InkPresenter_get_HighContrastAdjustment, (setter)InkPresenter_put_HighContrastAdjustment, nullptr, nullptr },
        { const_cast<char*>("input_configuration"), (getter)InkPresenter_get_InputConfiguration, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InkPresenter[] = 
    {
        { Py_tp_new, _new_InkPresenter },
        { Py_tp_dealloc, _dealloc_InkPresenter },
        { Py_tp_methods, _methods_InkPresenter },
        { Py_tp_getset, _getset_InkPresenter },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkPresenter =
    {
        "_winrt_Windows_UI_Input_Inking.InkPresenter",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkPresenter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkPresenter
    };

    // ----- InkPresenterProtractor class --------------------
    constexpr const char* const _type_name_InkPresenterProtractor = "InkPresenterProtractor";

    static PyObject* _new_InkPresenterProtractor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkPresenter>(args, 0);

                winrt::Windows::UI::Input::Inking::InkPresenterProtractor instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkPresenterProtractor(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkPresenterProtractor_get_Radius(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Radius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_Radius(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Radius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_IsResizable(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsResizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_IsResizable(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsResizable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_IsCenterMarkerVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCenterMarkerVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_IsCenterMarkerVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCenterMarkerVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_IsAngleReadoutVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAngleReadoutVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_IsAngleReadoutVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAngleReadoutVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_AreTickMarksVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AreTickMarksVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_AreTickMarksVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AreTickMarksVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_AreRaysVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AreRaysVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_AreRaysVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AreRaysVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_AccentColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccentColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_AccentColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.AccentColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_Transform(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Transform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_Transform(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);

            self->obj.Transform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_IsVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_IsVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_ForegroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_ForegroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.ForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_BackgroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_BackgroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.BackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_Kind(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkPresenterProtractor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkPresenterProtractor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkPresenterProtractor[] = {
        { "_from", (PyCFunction)_from_InkPresenterProtractor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkPresenterProtractor[] = {
        { const_cast<char*>("radius"), (getter)InkPresenterProtractor_get_Radius, (setter)InkPresenterProtractor_put_Radius, nullptr, nullptr },
        { const_cast<char*>("is_resizable"), (getter)InkPresenterProtractor_get_IsResizable, (setter)InkPresenterProtractor_put_IsResizable, nullptr, nullptr },
        { const_cast<char*>("is_center_marker_visible"), (getter)InkPresenterProtractor_get_IsCenterMarkerVisible, (setter)InkPresenterProtractor_put_IsCenterMarkerVisible, nullptr, nullptr },
        { const_cast<char*>("is_angle_readout_visible"), (getter)InkPresenterProtractor_get_IsAngleReadoutVisible, (setter)InkPresenterProtractor_put_IsAngleReadoutVisible, nullptr, nullptr },
        { const_cast<char*>("are_tick_marks_visible"), (getter)InkPresenterProtractor_get_AreTickMarksVisible, (setter)InkPresenterProtractor_put_AreTickMarksVisible, nullptr, nullptr },
        { const_cast<char*>("are_rays_visible"), (getter)InkPresenterProtractor_get_AreRaysVisible, (setter)InkPresenterProtractor_put_AreRaysVisible, nullptr, nullptr },
        { const_cast<char*>("accent_color"), (getter)InkPresenterProtractor_get_AccentColor, (setter)InkPresenterProtractor_put_AccentColor, nullptr, nullptr },
        { const_cast<char*>("transform"), (getter)InkPresenterProtractor_get_Transform, (setter)InkPresenterProtractor_put_Transform, nullptr, nullptr },
        { const_cast<char*>("is_visible"), (getter)InkPresenterProtractor_get_IsVisible, (setter)InkPresenterProtractor_put_IsVisible, nullptr, nullptr },
        { const_cast<char*>("foreground_color"), (getter)InkPresenterProtractor_get_ForegroundColor, (setter)InkPresenterProtractor_put_ForegroundColor, nullptr, nullptr },
        { const_cast<char*>("background_color"), (getter)InkPresenterProtractor_get_BackgroundColor, (setter)InkPresenterProtractor_put_BackgroundColor, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)InkPresenterProtractor_get_Kind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InkPresenterProtractor[] = 
    {
        { Py_tp_new, _new_InkPresenterProtractor },
        { Py_tp_dealloc, _dealloc_InkPresenterProtractor },
        { Py_tp_methods, _methods_InkPresenterProtractor },
        { Py_tp_getset, _getset_InkPresenterProtractor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkPresenterProtractor =
    {
        "_winrt_Windows_UI_Input_Inking.InkPresenterProtractor",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkPresenterProtractor
    };

    // ----- InkPresenterRuler class --------------------
    constexpr const char* const _type_name_InkPresenterRuler = "InkPresenterRuler";

    static PyObject* _new_InkPresenterRuler(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkPresenter>(args, 0);

                winrt::Windows::UI::Input::Inking::InkPresenterRuler instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkPresenterRuler(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkPresenterRuler_get_Width(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_Width(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Width(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_Length(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_Length(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Length(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_IsCompassVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCompassVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_IsCompassVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCompassVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_AreTickMarksVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AreTickMarksVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_AreTickMarksVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AreTickMarksVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_Transform(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Transform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_Transform(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);

            self->obj.Transform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_IsVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_IsVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_ForegroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_ForegroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.ForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_BackgroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_BackgroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.BackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_Kind(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkPresenterRuler(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkPresenterRuler>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkPresenterRuler[] = {
        { "_from", (PyCFunction)_from_InkPresenterRuler, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkPresenterRuler[] = {
        { const_cast<char*>("width"), (getter)InkPresenterRuler_get_Width, (setter)InkPresenterRuler_put_Width, nullptr, nullptr },
        { const_cast<char*>("length"), (getter)InkPresenterRuler_get_Length, (setter)InkPresenterRuler_put_Length, nullptr, nullptr },
        { const_cast<char*>("is_compass_visible"), (getter)InkPresenterRuler_get_IsCompassVisible, (setter)InkPresenterRuler_put_IsCompassVisible, nullptr, nullptr },
        { const_cast<char*>("are_tick_marks_visible"), (getter)InkPresenterRuler_get_AreTickMarksVisible, (setter)InkPresenterRuler_put_AreTickMarksVisible, nullptr, nullptr },
        { const_cast<char*>("transform"), (getter)InkPresenterRuler_get_Transform, (setter)InkPresenterRuler_put_Transform, nullptr, nullptr },
        { const_cast<char*>("is_visible"), (getter)InkPresenterRuler_get_IsVisible, (setter)InkPresenterRuler_put_IsVisible, nullptr, nullptr },
        { const_cast<char*>("foreground_color"), (getter)InkPresenterRuler_get_ForegroundColor, (setter)InkPresenterRuler_put_ForegroundColor, nullptr, nullptr },
        { const_cast<char*>("background_color"), (getter)InkPresenterRuler_get_BackgroundColor, (setter)InkPresenterRuler_put_BackgroundColor, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)InkPresenterRuler_get_Kind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InkPresenterRuler[] = 
    {
        { Py_tp_new, _new_InkPresenterRuler },
        { Py_tp_dealloc, _dealloc_InkPresenterRuler },
        { Py_tp_methods, _methods_InkPresenterRuler },
        { Py_tp_getset, _getset_InkPresenterRuler },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkPresenterRuler =
    {
        "_winrt_Windows_UI_Input_Inking.InkPresenterRuler",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkPresenterRuler
    };

    // ----- InkRecognitionResult class --------------------
    constexpr const char* const _type_name_InkRecognitionResult = "InkRecognitionResult";

    static PyObject* _new_InkRecognitionResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkRecognitionResult);
        return nullptr;
    }

    static void _dealloc_InkRecognitionResult(py::wrapper::Windows::UI::Input::Inking::InkRecognitionResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkRecognitionResult_GetStrokes(py::wrapper::Windows::UI::Input::Inking::InkRecognitionResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetStrokes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkRecognitionResult_GetTextCandidates(py::wrapper::Windows::UI::Input::Inking::InkRecognitionResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetTextCandidates());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkRecognitionResult_get_BoundingRect(py::wrapper::Windows::UI::Input::Inking::InkRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BoundingRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkRecognitionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkRecognitionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkRecognitionResult[] = {
        { "get_strokes", (PyCFunction)InkRecognitionResult_GetStrokes, METH_VARARGS, nullptr },
        { "get_text_candidates", (PyCFunction)InkRecognitionResult_GetTextCandidates, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_InkRecognitionResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkRecognitionResult[] = {
        { const_cast<char*>("bounding_rect"), (getter)InkRecognitionResult_get_BoundingRect, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InkRecognitionResult[] = 
    {
        { Py_tp_new, _new_InkRecognitionResult },
        { Py_tp_dealloc, _dealloc_InkRecognitionResult },
        { Py_tp_methods, _methods_InkRecognitionResult },
        { Py_tp_getset, _getset_InkRecognitionResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkRecognitionResult =
    {
        "_winrt_Windows_UI_Input_Inking.InkRecognitionResult",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkRecognitionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkRecognitionResult
    };

    // ----- InkRecognizer class --------------------
    constexpr const char* const _type_name_InkRecognizer = "InkRecognizer";

    static PyObject* _new_InkRecognizer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkRecognizer);
        return nullptr;
    }

    static void _dealloc_InkRecognizer(py::wrapper::Windows::UI::Input::Inking::InkRecognizer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkRecognizer_get_Name(py::wrapper::Windows::UI::Input::Inking::InkRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkRecognizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkRecognizer[] = {
        { "_from", (PyCFunction)_from_InkRecognizer, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkRecognizer[] = {
        { const_cast<char*>("name"), (getter)InkRecognizer_get_Name, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InkRecognizer[] = 
    {
        { Py_tp_new, _new_InkRecognizer },
        { Py_tp_dealloc, _dealloc_InkRecognizer },
        { Py_tp_methods, _methods_InkRecognizer },
        { Py_tp_getset, _getset_InkRecognizer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkRecognizer =
    {
        "_winrt_Windows_UI_Input_Inking.InkRecognizer",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkRecognizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkRecognizer
    };

    // ----- InkRecognizerContainer class --------------------
    constexpr const char* const _type_name_InkRecognizerContainer = "InkRecognizerContainer";

    static PyObject* _new_InkRecognizerContainer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Inking::InkRecognizerContainer instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkRecognizerContainer(py::wrapper::Windows::UI::Input::Inking::InkRecognizerContainer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkRecognizerContainer_GetRecognizers(py::wrapper::Windows::UI::Input::Inking::InkRecognizerContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRecognizers());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkRecognizerContainer_RecognizeAsync(py::wrapper::Windows::UI::Input::Inking::InkRecognizerContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkStrokeContainer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Input::Inking::InkRecognitionTarget>(args, 1);

                return py::convert(self->obj.RecognizeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkRecognizerContainer_SetDefaultRecognizer(py::wrapper::Windows::UI::Input::Inking::InkRecognizerContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkRecognizer>(args, 0);

                self->obj.SetDefaultRecognizer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_InkRecognizerContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkRecognizerContainer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkRecognizerContainer[] = {
        { "get_recognizers", (PyCFunction)InkRecognizerContainer_GetRecognizers, METH_VARARGS, nullptr },
        { "recognize_async", (PyCFunction)InkRecognizerContainer_RecognizeAsync, METH_VARARGS, nullptr },
        { "set_default_recognizer", (PyCFunction)InkRecognizerContainer_SetDefaultRecognizer, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_InkRecognizerContainer, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkRecognizerContainer[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_InkRecognizerContainer[] = 
    {
        { Py_tp_new, _new_InkRecognizerContainer },
        { Py_tp_dealloc, _dealloc_InkRecognizerContainer },
        { Py_tp_methods, _methods_InkRecognizerContainer },
        { Py_tp_getset, _getset_InkRecognizerContainer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkRecognizerContainer =
    {
        "_winrt_Windows_UI_Input_Inking.InkRecognizerContainer",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkRecognizerContainer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkRecognizerContainer
    };

    // ----- InkStroke class --------------------
    constexpr const char* const _type_name_InkStroke = "InkStroke";

    static PyObject* _new_InkStroke(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkStroke);
        return nullptr;
    }

    static void _dealloc_InkStroke(py::wrapper::Windows::UI::Input::Inking::InkStroke* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkStroke_Clone(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Clone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStroke_GetInkPoints(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetInkPoints());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStroke_GetRenderingSegments(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRenderingSegments());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStroke_get_Selected(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Selected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkStroke_put_Selected(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Selected(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkStroke_get_DrawingAttributes(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DrawingAttributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkStroke_put_DrawingAttributes(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkDrawingAttributes>(arg);

            self->obj.DrawingAttributes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkStroke_get_BoundingRect(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BoundingRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStroke_get_Recognized(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Recognized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStroke_get_PointTransform(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkStroke_put_PointTransform(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);

            self->obj.PointTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkStroke_get_StrokeStartedTime(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StrokeStartedTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkStroke_put_StrokeStartedTime(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.StrokeStartedTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkStroke_get_StrokeDuration(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StrokeDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkStroke_put_StrokeDuration(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.StrokeDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkStroke_get_Id(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStroke_get_PointerId(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkStroke(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkStroke>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkStroke[] = {
        { "clone", (PyCFunction)InkStroke_Clone, METH_VARARGS, nullptr },
        { "get_ink_points", (PyCFunction)InkStroke_GetInkPoints, METH_VARARGS, nullptr },
        { "get_rendering_segments", (PyCFunction)InkStroke_GetRenderingSegments, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_InkStroke, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkStroke[] = {
        { const_cast<char*>("selected"), (getter)InkStroke_get_Selected, (setter)InkStroke_put_Selected, nullptr, nullptr },
        { const_cast<char*>("drawing_attributes"), (getter)InkStroke_get_DrawingAttributes, (setter)InkStroke_put_DrawingAttributes, nullptr, nullptr },
        { const_cast<char*>("bounding_rect"), (getter)InkStroke_get_BoundingRect, nullptr, nullptr, nullptr },
        { const_cast<char*>("recognized"), (getter)InkStroke_get_Recognized, nullptr, nullptr, nullptr },
        { const_cast<char*>("point_transform"), (getter)InkStroke_get_PointTransform, (setter)InkStroke_put_PointTransform, nullptr, nullptr },
        { const_cast<char*>("stroke_started_time"), (getter)InkStroke_get_StrokeStartedTime, (setter)InkStroke_put_StrokeStartedTime, nullptr, nullptr },
        { const_cast<char*>("stroke_duration"), (getter)InkStroke_get_StrokeDuration, (setter)InkStroke_put_StrokeDuration, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)InkStroke_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("pointer_id"), (getter)InkStroke_get_PointerId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InkStroke[] = 
    {
        { Py_tp_new, _new_InkStroke },
        { Py_tp_dealloc, _dealloc_InkStroke },
        { Py_tp_methods, _methods_InkStroke },
        { Py_tp_getset, _getset_InkStroke },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkStroke =
    {
        "_winrt_Windows_UI_Input_Inking.InkStroke",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkStroke),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkStroke
    };

    // ----- InkStrokeBuilder class --------------------
    constexpr const char* const _type_name_InkStrokeBuilder = "InkStrokeBuilder";

    static PyObject* _new_InkStrokeBuilder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Inking::InkStrokeBuilder instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkStrokeBuilder(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkStrokeBuilder_AppendToStroke(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                return py::convert(self->obj.AppendToStroke(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeBuilder_BeginStroke(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                self->obj.BeginStroke(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeBuilder_CreateStroke(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Point>>(args, 0);

                return py::convert(self->obj.CreateStroke(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeBuilder_CreateStrokeFromInkPoints(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Input::Inking::InkPoint>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(args, 1);

                return py::convert(self->obj.CreateStrokeFromInkPoints(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Input::Inking::InkPoint>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(args, 3);

                return py::convert(self->obj.CreateStrokeFromInkPoints(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeBuilder_EndStroke(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                return py::convert(self->obj.EndStroke(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeBuilder_SetDefaultDrawingAttributes(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkDrawingAttributes>(args, 0);

                self->obj.SetDefaultDrawingAttributes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_InkStrokeBuilder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkStrokeBuilder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkStrokeBuilder[] = {
        { "append_to_stroke", (PyCFunction)InkStrokeBuilder_AppendToStroke, METH_VARARGS, nullptr },
        { "begin_stroke", (PyCFunction)InkStrokeBuilder_BeginStroke, METH_VARARGS, nullptr },
        { "create_stroke", (PyCFunction)InkStrokeBuilder_CreateStroke, METH_VARARGS, nullptr },
        { "create_stroke_from_ink_points", (PyCFunction)InkStrokeBuilder_CreateStrokeFromInkPoints, METH_VARARGS, nullptr },
        { "end_stroke", (PyCFunction)InkStrokeBuilder_EndStroke, METH_VARARGS, nullptr },
        { "set_default_drawing_attributes", (PyCFunction)InkStrokeBuilder_SetDefaultDrawingAttributes, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_InkStrokeBuilder, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkStrokeBuilder[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_InkStrokeBuilder[] = 
    {
        { Py_tp_new, _new_InkStrokeBuilder },
        { Py_tp_dealloc, _dealloc_InkStrokeBuilder },
        { Py_tp_methods, _methods_InkStrokeBuilder },
        { Py_tp_getset, _getset_InkStrokeBuilder },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkStrokeBuilder =
    {
        "_winrt_Windows_UI_Input_Inking.InkStrokeBuilder",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkStrokeBuilder
    };

    // ----- InkStrokeContainer class --------------------
    constexpr const char* const _type_name_InkStrokeContainer = "InkStrokeContainer";

    static PyObject* _new_InkStrokeContainer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Inking::InkStrokeContainer instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkStrokeContainer(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkStrokeContainer_AddStroke(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkStroke>(args, 0);

                self->obj.AddStroke(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_AddStrokes(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Input::Inking::InkStroke>>(args, 0);

                self->obj.AddStrokes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_CanPasteFromClipboard(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CanPasteFromClipboard());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_Clear(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_CopySelectedToClipboard(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.CopySelectedToClipboard();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_DeleteSelected(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteSelected());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_GetRecognitionResults(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRecognitionResults());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_GetStrokeById(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetStrokeById(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_GetStrokes(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetStrokes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_LoadAsync(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.LoadAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_MoveSelected(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.MoveSelected(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_PasteFromClipboard(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.PasteFromClipboard(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_SaveAsync(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.SaveAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Input::Inking::InkPersistenceFormat>(args, 1);

                return py::convert(self->obj.SaveAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_SelectWithLine(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                return py::convert(self->obj.SelectWithLine(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_SelectWithPolyLine(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Point>>(args, 0);

                return py::convert(self->obj.SelectWithPolyLine(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_UpdateRecognitionResults(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::UI::Input::Inking::InkRecognitionResult>>(args, 0);

                self->obj.UpdateRecognitionResults(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_get_BoundingRect(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BoundingRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkStrokeContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkStrokeContainer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkStrokeContainer[] = {
        { "add_stroke", (PyCFunction)InkStrokeContainer_AddStroke, METH_VARARGS, nullptr },
        { "add_strokes", (PyCFunction)InkStrokeContainer_AddStrokes, METH_VARARGS, nullptr },
        { "can_paste_from_clipboard", (PyCFunction)InkStrokeContainer_CanPasteFromClipboard, METH_VARARGS, nullptr },
        { "clear", (PyCFunction)InkStrokeContainer_Clear, METH_VARARGS, nullptr },
        { "copy_selected_to_clipboard", (PyCFunction)InkStrokeContainer_CopySelectedToClipboard, METH_VARARGS, nullptr },
        { "delete_selected", (PyCFunction)InkStrokeContainer_DeleteSelected, METH_VARARGS, nullptr },
        { "get_recognition_results", (PyCFunction)InkStrokeContainer_GetRecognitionResults, METH_VARARGS, nullptr },
        { "get_stroke_by_id", (PyCFunction)InkStrokeContainer_GetStrokeById, METH_VARARGS, nullptr },
        { "get_strokes", (PyCFunction)InkStrokeContainer_GetStrokes, METH_VARARGS, nullptr },
        { "load_async", (PyCFunction)InkStrokeContainer_LoadAsync, METH_VARARGS, nullptr },
        { "move_selected", (PyCFunction)InkStrokeContainer_MoveSelected, METH_VARARGS, nullptr },
        { "paste_from_clipboard", (PyCFunction)InkStrokeContainer_PasteFromClipboard, METH_VARARGS, nullptr },
        { "save_async", (PyCFunction)InkStrokeContainer_SaveAsync, METH_VARARGS, nullptr },
        { "select_with_line", (PyCFunction)InkStrokeContainer_SelectWithLine, METH_VARARGS, nullptr },
        { "select_with_poly_line", (PyCFunction)InkStrokeContainer_SelectWithPolyLine, METH_VARARGS, nullptr },
        { "update_recognition_results", (PyCFunction)InkStrokeContainer_UpdateRecognitionResults, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_InkStrokeContainer, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkStrokeContainer[] = {
        { const_cast<char*>("bounding_rect"), (getter)InkStrokeContainer_get_BoundingRect, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InkStrokeContainer[] = 
    {
        { Py_tp_new, _new_InkStrokeContainer },
        { Py_tp_dealloc, _dealloc_InkStrokeContainer },
        { Py_tp_methods, _methods_InkStrokeContainer },
        { Py_tp_getset, _getset_InkStrokeContainer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkStrokeContainer =
    {
        "_winrt_Windows_UI_Input_Inking.InkStrokeContainer",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkStrokeContainer
    };

    // ----- InkStrokeInput class --------------------
    constexpr const char* const _type_name_InkStrokeInput = "InkStrokeInput";

    static PyObject* _new_InkStrokeInput(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkStrokeInput);
        return nullptr;
    }

    static void _dealloc_InkStrokeInput(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkStrokeInput_get_InkPresenter(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InkPresenter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_add_StrokeCanceled(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkStrokeInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.StrokeCanceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_remove_StrokeCanceled(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StrokeCanceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_add_StrokeContinued(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkStrokeInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.StrokeContinued(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_remove_StrokeContinued(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StrokeContinued(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_add_StrokeEnded(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkStrokeInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.StrokeEnded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_remove_StrokeEnded(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StrokeEnded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_add_StrokeStarted(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkStrokeInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.StrokeStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_remove_StrokeStarted(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StrokeStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkStrokeInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkStrokeInput>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkStrokeInput[] = {
        { "add_stroke_canceled", (PyCFunction)InkStrokeInput_add_StrokeCanceled, METH_O, nullptr },
        { "remove_stroke_canceled", (PyCFunction)InkStrokeInput_remove_StrokeCanceled, METH_O, nullptr },
        { "add_stroke_continued", (PyCFunction)InkStrokeInput_add_StrokeContinued, METH_O, nullptr },
        { "remove_stroke_continued", (PyCFunction)InkStrokeInput_remove_StrokeContinued, METH_O, nullptr },
        { "add_stroke_ended", (PyCFunction)InkStrokeInput_add_StrokeEnded, METH_O, nullptr },
        { "remove_stroke_ended", (PyCFunction)InkStrokeInput_remove_StrokeEnded, METH_O, nullptr },
        { "add_stroke_started", (PyCFunction)InkStrokeInput_add_StrokeStarted, METH_O, nullptr },
        { "remove_stroke_started", (PyCFunction)InkStrokeInput_remove_StrokeStarted, METH_O, nullptr },
        { "_from", (PyCFunction)_from_InkStrokeInput, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkStrokeInput[] = {
        { const_cast<char*>("ink_presenter"), (getter)InkStrokeInput_get_InkPresenter, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InkStrokeInput[] = 
    {
        { Py_tp_new, _new_InkStrokeInput },
        { Py_tp_dealloc, _dealloc_InkStrokeInput },
        { Py_tp_methods, _methods_InkStrokeInput },
        { Py_tp_getset, _getset_InkStrokeInput },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkStrokeInput =
    {
        "_winrt_Windows_UI_Input_Inking.InkStrokeInput",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkStrokeInput
    };

    // ----- InkStrokeRenderingSegment class --------------------
    constexpr const char* const _type_name_InkStrokeRenderingSegment = "InkStrokeRenderingSegment";

    static PyObject* _new_InkStrokeRenderingSegment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkStrokeRenderingSegment);
        return nullptr;
    }

    static void _dealloc_InkStrokeRenderingSegment(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkStrokeRenderingSegment_get_BezierControlPoint1(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BezierControlPoint1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeRenderingSegment_get_BezierControlPoint2(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BezierControlPoint2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeRenderingSegment_get_Position(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeRenderingSegment_get_Pressure(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeRenderingSegment_get_TiltX(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TiltX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeRenderingSegment_get_TiltY(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TiltY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeRenderingSegment_get_Twist(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Twist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkStrokeRenderingSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkStrokeRenderingSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkStrokeRenderingSegment[] = {
        { "_from", (PyCFunction)_from_InkStrokeRenderingSegment, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkStrokeRenderingSegment[] = {
        { const_cast<char*>("bezier_control_point1"), (getter)InkStrokeRenderingSegment_get_BezierControlPoint1, nullptr, nullptr, nullptr },
        { const_cast<char*>("bezier_control_point2"), (getter)InkStrokeRenderingSegment_get_BezierControlPoint2, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)InkStrokeRenderingSegment_get_Position, nullptr, nullptr, nullptr },
        { const_cast<char*>("pressure"), (getter)InkStrokeRenderingSegment_get_Pressure, nullptr, nullptr, nullptr },
        { const_cast<char*>("tilt_x"), (getter)InkStrokeRenderingSegment_get_TiltX, nullptr, nullptr, nullptr },
        { const_cast<char*>("tilt_y"), (getter)InkStrokeRenderingSegment_get_TiltY, nullptr, nullptr, nullptr },
        { const_cast<char*>("twist"), (getter)InkStrokeRenderingSegment_get_Twist, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InkStrokeRenderingSegment[] = 
    {
        { Py_tp_new, _new_InkStrokeRenderingSegment },
        { Py_tp_dealloc, _dealloc_InkStrokeRenderingSegment },
        { Py_tp_methods, _methods_InkStrokeRenderingSegment },
        { Py_tp_getset, _getset_InkStrokeRenderingSegment },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkStrokeRenderingSegment =
    {
        "_winrt_Windows_UI_Input_Inking.InkStrokeRenderingSegment",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkStrokeRenderingSegment
    };

    // ----- InkStrokesCollectedEventArgs class --------------------
    constexpr const char* const _type_name_InkStrokesCollectedEventArgs = "InkStrokesCollectedEventArgs";

    static PyObject* _new_InkStrokesCollectedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkStrokesCollectedEventArgs);
        return nullptr;
    }

    static void _dealloc_InkStrokesCollectedEventArgs(py::wrapper::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkStrokesCollectedEventArgs_get_Strokes(py::wrapper::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Strokes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkStrokesCollectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkStrokesCollectedEventArgs[] = {
        { "_from", (PyCFunction)_from_InkStrokesCollectedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkStrokesCollectedEventArgs[] = {
        { const_cast<char*>("strokes"), (getter)InkStrokesCollectedEventArgs_get_Strokes, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InkStrokesCollectedEventArgs[] = 
    {
        { Py_tp_new, _new_InkStrokesCollectedEventArgs },
        { Py_tp_dealloc, _dealloc_InkStrokesCollectedEventArgs },
        { Py_tp_methods, _methods_InkStrokesCollectedEventArgs },
        { Py_tp_getset, _getset_InkStrokesCollectedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkStrokesCollectedEventArgs =
    {
        "_winrt_Windows_UI_Input_Inking.InkStrokesCollectedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkStrokesCollectedEventArgs
    };

    // ----- InkStrokesErasedEventArgs class --------------------
    constexpr const char* const _type_name_InkStrokesErasedEventArgs = "InkStrokesErasedEventArgs";

    static PyObject* _new_InkStrokesErasedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkStrokesErasedEventArgs);
        return nullptr;
    }

    static void _dealloc_InkStrokesErasedEventArgs(py::wrapper::Windows::UI::Input::Inking::InkStrokesErasedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkStrokesErasedEventArgs_get_Strokes(py::wrapper::Windows::UI::Input::Inking::InkStrokesErasedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Strokes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkStrokesErasedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkStrokesErasedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkStrokesErasedEventArgs[] = {
        { "_from", (PyCFunction)_from_InkStrokesErasedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkStrokesErasedEventArgs[] = {
        { const_cast<char*>("strokes"), (getter)InkStrokesErasedEventArgs_get_Strokes, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InkStrokesErasedEventArgs[] = 
    {
        { Py_tp_new, _new_InkStrokesErasedEventArgs },
        { Py_tp_dealloc, _dealloc_InkStrokesErasedEventArgs },
        { Py_tp_methods, _methods_InkStrokesErasedEventArgs },
        { Py_tp_getset, _getset_InkStrokesErasedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkStrokesErasedEventArgs =
    {
        "_winrt_Windows_UI_Input_Inking.InkStrokesErasedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkStrokesErasedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkStrokesErasedEventArgs
    };

    // ----- InkSynchronizer class --------------------
    constexpr const char* const _type_name_InkSynchronizer = "InkSynchronizer";

    static PyObject* _new_InkSynchronizer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkSynchronizer);
        return nullptr;
    }

    static void _dealloc_InkSynchronizer(py::wrapper::Windows::UI::Input::Inking::InkSynchronizer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkSynchronizer_BeginDry(py::wrapper::Windows::UI::Input::Inking::InkSynchronizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.BeginDry());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkSynchronizer_EndDry(py::wrapper::Windows::UI::Input::Inking::InkSynchronizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.EndDry();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_InkSynchronizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkSynchronizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkSynchronizer[] = {
        { "begin_dry", (PyCFunction)InkSynchronizer_BeginDry, METH_VARARGS, nullptr },
        { "end_dry", (PyCFunction)InkSynchronizer_EndDry, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_InkSynchronizer, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkSynchronizer[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_InkSynchronizer[] = 
    {
        { Py_tp_new, _new_InkSynchronizer },
        { Py_tp_dealloc, _dealloc_InkSynchronizer },
        { Py_tp_methods, _methods_InkSynchronizer },
        { Py_tp_getset, _getset_InkSynchronizer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkSynchronizer =
    {
        "_winrt_Windows_UI_Input_Inking.InkSynchronizer",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkSynchronizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkSynchronizer
    };

    // ----- InkUnprocessedInput class --------------------
    constexpr const char* const _type_name_InkUnprocessedInput = "InkUnprocessedInput";

    static PyObject* _new_InkUnprocessedInput(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkUnprocessedInput);
        return nullptr;
    }

    static void _dealloc_InkUnprocessedInput(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkUnprocessedInput_get_InkPresenter(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InkPresenter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_add_PointerEntered(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkUnprocessedInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_remove_PointerEntered(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_add_PointerExited(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkUnprocessedInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_remove_PointerExited(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_add_PointerHovered(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkUnprocessedInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerHovered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_remove_PointerHovered(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerHovered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_add_PointerLost(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkUnprocessedInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_remove_PointerLost(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_add_PointerMoved(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkUnprocessedInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerMoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_remove_PointerMoved(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerMoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_add_PointerPressed(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkUnprocessedInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_remove_PointerPressed(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_add_PointerReleased(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkUnprocessedInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_remove_PointerReleased(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkUnprocessedInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkUnprocessedInput>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkUnprocessedInput[] = {
        { "add_pointer_entered", (PyCFunction)InkUnprocessedInput_add_PointerEntered, METH_O, nullptr },
        { "remove_pointer_entered", (PyCFunction)InkUnprocessedInput_remove_PointerEntered, METH_O, nullptr },
        { "add_pointer_exited", (PyCFunction)InkUnprocessedInput_add_PointerExited, METH_O, nullptr },
        { "remove_pointer_exited", (PyCFunction)InkUnprocessedInput_remove_PointerExited, METH_O, nullptr },
        { "add_pointer_hovered", (PyCFunction)InkUnprocessedInput_add_PointerHovered, METH_O, nullptr },
        { "remove_pointer_hovered", (PyCFunction)InkUnprocessedInput_remove_PointerHovered, METH_O, nullptr },
        { "add_pointer_lost", (PyCFunction)InkUnprocessedInput_add_PointerLost, METH_O, nullptr },
        { "remove_pointer_lost", (PyCFunction)InkUnprocessedInput_remove_PointerLost, METH_O, nullptr },
        { "add_pointer_moved", (PyCFunction)InkUnprocessedInput_add_PointerMoved, METH_O, nullptr },
        { "remove_pointer_moved", (PyCFunction)InkUnprocessedInput_remove_PointerMoved, METH_O, nullptr },
        { "add_pointer_pressed", (PyCFunction)InkUnprocessedInput_add_PointerPressed, METH_O, nullptr },
        { "remove_pointer_pressed", (PyCFunction)InkUnprocessedInput_remove_PointerPressed, METH_O, nullptr },
        { "add_pointer_released", (PyCFunction)InkUnprocessedInput_add_PointerReleased, METH_O, nullptr },
        { "remove_pointer_released", (PyCFunction)InkUnprocessedInput_remove_PointerReleased, METH_O, nullptr },
        { "_from", (PyCFunction)_from_InkUnprocessedInput, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InkUnprocessedInput[] = {
        { const_cast<char*>("ink_presenter"), (getter)InkUnprocessedInput_get_InkPresenter, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InkUnprocessedInput[] = 
    {
        { Py_tp_new, _new_InkUnprocessedInput },
        { Py_tp_dealloc, _dealloc_InkUnprocessedInput },
        { Py_tp_methods, _methods_InkUnprocessedInput },
        { Py_tp_getset, _getset_InkUnprocessedInput },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InkUnprocessedInput =
    {
        "_winrt_Windows_UI_Input_Inking.InkUnprocessedInput",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkUnprocessedInput
    };

    // ----- PenAndInkSettings class --------------------
    constexpr const char* const _type_name_PenAndInkSettings = "PenAndInkSettings";

    static PyObject* _new_PenAndInkSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PenAndInkSettings);
        return nullptr;
    }

    static void _dealloc_PenAndInkSettings(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PenAndInkSettings_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::Input::Inking::PenAndInkSettings::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenAndInkSettings_SetPenHandedness(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::PenHandedness>(args, 0);

                self->obj.SetPenHandedness(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenAndInkSettings_get_FontFamilyName(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FontFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenAndInkSettings_get_HandwritingLineHeight(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HandwritingLineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenAndInkSettings_get_IsHandwritingDirectlyIntoTextFieldEnabled(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHandwritingDirectlyIntoTextFieldEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenAndInkSettings_get_IsTouchHandwritingEnabled(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTouchHandwritingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenAndInkSettings_get_PenHandedness(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PenHandedness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenAndInkSettings_get_UserConsentsToHandwritingTelemetryCollection(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserConsentsToHandwritingTelemetryCollection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PenAndInkSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::PenAndInkSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenAndInkSettings[] = {
        { "get_default", (PyCFunction)PenAndInkSettings_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "set_pen_handedness", (PyCFunction)PenAndInkSettings_SetPenHandedness, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PenAndInkSettings, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PenAndInkSettings[] = {
        { const_cast<char*>("font_family_name"), (getter)PenAndInkSettings_get_FontFamilyName, nullptr, nullptr, nullptr },
        { const_cast<char*>("handwriting_line_height"), (getter)PenAndInkSettings_get_HandwritingLineHeight, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_handwriting_directly_into_text_field_enabled"), (getter)PenAndInkSettings_get_IsHandwritingDirectlyIntoTextFieldEnabled, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_touch_handwriting_enabled"), (getter)PenAndInkSettings_get_IsTouchHandwritingEnabled, nullptr, nullptr, nullptr },
        { const_cast<char*>("pen_handedness"), (getter)PenAndInkSettings_get_PenHandedness, nullptr, nullptr, nullptr },
        { const_cast<char*>("user_consents_to_handwriting_telemetry_collection"), (getter)PenAndInkSettings_get_UserConsentsToHandwritingTelemetryCollection, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PenAndInkSettings[] = 
    {
        { Py_tp_new, _new_PenAndInkSettings },
        { Py_tp_dealloc, _dealloc_PenAndInkSettings },
        { Py_tp_methods, _methods_PenAndInkSettings },
        { Py_tp_getset, _getset_PenAndInkSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PenAndInkSettings =
    {
        "_winrt_Windows_UI_Input_Inking.PenAndInkSettings",
        sizeof(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenAndInkSettings
    };

    // ----- IInkPointFactory interface --------------------
    constexpr const char* const _type_name_IInkPointFactory = "IInkPointFactory";

    static PyObject* _new_IInkPointFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IInkPointFactory);
        return nullptr;
    }

    static void _dealloc_IInkPointFactory(py::wrapper::Windows::UI::Input::Inking::IInkPointFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IInkPointFactory_CreateInkPoint(py::wrapper::Windows::UI::Input::Inking::IInkPointFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                return py::convert(self->obj.CreateInkPoint(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IInkPointFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::IInkPointFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInkPointFactory[] = {
        { "create_ink_point", (PyCFunction)IInkPointFactory_CreateInkPoint, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IInkPointFactory, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IInkPointFactory[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IInkPointFactory[] = 
    {
        { Py_tp_new, _new_IInkPointFactory },
        { Py_tp_dealloc, _dealloc_IInkPointFactory },
        { Py_tp_methods, _methods_IInkPointFactory },
        { Py_tp_getset, _getset_IInkPointFactory },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IInkPointFactory =
    {
        "_winrt_Windows_UI_Input_Inking.IInkPointFactory",
        sizeof(py::wrapper::Windows::UI::Input::Inking::IInkPointFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInkPointFactory
    };

    // ----- IInkPresenterRulerFactory interface --------------------
    constexpr const char* const _type_name_IInkPresenterRulerFactory = "IInkPresenterRulerFactory";

    static PyObject* _new_IInkPresenterRulerFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IInkPresenterRulerFactory);
        return nullptr;
    }

    static void _dealloc_IInkPresenterRulerFactory(py::wrapper::Windows::UI::Input::Inking::IInkPresenterRulerFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IInkPresenterRulerFactory_Create(py::wrapper::Windows::UI::Input::Inking::IInkPresenterRulerFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkPresenter>(args, 0);

                return py::convert(self->obj.Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IInkPresenterRulerFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::IInkPresenterRulerFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInkPresenterRulerFactory[] = {
        { "create", (PyCFunction)IInkPresenterRulerFactory_Create, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IInkPresenterRulerFactory, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IInkPresenterRulerFactory[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IInkPresenterRulerFactory[] = 
    {
        { Py_tp_new, _new_IInkPresenterRulerFactory },
        { Py_tp_dealloc, _dealloc_IInkPresenterRulerFactory },
        { Py_tp_methods, _methods_IInkPresenterRulerFactory },
        { Py_tp_getset, _getset_IInkPresenterRulerFactory },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IInkPresenterRulerFactory =
    {
        "_winrt_Windows_UI_Input_Inking.IInkPresenterRulerFactory",
        sizeof(py::wrapper::Windows::UI::Input::Inking::IInkPresenterRulerFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInkPresenterRulerFactory
    };

    // ----- IInkPresenterStencil interface --------------------
    constexpr const char* const _type_name_IInkPresenterStencil = "IInkPresenterStencil";

    static PyObject* _new_IInkPresenterStencil(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IInkPresenterStencil);
        return nullptr;
    }

    static void _dealloc_IInkPresenterStencil(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IInkPresenterStencil_get_BackgroundColor(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IInkPresenterStencil_put_BackgroundColor(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.BackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IInkPresenterStencil_get_ForegroundColor(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IInkPresenterStencil_put_ForegroundColor(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.ForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IInkPresenterStencil_get_IsVisible(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IInkPresenterStencil_put_IsVisible(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IInkPresenterStencil_get_Kind(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IInkPresenterStencil_get_Transform(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Transform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IInkPresenterStencil_put_Transform(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);

            self->obj.Transform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IInkPresenterStencil(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::IInkPresenterStencil>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInkPresenterStencil[] = {
        { "_from", (PyCFunction)_from_IInkPresenterStencil, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IInkPresenterStencil[] = {
        { const_cast<char*>("background_color"), (getter)IInkPresenterStencil_get_BackgroundColor, (setter)IInkPresenterStencil_put_BackgroundColor, nullptr, nullptr },
        { const_cast<char*>("foreground_color"), (getter)IInkPresenterStencil_get_ForegroundColor, (setter)IInkPresenterStencil_put_ForegroundColor, nullptr, nullptr },
        { const_cast<char*>("is_visible"), (getter)IInkPresenterStencil_get_IsVisible, (setter)IInkPresenterStencil_put_IsVisible, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)IInkPresenterStencil_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("transform"), (getter)IInkPresenterStencil_get_Transform, (setter)IInkPresenterStencil_put_Transform, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IInkPresenterStencil[] = 
    {
        { Py_tp_new, _new_IInkPresenterStencil },
        { Py_tp_dealloc, _dealloc_IInkPresenterStencil },
        { Py_tp_methods, _methods_IInkPresenterStencil },
        { Py_tp_getset, _getset_IInkPresenterStencil },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IInkPresenterStencil =
    {
        "_winrt_Windows_UI_Input_Inking.IInkPresenterStencil",
        sizeof(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInkPresenterStencil
    };

    // ----- IInkRecognizerContainer interface --------------------
    constexpr const char* const _type_name_IInkRecognizerContainer = "IInkRecognizerContainer";

    static PyObject* _new_IInkRecognizerContainer(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IInkRecognizerContainer);
        return nullptr;
    }

    static void _dealloc_IInkRecognizerContainer(py::wrapper::Windows::UI::Input::Inking::IInkRecognizerContainer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IInkRecognizerContainer_GetRecognizers(py::wrapper::Windows::UI::Input::Inking::IInkRecognizerContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRecognizers());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkRecognizerContainer_RecognizeAsync(py::wrapper::Windows::UI::Input::Inking::IInkRecognizerContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkStrokeContainer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Input::Inking::InkRecognitionTarget>(args, 1);

                return py::convert(self->obj.RecognizeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkRecognizerContainer_SetDefaultRecognizer(py::wrapper::Windows::UI::Input::Inking::IInkRecognizerContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkRecognizer>(args, 0);

                self->obj.SetDefaultRecognizer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IInkRecognizerContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::IInkRecognizerContainer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInkRecognizerContainer[] = {
        { "get_recognizers", (PyCFunction)IInkRecognizerContainer_GetRecognizers, METH_VARARGS, nullptr },
        { "recognize_async", (PyCFunction)IInkRecognizerContainer_RecognizeAsync, METH_VARARGS, nullptr },
        { "set_default_recognizer", (PyCFunction)IInkRecognizerContainer_SetDefaultRecognizer, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IInkRecognizerContainer, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IInkRecognizerContainer[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IInkRecognizerContainer[] = 
    {
        { Py_tp_new, _new_IInkRecognizerContainer },
        { Py_tp_dealloc, _dealloc_IInkRecognizerContainer },
        { Py_tp_methods, _methods_IInkRecognizerContainer },
        { Py_tp_getset, _getset_IInkRecognizerContainer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IInkRecognizerContainer =
    {
        "_winrt_Windows_UI_Input_Inking.IInkRecognizerContainer",
        sizeof(py::wrapper::Windows::UI::Input::Inking::IInkRecognizerContainer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInkRecognizerContainer
    };

    // ----- IInkStrokeContainer interface --------------------
    constexpr const char* const _type_name_IInkStrokeContainer = "IInkStrokeContainer";

    static PyObject* _new_IInkStrokeContainer(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IInkStrokeContainer);
        return nullptr;
    }

    static void _dealloc_IInkStrokeContainer(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IInkStrokeContainer_AddStroke(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkStroke>(args, 0);

                self->obj.AddStroke(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_CanPasteFromClipboard(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CanPasteFromClipboard());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_CopySelectedToClipboard(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.CopySelectedToClipboard();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_DeleteSelected(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteSelected());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_GetRecognitionResults(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRecognitionResults());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_GetStrokes(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetStrokes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_LoadAsync(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.LoadAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_MoveSelected(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.MoveSelected(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_PasteFromClipboard(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.PasteFromClipboard(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_SaveAsync(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.SaveAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_SelectWithLine(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                return py::convert(self->obj.SelectWithLine(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_SelectWithPolyLine(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Point>>(args, 0);

                return py::convert(self->obj.SelectWithPolyLine(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_UpdateRecognitionResults(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::UI::Input::Inking::InkRecognitionResult>>(args, 0);

                self->obj.UpdateRecognitionResults(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_get_BoundingRect(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BoundingRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IInkStrokeContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::IInkStrokeContainer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInkStrokeContainer[] = {
        { "add_stroke", (PyCFunction)IInkStrokeContainer_AddStroke, METH_VARARGS, nullptr },
        { "can_paste_from_clipboard", (PyCFunction)IInkStrokeContainer_CanPasteFromClipboard, METH_VARARGS, nullptr },
        { "copy_selected_to_clipboard", (PyCFunction)IInkStrokeContainer_CopySelectedToClipboard, METH_VARARGS, nullptr },
        { "delete_selected", (PyCFunction)IInkStrokeContainer_DeleteSelected, METH_VARARGS, nullptr },
        { "get_recognition_results", (PyCFunction)IInkStrokeContainer_GetRecognitionResults, METH_VARARGS, nullptr },
        { "get_strokes", (PyCFunction)IInkStrokeContainer_GetStrokes, METH_VARARGS, nullptr },
        { "load_async", (PyCFunction)IInkStrokeContainer_LoadAsync, METH_VARARGS, nullptr },
        { "move_selected", (PyCFunction)IInkStrokeContainer_MoveSelected, METH_VARARGS, nullptr },
        { "paste_from_clipboard", (PyCFunction)IInkStrokeContainer_PasteFromClipboard, METH_VARARGS, nullptr },
        { "save_async", (PyCFunction)IInkStrokeContainer_SaveAsync, METH_VARARGS, nullptr },
        { "select_with_line", (PyCFunction)IInkStrokeContainer_SelectWithLine, METH_VARARGS, nullptr },
        { "select_with_poly_line", (PyCFunction)IInkStrokeContainer_SelectWithPolyLine, METH_VARARGS, nullptr },
        { "update_recognition_results", (PyCFunction)IInkStrokeContainer_UpdateRecognitionResults, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IInkStrokeContainer, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IInkStrokeContainer[] = {
        { const_cast<char*>("bounding_rect"), (getter)IInkStrokeContainer_get_BoundingRect, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IInkStrokeContainer[] = 
    {
        { Py_tp_new, _new_IInkStrokeContainer },
        { Py_tp_dealloc, _dealloc_IInkStrokeContainer },
        { Py_tp_methods, _methods_IInkStrokeContainer },
        { Py_tp_getset, _getset_IInkStrokeContainer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IInkStrokeContainer =
    {
        "_winrt_Windows_UI_Input_Inking.IInkStrokeContainer",
        sizeof(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInkStrokeContainer
    };

    // ----- Windows.UI.Input.Inking Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::UI::Input::Inking::InkDrawingAttributes>::python_type = py::register_python_type(module, _type_name_InkDrawingAttributes, &_type_spec_InkDrawingAttributes, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties>::python_type = py::register_python_type(module, _type_name_InkDrawingAttributesPencilProperties, &_type_spec_InkDrawingAttributesPencilProperties, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkInputConfiguration>::python_type = py::register_python_type(module, _type_name_InkInputConfiguration, &_type_spec_InkInputConfiguration, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkInputProcessingConfiguration>::python_type = py::register_python_type(module, _type_name_InkInputProcessingConfiguration, &_type_spec_InkInputProcessingConfiguration, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkManager>::python_type = py::register_python_type(module, _type_name_InkManager, &_type_spec_InkManager, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkModelerAttributes>::python_type = py::register_python_type(module, _type_name_InkModelerAttributes, &_type_spec_InkModelerAttributes, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkPoint>::python_type = py::register_python_type(module, _type_name_InkPoint, &_type_spec_InkPoint, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkPresenter>::python_type = py::register_python_type(module, _type_name_InkPresenter, &_type_spec_InkPresenter, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkPresenterProtractor>::python_type = py::register_python_type(module, _type_name_InkPresenterProtractor, &_type_spec_InkPresenterProtractor, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkPresenterRuler>::python_type = py::register_python_type(module, _type_name_InkPresenterRuler, &_type_spec_InkPresenterRuler, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkRecognitionResult>::python_type = py::register_python_type(module, _type_name_InkRecognitionResult, &_type_spec_InkRecognitionResult, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkRecognizer>::python_type = py::register_python_type(module, _type_name_InkRecognizer, &_type_spec_InkRecognizer, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkRecognizerContainer>::python_type = py::register_python_type(module, _type_name_InkRecognizerContainer, &_type_spec_InkRecognizerContainer, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkStroke>::python_type = py::register_python_type(module, _type_name_InkStroke, &_type_spec_InkStroke, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokeBuilder>::python_type = py::register_python_type(module, _type_name_InkStrokeBuilder, &_type_spec_InkStrokeBuilder, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokeContainer>::python_type = py::register_python_type(module, _type_name_InkStrokeContainer, &_type_spec_InkStrokeContainer, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokeInput>::python_type = py::register_python_type(module, _type_name_InkStrokeInput, &_type_spec_InkStrokeInput, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokeRenderingSegment>::python_type = py::register_python_type(module, _type_name_InkStrokeRenderingSegment, &_type_spec_InkStrokeRenderingSegment, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs>::python_type = py::register_python_type(module, _type_name_InkStrokesCollectedEventArgs, &_type_spec_InkStrokesCollectedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokesErasedEventArgs>::python_type = py::register_python_type(module, _type_name_InkStrokesErasedEventArgs, &_type_spec_InkStrokesErasedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkSynchronizer>::python_type = py::register_python_type(module, _type_name_InkSynchronizer, &_type_spec_InkSynchronizer, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkUnprocessedInput>::python_type = py::register_python_type(module, _type_name_InkUnprocessedInput, &_type_spec_InkUnprocessedInput, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::PenAndInkSettings>::python_type = py::register_python_type(module, _type_name_PenAndInkSettings, &_type_spec_PenAndInkSettings, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::IInkPointFactory>::python_type = py::register_python_type(module, _type_name_IInkPointFactory, &_type_spec_IInkPointFactory, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::IInkPresenterRulerFactory>::python_type = py::register_python_type(module, _type_name_IInkPresenterRulerFactory, &_type_spec_IInkPresenterRulerFactory, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::IInkPresenterStencil>::python_type = py::register_python_type(module, _type_name_IInkPresenterStencil, &_type_spec_IInkPresenterStencil, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::IInkRecognizerContainer>::python_type = py::register_python_type(module, _type_name_IInkRecognizerContainer, &_type_spec_IInkRecognizerContainer, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::IInkStrokeContainer>::python_type = py::register_python_type(module, _type_name_IInkStrokeContainer, &_type_spec_IInkStrokeContainer, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.UI.Input.Inking");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_UI_Input_Inking",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::UI::Input::Inking

PyMODINIT_FUNC
PyInit__winrt_Windows_UI_Input_Inking (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::UI::Input::Inking::module_def);
}
