// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Storage.h"

PyTypeObject* py::winrt_type<winrt::Windows::Storage::AppDataPaths>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::ApplicationData>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::ApplicationDataCompositeValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::ApplicationDataContainer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::ApplicationDataContainerSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::CachedFileManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::DownloadsFolder>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::FileIO>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::KnownFolders>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::PathIO>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SetVersionDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SetVersionRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageFile>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageFolder>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageLibrary>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageLibraryChange>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageLibraryChangeReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageLibraryChangeTracker>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageLibraryChangeTrackerOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageLibraryLastChangeId>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageProvider>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageStreamTransaction>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StreamedFileDataRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemAudioProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemDataPaths>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemGPSProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemImageProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemMediaProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemMusicProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemPhotoProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemVideoProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::UserDataPaths>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageFile>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageFile2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageFolder>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageFolder2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageItem>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageItem2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageItemProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageItemProperties2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStreamedFileDataRequest>::python_type;

namespace py::cpp::Windows::Storage
{
    // ----- AppDataPaths class --------------------
    constexpr const char* const _type_name_AppDataPaths = "AppDataPaths";

    static PyObject* _new_AppDataPaths(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppDataPaths);
        return nullptr;
    }

    static void _dealloc_AppDataPaths(py::wrapper::Windows::Storage::AppDataPaths* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppDataPaths_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Storage::AppDataPaths::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::Storage::AppDataPaths::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_Cookies(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Cookies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_Desktop(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Desktop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_Documents(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Documents());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_Favorites(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Favorites());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_History(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.History());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_InternetCache(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InternetCache());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_LocalAppData(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAppData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_ProgramData(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProgramData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_RoamingAppData(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoamingAppData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppDataPaths(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::AppDataPaths>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppDataPaths[] = {
        { "get_default", (PyCFunction)AppDataPaths_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", (PyCFunction)AppDataPaths_GetForUser, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_AppDataPaths, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppDataPaths[] = {
        { const_cast<char*>("cookies"), (getter)AppDataPaths_get_Cookies, nullptr, nullptr, nullptr },
        { const_cast<char*>("desktop"), (getter)AppDataPaths_get_Desktop, nullptr, nullptr, nullptr },
        { const_cast<char*>("documents"), (getter)AppDataPaths_get_Documents, nullptr, nullptr, nullptr },
        { const_cast<char*>("favorites"), (getter)AppDataPaths_get_Favorites, nullptr, nullptr, nullptr },
        { const_cast<char*>("history"), (getter)AppDataPaths_get_History, nullptr, nullptr, nullptr },
        { const_cast<char*>("internet_cache"), (getter)AppDataPaths_get_InternetCache, nullptr, nullptr, nullptr },
        { const_cast<char*>("local_app_data"), (getter)AppDataPaths_get_LocalAppData, nullptr, nullptr, nullptr },
        { const_cast<char*>("program_data"), (getter)AppDataPaths_get_ProgramData, nullptr, nullptr, nullptr },
        { const_cast<char*>("roaming_app_data"), (getter)AppDataPaths_get_RoamingAppData, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppDataPaths[] = 
    {
        { Py_tp_new, _new_AppDataPaths },
        { Py_tp_dealloc, _dealloc_AppDataPaths },
        { Py_tp_methods, _methods_AppDataPaths },
        { Py_tp_getset, _getset_AppDataPaths },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppDataPaths =
    {
        "_winrt_Windows_Storage.AppDataPaths",
        sizeof(py::wrapper::Windows::Storage::AppDataPaths),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppDataPaths
    };

    // ----- ApplicationData class --------------------
    constexpr const char* const _type_name_ApplicationData = "ApplicationData";

    static PyObject* _new_ApplicationData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ApplicationData);
        return nullptr;
    }

    static void _dealloc_ApplicationData(py::wrapper::Windows::Storage::ApplicationData* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ApplicationData_ClearAsync(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClearAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::ApplicationDataLocality>(args, 0);

                return py::convert(self->obj.ClearAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_ClearPublisherCacheFolderAsync(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ClearPublisherCacheFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_Close(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_GetForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::Storage::ApplicationData::GetForUserAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_GetPublisherCacheFolder(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetPublisherCacheFolder(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_SetVersionAsync(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::ApplicationDataSetVersionHandler>(args, 1);

                return py::convert(self->obj.SetVersionAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_SignalDataChanged(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.SignalDataChanged();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_LocalFolder(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_LocalSettings(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_RoamingFolder(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoamingFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_RoamingSettings(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoamingSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_RoamingStorageQuota(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoamingStorageQuota());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_TemporaryFolder(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TemporaryFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_Version(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_LocalCacheFolder(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalCacheFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_SharedLocalFolder(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SharedLocalFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_Current(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::ApplicationData::Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_add_DataChanged(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::ApplicationData, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.DataChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_remove_DataChanged(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DataChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ApplicationData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::ApplicationData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ApplicationData(py::wrapper::Windows::Storage::ApplicationData* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_ApplicationData(py::wrapper::Windows::Storage::ApplicationData* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationData[] = {
        { "clear_async", (PyCFunction)ApplicationData_ClearAsync, METH_VARARGS, nullptr },
        { "clear_publisher_cache_folder_async", (PyCFunction)ApplicationData_ClearPublisherCacheFolderAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)ApplicationData_Close, METH_VARARGS, nullptr },
        { "get_for_user_async", (PyCFunction)ApplicationData_GetForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_publisher_cache_folder", (PyCFunction)ApplicationData_GetPublisherCacheFolder, METH_VARARGS, nullptr },
        { "set_version_async", (PyCFunction)ApplicationData_SetVersionAsync, METH_VARARGS, nullptr },
        { "signal_data_changed", (PyCFunction)ApplicationData_SignalDataChanged, METH_VARARGS, nullptr },
        { "get_current", (PyCFunction)ApplicationData_get_Current, METH_NOARGS | METH_STATIC, nullptr },
        { "add_data_changed", (PyCFunction)ApplicationData_add_DataChanged, METH_O, nullptr },
        { "remove_data_changed", (PyCFunction)ApplicationData_remove_DataChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ApplicationData, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_ApplicationData, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_ApplicationData, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ApplicationData[] = {
        { const_cast<char*>("local_folder"), (getter)ApplicationData_get_LocalFolder, nullptr, nullptr, nullptr },
        { const_cast<char*>("local_settings"), (getter)ApplicationData_get_LocalSettings, nullptr, nullptr, nullptr },
        { const_cast<char*>("roaming_folder"), (getter)ApplicationData_get_RoamingFolder, nullptr, nullptr, nullptr },
        { const_cast<char*>("roaming_settings"), (getter)ApplicationData_get_RoamingSettings, nullptr, nullptr, nullptr },
        { const_cast<char*>("roaming_storage_quota"), (getter)ApplicationData_get_RoamingStorageQuota, nullptr, nullptr, nullptr },
        { const_cast<char*>("temporary_folder"), (getter)ApplicationData_get_TemporaryFolder, nullptr, nullptr, nullptr },
        { const_cast<char*>("version"), (getter)ApplicationData_get_Version, nullptr, nullptr, nullptr },
        { const_cast<char*>("local_cache_folder"), (getter)ApplicationData_get_LocalCacheFolder, nullptr, nullptr, nullptr },
        { const_cast<char*>("shared_local_folder"), (getter)ApplicationData_get_SharedLocalFolder, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ApplicationData[] = 
    {
        { Py_tp_new, _new_ApplicationData },
        { Py_tp_dealloc, _dealloc_ApplicationData },
        { Py_tp_methods, _methods_ApplicationData },
        { Py_tp_getset, _getset_ApplicationData },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ApplicationData =
    {
        "_winrt_Windows_Storage.ApplicationData",
        sizeof(py::wrapper::Windows::Storage::ApplicationData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationData
    };

    // ----- ApplicationDataCompositeValue class --------------------
    constexpr const char* const _type_name_ApplicationDataCompositeValue = "ApplicationDataCompositeValue";

    static PyObject* _new_ApplicationDataCompositeValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::ApplicationDataCompositeValue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ApplicationDataCompositeValue_Clear(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_First(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_GetView(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_HasKey(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_Insert(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_Lookup(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_Remove(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_get_Size(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_add_MapChanged(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::MapChangedEventHandler<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.MapChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_remove_MapChanged(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ApplicationDataCompositeValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::ApplicationDataCompositeValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _map_length_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* key) noexcept
    {
        try
        {
            return py::convert(self->obj.Lookup(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            if (value == nullptr) { self->obj.Remove(_key); }
            else { self->obj.Insert(_key, py::convert_to<winrt::Windows::Foundation::IInspectable>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_ApplicationDataCompositeValue[] = {
        { "clear", (PyCFunction)ApplicationDataCompositeValue_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)ApplicationDataCompositeValue_First, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)ApplicationDataCompositeValue_GetView, METH_VARARGS, nullptr },
        { "has_key", (PyCFunction)ApplicationDataCompositeValue_HasKey, METH_VARARGS, nullptr },
        { "insert", (PyCFunction)ApplicationDataCompositeValue_Insert, METH_VARARGS, nullptr },
        { "lookup", (PyCFunction)ApplicationDataCompositeValue_Lookup, METH_VARARGS, nullptr },
        { "remove", (PyCFunction)ApplicationDataCompositeValue_Remove, METH_VARARGS, nullptr },
        { "add_map_changed", (PyCFunction)ApplicationDataCompositeValue_add_MapChanged, METH_O, nullptr },
        { "remove_map_changed", (PyCFunction)ApplicationDataCompositeValue_remove_MapChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ApplicationDataCompositeValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ApplicationDataCompositeValue[] = {
        { const_cast<char*>("size"), (getter)ApplicationDataCompositeValue_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ApplicationDataCompositeValue[] = 
    {
        { Py_tp_new, _new_ApplicationDataCompositeValue },
        { Py_tp_dealloc, _dealloc_ApplicationDataCompositeValue },
        { Py_tp_methods, _methods_ApplicationDataCompositeValue },
        { Py_tp_getset, _getset_ApplicationDataCompositeValue },
        { Py_tp_iter, _iterator_ApplicationDataCompositeValue },
        { Py_mp_length, _map_length_ApplicationDataCompositeValue },
        { Py_mp_subscript, _map_subscript_ApplicationDataCompositeValue },
        { Py_mp_ass_subscript, _map_assign_ApplicationDataCompositeValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ApplicationDataCompositeValue =
    {
        "_winrt_Windows_Storage.ApplicationDataCompositeValue",
        sizeof(py::wrapper::Windows::Storage::ApplicationDataCompositeValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationDataCompositeValue
    };

    // ----- ApplicationDataContainer class --------------------
    constexpr const char* const _type_name_ApplicationDataContainer = "ApplicationDataContainer";

    static PyObject* _new_ApplicationDataContainer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ApplicationDataContainer);
        return nullptr;
    }

    static void _dealloc_ApplicationDataContainer(py::wrapper::Windows::Storage::ApplicationDataContainer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ApplicationDataContainer_Close(py::wrapper::Windows::Storage::ApplicationDataContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_CreateContainer(py::wrapper::Windows::Storage::ApplicationDataContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::ApplicationDataCreateDisposition>(args, 1);

                return py::convert(self->obj.CreateContainer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_DeleteContainer(py::wrapper::Windows::Storage::ApplicationDataContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.DeleteContainer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_get_Containers(py::wrapper::Windows::Storage::ApplicationDataContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Containers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_get_Locality(py::wrapper::Windows::Storage::ApplicationDataContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Locality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_get_Name(py::wrapper::Windows::Storage::ApplicationDataContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_get_Values(py::wrapper::Windows::Storage::ApplicationDataContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Values());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ApplicationDataContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::ApplicationDataContainer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ApplicationDataContainer(py::wrapper::Windows::Storage::ApplicationDataContainer* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_ApplicationDataContainer(py::wrapper::Windows::Storage::ApplicationDataContainer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationDataContainer[] = {
        { "close", (PyCFunction)ApplicationDataContainer_Close, METH_VARARGS, nullptr },
        { "create_container", (PyCFunction)ApplicationDataContainer_CreateContainer, METH_VARARGS, nullptr },
        { "delete_container", (PyCFunction)ApplicationDataContainer_DeleteContainer, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ApplicationDataContainer, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_ApplicationDataContainer, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_ApplicationDataContainer, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ApplicationDataContainer[] = {
        { const_cast<char*>("containers"), (getter)ApplicationDataContainer_get_Containers, nullptr, nullptr, nullptr },
        { const_cast<char*>("locality"), (getter)ApplicationDataContainer_get_Locality, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)ApplicationDataContainer_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("values"), (getter)ApplicationDataContainer_get_Values, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ApplicationDataContainer[] = 
    {
        { Py_tp_new, _new_ApplicationDataContainer },
        { Py_tp_dealloc, _dealloc_ApplicationDataContainer },
        { Py_tp_methods, _methods_ApplicationDataContainer },
        { Py_tp_getset, _getset_ApplicationDataContainer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ApplicationDataContainer =
    {
        "_winrt_Windows_Storage.ApplicationDataContainer",
        sizeof(py::wrapper::Windows::Storage::ApplicationDataContainer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationDataContainer
    };

    // ----- ApplicationDataContainerSettings class --------------------
    constexpr const char* const _type_name_ApplicationDataContainerSettings = "ApplicationDataContainerSettings";

    static PyObject* _new_ApplicationDataContainerSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ApplicationDataContainerSettings);
        return nullptr;
    }

    static void _dealloc_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ApplicationDataContainerSettings_Clear(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_First(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_GetView(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_HasKey(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_Insert(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_Lookup(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_Remove(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_get_Size(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_add_MapChanged(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::MapChangedEventHandler<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.MapChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_remove_MapChanged(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ApplicationDataContainerSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::ApplicationDataContainerSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _map_length_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* key) noexcept
    {
        try
        {
            return py::convert(self->obj.Lookup(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            if (value == nullptr) { self->obj.Remove(_key); }
            else { self->obj.Insert(_key, py::convert_to<winrt::Windows::Foundation::IInspectable>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_ApplicationDataContainerSettings[] = {
        { "clear", (PyCFunction)ApplicationDataContainerSettings_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)ApplicationDataContainerSettings_First, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)ApplicationDataContainerSettings_GetView, METH_VARARGS, nullptr },
        { "has_key", (PyCFunction)ApplicationDataContainerSettings_HasKey, METH_VARARGS, nullptr },
        { "insert", (PyCFunction)ApplicationDataContainerSettings_Insert, METH_VARARGS, nullptr },
        { "lookup", (PyCFunction)ApplicationDataContainerSettings_Lookup, METH_VARARGS, nullptr },
        { "remove", (PyCFunction)ApplicationDataContainerSettings_Remove, METH_VARARGS, nullptr },
        { "add_map_changed", (PyCFunction)ApplicationDataContainerSettings_add_MapChanged, METH_O, nullptr },
        { "remove_map_changed", (PyCFunction)ApplicationDataContainerSettings_remove_MapChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ApplicationDataContainerSettings, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ApplicationDataContainerSettings[] = {
        { const_cast<char*>("size"), (getter)ApplicationDataContainerSettings_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ApplicationDataContainerSettings[] = 
    {
        { Py_tp_new, _new_ApplicationDataContainerSettings },
        { Py_tp_dealloc, _dealloc_ApplicationDataContainerSettings },
        { Py_tp_methods, _methods_ApplicationDataContainerSettings },
        { Py_tp_getset, _getset_ApplicationDataContainerSettings },
        { Py_tp_iter, _iterator_ApplicationDataContainerSettings },
        { Py_mp_length, _map_length_ApplicationDataContainerSettings },
        { Py_mp_subscript, _map_subscript_ApplicationDataContainerSettings },
        { Py_mp_ass_subscript, _map_assign_ApplicationDataContainerSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ApplicationDataContainerSettings =
    {
        "_winrt_Windows_Storage.ApplicationDataContainerSettings",
        sizeof(py::wrapper::Windows::Storage::ApplicationDataContainerSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationDataContainerSettings
    };

    // ----- CachedFileManager class --------------------
    constexpr const char* const _type_name_CachedFileManager = "CachedFileManager";

    static PyObject* _new_CachedFileManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CachedFileManager);
        return nullptr;
    }

    static PyObject* CachedFileManager_CompleteUpdatesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Storage::CachedFileManager::CompleteUpdatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CachedFileManager_DeferUpdates(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                winrt::Windows::Storage::CachedFileManager::DeferUpdates(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileManager[] = {
        { "complete_updates_async", (PyCFunction)CachedFileManager_CompleteUpdatesAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "defer_updates", (PyCFunction)CachedFileManager_DeferUpdates, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CachedFileManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_CachedFileManager[] = 
    {
        { Py_tp_new, _new_CachedFileManager },
        { Py_tp_methods, _methods_CachedFileManager },
        { Py_tp_getset, _getset_CachedFileManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CachedFileManager =
    {
        "_winrt_Windows_Storage.CachedFileManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileManager
    };

    // ----- DownloadsFolder class --------------------
    constexpr const char* const _type_name_DownloadsFolder = "DownloadsFolder";

    static PyObject* _new_DownloadsFolder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DownloadsFolder);
        return nullptr;
    }

    static PyObject* DownloadsFolder_CreateFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadsFolder_CreateFileForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFileForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 2);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFileForUserAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadsFolder_CreateFolderAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFolderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadsFolder_CreateFolderForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFolderForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 2);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFolderForUserAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_DownloadsFolder[] = {
        { "create_file_async", (PyCFunction)DownloadsFolder_CreateFileAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "create_file_for_user_async", (PyCFunction)DownloadsFolder_CreateFileForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "create_folder_async", (PyCFunction)DownloadsFolder_CreateFolderAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "create_folder_for_user_async", (PyCFunction)DownloadsFolder_CreateFolderForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DownloadsFolder[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_DownloadsFolder[] = 
    {
        { Py_tp_new, _new_DownloadsFolder },
        { Py_tp_methods, _methods_DownloadsFolder },
        { Py_tp_getset, _getset_DownloadsFolder },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DownloadsFolder =
    {
        "_winrt_Windows_Storage.DownloadsFolder",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DownloadsFolder
    };

    // ----- FileIO class --------------------
    constexpr const char* const _type_name_FileIO = "FileIO";

    static PyObject* _new_FileIO(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FileIO);
        return nullptr;
    }

    static PyObject* FileIO_AppendLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::AppendLinesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::FileIO::AppendLinesAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_AppendTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::AppendTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::FileIO::AppendTextAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_ReadBufferAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Storage::FileIO::ReadBufferAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_ReadLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Storage::FileIO::ReadLinesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::ReadLinesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_ReadTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Storage::FileIO::ReadTextAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::ReadTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_WriteBufferAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::WriteBufferAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_WriteBytesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::WriteBytesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_WriteLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::WriteLinesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::FileIO::WriteLinesAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_WriteTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::WriteTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::FileIO::WriteTextAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileIO[] = {
        { "append_lines_async", (PyCFunction)FileIO_AppendLinesAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "append_text_async", (PyCFunction)FileIO_AppendTextAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "read_buffer_async", (PyCFunction)FileIO_ReadBufferAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "read_lines_async", (PyCFunction)FileIO_ReadLinesAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "read_text_async", (PyCFunction)FileIO_ReadTextAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "write_buffer_async", (PyCFunction)FileIO_WriteBufferAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "write_bytes_async", (PyCFunction)FileIO_WriteBytesAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "write_lines_async", (PyCFunction)FileIO_WriteLinesAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "write_text_async", (PyCFunction)FileIO_WriteTextAsync, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FileIO[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_FileIO[] = 
    {
        { Py_tp_new, _new_FileIO },
        { Py_tp_methods, _methods_FileIO },
        { Py_tp_getset, _getset_FileIO },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FileIO =
    {
        "_winrt_Windows_Storage.FileIO",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileIO
    };

    // ----- KnownFolders class --------------------
    constexpr const char* const _type_name_KnownFolders = "KnownFolders";

    static PyObject* _new_KnownFolders(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KnownFolders);
        return nullptr;
    }

    static PyObject* KnownFolders_GetFolderAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::KnownFolderId>(args, 0);

                return py::convert(winrt::Windows::Storage::KnownFolders::GetFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownFolders_GetFolderForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::KnownFolderId>(args, 1);

                return py::convert(winrt::Windows::Storage::KnownFolders::GetFolderForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownFolders_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::KnownFolderId>(args, 0);

                return py::convert(winrt::Windows::Storage::KnownFolders::RequestAccessAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownFolders_RequestAccessForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::KnownFolderId>(args, 1);

                return py::convert(winrt::Windows::Storage::KnownFolders::RequestAccessForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_CameraRoll(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::CameraRoll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_Playlists(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::Playlists());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_SavedPictures(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::SavedPictures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_DocumentsLibrary(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::DocumentsLibrary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_HomeGroup(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::HomeGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_MediaServerDevices(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::MediaServerDevices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_MusicLibrary(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::MusicLibrary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_PicturesLibrary(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::PicturesLibrary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_RemovableDevices(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::RemovableDevices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_VideosLibrary(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::VideosLibrary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_AppCaptures(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::AppCaptures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_Objects3D(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::Objects3D());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_RecordedCalls(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::RecordedCalls());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownFolders[] = {
        { "get_folder_async", (PyCFunction)KnownFolders_GetFolderAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_folder_for_user_async", (PyCFunction)KnownFolders_GetFolderForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "request_access_async", (PyCFunction)KnownFolders_RequestAccessAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "request_access_for_user_async", (PyCFunction)KnownFolders_RequestAccessForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_camera_roll", (PyCFunction)KnownFolders_get_CameraRoll, METH_NOARGS | METH_STATIC, nullptr },
        { "get_playlists", (PyCFunction)KnownFolders_get_Playlists, METH_NOARGS | METH_STATIC, nullptr },
        { "get_saved_pictures", (PyCFunction)KnownFolders_get_SavedPictures, METH_NOARGS | METH_STATIC, nullptr },
        { "get_documents_library", (PyCFunction)KnownFolders_get_DocumentsLibrary, METH_NOARGS | METH_STATIC, nullptr },
        { "get_home_group", (PyCFunction)KnownFolders_get_HomeGroup, METH_NOARGS | METH_STATIC, nullptr },
        { "get_media_server_devices", (PyCFunction)KnownFolders_get_MediaServerDevices, METH_NOARGS | METH_STATIC, nullptr },
        { "get_music_library", (PyCFunction)KnownFolders_get_MusicLibrary, METH_NOARGS | METH_STATIC, nullptr },
        { "get_pictures_library", (PyCFunction)KnownFolders_get_PicturesLibrary, METH_NOARGS | METH_STATIC, nullptr },
        { "get_removable_devices", (PyCFunction)KnownFolders_get_RemovableDevices, METH_NOARGS | METH_STATIC, nullptr },
        { "get_videos_library", (PyCFunction)KnownFolders_get_VideosLibrary, METH_NOARGS | METH_STATIC, nullptr },
        { "get_app_captures", (PyCFunction)KnownFolders_get_AppCaptures, METH_NOARGS | METH_STATIC, nullptr },
        { "get_objects3_d", (PyCFunction)KnownFolders_get_Objects3D, METH_NOARGS | METH_STATIC, nullptr },
        { "get_recorded_calls", (PyCFunction)KnownFolders_get_RecordedCalls, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_KnownFolders[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_KnownFolders[] = 
    {
        { Py_tp_new, _new_KnownFolders },
        { Py_tp_methods, _methods_KnownFolders },
        { Py_tp_getset, _getset_KnownFolders },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_KnownFolders =
    {
        "_winrt_Windows_Storage.KnownFolders",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownFolders
    };

    // ----- PathIO class --------------------
    constexpr const char* const _type_name_PathIO = "PathIO";

    static PyObject* _new_PathIO(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PathIO);
        return nullptr;
    }

    static PyObject* PathIO_AppendLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::AppendLinesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::PathIO::AppendLinesAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_AppendTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::AppendTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::PathIO::AppendTextAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_ReadBufferAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::PathIO::ReadBufferAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_ReadLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::PathIO::ReadLinesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::ReadLinesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_ReadTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::PathIO::ReadTextAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::ReadTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_WriteBufferAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::WriteBufferAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_WriteBytesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::WriteBytesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_WriteLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::WriteLinesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::PathIO::WriteLinesAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_WriteTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::WriteTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::PathIO::WriteTextAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PathIO[] = {
        { "append_lines_async", (PyCFunction)PathIO_AppendLinesAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "append_text_async", (PyCFunction)PathIO_AppendTextAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "read_buffer_async", (PyCFunction)PathIO_ReadBufferAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "read_lines_async", (PyCFunction)PathIO_ReadLinesAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "read_text_async", (PyCFunction)PathIO_ReadTextAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "write_buffer_async", (PyCFunction)PathIO_WriteBufferAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "write_bytes_async", (PyCFunction)PathIO_WriteBytesAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "write_lines_async", (PyCFunction)PathIO_WriteLinesAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "write_text_async", (PyCFunction)PathIO_WriteTextAsync, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PathIO[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PathIO[] = 
    {
        { Py_tp_new, _new_PathIO },
        { Py_tp_methods, _methods_PathIO },
        { Py_tp_getset, _getset_PathIO },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PathIO =
    {
        "_winrt_Windows_Storage.PathIO",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PathIO
    };

    // ----- SetVersionDeferral class --------------------
    constexpr const char* const _type_name_SetVersionDeferral = "SetVersionDeferral";

    static PyObject* _new_SetVersionDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SetVersionDeferral);
        return nullptr;
    }

    static void _dealloc_SetVersionDeferral(py::wrapper::Windows::Storage::SetVersionDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SetVersionDeferral_Complete(py::wrapper::Windows::Storage::SetVersionDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_SetVersionDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SetVersionDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SetVersionDeferral[] = {
        { "complete", (PyCFunction)SetVersionDeferral_Complete, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_SetVersionDeferral, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SetVersionDeferral[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_SetVersionDeferral[] = 
    {
        { Py_tp_new, _new_SetVersionDeferral },
        { Py_tp_dealloc, _dealloc_SetVersionDeferral },
        { Py_tp_methods, _methods_SetVersionDeferral },
        { Py_tp_getset, _getset_SetVersionDeferral },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SetVersionDeferral =
    {
        "_winrt_Windows_Storage.SetVersionDeferral",
        sizeof(py::wrapper::Windows::Storage::SetVersionDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SetVersionDeferral
    };

    // ----- SetVersionRequest class --------------------
    constexpr const char* const _type_name_SetVersionRequest = "SetVersionRequest";

    static PyObject* _new_SetVersionRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SetVersionRequest);
        return nullptr;
    }

    static void _dealloc_SetVersionRequest(py::wrapper::Windows::Storage::SetVersionRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SetVersionRequest_GetDeferral(py::wrapper::Windows::Storage::SetVersionRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SetVersionRequest_get_CurrentVersion(py::wrapper::Windows::Storage::SetVersionRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SetVersionRequest_get_DesiredVersion(py::wrapper::Windows::Storage::SetVersionRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SetVersionRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SetVersionRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SetVersionRequest[] = {
        { "get_deferral", (PyCFunction)SetVersionRequest_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_SetVersionRequest, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SetVersionRequest[] = {
        { const_cast<char*>("current_version"), (getter)SetVersionRequest_get_CurrentVersion, nullptr, nullptr, nullptr },
        { const_cast<char*>("desired_version"), (getter)SetVersionRequest_get_DesiredVersion, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SetVersionRequest[] = 
    {
        { Py_tp_new, _new_SetVersionRequest },
        { Py_tp_dealloc, _dealloc_SetVersionRequest },
        { Py_tp_methods, _methods_SetVersionRequest },
        { Py_tp_getset, _getset_SetVersionRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SetVersionRequest =
    {
        "_winrt_Windows_Storage.SetVersionRequest",
        sizeof(py::wrapper::Windows::Storage::SetVersionRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SetVersionRequest
    };

    // ----- StorageFile class --------------------
    constexpr const char* const _type_name_StorageFile = "StorageFile";

    static PyObject* _new_StorageFile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageFile);
        return nullptr;
    }

    static void _dealloc_StorageFile(py::wrapper::Windows::Storage::StorageFile* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageFile_CopyAndReplaceAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.CopyAndReplaceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_CopyAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert(self->obj.CopyAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CopyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);

                return py::convert(self->obj.CopyAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_CreateStreamedFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StreamedFileDataRequestedHandler>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);

                return py::convert(winrt::Windows::Storage::StorageFile::CreateStreamedFileAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_CreateStreamedFileFromUriAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);

                return py::convert(winrt::Windows::Storage::StorageFile::CreateStreamedFileFromUriAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_DeleteAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetBasicPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetFileFromApplicationUriAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::Storage::StorageFile::GetFileFromApplicationUriAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetFileFromPathAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::StorageFile::GetFileFromPathAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetFileFromPathForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::StorageFile::GetFileFromPathForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetParentAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetParentAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetScaledImageAsThumbnailAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetThumbnailAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_IsEqual(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_IsOfType(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert(self->obj.IsOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_MoveAndReplaceAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.MoveAndReplaceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_MoveAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert(self->obj.MoveAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.MoveAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);

                return py::convert(self->obj.MoveAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_OpenAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);

                return py::convert(self->obj.OpenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 1);

                return py::convert(self->obj.OpenAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_OpenReadAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenReadAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_OpenSequentialReadAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenSequentialReadAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_OpenTransactedWriteAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenTransactedWriteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 0);

                return py::convert(self->obj.OpenTransactedWriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_RenameAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RenameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert(self->obj.RenameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_ReplaceWithStreamedFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StreamedFileDataRequestedHandler>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);

                return py::convert(winrt::Windows::Storage::StorageFile::ReplaceWithStreamedFileAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_ReplaceWithStreamedFileFromUriAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);

                return py::convert(winrt::Windows::Storage::StorageFile::ReplaceWithStreamedFileFromUriAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_ContentType(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_FileType(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_IsAvailable(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_Attributes(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_DateCreated(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DateCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_Name(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_Path(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_DisplayName(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_DisplayType(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_FolderRelativeId(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FolderRelativeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_Properties(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_Provider(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Provider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageFile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageFile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageFile[] = {
        { "copy_and_replace_async", (PyCFunction)StorageFile_CopyAndReplaceAsync, METH_VARARGS, nullptr },
        { "copy_async", (PyCFunction)StorageFile_CopyAsync, METH_VARARGS, nullptr },
        { "create_streamed_file_async", (PyCFunction)StorageFile_CreateStreamedFileAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "create_streamed_file_from_uri_async", (PyCFunction)StorageFile_CreateStreamedFileFromUriAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "delete_async", (PyCFunction)StorageFile_DeleteAsync, METH_VARARGS, nullptr },
        { "get_basic_properties_async", (PyCFunction)StorageFile_GetBasicPropertiesAsync, METH_VARARGS, nullptr },
        { "get_file_from_application_uri_async", (PyCFunction)StorageFile_GetFileFromApplicationUriAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_file_from_path_async", (PyCFunction)StorageFile_GetFileFromPathAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_file_from_path_for_user_async", (PyCFunction)StorageFile_GetFileFromPathForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_parent_async", (PyCFunction)StorageFile_GetParentAsync, METH_VARARGS, nullptr },
        { "get_scaled_image_as_thumbnail_async", (PyCFunction)StorageFile_GetScaledImageAsThumbnailAsync, METH_VARARGS, nullptr },
        { "get_thumbnail_async", (PyCFunction)StorageFile_GetThumbnailAsync, METH_VARARGS, nullptr },
        { "is_equal", (PyCFunction)StorageFile_IsEqual, METH_VARARGS, nullptr },
        { "is_of_type", (PyCFunction)StorageFile_IsOfType, METH_VARARGS, nullptr },
        { "move_and_replace_async", (PyCFunction)StorageFile_MoveAndReplaceAsync, METH_VARARGS, nullptr },
        { "move_async", (PyCFunction)StorageFile_MoveAsync, METH_VARARGS, nullptr },
        { "open_async", (PyCFunction)StorageFile_OpenAsync, METH_VARARGS, nullptr },
        { "open_read_async", (PyCFunction)StorageFile_OpenReadAsync, METH_VARARGS, nullptr },
        { "open_sequential_read_async", (PyCFunction)StorageFile_OpenSequentialReadAsync, METH_VARARGS, nullptr },
        { "open_transacted_write_async", (PyCFunction)StorageFile_OpenTransactedWriteAsync, METH_VARARGS, nullptr },
        { "rename_async", (PyCFunction)StorageFile_RenameAsync, METH_VARARGS, nullptr },
        { "replace_with_streamed_file_async", (PyCFunction)StorageFile_ReplaceWithStreamedFileAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "replace_with_streamed_file_from_uri_async", (PyCFunction)StorageFile_ReplaceWithStreamedFileFromUriAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_StorageFile, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageFile[] = {
        { const_cast<char*>("content_type"), (getter)StorageFile_get_ContentType, nullptr, nullptr, nullptr },
        { const_cast<char*>("file_type"), (getter)StorageFile_get_FileType, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_available"), (getter)StorageFile_get_IsAvailable, nullptr, nullptr, nullptr },
        { const_cast<char*>("attributes"), (getter)StorageFile_get_Attributes, nullptr, nullptr, nullptr },
        { const_cast<char*>("date_created"), (getter)StorageFile_get_DateCreated, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)StorageFile_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("path"), (getter)StorageFile_get_Path, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)StorageFile_get_DisplayName, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_type"), (getter)StorageFile_get_DisplayType, nullptr, nullptr, nullptr },
        { const_cast<char*>("folder_relative_id"), (getter)StorageFile_get_FolderRelativeId, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)StorageFile_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("provider"), (getter)StorageFile_get_Provider, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageFile[] = 
    {
        { Py_tp_new, _new_StorageFile },
        { Py_tp_dealloc, _dealloc_StorageFile },
        { Py_tp_methods, _methods_StorageFile },
        { Py_tp_getset, _getset_StorageFile },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageFile =
    {
        "_winrt_Windows_Storage.StorageFile",
        sizeof(py::wrapper::Windows::Storage::StorageFile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageFile
    };

    // ----- StorageFolder class --------------------
    constexpr const char* const _type_name_StorageFolder = "StorageFolder";

    static PyObject* _new_StorageFolder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageFolder);
        return nullptr;
    }

    static void _dealloc_StorageFolder(py::wrapper::Windows::Storage::StorageFolder* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageFolder_AreQueryOptionsSupported(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

                return py::convert(self->obj.AreQueryOptionsSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFileAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert(self->obj.CreateFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFileQuery(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateFileQuery());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);

                return py::convert(self->obj.CreateFileQuery(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFileQueryWithOptions(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

                return py::convert(self->obj.CreateFileQueryWithOptions(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFolderAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert(self->obj.CreateFolderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFolderQuery(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateFolderQuery());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);

                return py::convert(self->obj.CreateFolderQuery(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFolderQueryWithOptions(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

                return py::convert(self->obj.CreateFolderQueryWithOptions(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateItemQuery(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateItemQuery());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateItemQueryWithOptions(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

                return py::convert(self->obj.CreateItemQueryWithOptions(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_DeleteAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetBasicPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFileAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFilesAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetFilesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);

                return py::convert(self->obj.GetFilesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(self->obj.GetFilesAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFolderAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFolderFromPathAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::StorageFolder::GetFolderFromPathAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFolderFromPathForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::StorageFolder::GetFolderFromPathForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFoldersAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetFoldersAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);

                return py::convert(self->obj.GetFoldersAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(self->obj.GetFoldersAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetIndexedStateAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetIndexedStateAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetItemAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetItemAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetItemsAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetItemsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetItemsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetParentAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetParentAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetScaledImageAsThumbnailAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetThumbnailAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_IsCommonFileQuerySupported(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);

                return py::convert(self->obj.IsCommonFileQuerySupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_IsCommonFolderQuerySupported(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);

                return py::convert(self->obj.IsCommonFolderQuerySupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_IsEqual(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_IsOfType(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert(self->obj.IsOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_RenameAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RenameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert(self->obj.RenameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_TryGetChangeTracker(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryGetChangeTracker());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_TryGetItemAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryGetItemAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_Attributes(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_DateCreated(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DateCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_Name(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_Path(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_DisplayName(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_DisplayType(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_FolderRelativeId(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FolderRelativeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_Properties(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_Provider(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Provider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageFolder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageFolder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageFolder[] = {
        { "are_query_options_supported", (PyCFunction)StorageFolder_AreQueryOptionsSupported, METH_VARARGS, nullptr },
        { "create_file_async", (PyCFunction)StorageFolder_CreateFileAsync, METH_VARARGS, nullptr },
        { "create_file_query", (PyCFunction)StorageFolder_CreateFileQuery, METH_VARARGS, nullptr },
        { "create_file_query_with_options", (PyCFunction)StorageFolder_CreateFileQueryWithOptions, METH_VARARGS, nullptr },
        { "create_folder_async", (PyCFunction)StorageFolder_CreateFolderAsync, METH_VARARGS, nullptr },
        { "create_folder_query", (PyCFunction)StorageFolder_CreateFolderQuery, METH_VARARGS, nullptr },
        { "create_folder_query_with_options", (PyCFunction)StorageFolder_CreateFolderQueryWithOptions, METH_VARARGS, nullptr },
        { "create_item_query", (PyCFunction)StorageFolder_CreateItemQuery, METH_VARARGS, nullptr },
        { "create_item_query_with_options", (PyCFunction)StorageFolder_CreateItemQueryWithOptions, METH_VARARGS, nullptr },
        { "delete_async", (PyCFunction)StorageFolder_DeleteAsync, METH_VARARGS, nullptr },
        { "get_basic_properties_async", (PyCFunction)StorageFolder_GetBasicPropertiesAsync, METH_VARARGS, nullptr },
        { "get_file_async", (PyCFunction)StorageFolder_GetFileAsync, METH_VARARGS, nullptr },
        { "get_files_async", (PyCFunction)StorageFolder_GetFilesAsync, METH_VARARGS, nullptr },
        { "get_folder_async", (PyCFunction)StorageFolder_GetFolderAsync, METH_VARARGS, nullptr },
        { "get_folder_from_path_async", (PyCFunction)StorageFolder_GetFolderFromPathAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_folder_from_path_for_user_async", (PyCFunction)StorageFolder_GetFolderFromPathForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_folders_async", (PyCFunction)StorageFolder_GetFoldersAsync, METH_VARARGS, nullptr },
        { "get_indexed_state_async", (PyCFunction)StorageFolder_GetIndexedStateAsync, METH_VARARGS, nullptr },
        { "get_item_async", (PyCFunction)StorageFolder_GetItemAsync, METH_VARARGS, nullptr },
        { "get_items_async", (PyCFunction)StorageFolder_GetItemsAsync, METH_VARARGS, nullptr },
        { "get_parent_async", (PyCFunction)StorageFolder_GetParentAsync, METH_VARARGS, nullptr },
        { "get_scaled_image_as_thumbnail_async", (PyCFunction)StorageFolder_GetScaledImageAsThumbnailAsync, METH_VARARGS, nullptr },
        { "get_thumbnail_async", (PyCFunction)StorageFolder_GetThumbnailAsync, METH_VARARGS, nullptr },
        { "is_common_file_query_supported", (PyCFunction)StorageFolder_IsCommonFileQuerySupported, METH_VARARGS, nullptr },
        { "is_common_folder_query_supported", (PyCFunction)StorageFolder_IsCommonFolderQuerySupported, METH_VARARGS, nullptr },
        { "is_equal", (PyCFunction)StorageFolder_IsEqual, METH_VARARGS, nullptr },
        { "is_of_type", (PyCFunction)StorageFolder_IsOfType, METH_VARARGS, nullptr },
        { "rename_async", (PyCFunction)StorageFolder_RenameAsync, METH_VARARGS, nullptr },
        { "try_get_change_tracker", (PyCFunction)StorageFolder_TryGetChangeTracker, METH_VARARGS, nullptr },
        { "try_get_item_async", (PyCFunction)StorageFolder_TryGetItemAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_StorageFolder, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageFolder[] = {
        { const_cast<char*>("attributes"), (getter)StorageFolder_get_Attributes, nullptr, nullptr, nullptr },
        { const_cast<char*>("date_created"), (getter)StorageFolder_get_DateCreated, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)StorageFolder_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("path"), (getter)StorageFolder_get_Path, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)StorageFolder_get_DisplayName, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_type"), (getter)StorageFolder_get_DisplayType, nullptr, nullptr, nullptr },
        { const_cast<char*>("folder_relative_id"), (getter)StorageFolder_get_FolderRelativeId, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)StorageFolder_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("provider"), (getter)StorageFolder_get_Provider, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageFolder[] = 
    {
        { Py_tp_new, _new_StorageFolder },
        { Py_tp_dealloc, _dealloc_StorageFolder },
        { Py_tp_methods, _methods_StorageFolder },
        { Py_tp_getset, _getset_StorageFolder },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageFolder =
    {
        "_winrt_Windows_Storage.StorageFolder",
        sizeof(py::wrapper::Windows::Storage::StorageFolder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageFolder
    };

    // ----- StorageLibrary class --------------------
    constexpr const char* const _type_name_StorageLibrary = "StorageLibrary";

    static PyObject* _new_StorageLibrary(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageLibrary);
        return nullptr;
    }

    static void _dealloc_StorageLibrary(py::wrapper::Windows::Storage::StorageLibrary* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageLibrary_AreFolderSuggestionsAvailableAsync(py::wrapper::Windows::Storage::StorageLibrary* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.AreFolderSuggestionsAvailableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_GetLibraryAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::KnownLibraryId>(args, 0);

                return py::convert(winrt::Windows::Storage::StorageLibrary::GetLibraryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_GetLibraryForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::KnownLibraryId>(args, 1);

                return py::convert(winrt::Windows::Storage::StorageLibrary::GetLibraryForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_RequestAddFolderAsync(py::wrapper::Windows::Storage::StorageLibrary* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestAddFolderAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_RequestRemoveFolderAsync(py::wrapper::Windows::Storage::StorageLibrary* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFolder>(args, 0);

                return py::convert(self->obj.RequestRemoveFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_get_Folders(py::wrapper::Windows::Storage::StorageLibrary* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Folders());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_get_SaveFolder(py::wrapper::Windows::Storage::StorageLibrary* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SaveFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_get_ChangeTracker(py::wrapper::Windows::Storage::StorageLibrary* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeTracker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_add_DefinitionChanged(py::wrapper::Windows::Storage::StorageLibrary* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::StorageLibrary, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.DefinitionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_remove_DefinitionChanged(py::wrapper::Windows::Storage::StorageLibrary* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DefinitionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageLibrary(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibrary>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibrary[] = {
        { "are_folder_suggestions_available_async", (PyCFunction)StorageLibrary_AreFolderSuggestionsAvailableAsync, METH_VARARGS, nullptr },
        { "get_library_async", (PyCFunction)StorageLibrary_GetLibraryAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_library_for_user_async", (PyCFunction)StorageLibrary_GetLibraryForUserAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "request_add_folder_async", (PyCFunction)StorageLibrary_RequestAddFolderAsync, METH_VARARGS, nullptr },
        { "request_remove_folder_async", (PyCFunction)StorageLibrary_RequestRemoveFolderAsync, METH_VARARGS, nullptr },
        { "add_definition_changed", (PyCFunction)StorageLibrary_add_DefinitionChanged, METH_O, nullptr },
        { "remove_definition_changed", (PyCFunction)StorageLibrary_remove_DefinitionChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_StorageLibrary, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageLibrary[] = {
        { const_cast<char*>("folders"), (getter)StorageLibrary_get_Folders, nullptr, nullptr, nullptr },
        { const_cast<char*>("save_folder"), (getter)StorageLibrary_get_SaveFolder, nullptr, nullptr, nullptr },
        { const_cast<char*>("change_tracker"), (getter)StorageLibrary_get_ChangeTracker, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageLibrary[] = 
    {
        { Py_tp_new, _new_StorageLibrary },
        { Py_tp_dealloc, _dealloc_StorageLibrary },
        { Py_tp_methods, _methods_StorageLibrary },
        { Py_tp_getset, _getset_StorageLibrary },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageLibrary =
    {
        "_winrt_Windows_Storage.StorageLibrary",
        sizeof(py::wrapper::Windows::Storage::StorageLibrary),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibrary
    };

    // ----- StorageLibraryChange class --------------------
    constexpr const char* const _type_name_StorageLibraryChange = "StorageLibraryChange";

    static PyObject* _new_StorageLibraryChange(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageLibraryChange);
        return nullptr;
    }

    static void _dealloc_StorageLibraryChange(py::wrapper::Windows::Storage::StorageLibraryChange* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageLibraryChange_GetStorageItemAsync(py::wrapper::Windows::Storage::StorageLibraryChange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetStorageItemAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChange_IsOfType(py::wrapper::Windows::Storage::StorageLibraryChange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert(self->obj.IsOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChange_get_ChangeType(py::wrapper::Windows::Storage::StorageLibraryChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChange_get_Path(py::wrapper::Windows::Storage::StorageLibraryChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChange_get_PreviousPath(py::wrapper::Windows::Storage::StorageLibraryChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageLibraryChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibraryChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryChange[] = {
        { "get_storage_item_async", (PyCFunction)StorageLibraryChange_GetStorageItemAsync, METH_VARARGS, nullptr },
        { "is_of_type", (PyCFunction)StorageLibraryChange_IsOfType, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_StorageLibraryChange, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageLibraryChange[] = {
        { const_cast<char*>("change_type"), (getter)StorageLibraryChange_get_ChangeType, nullptr, nullptr, nullptr },
        { const_cast<char*>("path"), (getter)StorageLibraryChange_get_Path, nullptr, nullptr, nullptr },
        { const_cast<char*>("previous_path"), (getter)StorageLibraryChange_get_PreviousPath, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageLibraryChange[] = 
    {
        { Py_tp_new, _new_StorageLibraryChange },
        { Py_tp_dealloc, _dealloc_StorageLibraryChange },
        { Py_tp_methods, _methods_StorageLibraryChange },
        { Py_tp_getset, _getset_StorageLibraryChange },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageLibraryChange =
    {
        "_winrt_Windows_Storage.StorageLibraryChange",
        sizeof(py::wrapper::Windows::Storage::StorageLibraryChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryChange
    };

    // ----- StorageLibraryChangeReader class --------------------
    constexpr const char* const _type_name_StorageLibraryChangeReader = "StorageLibraryChangeReader";

    static PyObject* _new_StorageLibraryChangeReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageLibraryChangeReader);
        return nullptr;
    }

    static void _dealloc_StorageLibraryChangeReader(py::wrapper::Windows::Storage::StorageLibraryChangeReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageLibraryChangeReader_AcceptChangesAsync(py::wrapper::Windows::Storage::StorageLibraryChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.AcceptChangesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChangeReader_GetLastChangeId(py::wrapper::Windows::Storage::StorageLibraryChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetLastChangeId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChangeReader_ReadBatchAsync(py::wrapper::Windows::Storage::StorageLibraryChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_StorageLibraryChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibraryChangeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryChangeReader[] = {
        { "accept_changes_async", (PyCFunction)StorageLibraryChangeReader_AcceptChangesAsync, METH_VARARGS, nullptr },
        { "get_last_change_id", (PyCFunction)StorageLibraryChangeReader_GetLastChangeId, METH_VARARGS, nullptr },
        { "read_batch_async", (PyCFunction)StorageLibraryChangeReader_ReadBatchAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_StorageLibraryChangeReader, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageLibraryChangeReader[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageLibraryChangeReader[] = 
    {
        { Py_tp_new, _new_StorageLibraryChangeReader },
        { Py_tp_dealloc, _dealloc_StorageLibraryChangeReader },
        { Py_tp_methods, _methods_StorageLibraryChangeReader },
        { Py_tp_getset, _getset_StorageLibraryChangeReader },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageLibraryChangeReader =
    {
        "_winrt_Windows_Storage.StorageLibraryChangeReader",
        sizeof(py::wrapper::Windows::Storage::StorageLibraryChangeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryChangeReader
    };

    // ----- StorageLibraryChangeTracker class --------------------
    constexpr const char* const _type_name_StorageLibraryChangeTracker = "StorageLibraryChangeTracker";

    static PyObject* _new_StorageLibraryChangeTracker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageLibraryChangeTracker);
        return nullptr;
    }

    static void _dealloc_StorageLibraryChangeTracker(py::wrapper::Windows::Storage::StorageLibraryChangeTracker* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageLibraryChangeTracker_Disable(py::wrapper::Windows::Storage::StorageLibraryChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Disable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChangeTracker_Enable(py::wrapper::Windows::Storage::StorageLibraryChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Enable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageLibraryChangeTrackerOptions>(args, 0);

                self->obj.Enable(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChangeTracker_GetChangeReader(py::wrapper::Windows::Storage::StorageLibraryChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetChangeReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChangeTracker_Reset(py::wrapper::Windows::Storage::StorageLibraryChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_StorageLibraryChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibraryChangeTracker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryChangeTracker[] = {
        { "disable", (PyCFunction)StorageLibraryChangeTracker_Disable, METH_VARARGS, nullptr },
        { "enable", (PyCFunction)StorageLibraryChangeTracker_Enable, METH_VARARGS, nullptr },
        { "get_change_reader", (PyCFunction)StorageLibraryChangeTracker_GetChangeReader, METH_VARARGS, nullptr },
        { "reset", (PyCFunction)StorageLibraryChangeTracker_Reset, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_StorageLibraryChangeTracker, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageLibraryChangeTracker[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageLibraryChangeTracker[] = 
    {
        { Py_tp_new, _new_StorageLibraryChangeTracker },
        { Py_tp_dealloc, _dealloc_StorageLibraryChangeTracker },
        { Py_tp_methods, _methods_StorageLibraryChangeTracker },
        { Py_tp_getset, _getset_StorageLibraryChangeTracker },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageLibraryChangeTracker =
    {
        "_winrt_Windows_Storage.StorageLibraryChangeTracker",
        sizeof(py::wrapper::Windows::Storage::StorageLibraryChangeTracker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryChangeTracker
    };

    // ----- StorageLibraryChangeTrackerOptions class --------------------
    constexpr const char* const _type_name_StorageLibraryChangeTrackerOptions = "StorageLibraryChangeTrackerOptions";

    static PyObject* _new_StorageLibraryChangeTrackerOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::StorageLibraryChangeTrackerOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageLibraryChangeTrackerOptions(py::wrapper::Windows::Storage::StorageLibraryChangeTrackerOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageLibraryChangeTrackerOptions_get_TrackChangeDetails(py::wrapper::Windows::Storage::StorageLibraryChangeTrackerOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrackChangeDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageLibraryChangeTrackerOptions_put_TrackChangeDetails(py::wrapper::Windows::Storage::StorageLibraryChangeTrackerOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.TrackChangeDetails(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StorageLibraryChangeTrackerOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibraryChangeTrackerOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryChangeTrackerOptions[] = {
        { "_from", (PyCFunction)_from_StorageLibraryChangeTrackerOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageLibraryChangeTrackerOptions[] = {
        { const_cast<char*>("track_change_details"), (getter)StorageLibraryChangeTrackerOptions_get_TrackChangeDetails, (setter)StorageLibraryChangeTrackerOptions_put_TrackChangeDetails, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageLibraryChangeTrackerOptions[] = 
    {
        { Py_tp_new, _new_StorageLibraryChangeTrackerOptions },
        { Py_tp_dealloc, _dealloc_StorageLibraryChangeTrackerOptions },
        { Py_tp_methods, _methods_StorageLibraryChangeTrackerOptions },
        { Py_tp_getset, _getset_StorageLibraryChangeTrackerOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageLibraryChangeTrackerOptions =
    {
        "_winrt_Windows_Storage.StorageLibraryChangeTrackerOptions",
        sizeof(py::wrapper::Windows::Storage::StorageLibraryChangeTrackerOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryChangeTrackerOptions
    };

    // ----- StorageLibraryLastChangeId class --------------------
    constexpr const char* const _type_name_StorageLibraryLastChangeId = "StorageLibraryLastChangeId";

    static PyObject* _new_StorageLibraryLastChangeId(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageLibraryLastChangeId);
        return nullptr;
    }

    static void _dealloc_StorageLibraryLastChangeId(py::wrapper::Windows::Storage::StorageLibraryLastChangeId* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageLibraryLastChangeId_get_Unknown(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::StorageLibraryLastChangeId::Unknown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageLibraryLastChangeId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibraryLastChangeId>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryLastChangeId[] = {
        { "get_unknown", (PyCFunction)StorageLibraryLastChangeId_get_Unknown, METH_NOARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_StorageLibraryLastChangeId, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageLibraryLastChangeId[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageLibraryLastChangeId[] = 
    {
        { Py_tp_new, _new_StorageLibraryLastChangeId },
        { Py_tp_dealloc, _dealloc_StorageLibraryLastChangeId },
        { Py_tp_methods, _methods_StorageLibraryLastChangeId },
        { Py_tp_getset, _getset_StorageLibraryLastChangeId },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageLibraryLastChangeId =
    {
        "_winrt_Windows_Storage.StorageLibraryLastChangeId",
        sizeof(py::wrapper::Windows::Storage::StorageLibraryLastChangeId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryLastChangeId
    };

    // ----- StorageProvider class --------------------
    constexpr const char* const _type_name_StorageProvider = "StorageProvider";

    static PyObject* _new_StorageProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageProvider);
        return nullptr;
    }

    static void _dealloc_StorageProvider(py::wrapper::Windows::Storage::StorageProvider* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageProvider_IsPropertySupportedForPartialFileAsync(py::wrapper::Windows::Storage::StorageProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsPropertySupportedForPartialFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProvider_get_DisplayName(py::wrapper::Windows::Storage::StorageProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProvider_get_Id(py::wrapper::Windows::Storage::StorageProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProvider[] = {
        { "is_property_supported_for_partial_file_async", (PyCFunction)StorageProvider_IsPropertySupportedForPartialFileAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_StorageProvider, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageProvider[] = {
        { const_cast<char*>("display_name"), (getter)StorageProvider_get_DisplayName, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)StorageProvider_get_Id, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageProvider[] = 
    {
        { Py_tp_new, _new_StorageProvider },
        { Py_tp_dealloc, _dealloc_StorageProvider },
        { Py_tp_methods, _methods_StorageProvider },
        { Py_tp_getset, _getset_StorageProvider },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProvider =
    {
        "_winrt_Windows_Storage.StorageProvider",
        sizeof(py::wrapper::Windows::Storage::StorageProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProvider
    };

    // ----- StorageStreamTransaction class --------------------
    constexpr const char* const _type_name_StorageStreamTransaction = "StorageStreamTransaction";

    static PyObject* _new_StorageStreamTransaction(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageStreamTransaction);
        return nullptr;
    }

    static void _dealloc_StorageStreamTransaction(py::wrapper::Windows::Storage::StorageStreamTransaction* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageStreamTransaction_Close(py::wrapper::Windows::Storage::StorageStreamTransaction* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageStreamTransaction_CommitAsync(py::wrapper::Windows::Storage::StorageStreamTransaction* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CommitAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageStreamTransaction_get_Stream(py::wrapper::Windows::Storage::StorageStreamTransaction* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Stream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageStreamTransaction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageStreamTransaction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StorageStreamTransaction(py::wrapper::Windows::Storage::StorageStreamTransaction* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_StorageStreamTransaction(py::wrapper::Windows::Storage::StorageStreamTransaction* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageStreamTransaction[] = {
        { "close", (PyCFunction)StorageStreamTransaction_Close, METH_VARARGS, nullptr },
        { "commit_async", (PyCFunction)StorageStreamTransaction_CommitAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_StorageStreamTransaction, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_StorageStreamTransaction, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_StorageStreamTransaction, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageStreamTransaction[] = {
        { const_cast<char*>("stream"), (getter)StorageStreamTransaction_get_Stream, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageStreamTransaction[] = 
    {
        { Py_tp_new, _new_StorageStreamTransaction },
        { Py_tp_dealloc, _dealloc_StorageStreamTransaction },
        { Py_tp_methods, _methods_StorageStreamTransaction },
        { Py_tp_getset, _getset_StorageStreamTransaction },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageStreamTransaction =
    {
        "_winrt_Windows_Storage.StorageStreamTransaction",
        sizeof(py::wrapper::Windows::Storage::StorageStreamTransaction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageStreamTransaction
    };

    // ----- StreamedFileDataRequest class --------------------
    constexpr const char* const _type_name_StreamedFileDataRequest = "StreamedFileDataRequest";

    static PyObject* _new_StreamedFileDataRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StreamedFileDataRequest);
        return nullptr;
    }

    static void _dealloc_StreamedFileDataRequest(py::wrapper::Windows::Storage::StreamedFileDataRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamedFileDataRequest_Close(py::wrapper::Windows::Storage::StreamedFileDataRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamedFileDataRequest_FailAndClose(py::wrapper::Windows::Storage::StreamedFileDataRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StreamedFileFailureMode>(args, 0);

                self->obj.FailAndClose(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamedFileDataRequest_FlushAsync(py::wrapper::Windows::Storage::StreamedFileDataRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamedFileDataRequest_WriteAsync(py::wrapper::Windows::Storage::StreamedFileDataRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_StreamedFileDataRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StreamedFileDataRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StreamedFileDataRequest(py::wrapper::Windows::Storage::StreamedFileDataRequest* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_StreamedFileDataRequest(py::wrapper::Windows::Storage::StreamedFileDataRequest* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamedFileDataRequest[] = {
        { "close", (PyCFunction)StreamedFileDataRequest_Close, METH_VARARGS, nullptr },
        { "fail_and_close", (PyCFunction)StreamedFileDataRequest_FailAndClose, METH_VARARGS, nullptr },
        { "flush_async", (PyCFunction)StreamedFileDataRequest_FlushAsync, METH_VARARGS, nullptr },
        { "write_async", (PyCFunction)StreamedFileDataRequest_WriteAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_StreamedFileDataRequest, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_StreamedFileDataRequest, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_StreamedFileDataRequest, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StreamedFileDataRequest[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_StreamedFileDataRequest[] = 
    {
        { Py_tp_new, _new_StreamedFileDataRequest },
        { Py_tp_dealloc, _dealloc_StreamedFileDataRequest },
        { Py_tp_methods, _methods_StreamedFileDataRequest },
        { Py_tp_getset, _getset_StreamedFileDataRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StreamedFileDataRequest =
    {
        "_winrt_Windows_Storage.StreamedFileDataRequest",
        sizeof(py::wrapper::Windows::Storage::StreamedFileDataRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamedFileDataRequest
    };

    // ----- SystemAudioProperties class --------------------
    constexpr const char* const _type_name_SystemAudioProperties = "SystemAudioProperties";

    static PyObject* _new_SystemAudioProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemAudioProperties);
        return nullptr;
    }

    static void _dealloc_SystemAudioProperties(py::wrapper::Windows::Storage::SystemAudioProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemAudioProperties_get_EncodingBitrate(py::wrapper::Windows::Storage::SystemAudioProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemAudioProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemAudioProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemAudioProperties[] = {
        { "_from", (PyCFunction)_from_SystemAudioProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemAudioProperties[] = {
        { const_cast<char*>("encoding_bitrate"), (getter)SystemAudioProperties_get_EncodingBitrate, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemAudioProperties[] = 
    {
        { Py_tp_new, _new_SystemAudioProperties },
        { Py_tp_dealloc, _dealloc_SystemAudioProperties },
        { Py_tp_methods, _methods_SystemAudioProperties },
        { Py_tp_getset, _getset_SystemAudioProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemAudioProperties =
    {
        "_winrt_Windows_Storage.SystemAudioProperties",
        sizeof(py::wrapper::Windows::Storage::SystemAudioProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemAudioProperties
    };

    // ----- SystemDataPaths class --------------------
    constexpr const char* const _type_name_SystemDataPaths = "SystemDataPaths";

    static PyObject* _new_SystemDataPaths(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemDataPaths);
        return nullptr;
    }

    static void _dealloc_SystemDataPaths(py::wrapper::Windows::Storage::SystemDataPaths* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemDataPaths_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Storage::SystemDataPaths::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_Fonts(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Fonts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_ProgramData(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProgramData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_Public(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Public());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicDesktop(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PublicDesktop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicDocuments(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PublicDocuments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicDownloads(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PublicDownloads());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicMusic(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PublicMusic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicPictures(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PublicPictures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicVideos(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PublicVideos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_System(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.System());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_SystemArm(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemArm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_SystemHost(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemHost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_SystemX64(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemX64());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_SystemX86(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemX86());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_UserProfiles(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_Windows(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Windows());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemDataPaths(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemDataPaths>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemDataPaths[] = {
        { "get_default", (PyCFunction)SystemDataPaths_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_SystemDataPaths, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemDataPaths[] = {
        { const_cast<char*>("fonts"), (getter)SystemDataPaths_get_Fonts, nullptr, nullptr, nullptr },
        { const_cast<char*>("program_data"), (getter)SystemDataPaths_get_ProgramData, nullptr, nullptr, nullptr },
        { const_cast<char*>("public"), (getter)SystemDataPaths_get_Public, nullptr, nullptr, nullptr },
        { const_cast<char*>("public_desktop"), (getter)SystemDataPaths_get_PublicDesktop, nullptr, nullptr, nullptr },
        { const_cast<char*>("public_documents"), (getter)SystemDataPaths_get_PublicDocuments, nullptr, nullptr, nullptr },
        { const_cast<char*>("public_downloads"), (getter)SystemDataPaths_get_PublicDownloads, nullptr, nullptr, nullptr },
        { const_cast<char*>("public_music"), (getter)SystemDataPaths_get_PublicMusic, nullptr, nullptr, nullptr },
        { const_cast<char*>("public_pictures"), (getter)SystemDataPaths_get_PublicPictures, nullptr, nullptr, nullptr },
        { const_cast<char*>("public_videos"), (getter)SystemDataPaths_get_PublicVideos, nullptr, nullptr, nullptr },
        { const_cast<char*>("system"), (getter)SystemDataPaths_get_System, nullptr, nullptr, nullptr },
        { const_cast<char*>("system_arm"), (getter)SystemDataPaths_get_SystemArm, nullptr, nullptr, nullptr },
        { const_cast<char*>("system_host"), (getter)SystemDataPaths_get_SystemHost, nullptr, nullptr, nullptr },
        { const_cast<char*>("system_x64"), (getter)SystemDataPaths_get_SystemX64, nullptr, nullptr, nullptr },
        { const_cast<char*>("system_x86"), (getter)SystemDataPaths_get_SystemX86, nullptr, nullptr, nullptr },
        { const_cast<char*>("user_profiles"), (getter)SystemDataPaths_get_UserProfiles, nullptr, nullptr, nullptr },
        { const_cast<char*>("windows"), (getter)SystemDataPaths_get_Windows, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemDataPaths[] = 
    {
        { Py_tp_new, _new_SystemDataPaths },
        { Py_tp_dealloc, _dealloc_SystemDataPaths },
        { Py_tp_methods, _methods_SystemDataPaths },
        { Py_tp_getset, _getset_SystemDataPaths },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemDataPaths =
    {
        "_winrt_Windows_Storage.SystemDataPaths",
        sizeof(py::wrapper::Windows::Storage::SystemDataPaths),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemDataPaths
    };

    // ----- SystemGPSProperties class --------------------
    constexpr const char* const _type_name_SystemGPSProperties = "SystemGPSProperties";

    static PyObject* _new_SystemGPSProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemGPSProperties);
        return nullptr;
    }

    static void _dealloc_SystemGPSProperties(py::wrapper::Windows::Storage::SystemGPSProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemGPSProperties_get_LatitudeDecimal(py::wrapper::Windows::Storage::SystemGPSProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LatitudeDecimal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemGPSProperties_get_LongitudeDecimal(py::wrapper::Windows::Storage::SystemGPSProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LongitudeDecimal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemGPSProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemGPSProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemGPSProperties[] = {
        { "_from", (PyCFunction)_from_SystemGPSProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemGPSProperties[] = {
        { const_cast<char*>("latitude_decimal"), (getter)SystemGPSProperties_get_LatitudeDecimal, nullptr, nullptr, nullptr },
        { const_cast<char*>("longitude_decimal"), (getter)SystemGPSProperties_get_LongitudeDecimal, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemGPSProperties[] = 
    {
        { Py_tp_new, _new_SystemGPSProperties },
        { Py_tp_dealloc, _dealloc_SystemGPSProperties },
        { Py_tp_methods, _methods_SystemGPSProperties },
        { Py_tp_getset, _getset_SystemGPSProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemGPSProperties =
    {
        "_winrt_Windows_Storage.SystemGPSProperties",
        sizeof(py::wrapper::Windows::Storage::SystemGPSProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemGPSProperties
    };

    // ----- SystemImageProperties class --------------------
    constexpr const char* const _type_name_SystemImageProperties = "SystemImageProperties";

    static PyObject* _new_SystemImageProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemImageProperties);
        return nullptr;
    }

    static void _dealloc_SystemImageProperties(py::wrapper::Windows::Storage::SystemImageProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemImageProperties_get_HorizontalSize(py::wrapper::Windows::Storage::SystemImageProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HorizontalSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemImageProperties_get_VerticalSize(py::wrapper::Windows::Storage::SystemImageProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VerticalSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemImageProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemImageProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemImageProperties[] = {
        { "_from", (PyCFunction)_from_SystemImageProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemImageProperties[] = {
        { const_cast<char*>("horizontal_size"), (getter)SystemImageProperties_get_HorizontalSize, nullptr, nullptr, nullptr },
        { const_cast<char*>("vertical_size"), (getter)SystemImageProperties_get_VerticalSize, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemImageProperties[] = 
    {
        { Py_tp_new, _new_SystemImageProperties },
        { Py_tp_dealloc, _dealloc_SystemImageProperties },
        { Py_tp_methods, _methods_SystemImageProperties },
        { Py_tp_getset, _getset_SystemImageProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemImageProperties =
    {
        "_winrt_Windows_Storage.SystemImageProperties",
        sizeof(py::wrapper::Windows::Storage::SystemImageProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemImageProperties
    };

    // ----- SystemMediaProperties class --------------------
    constexpr const char* const _type_name_SystemMediaProperties = "SystemMediaProperties";

    static PyObject* _new_SystemMediaProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemMediaProperties);
        return nullptr;
    }

    static void _dealloc_SystemMediaProperties(py::wrapper::Windows::Storage::SystemMediaProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemMediaProperties_get_Duration(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaProperties_get_Producer(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Producer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaProperties_get_Publisher(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Publisher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaProperties_get_SubTitle(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SubTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaProperties_get_Writer(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Writer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaProperties_get_Year(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Year());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemMediaProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemMediaProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMediaProperties[] = {
        { "_from", (PyCFunction)_from_SystemMediaProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemMediaProperties[] = {
        { const_cast<char*>("duration"), (getter)SystemMediaProperties_get_Duration, nullptr, nullptr, nullptr },
        { const_cast<char*>("producer"), (getter)SystemMediaProperties_get_Producer, nullptr, nullptr, nullptr },
        { const_cast<char*>("publisher"), (getter)SystemMediaProperties_get_Publisher, nullptr, nullptr, nullptr },
        { const_cast<char*>("sub_title"), (getter)SystemMediaProperties_get_SubTitle, nullptr, nullptr, nullptr },
        { const_cast<char*>("writer"), (getter)SystemMediaProperties_get_Writer, nullptr, nullptr, nullptr },
        { const_cast<char*>("year"), (getter)SystemMediaProperties_get_Year, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemMediaProperties[] = 
    {
        { Py_tp_new, _new_SystemMediaProperties },
        { Py_tp_dealloc, _dealloc_SystemMediaProperties },
        { Py_tp_methods, _methods_SystemMediaProperties },
        { Py_tp_getset, _getset_SystemMediaProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemMediaProperties =
    {
        "_winrt_Windows_Storage.SystemMediaProperties",
        sizeof(py::wrapper::Windows::Storage::SystemMediaProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMediaProperties
    };

    // ----- SystemMusicProperties class --------------------
    constexpr const char* const _type_name_SystemMusicProperties = "SystemMusicProperties";

    static PyObject* _new_SystemMusicProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemMusicProperties);
        return nullptr;
    }

    static void _dealloc_SystemMusicProperties(py::wrapper::Windows::Storage::SystemMusicProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemMusicProperties_get_AlbumArtist(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlbumArtist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_AlbumTitle(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlbumTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_Artist(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Artist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_Composer(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Composer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_Conductor(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Conductor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_DisplayArtist(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayArtist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_Genre(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Genre());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_TrackNumber(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrackNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemMusicProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemMusicProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMusicProperties[] = {
        { "_from", (PyCFunction)_from_SystemMusicProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemMusicProperties[] = {
        { const_cast<char*>("album_artist"), (getter)SystemMusicProperties_get_AlbumArtist, nullptr, nullptr, nullptr },
        { const_cast<char*>("album_title"), (getter)SystemMusicProperties_get_AlbumTitle, nullptr, nullptr, nullptr },
        { const_cast<char*>("artist"), (getter)SystemMusicProperties_get_Artist, nullptr, nullptr, nullptr },
        { const_cast<char*>("composer"), (getter)SystemMusicProperties_get_Composer, nullptr, nullptr, nullptr },
        { const_cast<char*>("conductor"), (getter)SystemMusicProperties_get_Conductor, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_artist"), (getter)SystemMusicProperties_get_DisplayArtist, nullptr, nullptr, nullptr },
        { const_cast<char*>("genre"), (getter)SystemMusicProperties_get_Genre, nullptr, nullptr, nullptr },
        { const_cast<char*>("track_number"), (getter)SystemMusicProperties_get_TrackNumber, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemMusicProperties[] = 
    {
        { Py_tp_new, _new_SystemMusicProperties },
        { Py_tp_dealloc, _dealloc_SystemMusicProperties },
        { Py_tp_methods, _methods_SystemMusicProperties },
        { Py_tp_getset, _getset_SystemMusicProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemMusicProperties =
    {
        "_winrt_Windows_Storage.SystemMusicProperties",
        sizeof(py::wrapper::Windows::Storage::SystemMusicProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMusicProperties
    };

    // ----- SystemPhotoProperties class --------------------
    constexpr const char* const _type_name_SystemPhotoProperties = "SystemPhotoProperties";

    static PyObject* _new_SystemPhotoProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemPhotoProperties);
        return nullptr;
    }

    static void _dealloc_SystemPhotoProperties(py::wrapper::Windows::Storage::SystemPhotoProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemPhotoProperties_get_CameraManufacturer(py::wrapper::Windows::Storage::SystemPhotoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CameraManufacturer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemPhotoProperties_get_CameraModel(py::wrapper::Windows::Storage::SystemPhotoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CameraModel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemPhotoProperties_get_DateTaken(py::wrapper::Windows::Storage::SystemPhotoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DateTaken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemPhotoProperties_get_Orientation(py::wrapper::Windows::Storage::SystemPhotoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemPhotoProperties_get_PeopleNames(py::wrapper::Windows::Storage::SystemPhotoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PeopleNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemPhotoProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemPhotoProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemPhotoProperties[] = {
        { "_from", (PyCFunction)_from_SystemPhotoProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemPhotoProperties[] = {
        { const_cast<char*>("camera_manufacturer"), (getter)SystemPhotoProperties_get_CameraManufacturer, nullptr, nullptr, nullptr },
        { const_cast<char*>("camera_model"), (getter)SystemPhotoProperties_get_CameraModel, nullptr, nullptr, nullptr },
        { const_cast<char*>("date_taken"), (getter)SystemPhotoProperties_get_DateTaken, nullptr, nullptr, nullptr },
        { const_cast<char*>("orientation"), (getter)SystemPhotoProperties_get_Orientation, nullptr, nullptr, nullptr },
        { const_cast<char*>("people_names"), (getter)SystemPhotoProperties_get_PeopleNames, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemPhotoProperties[] = 
    {
        { Py_tp_new, _new_SystemPhotoProperties },
        { Py_tp_dealloc, _dealloc_SystemPhotoProperties },
        { Py_tp_methods, _methods_SystemPhotoProperties },
        { Py_tp_getset, _getset_SystemPhotoProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemPhotoProperties =
    {
        "_winrt_Windows_Storage.SystemPhotoProperties",
        sizeof(py::wrapper::Windows::Storage::SystemPhotoProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemPhotoProperties
    };

    // ----- SystemProperties class --------------------
    constexpr const char* const _type_name_SystemProperties = "SystemProperties";

    static PyObject* _new_SystemProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemProperties);
        return nullptr;
    }

    static PyObject* SystemProperties_get_Audio(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Audio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Author(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Author());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Comment(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Comment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_GPS(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::GPS());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Image(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Image());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_ItemNameDisplay(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::ItemNameDisplay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Keywords(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Keywords());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Media(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Media());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Music(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Music());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Photo(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Photo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Rating(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Rating());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Title(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Video(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Video());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemProperties[] = {
        { "get_audio", (PyCFunction)SystemProperties_get_Audio, METH_NOARGS | METH_STATIC, nullptr },
        { "get_author", (PyCFunction)SystemProperties_get_Author, METH_NOARGS | METH_STATIC, nullptr },
        { "get_comment", (PyCFunction)SystemProperties_get_Comment, METH_NOARGS | METH_STATIC, nullptr },
        { "get_g_p_s", (PyCFunction)SystemProperties_get_GPS, METH_NOARGS | METH_STATIC, nullptr },
        { "get_image", (PyCFunction)SystemProperties_get_Image, METH_NOARGS | METH_STATIC, nullptr },
        { "get_item_name_display", (PyCFunction)SystemProperties_get_ItemNameDisplay, METH_NOARGS | METH_STATIC, nullptr },
        { "get_keywords", (PyCFunction)SystemProperties_get_Keywords, METH_NOARGS | METH_STATIC, nullptr },
        { "get_media", (PyCFunction)SystemProperties_get_Media, METH_NOARGS | METH_STATIC, nullptr },
        { "get_music", (PyCFunction)SystemProperties_get_Music, METH_NOARGS | METH_STATIC, nullptr },
        { "get_photo", (PyCFunction)SystemProperties_get_Photo, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rating", (PyCFunction)SystemProperties_get_Rating, METH_NOARGS | METH_STATIC, nullptr },
        { "get_title", (PyCFunction)SystemProperties_get_Title, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video", (PyCFunction)SystemProperties_get_Video, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemProperties[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemProperties[] = 
    {
        { Py_tp_new, _new_SystemProperties },
        { Py_tp_methods, _methods_SystemProperties },
        { Py_tp_getset, _getset_SystemProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemProperties =
    {
        "_winrt_Windows_Storage.SystemProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemProperties
    };

    // ----- SystemVideoProperties class --------------------
    constexpr const char* const _type_name_SystemVideoProperties = "SystemVideoProperties";

    static PyObject* _new_SystemVideoProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemVideoProperties);
        return nullptr;
    }

    static void _dealloc_SystemVideoProperties(py::wrapper::Windows::Storage::SystemVideoProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemVideoProperties_get_Director(py::wrapper::Windows::Storage::SystemVideoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Director());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemVideoProperties_get_FrameHeight(py::wrapper::Windows::Storage::SystemVideoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemVideoProperties_get_FrameWidth(py::wrapper::Windows::Storage::SystemVideoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemVideoProperties_get_Orientation(py::wrapper::Windows::Storage::SystemVideoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemVideoProperties_get_TotalBitrate(py::wrapper::Windows::Storage::SystemVideoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemVideoProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemVideoProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemVideoProperties[] = {
        { "_from", (PyCFunction)_from_SystemVideoProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemVideoProperties[] = {
        { const_cast<char*>("director"), (getter)SystemVideoProperties_get_Director, nullptr, nullptr, nullptr },
        { const_cast<char*>("frame_height"), (getter)SystemVideoProperties_get_FrameHeight, nullptr, nullptr, nullptr },
        { const_cast<char*>("frame_width"), (getter)SystemVideoProperties_get_FrameWidth, nullptr, nullptr, nullptr },
        { const_cast<char*>("orientation"), (getter)SystemVideoProperties_get_Orientation, nullptr, nullptr, nullptr },
        { const_cast<char*>("total_bitrate"), (getter)SystemVideoProperties_get_TotalBitrate, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemVideoProperties[] = 
    {
        { Py_tp_new, _new_SystemVideoProperties },
        { Py_tp_dealloc, _dealloc_SystemVideoProperties },
        { Py_tp_methods, _methods_SystemVideoProperties },
        { Py_tp_getset, _getset_SystemVideoProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemVideoProperties =
    {
        "_winrt_Windows_Storage.SystemVideoProperties",
        sizeof(py::wrapper::Windows::Storage::SystemVideoProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemVideoProperties
    };

    // ----- UserDataPaths class --------------------
    constexpr const char* const _type_name_UserDataPaths = "UserDataPaths";

    static PyObject* _new_UserDataPaths(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UserDataPaths);
        return nullptr;
    }

    static void _dealloc_UserDataPaths(py::wrapper::Windows::Storage::UserDataPaths* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UserDataPaths_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Storage::UserDataPaths::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::Storage::UserDataPaths::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_CameraRoll(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CameraRoll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Cookies(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Cookies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Desktop(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Desktop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Documents(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Documents());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Downloads(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Downloads());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Favorites(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Favorites());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_History(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.History());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_InternetCache(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InternetCache());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_LocalAppData(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAppData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_LocalAppDataLow(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAppDataLow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Music(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Music());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Pictures(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pictures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Profile(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Profile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Recent(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Recent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_RoamingAppData(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoamingAppData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_SavedPictures(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SavedPictures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Screenshots(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Screenshots());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Templates(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Templates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Videos(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Videos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UserDataPaths(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::UserDataPaths>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserDataPaths[] = {
        { "get_default", (PyCFunction)UserDataPaths_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", (PyCFunction)UserDataPaths_GetForUser, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_UserDataPaths, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UserDataPaths[] = {
        { const_cast<char*>("camera_roll"), (getter)UserDataPaths_get_CameraRoll, nullptr, nullptr, nullptr },
        { const_cast<char*>("cookies"), (getter)UserDataPaths_get_Cookies, nullptr, nullptr, nullptr },
        { const_cast<char*>("desktop"), (getter)UserDataPaths_get_Desktop, nullptr, nullptr, nullptr },
        { const_cast<char*>("documents"), (getter)UserDataPaths_get_Documents, nullptr, nullptr, nullptr },
        { const_cast<char*>("downloads"), (getter)UserDataPaths_get_Downloads, nullptr, nullptr, nullptr },
        { const_cast<char*>("favorites"), (getter)UserDataPaths_get_Favorites, nullptr, nullptr, nullptr },
        { const_cast<char*>("history"), (getter)UserDataPaths_get_History, nullptr, nullptr, nullptr },
        { const_cast<char*>("internet_cache"), (getter)UserDataPaths_get_InternetCache, nullptr, nullptr, nullptr },
        { const_cast<char*>("local_app_data"), (getter)UserDataPaths_get_LocalAppData, nullptr, nullptr, nullptr },
        { const_cast<char*>("local_app_data_low"), (getter)UserDataPaths_get_LocalAppDataLow, nullptr, nullptr, nullptr },
        { const_cast<char*>("music"), (getter)UserDataPaths_get_Music, nullptr, nullptr, nullptr },
        { const_cast<char*>("pictures"), (getter)UserDataPaths_get_Pictures, nullptr, nullptr, nullptr },
        { const_cast<char*>("profile"), (getter)UserDataPaths_get_Profile, nullptr, nullptr, nullptr },
        { const_cast<char*>("recent"), (getter)UserDataPaths_get_Recent, nullptr, nullptr, nullptr },
        { const_cast<char*>("roaming_app_data"), (getter)UserDataPaths_get_RoamingAppData, nullptr, nullptr, nullptr },
        { const_cast<char*>("saved_pictures"), (getter)UserDataPaths_get_SavedPictures, nullptr, nullptr, nullptr },
        { const_cast<char*>("screenshots"), (getter)UserDataPaths_get_Screenshots, nullptr, nullptr, nullptr },
        { const_cast<char*>("templates"), (getter)UserDataPaths_get_Templates, nullptr, nullptr, nullptr },
        { const_cast<char*>("videos"), (getter)UserDataPaths_get_Videos, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UserDataPaths[] = 
    {
        { Py_tp_new, _new_UserDataPaths },
        { Py_tp_dealloc, _dealloc_UserDataPaths },
        { Py_tp_methods, _methods_UserDataPaths },
        { Py_tp_getset, _getset_UserDataPaths },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UserDataPaths =
    {
        "_winrt_Windows_Storage.UserDataPaths",
        sizeof(py::wrapper::Windows::Storage::UserDataPaths),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserDataPaths
    };

    // ----- IStorageFile interface --------------------
    constexpr const char* const _type_name_IStorageFile = "IStorageFile";

    static PyObject* _new_IStorageFile(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageFile);
        return nullptr;
    }

    static void _dealloc_IStorageFile(py::wrapper::Windows::Storage::IStorageFile* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageFile_CopyAndReplaceAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.CopyAndReplaceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_CopyAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert(self->obj.CopyAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CopyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);

                return py::convert(self->obj.CopyAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_DeleteAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetBasicPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_IsOfType(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert(self->obj.IsOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_MoveAndReplaceAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.MoveAndReplaceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_MoveAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert(self->obj.MoveAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.MoveAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);

                return py::convert(self->obj.MoveAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_OpenAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);

                return py::convert(self->obj.OpenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_OpenReadAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenReadAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_OpenSequentialReadAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenSequentialReadAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_OpenTransactedWriteAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenTransactedWriteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_RenameAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RenameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert(self->obj.RenameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_ContentType(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_FileType(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_Attributes(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_DateCreated(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DateCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_Name(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_Path(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IStorageFile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageFile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageFile[] = {
        { "copy_and_replace_async", (PyCFunction)IStorageFile_CopyAndReplaceAsync, METH_VARARGS, nullptr },
        { "copy_async", (PyCFunction)IStorageFile_CopyAsync, METH_VARARGS, nullptr },
        { "move_and_replace_async", (PyCFunction)IStorageFile_MoveAndReplaceAsync, METH_VARARGS, nullptr },
        { "move_async", (PyCFunction)IStorageFile_MoveAsync, METH_VARARGS, nullptr },
        { "open_async", (PyCFunction)IStorageFile_OpenAsync, METH_VARARGS, nullptr },
        { "open_transacted_write_async", (PyCFunction)IStorageFile_OpenTransactedWriteAsync, METH_VARARGS, nullptr },
        { "delete_async", (PyCFunction)IStorageFile_DeleteAsync, METH_VARARGS, nullptr },
        { "get_basic_properties_async", (PyCFunction)IStorageFile_GetBasicPropertiesAsync, METH_VARARGS, nullptr },
        { "is_of_type", (PyCFunction)IStorageFile_IsOfType, METH_VARARGS, nullptr },
        { "rename_async", (PyCFunction)IStorageFile_RenameAsync, METH_VARARGS, nullptr },
        { "open_read_async", (PyCFunction)IStorageFile_OpenReadAsync, METH_VARARGS, nullptr },
        { "open_sequential_read_async", (PyCFunction)IStorageFile_OpenSequentialReadAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IStorageFile, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IStorageFile[] = {
        { const_cast<char*>("content_type"), (getter)IStorageFile_get_ContentType, nullptr, nullptr, nullptr },
        { const_cast<char*>("file_type"), (getter)IStorageFile_get_FileType, nullptr, nullptr, nullptr },
        { const_cast<char*>("attributes"), (getter)IStorageFile_get_Attributes, nullptr, nullptr, nullptr },
        { const_cast<char*>("date_created"), (getter)IStorageFile_get_DateCreated, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)IStorageFile_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("path"), (getter)IStorageFile_get_Path, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IStorageFile[] = 
    {
        { Py_tp_new, _new_IStorageFile },
        { Py_tp_dealloc, _dealloc_IStorageFile },
        { Py_tp_methods, _methods_IStorageFile },
        { Py_tp_getset, _getset_IStorageFile },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStorageFile =
    {
        "_winrt_Windows_Storage.IStorageFile",
        sizeof(py::wrapper::Windows::Storage::IStorageFile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageFile
    };

    // ----- IStorageFile2 interface --------------------
    constexpr const char* const _type_name_IStorageFile2 = "IStorageFile2";

    static PyObject* _new_IStorageFile2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageFile2);
        return nullptr;
    }

    static void _dealloc_IStorageFile2(py::wrapper::Windows::Storage::IStorageFile2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageFile2_OpenAsync(py::wrapper::Windows::Storage::IStorageFile2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 1);

                return py::convert(self->obj.OpenAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile2_OpenTransactedWriteAsync(py::wrapper::Windows::Storage::IStorageFile2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 0);

                return py::convert(self->obj.OpenTransactedWriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IStorageFile2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageFile2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageFile2[] = {
        { "open_async", (PyCFunction)IStorageFile2_OpenAsync, METH_VARARGS, nullptr },
        { "open_transacted_write_async", (PyCFunction)IStorageFile2_OpenTransactedWriteAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IStorageFile2, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IStorageFile2[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IStorageFile2[] = 
    {
        { Py_tp_new, _new_IStorageFile2 },
        { Py_tp_dealloc, _dealloc_IStorageFile2 },
        { Py_tp_methods, _methods_IStorageFile2 },
        { Py_tp_getset, _getset_IStorageFile2 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStorageFile2 =
    {
        "_winrt_Windows_Storage.IStorageFile2",
        sizeof(py::wrapper::Windows::Storage::IStorageFile2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageFile2
    };

    // ----- IStorageFilePropertiesWithAvailability interface --------------------
    constexpr const char* const _type_name_IStorageFilePropertiesWithAvailability = "IStorageFilePropertiesWithAvailability";

    static PyObject* _new_IStorageFilePropertiesWithAvailability(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageFilePropertiesWithAvailability);
        return nullptr;
    }

    static void _dealloc_IStorageFilePropertiesWithAvailability(py::wrapper::Windows::Storage::IStorageFilePropertiesWithAvailability* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageFilePropertiesWithAvailability_get_IsAvailable(py::wrapper::Windows::Storage::IStorageFilePropertiesWithAvailability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IStorageFilePropertiesWithAvailability(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageFilePropertiesWithAvailability[] = {
        { "_from", (PyCFunction)_from_IStorageFilePropertiesWithAvailability, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IStorageFilePropertiesWithAvailability[] = {
        { const_cast<char*>("is_available"), (getter)IStorageFilePropertiesWithAvailability_get_IsAvailable, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IStorageFilePropertiesWithAvailability[] = 
    {
        { Py_tp_new, _new_IStorageFilePropertiesWithAvailability },
        { Py_tp_dealloc, _dealloc_IStorageFilePropertiesWithAvailability },
        { Py_tp_methods, _methods_IStorageFilePropertiesWithAvailability },
        { Py_tp_getset, _getset_IStorageFilePropertiesWithAvailability },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStorageFilePropertiesWithAvailability =
    {
        "_winrt_Windows_Storage.IStorageFilePropertiesWithAvailability",
        sizeof(py::wrapper::Windows::Storage::IStorageFilePropertiesWithAvailability),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageFilePropertiesWithAvailability
    };

    // ----- IStorageFolder interface --------------------
    constexpr const char* const _type_name_IStorageFolder = "IStorageFolder";

    static PyObject* _new_IStorageFolder(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageFolder);
        return nullptr;
    }

    static void _dealloc_IStorageFolder(py::wrapper::Windows::Storage::IStorageFolder* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageFolder_CreateFileAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert(self->obj.CreateFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_CreateFolderAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert(self->obj.CreateFolderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_DeleteAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetBasicPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetFileAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetFilesAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetFilesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetFolderAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetFoldersAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetFoldersAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetItemAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetItemAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetItemsAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetItemsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_IsOfType(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert(self->obj.IsOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_RenameAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RenameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert(self->obj.RenameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_get_Attributes(py::wrapper::Windows::Storage::IStorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_get_DateCreated(py::wrapper::Windows::Storage::IStorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DateCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_get_Name(py::wrapper::Windows::Storage::IStorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_get_Path(py::wrapper::Windows::Storage::IStorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IStorageFolder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageFolder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageFolder[] = {
        { "create_file_async", (PyCFunction)IStorageFolder_CreateFileAsync, METH_VARARGS, nullptr },
        { "create_folder_async", (PyCFunction)IStorageFolder_CreateFolderAsync, METH_VARARGS, nullptr },
        { "get_file_async", (PyCFunction)IStorageFolder_GetFileAsync, METH_VARARGS, nullptr },
        { "get_files_async", (PyCFunction)IStorageFolder_GetFilesAsync, METH_VARARGS, nullptr },
        { "get_folder_async", (PyCFunction)IStorageFolder_GetFolderAsync, METH_VARARGS, nullptr },
        { "get_folders_async", (PyCFunction)IStorageFolder_GetFoldersAsync, METH_VARARGS, nullptr },
        { "get_item_async", (PyCFunction)IStorageFolder_GetItemAsync, METH_VARARGS, nullptr },
        { "get_items_async", (PyCFunction)IStorageFolder_GetItemsAsync, METH_VARARGS, nullptr },
        { "delete_async", (PyCFunction)IStorageFolder_DeleteAsync, METH_VARARGS, nullptr },
        { "get_basic_properties_async", (PyCFunction)IStorageFolder_GetBasicPropertiesAsync, METH_VARARGS, nullptr },
        { "is_of_type", (PyCFunction)IStorageFolder_IsOfType, METH_VARARGS, nullptr },
        { "rename_async", (PyCFunction)IStorageFolder_RenameAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IStorageFolder, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IStorageFolder[] = {
        { const_cast<char*>("attributes"), (getter)IStorageFolder_get_Attributes, nullptr, nullptr, nullptr },
        { const_cast<char*>("date_created"), (getter)IStorageFolder_get_DateCreated, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)IStorageFolder_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("path"), (getter)IStorageFolder_get_Path, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IStorageFolder[] = 
    {
        { Py_tp_new, _new_IStorageFolder },
        { Py_tp_dealloc, _dealloc_IStorageFolder },
        { Py_tp_methods, _methods_IStorageFolder },
        { Py_tp_getset, _getset_IStorageFolder },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStorageFolder =
    {
        "_winrt_Windows_Storage.IStorageFolder",
        sizeof(py::wrapper::Windows::Storage::IStorageFolder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageFolder
    };

    // ----- IStorageFolder2 interface --------------------
    constexpr const char* const _type_name_IStorageFolder2 = "IStorageFolder2";

    static PyObject* _new_IStorageFolder2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageFolder2);
        return nullptr;
    }

    static void _dealloc_IStorageFolder2(py::wrapper::Windows::Storage::IStorageFolder2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageFolder2_TryGetItemAsync(py::wrapper::Windows::Storage::IStorageFolder2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryGetItemAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IStorageFolder2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageFolder2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageFolder2[] = {
        { "try_get_item_async", (PyCFunction)IStorageFolder2_TryGetItemAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IStorageFolder2, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IStorageFolder2[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IStorageFolder2[] = 
    {
        { Py_tp_new, _new_IStorageFolder2 },
        { Py_tp_dealloc, _dealloc_IStorageFolder2 },
        { Py_tp_methods, _methods_IStorageFolder2 },
        { Py_tp_getset, _getset_IStorageFolder2 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStorageFolder2 =
    {
        "_winrt_Windows_Storage.IStorageFolder2",
        sizeof(py::wrapper::Windows::Storage::IStorageFolder2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageFolder2
    };

    // ----- IStorageItem interface --------------------
    constexpr const char* const _type_name_IStorageItem = "IStorageItem";

    static PyObject* _new_IStorageItem(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageItem);
        return nullptr;
    }

    static void _dealloc_IStorageItem(py::wrapper::Windows::Storage::IStorageItem* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageItem_DeleteAsync(py::wrapper::Windows::Storage::IStorageItem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::IStorageItem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetBasicPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem_IsOfType(py::wrapper::Windows::Storage::IStorageItem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert(self->obj.IsOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem_RenameAsync(py::wrapper::Windows::Storage::IStorageItem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RenameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert(self->obj.RenameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem_get_Attributes(py::wrapper::Windows::Storage::IStorageItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem_get_DateCreated(py::wrapper::Windows::Storage::IStorageItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DateCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem_get_Name(py::wrapper::Windows::Storage::IStorageItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem_get_Path(py::wrapper::Windows::Storage::IStorageItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IStorageItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageItem[] = {
        { "delete_async", (PyCFunction)IStorageItem_DeleteAsync, METH_VARARGS, nullptr },
        { "get_basic_properties_async", (PyCFunction)IStorageItem_GetBasicPropertiesAsync, METH_VARARGS, nullptr },
        { "is_of_type", (PyCFunction)IStorageItem_IsOfType, METH_VARARGS, nullptr },
        { "rename_async", (PyCFunction)IStorageItem_RenameAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IStorageItem, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IStorageItem[] = {
        { const_cast<char*>("attributes"), (getter)IStorageItem_get_Attributes, nullptr, nullptr, nullptr },
        { const_cast<char*>("date_created"), (getter)IStorageItem_get_DateCreated, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)IStorageItem_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("path"), (getter)IStorageItem_get_Path, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IStorageItem[] = 
    {
        { Py_tp_new, _new_IStorageItem },
        { Py_tp_dealloc, _dealloc_IStorageItem },
        { Py_tp_methods, _methods_IStorageItem },
        { Py_tp_getset, _getset_IStorageItem },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStorageItem =
    {
        "_winrt_Windows_Storage.IStorageItem",
        sizeof(py::wrapper::Windows::Storage::IStorageItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageItem
    };

    // ----- IStorageItem2 interface --------------------
    constexpr const char* const _type_name_IStorageItem2 = "IStorageItem2";

    static PyObject* _new_IStorageItem2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageItem2);
        return nullptr;
    }

    static void _dealloc_IStorageItem2(py::wrapper::Windows::Storage::IStorageItem2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageItem2_DeleteAsync(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetBasicPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_GetParentAsync(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetParentAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_IsEqual(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_IsOfType(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert(self->obj.IsOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_RenameAsync(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RenameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert(self->obj.RenameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_get_Attributes(py::wrapper::Windows::Storage::IStorageItem2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_get_DateCreated(py::wrapper::Windows::Storage::IStorageItem2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DateCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_get_Name(py::wrapper::Windows::Storage::IStorageItem2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_get_Path(py::wrapper::Windows::Storage::IStorageItem2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IStorageItem2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageItem2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageItem2[] = {
        { "get_parent_async", (PyCFunction)IStorageItem2_GetParentAsync, METH_VARARGS, nullptr },
        { "is_equal", (PyCFunction)IStorageItem2_IsEqual, METH_VARARGS, nullptr },
        { "delete_async", (PyCFunction)IStorageItem2_DeleteAsync, METH_VARARGS, nullptr },
        { "get_basic_properties_async", (PyCFunction)IStorageItem2_GetBasicPropertiesAsync, METH_VARARGS, nullptr },
        { "is_of_type", (PyCFunction)IStorageItem2_IsOfType, METH_VARARGS, nullptr },
        { "rename_async", (PyCFunction)IStorageItem2_RenameAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IStorageItem2, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IStorageItem2[] = {
        { const_cast<char*>("attributes"), (getter)IStorageItem2_get_Attributes, nullptr, nullptr, nullptr },
        { const_cast<char*>("date_created"), (getter)IStorageItem2_get_DateCreated, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)IStorageItem2_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("path"), (getter)IStorageItem2_get_Path, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IStorageItem2[] = 
    {
        { Py_tp_new, _new_IStorageItem2 },
        { Py_tp_dealloc, _dealloc_IStorageItem2 },
        { Py_tp_methods, _methods_IStorageItem2 },
        { Py_tp_getset, _getset_IStorageItem2 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStorageItem2 =
    {
        "_winrt_Windows_Storage.IStorageItem2",
        sizeof(py::wrapper::Windows::Storage::IStorageItem2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageItem2
    };

    // ----- IStorageItemProperties interface --------------------
    constexpr const char* const _type_name_IStorageItemProperties = "IStorageItemProperties";

    static PyObject* _new_IStorageItemProperties(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageItemProperties);
        return nullptr;
    }

    static void _dealloc_IStorageItemProperties(py::wrapper::Windows::Storage::IStorageItemProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageItemProperties_GetThumbnailAsync(py::wrapper::Windows::Storage::IStorageItemProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties_get_DisplayName(py::wrapper::Windows::Storage::IStorageItemProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties_get_DisplayType(py::wrapper::Windows::Storage::IStorageItemProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties_get_FolderRelativeId(py::wrapper::Windows::Storage::IStorageItemProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FolderRelativeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties_get_Properties(py::wrapper::Windows::Storage::IStorageItemProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IStorageItemProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageItemProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageItemProperties[] = {
        { "get_thumbnail_async", (PyCFunction)IStorageItemProperties_GetThumbnailAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IStorageItemProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IStorageItemProperties[] = {
        { const_cast<char*>("display_name"), (getter)IStorageItemProperties_get_DisplayName, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_type"), (getter)IStorageItemProperties_get_DisplayType, nullptr, nullptr, nullptr },
        { const_cast<char*>("folder_relative_id"), (getter)IStorageItemProperties_get_FolderRelativeId, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)IStorageItemProperties_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IStorageItemProperties[] = 
    {
        { Py_tp_new, _new_IStorageItemProperties },
        { Py_tp_dealloc, _dealloc_IStorageItemProperties },
        { Py_tp_methods, _methods_IStorageItemProperties },
        { Py_tp_getset, _getset_IStorageItemProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStorageItemProperties =
    {
        "_winrt_Windows_Storage.IStorageItemProperties",
        sizeof(py::wrapper::Windows::Storage::IStorageItemProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageItemProperties
    };

    // ----- IStorageItemProperties2 interface --------------------
    constexpr const char* const _type_name_IStorageItemProperties2 = "IStorageItemProperties2";

    static PyObject* _new_IStorageItemProperties2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageItemProperties2);
        return nullptr;
    }

    static void _dealloc_IStorageItemProperties2(py::wrapper::Windows::Storage::IStorageItemProperties2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageItemProperties2_GetScaledImageAsThumbnailAsync(py::wrapper::Windows::Storage::IStorageItemProperties2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_GetThumbnailAsync(py::wrapper::Windows::Storage::IStorageItemProperties2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_get_DisplayName(py::wrapper::Windows::Storage::IStorageItemProperties2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_get_DisplayType(py::wrapper::Windows::Storage::IStorageItemProperties2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_get_FolderRelativeId(py::wrapper::Windows::Storage::IStorageItemProperties2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FolderRelativeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_get_Properties(py::wrapper::Windows::Storage::IStorageItemProperties2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IStorageItemProperties2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageItemProperties2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageItemProperties2[] = {
        { "get_scaled_image_as_thumbnail_async", (PyCFunction)IStorageItemProperties2_GetScaledImageAsThumbnailAsync, METH_VARARGS, nullptr },
        { "get_thumbnail_async", (PyCFunction)IStorageItemProperties2_GetThumbnailAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IStorageItemProperties2, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IStorageItemProperties2[] = {
        { const_cast<char*>("display_name"), (getter)IStorageItemProperties2_get_DisplayName, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_type"), (getter)IStorageItemProperties2_get_DisplayType, nullptr, nullptr, nullptr },
        { const_cast<char*>("folder_relative_id"), (getter)IStorageItemProperties2_get_FolderRelativeId, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)IStorageItemProperties2_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IStorageItemProperties2[] = 
    {
        { Py_tp_new, _new_IStorageItemProperties2 },
        { Py_tp_dealloc, _dealloc_IStorageItemProperties2 },
        { Py_tp_methods, _methods_IStorageItemProperties2 },
        { Py_tp_getset, _getset_IStorageItemProperties2 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStorageItemProperties2 =
    {
        "_winrt_Windows_Storage.IStorageItemProperties2",
        sizeof(py::wrapper::Windows::Storage::IStorageItemProperties2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageItemProperties2
    };

    // ----- IStorageItemPropertiesWithProvider interface --------------------
    constexpr const char* const _type_name_IStorageItemPropertiesWithProvider = "IStorageItemPropertiesWithProvider";

    static PyObject* _new_IStorageItemPropertiesWithProvider(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageItemPropertiesWithProvider);
        return nullptr;
    }

    static void _dealloc_IStorageItemPropertiesWithProvider(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageItemPropertiesWithProvider_GetThumbnailAsync(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_get_Provider(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Provider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_get_DisplayName(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_get_DisplayType(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_get_FolderRelativeId(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FolderRelativeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_get_Properties(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IStorageItemPropertiesWithProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageItemPropertiesWithProvider[] = {
        { "get_thumbnail_async", (PyCFunction)IStorageItemPropertiesWithProvider_GetThumbnailAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IStorageItemPropertiesWithProvider, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IStorageItemPropertiesWithProvider[] = {
        { const_cast<char*>("provider"), (getter)IStorageItemPropertiesWithProvider_get_Provider, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)IStorageItemPropertiesWithProvider_get_DisplayName, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_type"), (getter)IStorageItemPropertiesWithProvider_get_DisplayType, nullptr, nullptr, nullptr },
        { const_cast<char*>("folder_relative_id"), (getter)IStorageItemPropertiesWithProvider_get_FolderRelativeId, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)IStorageItemPropertiesWithProvider_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IStorageItemPropertiesWithProvider[] = 
    {
        { Py_tp_new, _new_IStorageItemPropertiesWithProvider },
        { Py_tp_dealloc, _dealloc_IStorageItemPropertiesWithProvider },
        { Py_tp_methods, _methods_IStorageItemPropertiesWithProvider },
        { Py_tp_getset, _getset_IStorageItemPropertiesWithProvider },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStorageItemPropertiesWithProvider =
    {
        "_winrt_Windows_Storage.IStorageItemPropertiesWithProvider",
        sizeof(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageItemPropertiesWithProvider
    };

    // ----- IStreamedFileDataRequest interface --------------------
    constexpr const char* const _type_name_IStreamedFileDataRequest = "IStreamedFileDataRequest";

    static PyObject* _new_IStreamedFileDataRequest(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStreamedFileDataRequest);
        return nullptr;
    }

    static void _dealloc_IStreamedFileDataRequest(py::wrapper::Windows::Storage::IStreamedFileDataRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStreamedFileDataRequest_FailAndClose(py::wrapper::Windows::Storage::IStreamedFileDataRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StreamedFileFailureMode>(args, 0);

                self->obj.FailAndClose(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IStreamedFileDataRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStreamedFileDataRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStreamedFileDataRequest[] = {
        { "fail_and_close", (PyCFunction)IStreamedFileDataRequest_FailAndClose, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IStreamedFileDataRequest, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IStreamedFileDataRequest[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IStreamedFileDataRequest[] = 
    {
        { Py_tp_new, _new_IStreamedFileDataRequest },
        { Py_tp_dealloc, _dealloc_IStreamedFileDataRequest },
        { Py_tp_methods, _methods_IStreamedFileDataRequest },
        { Py_tp_getset, _getset_IStreamedFileDataRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStreamedFileDataRequest =
    {
        "_winrt_Windows_Storage.IStreamedFileDataRequest",
        sizeof(py::wrapper::Windows::Storage::IStreamedFileDataRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStreamedFileDataRequest
    };

    // ----- Windows.Storage Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Storage::AppDataPaths>::python_type = py::register_python_type(module, _type_name_AppDataPaths, &_type_spec_AppDataPaths, bases.get());
            py::winrt_type<winrt::Windows::Storage::ApplicationData>::python_type = py::register_python_type(module, _type_name_ApplicationData, &_type_spec_ApplicationData, bases.get());
            py::winrt_type<winrt::Windows::Storage::ApplicationDataCompositeValue>::python_type = py::register_python_type(module, _type_name_ApplicationDataCompositeValue, &_type_spec_ApplicationDataCompositeValue, bases.get());
            py::winrt_type<winrt::Windows::Storage::ApplicationDataContainer>::python_type = py::register_python_type(module, _type_name_ApplicationDataContainer, &_type_spec_ApplicationDataContainer, bases.get());
            py::winrt_type<winrt::Windows::Storage::ApplicationDataContainerSettings>::python_type = py::register_python_type(module, _type_name_ApplicationDataContainerSettings, &_type_spec_ApplicationDataContainerSettings, bases.get());
            py::winrt_type<winrt::Windows::Storage::CachedFileManager>::python_type = py::register_python_type(module, _type_name_CachedFileManager, &_type_spec_CachedFileManager, nullptr);
            py::winrt_type<winrt::Windows::Storage::DownloadsFolder>::python_type = py::register_python_type(module, _type_name_DownloadsFolder, &_type_spec_DownloadsFolder, nullptr);
            py::winrt_type<winrt::Windows::Storage::FileIO>::python_type = py::register_python_type(module, _type_name_FileIO, &_type_spec_FileIO, nullptr);
            py::winrt_type<winrt::Windows::Storage::KnownFolders>::python_type = py::register_python_type(module, _type_name_KnownFolders, &_type_spec_KnownFolders, nullptr);
            py::winrt_type<winrt::Windows::Storage::PathIO>::python_type = py::register_python_type(module, _type_name_PathIO, &_type_spec_PathIO, nullptr);
            py::winrt_type<winrt::Windows::Storage::SetVersionDeferral>::python_type = py::register_python_type(module, _type_name_SetVersionDeferral, &_type_spec_SetVersionDeferral, bases.get());
            py::winrt_type<winrt::Windows::Storage::SetVersionRequest>::python_type = py::register_python_type(module, _type_name_SetVersionRequest, &_type_spec_SetVersionRequest, bases.get());
            py::winrt_type<winrt::Windows::Storage::StorageFile>::python_type = py::register_python_type(module, _type_name_StorageFile, &_type_spec_StorageFile, bases.get());
            py::winrt_type<winrt::Windows::Storage::StorageFolder>::python_type = py::register_python_type(module, _type_name_StorageFolder, &_type_spec_StorageFolder, bases.get());
            py::winrt_type<winrt::Windows::Storage::StorageLibrary>::python_type = py::register_python_type(module, _type_name_StorageLibrary, &_type_spec_StorageLibrary, bases.get());
            py::winrt_type<winrt::Windows::Storage::StorageLibraryChange>::python_type = py::register_python_type(module, _type_name_StorageLibraryChange, &_type_spec_StorageLibraryChange, bases.get());
            py::winrt_type<winrt::Windows::Storage::StorageLibraryChangeReader>::python_type = py::register_python_type(module, _type_name_StorageLibraryChangeReader, &_type_spec_StorageLibraryChangeReader, bases.get());
            py::winrt_type<winrt::Windows::Storage::StorageLibraryChangeTracker>::python_type = py::register_python_type(module, _type_name_StorageLibraryChangeTracker, &_type_spec_StorageLibraryChangeTracker, bases.get());
            py::winrt_type<winrt::Windows::Storage::StorageLibraryChangeTrackerOptions>::python_type = py::register_python_type(module, _type_name_StorageLibraryChangeTrackerOptions, &_type_spec_StorageLibraryChangeTrackerOptions, bases.get());
            py::winrt_type<winrt::Windows::Storage::StorageLibraryLastChangeId>::python_type = py::register_python_type(module, _type_name_StorageLibraryLastChangeId, &_type_spec_StorageLibraryLastChangeId, bases.get());
            py::winrt_type<winrt::Windows::Storage::StorageProvider>::python_type = py::register_python_type(module, _type_name_StorageProvider, &_type_spec_StorageProvider, bases.get());
            py::winrt_type<winrt::Windows::Storage::StorageStreamTransaction>::python_type = py::register_python_type(module, _type_name_StorageStreamTransaction, &_type_spec_StorageStreamTransaction, bases.get());
            py::winrt_type<winrt::Windows::Storage::StreamedFileDataRequest>::python_type = py::register_python_type(module, _type_name_StreamedFileDataRequest, &_type_spec_StreamedFileDataRequest, bases.get());
            py::winrt_type<winrt::Windows::Storage::SystemAudioProperties>::python_type = py::register_python_type(module, _type_name_SystemAudioProperties, &_type_spec_SystemAudioProperties, bases.get());
            py::winrt_type<winrt::Windows::Storage::SystemDataPaths>::python_type = py::register_python_type(module, _type_name_SystemDataPaths, &_type_spec_SystemDataPaths, bases.get());
            py::winrt_type<winrt::Windows::Storage::SystemGPSProperties>::python_type = py::register_python_type(module, _type_name_SystemGPSProperties, &_type_spec_SystemGPSProperties, bases.get());
            py::winrt_type<winrt::Windows::Storage::SystemImageProperties>::python_type = py::register_python_type(module, _type_name_SystemImageProperties, &_type_spec_SystemImageProperties, bases.get());
            py::winrt_type<winrt::Windows::Storage::SystemMediaProperties>::python_type = py::register_python_type(module, _type_name_SystemMediaProperties, &_type_spec_SystemMediaProperties, bases.get());
            py::winrt_type<winrt::Windows::Storage::SystemMusicProperties>::python_type = py::register_python_type(module, _type_name_SystemMusicProperties, &_type_spec_SystemMusicProperties, bases.get());
            py::winrt_type<winrt::Windows::Storage::SystemPhotoProperties>::python_type = py::register_python_type(module, _type_name_SystemPhotoProperties, &_type_spec_SystemPhotoProperties, bases.get());
            py::winrt_type<winrt::Windows::Storage::SystemProperties>::python_type = py::register_python_type(module, _type_name_SystemProperties, &_type_spec_SystemProperties, nullptr);
            py::winrt_type<winrt::Windows::Storage::SystemVideoProperties>::python_type = py::register_python_type(module, _type_name_SystemVideoProperties, &_type_spec_SystemVideoProperties, bases.get());
            py::winrt_type<winrt::Windows::Storage::UserDataPaths>::python_type = py::register_python_type(module, _type_name_UserDataPaths, &_type_spec_UserDataPaths, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStorageFile>::python_type = py::register_python_type(module, _type_name_IStorageFile, &_type_spec_IStorageFile, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStorageFile2>::python_type = py::register_python_type(module, _type_name_IStorageFile2, &_type_spec_IStorageFile2, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>::python_type = py::register_python_type(module, _type_name_IStorageFilePropertiesWithAvailability, &_type_spec_IStorageFilePropertiesWithAvailability, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStorageFolder>::python_type = py::register_python_type(module, _type_name_IStorageFolder, &_type_spec_IStorageFolder, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStorageFolder2>::python_type = py::register_python_type(module, _type_name_IStorageFolder2, &_type_spec_IStorageFolder2, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStorageItem>::python_type = py::register_python_type(module, _type_name_IStorageItem, &_type_spec_IStorageItem, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStorageItem2>::python_type = py::register_python_type(module, _type_name_IStorageItem2, &_type_spec_IStorageItem2, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStorageItemProperties>::python_type = py::register_python_type(module, _type_name_IStorageItemProperties, &_type_spec_IStorageItemProperties, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStorageItemProperties2>::python_type = py::register_python_type(module, _type_name_IStorageItemProperties2, &_type_spec_IStorageItemProperties2, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>::python_type = py::register_python_type(module, _type_name_IStorageItemPropertiesWithProvider, &_type_spec_IStorageItemPropertiesWithProvider, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStreamedFileDataRequest>::python_type = py::register_python_type(module, _type_name_IStreamedFileDataRequest, &_type_spec_IStreamedFileDataRequest, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Storage");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Storage",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Storage

PyMODINIT_FUNC
PyInit__winrt_Windows_Storage (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Storage::module_def);
}
