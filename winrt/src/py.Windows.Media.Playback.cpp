// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Media.Playback.h"

PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::BackgroundMediaPlayer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::CurrentMediaPlaybackItemChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaBreak>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaBreakEndedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaBreakManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaBreakSchedule>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaBreakSeekedOverEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaBreakSkippedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaBreakStartedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaItemDisplayProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackAudioTrackList>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerFastForwardReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerNextReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPauseReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPlayReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPositionReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPreviousReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerRateReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerRewindReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackItem>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackItemError>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackItemFailedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackItemOpenedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackList>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackSession>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackSessionBufferingStartedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackSessionOutputDegradationPolicyState>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackVideoTrackList>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlayer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlayerDataReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlayerFailedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlayerRateChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::MediaPlayerSurface>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::PlaybackMediaMarker>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::PlaybackMediaMarkerReachedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::PlaybackMediaMarkerSequence>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::TimedMetadataPresentationModeChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::IMediaEnginePlaybackSource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Playback::IMediaPlaybackSource>::python_type;

namespace py::cpp::Windows::Media::Playback
{
    // ----- BackgroundMediaPlayer class --------------------
    constexpr const char* const _type_name_BackgroundMediaPlayer = "BackgroundMediaPlayer";

    static PyObject* _new_BackgroundMediaPlayer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BackgroundMediaPlayer);
        return nullptr;
    }

    static PyObject* BackgroundMediaPlayer_IsMediaPlaying(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::Playback::BackgroundMediaPlayer::IsMediaPlaying());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundMediaPlayer_SendMessageToBackground(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);

                winrt::Windows::Media::Playback::BackgroundMediaPlayer::SendMessageToBackground(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundMediaPlayer_SendMessageToForeground(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);

                winrt::Windows::Media::Playback::BackgroundMediaPlayer::SendMessageToForeground(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundMediaPlayer_Shutdown(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Playback::BackgroundMediaPlayer::Shutdown();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundMediaPlayer_get_Current(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Playback::BackgroundMediaPlayer::Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundMediaPlayer_add_MessageReceivedFromBackground(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Media::Playback::MediaPlayerDataReceivedEventArgs>>(arg);

            return py::convert(winrt::Windows::Media::Playback::BackgroundMediaPlayer::MessageReceivedFromBackground(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundMediaPlayer_remove_MessageReceivedFromBackground(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::Playback::BackgroundMediaPlayer::MessageReceivedFromBackground(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundMediaPlayer_add_MessageReceivedFromForeground(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Media::Playback::MediaPlayerDataReceivedEventArgs>>(arg);

            return py::convert(winrt::Windows::Media::Playback::BackgroundMediaPlayer::MessageReceivedFromForeground(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundMediaPlayer_remove_MessageReceivedFromForeground(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::Playback::BackgroundMediaPlayer::MessageReceivedFromForeground(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundMediaPlayer[] = {
        { "is_media_playing", (PyCFunction)BackgroundMediaPlayer_IsMediaPlaying, METH_VARARGS | METH_STATIC, nullptr },
        { "send_message_to_background", (PyCFunction)BackgroundMediaPlayer_SendMessageToBackground, METH_VARARGS | METH_STATIC, nullptr },
        { "send_message_to_foreground", (PyCFunction)BackgroundMediaPlayer_SendMessageToForeground, METH_VARARGS | METH_STATIC, nullptr },
        { "shutdown", (PyCFunction)BackgroundMediaPlayer_Shutdown, METH_VARARGS | METH_STATIC, nullptr },
        { "get_current", (PyCFunction)BackgroundMediaPlayer_get_Current, METH_NOARGS | METH_STATIC, nullptr },
        { "add_message_received_from_background", (PyCFunction)BackgroundMediaPlayer_add_MessageReceivedFromBackground, METH_O | METH_STATIC, nullptr },
        { "remove_message_received_from_background", (PyCFunction)BackgroundMediaPlayer_remove_MessageReceivedFromBackground, METH_O | METH_STATIC, nullptr },
        { "add_message_received_from_foreground", (PyCFunction)BackgroundMediaPlayer_add_MessageReceivedFromForeground, METH_O | METH_STATIC, nullptr },
        { "remove_message_received_from_foreground", (PyCFunction)BackgroundMediaPlayer_remove_MessageReceivedFromForeground, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BackgroundMediaPlayer[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_BackgroundMediaPlayer[] = 
    {
        { Py_tp_new, _new_BackgroundMediaPlayer },
        { Py_tp_methods, _methods_BackgroundMediaPlayer },
        { Py_tp_getset, _getset_BackgroundMediaPlayer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BackgroundMediaPlayer =
    {
        "_winrt_Windows_Media_Playback.BackgroundMediaPlayer",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundMediaPlayer
    };

    // ----- CurrentMediaPlaybackItemChangedEventArgs class --------------------
    constexpr const char* const _type_name_CurrentMediaPlaybackItemChangedEventArgs = "CurrentMediaPlaybackItemChangedEventArgs";

    static PyObject* _new_CurrentMediaPlaybackItemChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CurrentMediaPlaybackItemChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_CurrentMediaPlaybackItemChangedEventArgs(py::wrapper::Windows::Media::Playback::CurrentMediaPlaybackItemChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CurrentMediaPlaybackItemChangedEventArgs_get_NewItem(py::wrapper::Windows::Media::Playback::CurrentMediaPlaybackItemChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NewItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrentMediaPlaybackItemChangedEventArgs_get_OldItem(py::wrapper::Windows::Media::Playback::CurrentMediaPlaybackItemChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OldItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CurrentMediaPlaybackItemChangedEventArgs_get_Reason(py::wrapper::Windows::Media::Playback::CurrentMediaPlaybackItemChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CurrentMediaPlaybackItemChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::CurrentMediaPlaybackItemChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CurrentMediaPlaybackItemChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_CurrentMediaPlaybackItemChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CurrentMediaPlaybackItemChangedEventArgs[] = {
        { const_cast<char*>("new_item"), (getter)CurrentMediaPlaybackItemChangedEventArgs_get_NewItem, nullptr, nullptr, nullptr },
        { const_cast<char*>("old_item"), (getter)CurrentMediaPlaybackItemChangedEventArgs_get_OldItem, nullptr, nullptr, nullptr },
        { const_cast<char*>("reason"), (getter)CurrentMediaPlaybackItemChangedEventArgs_get_Reason, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CurrentMediaPlaybackItemChangedEventArgs[] = 
    {
        { Py_tp_new, _new_CurrentMediaPlaybackItemChangedEventArgs },
        { Py_tp_dealloc, _dealloc_CurrentMediaPlaybackItemChangedEventArgs },
        { Py_tp_methods, _methods_CurrentMediaPlaybackItemChangedEventArgs },
        { Py_tp_getset, _getset_CurrentMediaPlaybackItemChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CurrentMediaPlaybackItemChangedEventArgs =
    {
        "_winrt_Windows_Media_Playback.CurrentMediaPlaybackItemChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::CurrentMediaPlaybackItemChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CurrentMediaPlaybackItemChangedEventArgs
    };

    // ----- MediaBreak class --------------------
    constexpr const char* const _type_name_MediaBreak = "MediaBreak";

    static PyObject* _new_MediaBreak(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaBreakInsertionMethod>(args, 0);

                winrt::Windows::Media::Playback::MediaBreak instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaBreakInsertionMethod>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                winrt::Windows::Media::Playback::MediaBreak instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaBreak(py::wrapper::Windows::Media::Playback::MediaBreak* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaBreak_get_CanStart(py::wrapper::Windows::Media::Playback::MediaBreak* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaBreak_put_CanStart(py::wrapper::Windows::Media::Playback::MediaBreak* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanStart(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaBreak_get_CustomProperties(py::wrapper::Windows::Media::Playback::MediaBreak* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CustomProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreak_get_InsertionMethod(py::wrapper::Windows::Media::Playback::MediaBreak* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InsertionMethod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreak_get_PlaybackList(py::wrapper::Windows::Media::Playback::MediaBreak* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreak_get_PresentationPosition(py::wrapper::Windows::Media::Playback::MediaBreak* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PresentationPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaBreak(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaBreak>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBreak[] = {
        { "_from", (PyCFunction)_from_MediaBreak, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaBreak[] = {
        { const_cast<char*>("can_start"), (getter)MediaBreak_get_CanStart, (setter)MediaBreak_put_CanStart, nullptr, nullptr },
        { const_cast<char*>("custom_properties"), (getter)MediaBreak_get_CustomProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("insertion_method"), (getter)MediaBreak_get_InsertionMethod, nullptr, nullptr, nullptr },
        { const_cast<char*>("playback_list"), (getter)MediaBreak_get_PlaybackList, nullptr, nullptr, nullptr },
        { const_cast<char*>("presentation_position"), (getter)MediaBreak_get_PresentationPosition, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaBreak[] = 
    {
        { Py_tp_new, _new_MediaBreak },
        { Py_tp_dealloc, _dealloc_MediaBreak },
        { Py_tp_methods, _methods_MediaBreak },
        { Py_tp_getset, _getset_MediaBreak },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaBreak =
    {
        "_winrt_Windows_Media_Playback.MediaBreak",
        sizeof(py::wrapper::Windows::Media::Playback::MediaBreak),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBreak
    };

    // ----- MediaBreakEndedEventArgs class --------------------
    constexpr const char* const _type_name_MediaBreakEndedEventArgs = "MediaBreakEndedEventArgs";

    static PyObject* _new_MediaBreakEndedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaBreakEndedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaBreakEndedEventArgs(py::wrapper::Windows::Media::Playback::MediaBreakEndedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaBreakEndedEventArgs_get_MediaBreak(py::wrapper::Windows::Media::Playback::MediaBreakEndedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaBreak());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaBreakEndedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaBreakEndedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBreakEndedEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaBreakEndedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaBreakEndedEventArgs[] = {
        { const_cast<char*>("media_break"), (getter)MediaBreakEndedEventArgs_get_MediaBreak, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaBreakEndedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaBreakEndedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaBreakEndedEventArgs },
        { Py_tp_methods, _methods_MediaBreakEndedEventArgs },
        { Py_tp_getset, _getset_MediaBreakEndedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaBreakEndedEventArgs =
    {
        "_winrt_Windows_Media_Playback.MediaBreakEndedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaBreakEndedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBreakEndedEventArgs
    };

    // ----- MediaBreakManager class --------------------
    constexpr const char* const _type_name_MediaBreakManager = "MediaBreakManager";

    static PyObject* _new_MediaBreakManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaBreakManager);
        return nullptr;
    }

    static void _dealloc_MediaBreakManager(py::wrapper::Windows::Media::Playback::MediaBreakManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaBreakManager_PlayBreak(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaBreak>(args, 0);

                self->obj.PlayBreak(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_SkipCurrentBreak(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.SkipCurrentBreak();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_get_CurrentBreak(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentBreak());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_get_PlaybackSession(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackSession());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_add_BreakEnded(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaBreakManager, winrt::Windows::Media::Playback::MediaBreakEndedEventArgs>>(arg);

            return py::convert(self->obj.BreakEnded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_remove_BreakEnded(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BreakEnded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_add_BreakSkipped(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaBreakManager, winrt::Windows::Media::Playback::MediaBreakSkippedEventArgs>>(arg);

            return py::convert(self->obj.BreakSkipped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_remove_BreakSkipped(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BreakSkipped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_add_BreakStarted(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaBreakManager, winrt::Windows::Media::Playback::MediaBreakStartedEventArgs>>(arg);

            return py::convert(self->obj.BreakStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_remove_BreakStarted(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BreakStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_add_BreaksSeekedOver(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaBreakManager, winrt::Windows::Media::Playback::MediaBreakSeekedOverEventArgs>>(arg);

            return py::convert(self->obj.BreaksSeekedOver(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakManager_remove_BreaksSeekedOver(py::wrapper::Windows::Media::Playback::MediaBreakManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BreaksSeekedOver(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaBreakManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaBreakManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBreakManager[] = {
        { "play_break", (PyCFunction)MediaBreakManager_PlayBreak, METH_VARARGS, nullptr },
        { "skip_current_break", (PyCFunction)MediaBreakManager_SkipCurrentBreak, METH_VARARGS, nullptr },
        { "add_break_ended", (PyCFunction)MediaBreakManager_add_BreakEnded, METH_O, nullptr },
        { "remove_break_ended", (PyCFunction)MediaBreakManager_remove_BreakEnded, METH_O, nullptr },
        { "add_break_skipped", (PyCFunction)MediaBreakManager_add_BreakSkipped, METH_O, nullptr },
        { "remove_break_skipped", (PyCFunction)MediaBreakManager_remove_BreakSkipped, METH_O, nullptr },
        { "add_break_started", (PyCFunction)MediaBreakManager_add_BreakStarted, METH_O, nullptr },
        { "remove_break_started", (PyCFunction)MediaBreakManager_remove_BreakStarted, METH_O, nullptr },
        { "add_breaks_seeked_over", (PyCFunction)MediaBreakManager_add_BreaksSeekedOver, METH_O, nullptr },
        { "remove_breaks_seeked_over", (PyCFunction)MediaBreakManager_remove_BreaksSeekedOver, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MediaBreakManager, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaBreakManager[] = {
        { const_cast<char*>("current_break"), (getter)MediaBreakManager_get_CurrentBreak, nullptr, nullptr, nullptr },
        { const_cast<char*>("playback_session"), (getter)MediaBreakManager_get_PlaybackSession, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaBreakManager[] = 
    {
        { Py_tp_new, _new_MediaBreakManager },
        { Py_tp_dealloc, _dealloc_MediaBreakManager },
        { Py_tp_methods, _methods_MediaBreakManager },
        { Py_tp_getset, _getset_MediaBreakManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaBreakManager =
    {
        "_winrt_Windows_Media_Playback.MediaBreakManager",
        sizeof(py::wrapper::Windows::Media::Playback::MediaBreakManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBreakManager
    };

    // ----- MediaBreakSchedule class --------------------
    constexpr const char* const _type_name_MediaBreakSchedule = "MediaBreakSchedule";

    static PyObject* _new_MediaBreakSchedule(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaBreakSchedule);
        return nullptr;
    }

    static void _dealloc_MediaBreakSchedule(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaBreakSchedule_InsertMidrollBreak(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaBreak>(args, 0);

                self->obj.InsertMidrollBreak(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBreakSchedule_RemoveMidrollBreak(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaBreak>(args, 0);

                self->obj.RemoveMidrollBreak(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBreakSchedule_get_PrerollBreak(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrerollBreak());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaBreakSchedule_put_PrerollBreak(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaBreak>(arg);

            self->obj.PrerollBreak(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaBreakSchedule_get_PostrollBreak(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PostrollBreak());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaBreakSchedule_put_PostrollBreak(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaBreak>(arg);

            self->obj.PostrollBreak(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaBreakSchedule_get_MidrollBreaks(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MidrollBreaks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakSchedule_get_PlaybackItem(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakSchedule_add_ScheduleChanged(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaBreakSchedule, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ScheduleChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakSchedule_remove_ScheduleChanged(py::wrapper::Windows::Media::Playback::MediaBreakSchedule* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ScheduleChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaBreakSchedule(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaBreakSchedule>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBreakSchedule[] = {
        { "insert_midroll_break", (PyCFunction)MediaBreakSchedule_InsertMidrollBreak, METH_VARARGS, nullptr },
        { "remove_midroll_break", (PyCFunction)MediaBreakSchedule_RemoveMidrollBreak, METH_VARARGS, nullptr },
        { "add_schedule_changed", (PyCFunction)MediaBreakSchedule_add_ScheduleChanged, METH_O, nullptr },
        { "remove_schedule_changed", (PyCFunction)MediaBreakSchedule_remove_ScheduleChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MediaBreakSchedule, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaBreakSchedule[] = {
        { const_cast<char*>("preroll_break"), (getter)MediaBreakSchedule_get_PrerollBreak, (setter)MediaBreakSchedule_put_PrerollBreak, nullptr, nullptr },
        { const_cast<char*>("postroll_break"), (getter)MediaBreakSchedule_get_PostrollBreak, (setter)MediaBreakSchedule_put_PostrollBreak, nullptr, nullptr },
        { const_cast<char*>("midroll_breaks"), (getter)MediaBreakSchedule_get_MidrollBreaks, nullptr, nullptr, nullptr },
        { const_cast<char*>("playback_item"), (getter)MediaBreakSchedule_get_PlaybackItem, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaBreakSchedule[] = 
    {
        { Py_tp_new, _new_MediaBreakSchedule },
        { Py_tp_dealloc, _dealloc_MediaBreakSchedule },
        { Py_tp_methods, _methods_MediaBreakSchedule },
        { Py_tp_getset, _getset_MediaBreakSchedule },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaBreakSchedule =
    {
        "_winrt_Windows_Media_Playback.MediaBreakSchedule",
        sizeof(py::wrapper::Windows::Media::Playback::MediaBreakSchedule),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBreakSchedule
    };

    // ----- MediaBreakSeekedOverEventArgs class --------------------
    constexpr const char* const _type_name_MediaBreakSeekedOverEventArgs = "MediaBreakSeekedOverEventArgs";

    static PyObject* _new_MediaBreakSeekedOverEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaBreakSeekedOverEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaBreakSeekedOverEventArgs(py::wrapper::Windows::Media::Playback::MediaBreakSeekedOverEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaBreakSeekedOverEventArgs_get_NewPosition(py::wrapper::Windows::Media::Playback::MediaBreakSeekedOverEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NewPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakSeekedOverEventArgs_get_OldPosition(py::wrapper::Windows::Media::Playback::MediaBreakSeekedOverEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OldPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBreakSeekedOverEventArgs_get_SeekedOverBreaks(py::wrapper::Windows::Media::Playback::MediaBreakSeekedOverEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SeekedOverBreaks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaBreakSeekedOverEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaBreakSeekedOverEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBreakSeekedOverEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaBreakSeekedOverEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaBreakSeekedOverEventArgs[] = {
        { const_cast<char*>("new_position"), (getter)MediaBreakSeekedOverEventArgs_get_NewPosition, nullptr, nullptr, nullptr },
        { const_cast<char*>("old_position"), (getter)MediaBreakSeekedOverEventArgs_get_OldPosition, nullptr, nullptr, nullptr },
        { const_cast<char*>("seeked_over_breaks"), (getter)MediaBreakSeekedOverEventArgs_get_SeekedOverBreaks, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaBreakSeekedOverEventArgs[] = 
    {
        { Py_tp_new, _new_MediaBreakSeekedOverEventArgs },
        { Py_tp_dealloc, _dealloc_MediaBreakSeekedOverEventArgs },
        { Py_tp_methods, _methods_MediaBreakSeekedOverEventArgs },
        { Py_tp_getset, _getset_MediaBreakSeekedOverEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaBreakSeekedOverEventArgs =
    {
        "_winrt_Windows_Media_Playback.MediaBreakSeekedOverEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaBreakSeekedOverEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBreakSeekedOverEventArgs
    };

    // ----- MediaBreakSkippedEventArgs class --------------------
    constexpr const char* const _type_name_MediaBreakSkippedEventArgs = "MediaBreakSkippedEventArgs";

    static PyObject* _new_MediaBreakSkippedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaBreakSkippedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaBreakSkippedEventArgs(py::wrapper::Windows::Media::Playback::MediaBreakSkippedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaBreakSkippedEventArgs_get_MediaBreak(py::wrapper::Windows::Media::Playback::MediaBreakSkippedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaBreak());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaBreakSkippedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaBreakSkippedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBreakSkippedEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaBreakSkippedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaBreakSkippedEventArgs[] = {
        { const_cast<char*>("media_break"), (getter)MediaBreakSkippedEventArgs_get_MediaBreak, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaBreakSkippedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaBreakSkippedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaBreakSkippedEventArgs },
        { Py_tp_methods, _methods_MediaBreakSkippedEventArgs },
        { Py_tp_getset, _getset_MediaBreakSkippedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaBreakSkippedEventArgs =
    {
        "_winrt_Windows_Media_Playback.MediaBreakSkippedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaBreakSkippedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBreakSkippedEventArgs
    };

    // ----- MediaBreakStartedEventArgs class --------------------
    constexpr const char* const _type_name_MediaBreakStartedEventArgs = "MediaBreakStartedEventArgs";

    static PyObject* _new_MediaBreakStartedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaBreakStartedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaBreakStartedEventArgs(py::wrapper::Windows::Media::Playback::MediaBreakStartedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaBreakStartedEventArgs_get_MediaBreak(py::wrapper::Windows::Media::Playback::MediaBreakStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaBreak());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaBreakStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaBreakStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBreakStartedEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaBreakStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaBreakStartedEventArgs[] = {
        { const_cast<char*>("media_break"), (getter)MediaBreakStartedEventArgs_get_MediaBreak, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaBreakStartedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaBreakStartedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaBreakStartedEventArgs },
        { Py_tp_methods, _methods_MediaBreakStartedEventArgs },
        { Py_tp_getset, _getset_MediaBreakStartedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaBreakStartedEventArgs =
    {
        "_winrt_Windows_Media_Playback.MediaBreakStartedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaBreakStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBreakStartedEventArgs
    };

    // ----- MediaItemDisplayProperties class --------------------
    constexpr const char* const _type_name_MediaItemDisplayProperties = "MediaItemDisplayProperties";

    static PyObject* _new_MediaItemDisplayProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaItemDisplayProperties);
        return nullptr;
    }

    static void _dealloc_MediaItemDisplayProperties(py::wrapper::Windows::Media::Playback::MediaItemDisplayProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaItemDisplayProperties_ClearAll(py::wrapper::Windows::Media::Playback::MediaItemDisplayProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ClearAll();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaItemDisplayProperties_get_Type(py::wrapper::Windows::Media::Playback::MediaItemDisplayProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaItemDisplayProperties_put_Type(py::wrapper::Windows::Media::Playback::MediaItemDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaPlaybackType>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaItemDisplayProperties_get_Thumbnail(py::wrapper::Windows::Media::Playback::MediaItemDisplayProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaItemDisplayProperties_put_Thumbnail(py::wrapper::Windows::Media::Playback::MediaItemDisplayProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::RandomAccessStreamReference>(arg);

            self->obj.Thumbnail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaItemDisplayProperties_get_MusicProperties(py::wrapper::Windows::Media::Playback::MediaItemDisplayProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MusicProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaItemDisplayProperties_get_VideoProperties(py::wrapper::Windows::Media::Playback::MediaItemDisplayProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaItemDisplayProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaItemDisplayProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaItemDisplayProperties[] = {
        { "clear_all", (PyCFunction)MediaItemDisplayProperties_ClearAll, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaItemDisplayProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaItemDisplayProperties[] = {
        { const_cast<char*>("type"), (getter)MediaItemDisplayProperties_get_Type, (setter)MediaItemDisplayProperties_put_Type, nullptr, nullptr },
        { const_cast<char*>("thumbnail"), (getter)MediaItemDisplayProperties_get_Thumbnail, (setter)MediaItemDisplayProperties_put_Thumbnail, nullptr, nullptr },
        { const_cast<char*>("music_properties"), (getter)MediaItemDisplayProperties_get_MusicProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("video_properties"), (getter)MediaItemDisplayProperties_get_VideoProperties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaItemDisplayProperties[] = 
    {
        { Py_tp_new, _new_MediaItemDisplayProperties },
        { Py_tp_dealloc, _dealloc_MediaItemDisplayProperties },
        { Py_tp_methods, _methods_MediaItemDisplayProperties },
        { Py_tp_getset, _getset_MediaItemDisplayProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaItemDisplayProperties =
    {
        "_winrt_Windows_Media_Playback.MediaItemDisplayProperties",
        sizeof(py::wrapper::Windows::Media::Playback::MediaItemDisplayProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaItemDisplayProperties
    };

    // ----- MediaPlaybackAudioTrackList class --------------------
    constexpr const char* const _type_name_MediaPlaybackAudioTrackList = "MediaPlaybackAudioTrackList";

    static PyObject* _new_MediaPlaybackAudioTrackList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackAudioTrackList);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackAudioTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackAudioTrackList_First(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackAudioTrackList_GetAt(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackAudioTrackList_GetMany(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Media::Core::AudioTrack>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Media::Core::AudioTrack> param1 ( param1_count, py::empty_instance<winrt::Windows::Media::Core::AudioTrack>::get() );

                auto return_value = self->obj.GetMany(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackAudioTrackList_IndexOf(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::AudioTrack>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackAudioTrackList_get_Size(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackAudioTrackList_get_SelectedIndex(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SelectedIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackAudioTrackList_put_SelectedIndex(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SelectedIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackAudioTrackList_add_SelectedIndexChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::ISingleSelectMediaTrackList, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SelectedIndexChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackAudioTrackList_remove_SelectedIndexChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SelectedIndexChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlaybackAudioTrackList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackAudioTrackList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_MediaPlaybackAudioTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_MediaPlaybackAudioTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_MediaPlaybackAudioTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackAudioTrackList[] = {
        { "first", (PyCFunction)MediaPlaybackAudioTrackList_First, METH_VARARGS, nullptr },
        { "get_at", (PyCFunction)MediaPlaybackAudioTrackList_GetAt, METH_VARARGS, nullptr },
        { "get_many", (PyCFunction)MediaPlaybackAudioTrackList_GetMany, METH_VARARGS, nullptr },
        { "index_of", (PyCFunction)MediaPlaybackAudioTrackList_IndexOf, METH_VARARGS, nullptr },
        { "add_selected_index_changed", (PyCFunction)MediaPlaybackAudioTrackList_add_SelectedIndexChanged, METH_O, nullptr },
        { "remove_selected_index_changed", (PyCFunction)MediaPlaybackAudioTrackList_remove_SelectedIndexChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MediaPlaybackAudioTrackList, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackAudioTrackList[] = {
        { const_cast<char*>("size"), (getter)MediaPlaybackAudioTrackList_get_Size, nullptr, nullptr, nullptr },
        { const_cast<char*>("selected_index"), (getter)MediaPlaybackAudioTrackList_get_SelectedIndex, (setter)MediaPlaybackAudioTrackList_put_SelectedIndex, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackAudioTrackList[] = 
    {
        { Py_tp_new, _new_MediaPlaybackAudioTrackList },
        { Py_tp_dealloc, _dealloc_MediaPlaybackAudioTrackList },
        { Py_tp_methods, _methods_MediaPlaybackAudioTrackList },
        { Py_tp_getset, _getset_MediaPlaybackAudioTrackList },
        { Py_tp_iter, _iterator_MediaPlaybackAudioTrackList },
        { Py_sq_length, _seq_length_MediaPlaybackAudioTrackList },
        { Py_sq_item, _seq_item_MediaPlaybackAudioTrackList },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackAudioTrackList =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackAudioTrackList",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackAudioTrackList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackAudioTrackList
    };

    // ----- MediaPlaybackCommandManager class --------------------
    constexpr const char* const _type_name_MediaPlaybackCommandManager = "MediaPlaybackCommandManager";

    static PyObject* _new_MediaPlaybackCommandManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackCommandManager);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManager(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackCommandManager_get_IsEnabled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManager_put_IsEnabled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_AutoRepeatModeBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoRepeatModeBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_FastForwardBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FastForwardBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_MediaPlayer(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaPlayer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_NextBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NextBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_PauseBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PauseBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_PlayBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlayBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_PositionBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PositionBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_PreviousBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_RateBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RateBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_RewindBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RewindBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_get_ShuffleBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShuffleBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_add_AutoRepeatModeReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManager, winrt::Windows::Media::Playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs>>(arg);

            return py::convert(self->obj.AutoRepeatModeReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_remove_AutoRepeatModeReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AutoRepeatModeReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_add_FastForwardReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManager, winrt::Windows::Media::Playback::MediaPlaybackCommandManagerFastForwardReceivedEventArgs>>(arg);

            return py::convert(self->obj.FastForwardReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_remove_FastForwardReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FastForwardReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_add_NextReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManager, winrt::Windows::Media::Playback::MediaPlaybackCommandManagerNextReceivedEventArgs>>(arg);

            return py::convert(self->obj.NextReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_remove_NextReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NextReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_add_PauseReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManager, winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPauseReceivedEventArgs>>(arg);

            return py::convert(self->obj.PauseReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_remove_PauseReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PauseReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_add_PlayReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManager, winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPlayReceivedEventArgs>>(arg);

            return py::convert(self->obj.PlayReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_remove_PlayReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlayReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_add_PositionReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManager, winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPositionReceivedEventArgs>>(arg);

            return py::convert(self->obj.PositionReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_remove_PositionReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PositionReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_add_PreviousReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManager, winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPreviousReceivedEventArgs>>(arg);

            return py::convert(self->obj.PreviousReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_remove_PreviousReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PreviousReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_add_RateReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManager, winrt::Windows::Media::Playback::MediaPlaybackCommandManagerRateReceivedEventArgs>>(arg);

            return py::convert(self->obj.RateReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_remove_RateReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RateReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_add_RewindReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManager, winrt::Windows::Media::Playback::MediaPlaybackCommandManagerRewindReceivedEventArgs>>(arg);

            return py::convert(self->obj.RewindReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_remove_RewindReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RewindReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_add_ShuffleReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManager, winrt::Windows::Media::Playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs>>(arg);

            return py::convert(self->obj.ShuffleReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManager_remove_ShuffleReceived(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ShuffleReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlaybackCommandManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManager[] = {
        { "add_auto_repeat_mode_received", (PyCFunction)MediaPlaybackCommandManager_add_AutoRepeatModeReceived, METH_O, nullptr },
        { "remove_auto_repeat_mode_received", (PyCFunction)MediaPlaybackCommandManager_remove_AutoRepeatModeReceived, METH_O, nullptr },
        { "add_fast_forward_received", (PyCFunction)MediaPlaybackCommandManager_add_FastForwardReceived, METH_O, nullptr },
        { "remove_fast_forward_received", (PyCFunction)MediaPlaybackCommandManager_remove_FastForwardReceived, METH_O, nullptr },
        { "add_next_received", (PyCFunction)MediaPlaybackCommandManager_add_NextReceived, METH_O, nullptr },
        { "remove_next_received", (PyCFunction)MediaPlaybackCommandManager_remove_NextReceived, METH_O, nullptr },
        { "add_pause_received", (PyCFunction)MediaPlaybackCommandManager_add_PauseReceived, METH_O, nullptr },
        { "remove_pause_received", (PyCFunction)MediaPlaybackCommandManager_remove_PauseReceived, METH_O, nullptr },
        { "add_play_received", (PyCFunction)MediaPlaybackCommandManager_add_PlayReceived, METH_O, nullptr },
        { "remove_play_received", (PyCFunction)MediaPlaybackCommandManager_remove_PlayReceived, METH_O, nullptr },
        { "add_position_received", (PyCFunction)MediaPlaybackCommandManager_add_PositionReceived, METH_O, nullptr },
        { "remove_position_received", (PyCFunction)MediaPlaybackCommandManager_remove_PositionReceived, METH_O, nullptr },
        { "add_previous_received", (PyCFunction)MediaPlaybackCommandManager_add_PreviousReceived, METH_O, nullptr },
        { "remove_previous_received", (PyCFunction)MediaPlaybackCommandManager_remove_PreviousReceived, METH_O, nullptr },
        { "add_rate_received", (PyCFunction)MediaPlaybackCommandManager_add_RateReceived, METH_O, nullptr },
        { "remove_rate_received", (PyCFunction)MediaPlaybackCommandManager_remove_RateReceived, METH_O, nullptr },
        { "add_rewind_received", (PyCFunction)MediaPlaybackCommandManager_add_RewindReceived, METH_O, nullptr },
        { "remove_rewind_received", (PyCFunction)MediaPlaybackCommandManager_remove_RewindReceived, METH_O, nullptr },
        { "add_shuffle_received", (PyCFunction)MediaPlaybackCommandManager_add_ShuffleReceived, METH_O, nullptr },
        { "remove_shuffle_received", (PyCFunction)MediaPlaybackCommandManager_remove_ShuffleReceived, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MediaPlaybackCommandManager, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManager[] = {
        { const_cast<char*>("is_enabled"), (getter)MediaPlaybackCommandManager_get_IsEnabled, (setter)MediaPlaybackCommandManager_put_IsEnabled, nullptr, nullptr },
        { const_cast<char*>("auto_repeat_mode_behavior"), (getter)MediaPlaybackCommandManager_get_AutoRepeatModeBehavior, nullptr, nullptr, nullptr },
        { const_cast<char*>("fast_forward_behavior"), (getter)MediaPlaybackCommandManager_get_FastForwardBehavior, nullptr, nullptr, nullptr },
        { const_cast<char*>("media_player"), (getter)MediaPlaybackCommandManager_get_MediaPlayer, nullptr, nullptr, nullptr },
        { const_cast<char*>("next_behavior"), (getter)MediaPlaybackCommandManager_get_NextBehavior, nullptr, nullptr, nullptr },
        { const_cast<char*>("pause_behavior"), (getter)MediaPlaybackCommandManager_get_PauseBehavior, nullptr, nullptr, nullptr },
        { const_cast<char*>("play_behavior"), (getter)MediaPlaybackCommandManager_get_PlayBehavior, nullptr, nullptr, nullptr },
        { const_cast<char*>("position_behavior"), (getter)MediaPlaybackCommandManager_get_PositionBehavior, nullptr, nullptr, nullptr },
        { const_cast<char*>("previous_behavior"), (getter)MediaPlaybackCommandManager_get_PreviousBehavior, nullptr, nullptr, nullptr },
        { const_cast<char*>("rate_behavior"), (getter)MediaPlaybackCommandManager_get_RateBehavior, nullptr, nullptr, nullptr },
        { const_cast<char*>("rewind_behavior"), (getter)MediaPlaybackCommandManager_get_RewindBehavior, nullptr, nullptr, nullptr },
        { const_cast<char*>("shuffle_behavior"), (getter)MediaPlaybackCommandManager_get_ShuffleBehavior, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManager[] = 
    {
        { Py_tp_new, _new_MediaPlaybackCommandManager },
        { Py_tp_dealloc, _dealloc_MediaPlaybackCommandManager },
        { Py_tp_methods, _methods_MediaPlaybackCommandManager },
        { Py_tp_getset, _getset_MediaPlaybackCommandManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackCommandManager =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackCommandManager",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManager
    };

    // ----- MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs class --------------------
    constexpr const char* const _type_name_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs = "MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs";

    static PyObject* _new_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs_GetDeferral(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs_get_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs_put_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs_get_AutoRepeatMode(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoRepeatMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs[] = {
        { "get_deferral", (PyCFunction)MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs[] = {
        { const_cast<char*>("handled"), (getter)MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs_get_Handled, (setter)MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs_put_Handled, nullptr, nullptr },
        { const_cast<char*>("auto_repeat_mode"), (getter)MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs_get_AutoRepeatMode, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs },
        { Py_tp_methods, _methods_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs },
        { Py_tp_getset, _getset_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs
    };

    // ----- MediaPlaybackCommandManagerCommandBehavior class --------------------
    constexpr const char* const _type_name_MediaPlaybackCommandManagerCommandBehavior = "MediaPlaybackCommandManagerCommandBehavior";

    static PyObject* _new_MediaPlaybackCommandManagerCommandBehavior(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackCommandManagerCommandBehavior);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerCommandBehavior(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackCommandManagerCommandBehavior_get_EnablingRule(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EnablingRule());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerCommandBehavior_put_EnablingRule(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaCommandEnablingRule>(arg);

            self->obj.EnablingRule(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackCommandManagerCommandBehavior_get_CommandManager(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CommandManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerCommandBehavior_get_IsEnabled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerCommandBehavior_add_IsEnabledChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsEnabledChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerCommandBehavior_remove_IsEnabledChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsEnabledChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlaybackCommandManagerCommandBehavior(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerCommandBehavior[] = {
        { "add_is_enabled_changed", (PyCFunction)MediaPlaybackCommandManagerCommandBehavior_add_IsEnabledChanged, METH_O, nullptr },
        { "remove_is_enabled_changed", (PyCFunction)MediaPlaybackCommandManagerCommandBehavior_remove_IsEnabledChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MediaPlaybackCommandManagerCommandBehavior, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerCommandBehavior[] = {
        { const_cast<char*>("enabling_rule"), (getter)MediaPlaybackCommandManagerCommandBehavior_get_EnablingRule, (setter)MediaPlaybackCommandManagerCommandBehavior_put_EnablingRule, nullptr, nullptr },
        { const_cast<char*>("command_manager"), (getter)MediaPlaybackCommandManagerCommandBehavior_get_CommandManager, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_enabled"), (getter)MediaPlaybackCommandManagerCommandBehavior_get_IsEnabled, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerCommandBehavior[] = 
    {
        { Py_tp_new, _new_MediaPlaybackCommandManagerCommandBehavior },
        { Py_tp_dealloc, _dealloc_MediaPlaybackCommandManagerCommandBehavior },
        { Py_tp_methods, _methods_MediaPlaybackCommandManagerCommandBehavior },
        { Py_tp_getset, _getset_MediaPlaybackCommandManagerCommandBehavior },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackCommandManagerCommandBehavior =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackCommandManagerCommandBehavior",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerCommandBehavior
    };

    // ----- MediaPlaybackCommandManagerFastForwardReceivedEventArgs class --------------------
    constexpr const char* const _type_name_MediaPlaybackCommandManagerFastForwardReceivedEventArgs = "MediaPlaybackCommandManagerFastForwardReceivedEventArgs";

    static PyObject* _new_MediaPlaybackCommandManagerFastForwardReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackCommandManagerFastForwardReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerFastForwardReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerFastForwardReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackCommandManagerFastForwardReceivedEventArgs_GetDeferral(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerFastForwardReceivedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerFastForwardReceivedEventArgs_get_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerFastForwardReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerFastForwardReceivedEventArgs_put_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerFastForwardReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_MediaPlaybackCommandManagerFastForwardReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerFastForwardReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerFastForwardReceivedEventArgs[] = {
        { "get_deferral", (PyCFunction)MediaPlaybackCommandManagerFastForwardReceivedEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaPlaybackCommandManagerFastForwardReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerFastForwardReceivedEventArgs[] = {
        { const_cast<char*>("handled"), (getter)MediaPlaybackCommandManagerFastForwardReceivedEventArgs_get_Handled, (setter)MediaPlaybackCommandManagerFastForwardReceivedEventArgs_put_Handled, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerFastForwardReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaPlaybackCommandManagerFastForwardReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaPlaybackCommandManagerFastForwardReceivedEventArgs },
        { Py_tp_methods, _methods_MediaPlaybackCommandManagerFastForwardReceivedEventArgs },
        { Py_tp_getset, _getset_MediaPlaybackCommandManagerFastForwardReceivedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackCommandManagerFastForwardReceivedEventArgs =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackCommandManagerFastForwardReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerFastForwardReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerFastForwardReceivedEventArgs
    };

    // ----- MediaPlaybackCommandManagerNextReceivedEventArgs class --------------------
    constexpr const char* const _type_name_MediaPlaybackCommandManagerNextReceivedEventArgs = "MediaPlaybackCommandManagerNextReceivedEventArgs";

    static PyObject* _new_MediaPlaybackCommandManagerNextReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackCommandManagerNextReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerNextReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerNextReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackCommandManagerNextReceivedEventArgs_GetDeferral(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerNextReceivedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerNextReceivedEventArgs_get_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerNextReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerNextReceivedEventArgs_put_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerNextReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_MediaPlaybackCommandManagerNextReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerNextReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerNextReceivedEventArgs[] = {
        { "get_deferral", (PyCFunction)MediaPlaybackCommandManagerNextReceivedEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaPlaybackCommandManagerNextReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerNextReceivedEventArgs[] = {
        { const_cast<char*>("handled"), (getter)MediaPlaybackCommandManagerNextReceivedEventArgs_get_Handled, (setter)MediaPlaybackCommandManagerNextReceivedEventArgs_put_Handled, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerNextReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaPlaybackCommandManagerNextReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaPlaybackCommandManagerNextReceivedEventArgs },
        { Py_tp_methods, _methods_MediaPlaybackCommandManagerNextReceivedEventArgs },
        { Py_tp_getset, _getset_MediaPlaybackCommandManagerNextReceivedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackCommandManagerNextReceivedEventArgs =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackCommandManagerNextReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerNextReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerNextReceivedEventArgs
    };

    // ----- MediaPlaybackCommandManagerPauseReceivedEventArgs class --------------------
    constexpr const char* const _type_name_MediaPlaybackCommandManagerPauseReceivedEventArgs = "MediaPlaybackCommandManagerPauseReceivedEventArgs";

    static PyObject* _new_MediaPlaybackCommandManagerPauseReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackCommandManagerPauseReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerPauseReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPauseReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackCommandManagerPauseReceivedEventArgs_GetDeferral(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPauseReceivedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerPauseReceivedEventArgs_get_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPauseReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerPauseReceivedEventArgs_put_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPauseReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_MediaPlaybackCommandManagerPauseReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPauseReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerPauseReceivedEventArgs[] = {
        { "get_deferral", (PyCFunction)MediaPlaybackCommandManagerPauseReceivedEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaPlaybackCommandManagerPauseReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerPauseReceivedEventArgs[] = {
        { const_cast<char*>("handled"), (getter)MediaPlaybackCommandManagerPauseReceivedEventArgs_get_Handled, (setter)MediaPlaybackCommandManagerPauseReceivedEventArgs_put_Handled, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerPauseReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaPlaybackCommandManagerPauseReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaPlaybackCommandManagerPauseReceivedEventArgs },
        { Py_tp_methods, _methods_MediaPlaybackCommandManagerPauseReceivedEventArgs },
        { Py_tp_getset, _getset_MediaPlaybackCommandManagerPauseReceivedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackCommandManagerPauseReceivedEventArgs =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackCommandManagerPauseReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPauseReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerPauseReceivedEventArgs
    };

    // ----- MediaPlaybackCommandManagerPlayReceivedEventArgs class --------------------
    constexpr const char* const _type_name_MediaPlaybackCommandManagerPlayReceivedEventArgs = "MediaPlaybackCommandManagerPlayReceivedEventArgs";

    static PyObject* _new_MediaPlaybackCommandManagerPlayReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackCommandManagerPlayReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerPlayReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPlayReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackCommandManagerPlayReceivedEventArgs_GetDeferral(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPlayReceivedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerPlayReceivedEventArgs_get_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPlayReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerPlayReceivedEventArgs_put_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPlayReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_MediaPlaybackCommandManagerPlayReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPlayReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerPlayReceivedEventArgs[] = {
        { "get_deferral", (PyCFunction)MediaPlaybackCommandManagerPlayReceivedEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaPlaybackCommandManagerPlayReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerPlayReceivedEventArgs[] = {
        { const_cast<char*>("handled"), (getter)MediaPlaybackCommandManagerPlayReceivedEventArgs_get_Handled, (setter)MediaPlaybackCommandManagerPlayReceivedEventArgs_put_Handled, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerPlayReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaPlaybackCommandManagerPlayReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaPlaybackCommandManagerPlayReceivedEventArgs },
        { Py_tp_methods, _methods_MediaPlaybackCommandManagerPlayReceivedEventArgs },
        { Py_tp_getset, _getset_MediaPlaybackCommandManagerPlayReceivedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackCommandManagerPlayReceivedEventArgs =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackCommandManagerPlayReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPlayReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerPlayReceivedEventArgs
    };

    // ----- MediaPlaybackCommandManagerPositionReceivedEventArgs class --------------------
    constexpr const char* const _type_name_MediaPlaybackCommandManagerPositionReceivedEventArgs = "MediaPlaybackCommandManagerPositionReceivedEventArgs";

    static PyObject* _new_MediaPlaybackCommandManagerPositionReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackCommandManagerPositionReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerPositionReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPositionReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackCommandManagerPositionReceivedEventArgs_GetDeferral(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPositionReceivedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerPositionReceivedEventArgs_get_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPositionReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerPositionReceivedEventArgs_put_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPositionReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackCommandManagerPositionReceivedEventArgs_get_Position(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPositionReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlaybackCommandManagerPositionReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPositionReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerPositionReceivedEventArgs[] = {
        { "get_deferral", (PyCFunction)MediaPlaybackCommandManagerPositionReceivedEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaPlaybackCommandManagerPositionReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerPositionReceivedEventArgs[] = {
        { const_cast<char*>("handled"), (getter)MediaPlaybackCommandManagerPositionReceivedEventArgs_get_Handled, (setter)MediaPlaybackCommandManagerPositionReceivedEventArgs_put_Handled, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)MediaPlaybackCommandManagerPositionReceivedEventArgs_get_Position, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerPositionReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaPlaybackCommandManagerPositionReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaPlaybackCommandManagerPositionReceivedEventArgs },
        { Py_tp_methods, _methods_MediaPlaybackCommandManagerPositionReceivedEventArgs },
        { Py_tp_getset, _getset_MediaPlaybackCommandManagerPositionReceivedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackCommandManagerPositionReceivedEventArgs =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackCommandManagerPositionReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPositionReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerPositionReceivedEventArgs
    };

    // ----- MediaPlaybackCommandManagerPreviousReceivedEventArgs class --------------------
    constexpr const char* const _type_name_MediaPlaybackCommandManagerPreviousReceivedEventArgs = "MediaPlaybackCommandManagerPreviousReceivedEventArgs";

    static PyObject* _new_MediaPlaybackCommandManagerPreviousReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackCommandManagerPreviousReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerPreviousReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPreviousReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackCommandManagerPreviousReceivedEventArgs_GetDeferral(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPreviousReceivedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerPreviousReceivedEventArgs_get_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPreviousReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerPreviousReceivedEventArgs_put_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPreviousReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_MediaPlaybackCommandManagerPreviousReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPreviousReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerPreviousReceivedEventArgs[] = {
        { "get_deferral", (PyCFunction)MediaPlaybackCommandManagerPreviousReceivedEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaPlaybackCommandManagerPreviousReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerPreviousReceivedEventArgs[] = {
        { const_cast<char*>("handled"), (getter)MediaPlaybackCommandManagerPreviousReceivedEventArgs_get_Handled, (setter)MediaPlaybackCommandManagerPreviousReceivedEventArgs_put_Handled, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerPreviousReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaPlaybackCommandManagerPreviousReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaPlaybackCommandManagerPreviousReceivedEventArgs },
        { Py_tp_methods, _methods_MediaPlaybackCommandManagerPreviousReceivedEventArgs },
        { Py_tp_getset, _getset_MediaPlaybackCommandManagerPreviousReceivedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackCommandManagerPreviousReceivedEventArgs =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackCommandManagerPreviousReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerPreviousReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerPreviousReceivedEventArgs
    };

    // ----- MediaPlaybackCommandManagerRateReceivedEventArgs class --------------------
    constexpr const char* const _type_name_MediaPlaybackCommandManagerRateReceivedEventArgs = "MediaPlaybackCommandManagerRateReceivedEventArgs";

    static PyObject* _new_MediaPlaybackCommandManagerRateReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackCommandManagerRateReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerRateReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRateReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackCommandManagerRateReceivedEventArgs_GetDeferral(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRateReceivedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerRateReceivedEventArgs_get_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRateReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerRateReceivedEventArgs_put_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRateReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackCommandManagerRateReceivedEventArgs_get_PlaybackRate(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRateReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlaybackCommandManagerRateReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerRateReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerRateReceivedEventArgs[] = {
        { "get_deferral", (PyCFunction)MediaPlaybackCommandManagerRateReceivedEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaPlaybackCommandManagerRateReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerRateReceivedEventArgs[] = {
        { const_cast<char*>("handled"), (getter)MediaPlaybackCommandManagerRateReceivedEventArgs_get_Handled, (setter)MediaPlaybackCommandManagerRateReceivedEventArgs_put_Handled, nullptr, nullptr },
        { const_cast<char*>("playback_rate"), (getter)MediaPlaybackCommandManagerRateReceivedEventArgs_get_PlaybackRate, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerRateReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaPlaybackCommandManagerRateReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaPlaybackCommandManagerRateReceivedEventArgs },
        { Py_tp_methods, _methods_MediaPlaybackCommandManagerRateReceivedEventArgs },
        { Py_tp_getset, _getset_MediaPlaybackCommandManagerRateReceivedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackCommandManagerRateReceivedEventArgs =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackCommandManagerRateReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRateReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerRateReceivedEventArgs
    };

    // ----- MediaPlaybackCommandManagerRewindReceivedEventArgs class --------------------
    constexpr const char* const _type_name_MediaPlaybackCommandManagerRewindReceivedEventArgs = "MediaPlaybackCommandManagerRewindReceivedEventArgs";

    static PyObject* _new_MediaPlaybackCommandManagerRewindReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackCommandManagerRewindReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerRewindReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRewindReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackCommandManagerRewindReceivedEventArgs_GetDeferral(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRewindReceivedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerRewindReceivedEventArgs_get_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRewindReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerRewindReceivedEventArgs_put_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRewindReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_MediaPlaybackCommandManagerRewindReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerRewindReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerRewindReceivedEventArgs[] = {
        { "get_deferral", (PyCFunction)MediaPlaybackCommandManagerRewindReceivedEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaPlaybackCommandManagerRewindReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerRewindReceivedEventArgs[] = {
        { const_cast<char*>("handled"), (getter)MediaPlaybackCommandManagerRewindReceivedEventArgs_get_Handled, (setter)MediaPlaybackCommandManagerRewindReceivedEventArgs_put_Handled, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerRewindReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaPlaybackCommandManagerRewindReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaPlaybackCommandManagerRewindReceivedEventArgs },
        { Py_tp_methods, _methods_MediaPlaybackCommandManagerRewindReceivedEventArgs },
        { Py_tp_getset, _getset_MediaPlaybackCommandManagerRewindReceivedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackCommandManagerRewindReceivedEventArgs =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackCommandManagerRewindReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerRewindReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerRewindReceivedEventArgs
    };

    // ----- MediaPlaybackCommandManagerShuffleReceivedEventArgs class --------------------
    constexpr const char* const _type_name_MediaPlaybackCommandManagerShuffleReceivedEventArgs = "MediaPlaybackCommandManagerShuffleReceivedEventArgs";

    static PyObject* _new_MediaPlaybackCommandManagerShuffleReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackCommandManagerShuffleReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackCommandManagerShuffleReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackCommandManagerShuffleReceivedEventArgs_GetDeferral(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackCommandManagerShuffleReceivedEventArgs_get_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackCommandManagerShuffleReceivedEventArgs_put_Handled(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackCommandManagerShuffleReceivedEventArgs_get_IsShuffleRequested(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsShuffleRequested());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlaybackCommandManagerShuffleReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackCommandManagerShuffleReceivedEventArgs[] = {
        { "get_deferral", (PyCFunction)MediaPlaybackCommandManagerShuffleReceivedEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaPlaybackCommandManagerShuffleReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackCommandManagerShuffleReceivedEventArgs[] = {
        { const_cast<char*>("handled"), (getter)MediaPlaybackCommandManagerShuffleReceivedEventArgs_get_Handled, (setter)MediaPlaybackCommandManagerShuffleReceivedEventArgs_put_Handled, nullptr, nullptr },
        { const_cast<char*>("is_shuffle_requested"), (getter)MediaPlaybackCommandManagerShuffleReceivedEventArgs_get_IsShuffleRequested, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackCommandManagerShuffleReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaPlaybackCommandManagerShuffleReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaPlaybackCommandManagerShuffleReceivedEventArgs },
        { Py_tp_methods, _methods_MediaPlaybackCommandManagerShuffleReceivedEventArgs },
        { Py_tp_getset, _getset_MediaPlaybackCommandManagerShuffleReceivedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackCommandManagerShuffleReceivedEventArgs =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackCommandManagerShuffleReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackCommandManagerShuffleReceivedEventArgs
    };

    // ----- MediaPlaybackItem class --------------------
    constexpr const char* const _type_name_MediaPlaybackItem = "MediaPlaybackItem";

    static PyObject* _new_MediaPlaybackItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaSource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                winrt::Windows::Media::Playback::MediaPlaybackItem instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaSource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);

                winrt::Windows::Media::Playback::MediaPlaybackItem instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaSource>(args, 0);

                winrt::Windows::Media::Playback::MediaPlaybackItem instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaPlaybackItem(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackItem_ApplyDisplayProperties(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaItemDisplayProperties>(args, 0);

                self->obj.ApplyDisplayProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_FindFromMediaSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaSource>(args, 0);

                return py::convert(winrt::Windows::Media::Playback::MediaPlaybackItem::FindFromMediaSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_GetDisplayProperties(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDisplayProperties());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_get_AudioTracks(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioTracks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_get_Source(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_get_TimedMetadataTracks(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimedMetadataTracks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_get_VideoTracks(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoTracks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_get_CanSkip(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanSkip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackItem_put_CanSkip(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanSkip(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackItem_get_BreakSchedule(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BreakSchedule());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_get_DurationLimit(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DurationLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_get_StartTime(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_get_IsDisabledInPlaybackList(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDisabledInPlaybackList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackItem_put_IsDisabledInPlaybackList(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDisabledInPlaybackList(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackItem_get_AutoLoadedDisplayProperties(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoLoadedDisplayProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackItem_put_AutoLoadedDisplayProperties(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::AutoLoadedDisplayPropertyKind>(arg);

            self->obj.AutoLoadedDisplayProperties(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackItem_get_TotalDownloadProgress(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalDownloadProgress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_add_AudioTracksChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackItem, winrt::Windows::Foundation::Collections::IVectorChangedEventArgs>>(arg);

            return py::convert(self->obj.AudioTracksChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_remove_AudioTracksChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioTracksChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_add_TimedMetadataTracksChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackItem, winrt::Windows::Foundation::Collections::IVectorChangedEventArgs>>(arg);

            return py::convert(self->obj.TimedMetadataTracksChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_remove_TimedMetadataTracksChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TimedMetadataTracksChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_add_VideoTracksChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackItem, winrt::Windows::Foundation::Collections::IVectorChangedEventArgs>>(arg);

            return py::convert(self->obj.VideoTracksChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItem_remove_VideoTracksChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackItem* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VideoTracksChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlaybackItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackItem[] = {
        { "apply_display_properties", (PyCFunction)MediaPlaybackItem_ApplyDisplayProperties, METH_VARARGS, nullptr },
        { "find_from_media_source", (PyCFunction)MediaPlaybackItem_FindFromMediaSource, METH_VARARGS | METH_STATIC, nullptr },
        { "get_display_properties", (PyCFunction)MediaPlaybackItem_GetDisplayProperties, METH_VARARGS, nullptr },
        { "add_audio_tracks_changed", (PyCFunction)MediaPlaybackItem_add_AudioTracksChanged, METH_O, nullptr },
        { "remove_audio_tracks_changed", (PyCFunction)MediaPlaybackItem_remove_AudioTracksChanged, METH_O, nullptr },
        { "add_timed_metadata_tracks_changed", (PyCFunction)MediaPlaybackItem_add_TimedMetadataTracksChanged, METH_O, nullptr },
        { "remove_timed_metadata_tracks_changed", (PyCFunction)MediaPlaybackItem_remove_TimedMetadataTracksChanged, METH_O, nullptr },
        { "add_video_tracks_changed", (PyCFunction)MediaPlaybackItem_add_VideoTracksChanged, METH_O, nullptr },
        { "remove_video_tracks_changed", (PyCFunction)MediaPlaybackItem_remove_VideoTracksChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MediaPlaybackItem, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackItem[] = {
        { const_cast<char*>("audio_tracks"), (getter)MediaPlaybackItem_get_AudioTracks, nullptr, nullptr, nullptr },
        { const_cast<char*>("source"), (getter)MediaPlaybackItem_get_Source, nullptr, nullptr, nullptr },
        { const_cast<char*>("timed_metadata_tracks"), (getter)MediaPlaybackItem_get_TimedMetadataTracks, nullptr, nullptr, nullptr },
        { const_cast<char*>("video_tracks"), (getter)MediaPlaybackItem_get_VideoTracks, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_skip"), (getter)MediaPlaybackItem_get_CanSkip, (setter)MediaPlaybackItem_put_CanSkip, nullptr, nullptr },
        { const_cast<char*>("break_schedule"), (getter)MediaPlaybackItem_get_BreakSchedule, nullptr, nullptr, nullptr },
        { const_cast<char*>("duration_limit"), (getter)MediaPlaybackItem_get_DurationLimit, nullptr, nullptr, nullptr },
        { const_cast<char*>("start_time"), (getter)MediaPlaybackItem_get_StartTime, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_disabled_in_playback_list"), (getter)MediaPlaybackItem_get_IsDisabledInPlaybackList, (setter)MediaPlaybackItem_put_IsDisabledInPlaybackList, nullptr, nullptr },
        { const_cast<char*>("auto_loaded_display_properties"), (getter)MediaPlaybackItem_get_AutoLoadedDisplayProperties, (setter)MediaPlaybackItem_put_AutoLoadedDisplayProperties, nullptr, nullptr },
        { const_cast<char*>("total_download_progress"), (getter)MediaPlaybackItem_get_TotalDownloadProgress, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackItem[] = 
    {
        { Py_tp_new, _new_MediaPlaybackItem },
        { Py_tp_dealloc, _dealloc_MediaPlaybackItem },
        { Py_tp_methods, _methods_MediaPlaybackItem },
        { Py_tp_getset, _getset_MediaPlaybackItem },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackItem =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackItem",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackItem
    };

    // ----- MediaPlaybackItemError class --------------------
    constexpr const char* const _type_name_MediaPlaybackItemError = "MediaPlaybackItemError";

    static PyObject* _new_MediaPlaybackItemError(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackItemError);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackItemError(py::wrapper::Windows::Media::Playback::MediaPlaybackItemError* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackItemError_get_ErrorCode(py::wrapper::Windows::Media::Playback::MediaPlaybackItemError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItemError_get_ExtendedError(py::wrapper::Windows::Media::Playback::MediaPlaybackItemError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlaybackItemError(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackItemError>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackItemError[] = {
        { "_from", (PyCFunction)_from_MediaPlaybackItemError, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackItemError[] = {
        { const_cast<char*>("error_code"), (getter)MediaPlaybackItemError_get_ErrorCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_error"), (getter)MediaPlaybackItemError_get_ExtendedError, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackItemError[] = 
    {
        { Py_tp_new, _new_MediaPlaybackItemError },
        { Py_tp_dealloc, _dealloc_MediaPlaybackItemError },
        { Py_tp_methods, _methods_MediaPlaybackItemError },
        { Py_tp_getset, _getset_MediaPlaybackItemError },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackItemError =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackItemError",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackItemError),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackItemError
    };

    // ----- MediaPlaybackItemFailedEventArgs class --------------------
    constexpr const char* const _type_name_MediaPlaybackItemFailedEventArgs = "MediaPlaybackItemFailedEventArgs";

    static PyObject* _new_MediaPlaybackItemFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackItemFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackItemFailedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackItemFailedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackItemFailedEventArgs_get_Error(py::wrapper::Windows::Media::Playback::MediaPlaybackItemFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackItemFailedEventArgs_get_Item(py::wrapper::Windows::Media::Playback::MediaPlaybackItemFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Item());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlaybackItemFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackItemFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackItemFailedEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaPlaybackItemFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackItemFailedEventArgs[] = {
        { const_cast<char*>("error"), (getter)MediaPlaybackItemFailedEventArgs_get_Error, nullptr, nullptr, nullptr },
        { const_cast<char*>("item"), (getter)MediaPlaybackItemFailedEventArgs_get_Item, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackItemFailedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaPlaybackItemFailedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaPlaybackItemFailedEventArgs },
        { Py_tp_methods, _methods_MediaPlaybackItemFailedEventArgs },
        { Py_tp_getset, _getset_MediaPlaybackItemFailedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackItemFailedEventArgs =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackItemFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackItemFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackItemFailedEventArgs
    };

    // ----- MediaPlaybackItemOpenedEventArgs class --------------------
    constexpr const char* const _type_name_MediaPlaybackItemOpenedEventArgs = "MediaPlaybackItemOpenedEventArgs";

    static PyObject* _new_MediaPlaybackItemOpenedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackItemOpenedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackItemOpenedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackItemOpenedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackItemOpenedEventArgs_get_Item(py::wrapper::Windows::Media::Playback::MediaPlaybackItemOpenedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Item());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlaybackItemOpenedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackItemOpenedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackItemOpenedEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaPlaybackItemOpenedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackItemOpenedEventArgs[] = {
        { const_cast<char*>("item"), (getter)MediaPlaybackItemOpenedEventArgs_get_Item, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackItemOpenedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaPlaybackItemOpenedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaPlaybackItemOpenedEventArgs },
        { Py_tp_methods, _methods_MediaPlaybackItemOpenedEventArgs },
        { Py_tp_getset, _getset_MediaPlaybackItemOpenedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackItemOpenedEventArgs =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackItemOpenedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackItemOpenedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackItemOpenedEventArgs
    };

    // ----- MediaPlaybackList class --------------------
    constexpr const char* const _type_name_MediaPlaybackList = "MediaPlaybackList";

    static PyObject* _new_MediaPlaybackList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Playback::MediaPlaybackList instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaPlaybackList(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackList_MoveNext(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.MoveNext());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_MovePrevious(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.MovePrevious());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_MoveTo(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.MoveTo(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_SetShuffledItems(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Playback::MediaPlaybackItem>>(args, 0);

                self->obj.SetShuffledItems(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_get_ShuffleEnabled(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShuffleEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackList_put_ShuffleEnabled(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShuffleEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackList_get_AutoRepeatEnabled(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoRepeatEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackList_put_AutoRepeatEnabled(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoRepeatEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackList_get_CurrentItem(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_get_CurrentItemIndex(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentItemIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_get_Items(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_get_StartingItem(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartingItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackList_put_StartingItem(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaPlaybackItem>(arg);

            self->obj.StartingItem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackList_get_MaxPrefetchTime(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPrefetchTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackList_put_MaxPrefetchTime(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.MaxPrefetchTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackList_get_ShuffledItems(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShuffledItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_get_MaxPlayedItemsToKeepOpen(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPlayedItemsToKeepOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackList_put_MaxPlayedItemsToKeepOpen(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.MaxPlayedItemsToKeepOpen(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackList_add_CurrentItemChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackList, winrt::Windows::Media::Playback::CurrentMediaPlaybackItemChangedEventArgs>>(arg);

            return py::convert(self->obj.CurrentItemChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_remove_CurrentItemChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CurrentItemChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_add_ItemFailed(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackList, winrt::Windows::Media::Playback::MediaPlaybackItemFailedEventArgs>>(arg);

            return py::convert(self->obj.ItemFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_remove_ItemFailed(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ItemFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_add_ItemOpened(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackList, winrt::Windows::Media::Playback::MediaPlaybackItemOpenedEventArgs>>(arg);

            return py::convert(self->obj.ItemOpened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackList_remove_ItemOpened(py::wrapper::Windows::Media::Playback::MediaPlaybackList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ItemOpened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlaybackList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackList[] = {
        { "move_next", (PyCFunction)MediaPlaybackList_MoveNext, METH_VARARGS, nullptr },
        { "move_previous", (PyCFunction)MediaPlaybackList_MovePrevious, METH_VARARGS, nullptr },
        { "move_to", (PyCFunction)MediaPlaybackList_MoveTo, METH_VARARGS, nullptr },
        { "set_shuffled_items", (PyCFunction)MediaPlaybackList_SetShuffledItems, METH_VARARGS, nullptr },
        { "add_current_item_changed", (PyCFunction)MediaPlaybackList_add_CurrentItemChanged, METH_O, nullptr },
        { "remove_current_item_changed", (PyCFunction)MediaPlaybackList_remove_CurrentItemChanged, METH_O, nullptr },
        { "add_item_failed", (PyCFunction)MediaPlaybackList_add_ItemFailed, METH_O, nullptr },
        { "remove_item_failed", (PyCFunction)MediaPlaybackList_remove_ItemFailed, METH_O, nullptr },
        { "add_item_opened", (PyCFunction)MediaPlaybackList_add_ItemOpened, METH_O, nullptr },
        { "remove_item_opened", (PyCFunction)MediaPlaybackList_remove_ItemOpened, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MediaPlaybackList, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackList[] = {
        { const_cast<char*>("shuffle_enabled"), (getter)MediaPlaybackList_get_ShuffleEnabled, (setter)MediaPlaybackList_put_ShuffleEnabled, nullptr, nullptr },
        { const_cast<char*>("auto_repeat_enabled"), (getter)MediaPlaybackList_get_AutoRepeatEnabled, (setter)MediaPlaybackList_put_AutoRepeatEnabled, nullptr, nullptr },
        { const_cast<char*>("current_item"), (getter)MediaPlaybackList_get_CurrentItem, nullptr, nullptr, nullptr },
        { const_cast<char*>("current_item_index"), (getter)MediaPlaybackList_get_CurrentItemIndex, nullptr, nullptr, nullptr },
        { const_cast<char*>("items"), (getter)MediaPlaybackList_get_Items, nullptr, nullptr, nullptr },
        { const_cast<char*>("starting_item"), (getter)MediaPlaybackList_get_StartingItem, (setter)MediaPlaybackList_put_StartingItem, nullptr, nullptr },
        { const_cast<char*>("max_prefetch_time"), (getter)MediaPlaybackList_get_MaxPrefetchTime, (setter)MediaPlaybackList_put_MaxPrefetchTime, nullptr, nullptr },
        { const_cast<char*>("shuffled_items"), (getter)MediaPlaybackList_get_ShuffledItems, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_played_items_to_keep_open"), (getter)MediaPlaybackList_get_MaxPlayedItemsToKeepOpen, (setter)MediaPlaybackList_put_MaxPlayedItemsToKeepOpen, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackList[] = 
    {
        { Py_tp_new, _new_MediaPlaybackList },
        { Py_tp_dealloc, _dealloc_MediaPlaybackList },
        { Py_tp_methods, _methods_MediaPlaybackList },
        { Py_tp_getset, _getset_MediaPlaybackList },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackList =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackList",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackList
    };

    // ----- MediaPlaybackSession class --------------------
    constexpr const char* const _type_name_MediaPlaybackSession = "MediaPlaybackSession";

    static PyObject* _new_MediaPlaybackSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackSession);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackSession(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackSession_GetBufferedRanges(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetBufferedRanges());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_GetOutputDegradationPolicyState(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetOutputDegradationPolicyState());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_GetPlayedRanges(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPlayedRanges());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_GetSeekableRanges(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSeekableRanges());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_IsSupportedPlaybackRateRange(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                return py::convert(self->obj.IsSupportedPlaybackRateRange(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_StereoscopicVideoPackingMode(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StereoscopicVideoPackingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSession_put_StereoscopicVideoPackingMode(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::StereoscopicVideoPackingMode>(arg);

            self->obj.StereoscopicVideoPackingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackSession_get_Position(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSession_put_Position(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackSession_get_PlaybackRate(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSession_put_PlaybackRate(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.PlaybackRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackSession_get_NormalizedSourceRect(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NormalizedSourceRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSession_put_NormalizedSourceRect(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.NormalizedSourceRect(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackSession_get_BufferingProgress(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BufferingProgress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_CanPause(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanPause());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_CanSeek(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanSeek());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_DownloadProgress(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DownloadProgress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_IsProtected(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsProtected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_MediaPlayer(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaPlayer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_NaturalDuration(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NaturalDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_NaturalVideoHeight(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NaturalVideoHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_NaturalVideoWidth(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NaturalVideoWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_PlaybackState(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_IsMirroring(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsMirroring());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSession_put_IsMirroring(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMirroring(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackSession_get_SphericalVideoProjection(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SphericalVideoProjection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_get_PlaybackRotation(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackRotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSession_put_PlaybackRotation(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaRotation>(arg);

            self->obj.PlaybackRotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackSession_add_BufferingEnded(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.BufferingEnded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_BufferingEnded(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BufferingEnded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_BufferingProgressChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.BufferingProgressChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_BufferingProgressChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BufferingProgressChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_BufferingStarted(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.BufferingStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_BufferingStarted(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BufferingStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_DownloadProgressChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.DownloadProgressChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_DownloadProgressChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DownloadProgressChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_NaturalDurationChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.NaturalDurationChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_NaturalDurationChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NaturalDurationChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_NaturalVideoSizeChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.NaturalVideoSizeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_NaturalVideoSizeChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NaturalVideoSizeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_PlaybackRateChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.PlaybackRateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_PlaybackRateChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlaybackRateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_PlaybackStateChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.PlaybackStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_PlaybackStateChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlaybackStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_PositionChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.PositionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_PositionChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PositionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_SeekCompleted(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SeekCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_SeekCompleted(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SeekCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_BufferedRangesChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.BufferedRangesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_BufferedRangesChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BufferedRangesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_PlayedRangesChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.PlayedRangesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_PlayedRangesChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlayedRangesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_SeekableRangesChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SeekableRangesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_SeekableRangesChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SeekableRangesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_add_SupportedPlaybackRatesChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SupportedPlaybackRatesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackSession_remove_SupportedPlaybackRatesChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SupportedPlaybackRatesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlaybackSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackSession[] = {
        { "get_buffered_ranges", (PyCFunction)MediaPlaybackSession_GetBufferedRanges, METH_VARARGS, nullptr },
        { "get_output_degradation_policy_state", (PyCFunction)MediaPlaybackSession_GetOutputDegradationPolicyState, METH_VARARGS, nullptr },
        { "get_played_ranges", (PyCFunction)MediaPlaybackSession_GetPlayedRanges, METH_VARARGS, nullptr },
        { "get_seekable_ranges", (PyCFunction)MediaPlaybackSession_GetSeekableRanges, METH_VARARGS, nullptr },
        { "is_supported_playback_rate_range", (PyCFunction)MediaPlaybackSession_IsSupportedPlaybackRateRange, METH_VARARGS, nullptr },
        { "add_buffering_ended", (PyCFunction)MediaPlaybackSession_add_BufferingEnded, METH_O, nullptr },
        { "remove_buffering_ended", (PyCFunction)MediaPlaybackSession_remove_BufferingEnded, METH_O, nullptr },
        { "add_buffering_progress_changed", (PyCFunction)MediaPlaybackSession_add_BufferingProgressChanged, METH_O, nullptr },
        { "remove_buffering_progress_changed", (PyCFunction)MediaPlaybackSession_remove_BufferingProgressChanged, METH_O, nullptr },
        { "add_buffering_started", (PyCFunction)MediaPlaybackSession_add_BufferingStarted, METH_O, nullptr },
        { "remove_buffering_started", (PyCFunction)MediaPlaybackSession_remove_BufferingStarted, METH_O, nullptr },
        { "add_download_progress_changed", (PyCFunction)MediaPlaybackSession_add_DownloadProgressChanged, METH_O, nullptr },
        { "remove_download_progress_changed", (PyCFunction)MediaPlaybackSession_remove_DownloadProgressChanged, METH_O, nullptr },
        { "add_natural_duration_changed", (PyCFunction)MediaPlaybackSession_add_NaturalDurationChanged, METH_O, nullptr },
        { "remove_natural_duration_changed", (PyCFunction)MediaPlaybackSession_remove_NaturalDurationChanged, METH_O, nullptr },
        { "add_natural_video_size_changed", (PyCFunction)MediaPlaybackSession_add_NaturalVideoSizeChanged, METH_O, nullptr },
        { "remove_natural_video_size_changed", (PyCFunction)MediaPlaybackSession_remove_NaturalVideoSizeChanged, METH_O, nullptr },
        { "add_playback_rate_changed", (PyCFunction)MediaPlaybackSession_add_PlaybackRateChanged, METH_O, nullptr },
        { "remove_playback_rate_changed", (PyCFunction)MediaPlaybackSession_remove_PlaybackRateChanged, METH_O, nullptr },
        { "add_playback_state_changed", (PyCFunction)MediaPlaybackSession_add_PlaybackStateChanged, METH_O, nullptr },
        { "remove_playback_state_changed", (PyCFunction)MediaPlaybackSession_remove_PlaybackStateChanged, METH_O, nullptr },
        { "add_position_changed", (PyCFunction)MediaPlaybackSession_add_PositionChanged, METH_O, nullptr },
        { "remove_position_changed", (PyCFunction)MediaPlaybackSession_remove_PositionChanged, METH_O, nullptr },
        { "add_seek_completed", (PyCFunction)MediaPlaybackSession_add_SeekCompleted, METH_O, nullptr },
        { "remove_seek_completed", (PyCFunction)MediaPlaybackSession_remove_SeekCompleted, METH_O, nullptr },
        { "add_buffered_ranges_changed", (PyCFunction)MediaPlaybackSession_add_BufferedRangesChanged, METH_O, nullptr },
        { "remove_buffered_ranges_changed", (PyCFunction)MediaPlaybackSession_remove_BufferedRangesChanged, METH_O, nullptr },
        { "add_played_ranges_changed", (PyCFunction)MediaPlaybackSession_add_PlayedRangesChanged, METH_O, nullptr },
        { "remove_played_ranges_changed", (PyCFunction)MediaPlaybackSession_remove_PlayedRangesChanged, METH_O, nullptr },
        { "add_seekable_ranges_changed", (PyCFunction)MediaPlaybackSession_add_SeekableRangesChanged, METH_O, nullptr },
        { "remove_seekable_ranges_changed", (PyCFunction)MediaPlaybackSession_remove_SeekableRangesChanged, METH_O, nullptr },
        { "add_supported_playback_rates_changed", (PyCFunction)MediaPlaybackSession_add_SupportedPlaybackRatesChanged, METH_O, nullptr },
        { "remove_supported_playback_rates_changed", (PyCFunction)MediaPlaybackSession_remove_SupportedPlaybackRatesChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MediaPlaybackSession, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackSession[] = {
        { const_cast<char*>("stereoscopic_video_packing_mode"), (getter)MediaPlaybackSession_get_StereoscopicVideoPackingMode, (setter)MediaPlaybackSession_put_StereoscopicVideoPackingMode, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)MediaPlaybackSession_get_Position, (setter)MediaPlaybackSession_put_Position, nullptr, nullptr },
        { const_cast<char*>("playback_rate"), (getter)MediaPlaybackSession_get_PlaybackRate, (setter)MediaPlaybackSession_put_PlaybackRate, nullptr, nullptr },
        { const_cast<char*>("normalized_source_rect"), (getter)MediaPlaybackSession_get_NormalizedSourceRect, (setter)MediaPlaybackSession_put_NormalizedSourceRect, nullptr, nullptr },
        { const_cast<char*>("buffering_progress"), (getter)MediaPlaybackSession_get_BufferingProgress, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_pause"), (getter)MediaPlaybackSession_get_CanPause, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_seek"), (getter)MediaPlaybackSession_get_CanSeek, nullptr, nullptr, nullptr },
        { const_cast<char*>("download_progress"), (getter)MediaPlaybackSession_get_DownloadProgress, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_protected"), (getter)MediaPlaybackSession_get_IsProtected, nullptr, nullptr, nullptr },
        { const_cast<char*>("media_player"), (getter)MediaPlaybackSession_get_MediaPlayer, nullptr, nullptr, nullptr },
        { const_cast<char*>("natural_duration"), (getter)MediaPlaybackSession_get_NaturalDuration, nullptr, nullptr, nullptr },
        { const_cast<char*>("natural_video_height"), (getter)MediaPlaybackSession_get_NaturalVideoHeight, nullptr, nullptr, nullptr },
        { const_cast<char*>("natural_video_width"), (getter)MediaPlaybackSession_get_NaturalVideoWidth, nullptr, nullptr, nullptr },
        { const_cast<char*>("playback_state"), (getter)MediaPlaybackSession_get_PlaybackState, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_mirroring"), (getter)MediaPlaybackSession_get_IsMirroring, (setter)MediaPlaybackSession_put_IsMirroring, nullptr, nullptr },
        { const_cast<char*>("spherical_video_projection"), (getter)MediaPlaybackSession_get_SphericalVideoProjection, nullptr, nullptr, nullptr },
        { const_cast<char*>("playback_rotation"), (getter)MediaPlaybackSession_get_PlaybackRotation, (setter)MediaPlaybackSession_put_PlaybackRotation, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackSession[] = 
    {
        { Py_tp_new, _new_MediaPlaybackSession },
        { Py_tp_dealloc, _dealloc_MediaPlaybackSession },
        { Py_tp_methods, _methods_MediaPlaybackSession },
        { Py_tp_getset, _getset_MediaPlaybackSession },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackSession =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackSession",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackSession
    };

    // ----- MediaPlaybackSessionBufferingStartedEventArgs class --------------------
    constexpr const char* const _type_name_MediaPlaybackSessionBufferingStartedEventArgs = "MediaPlaybackSessionBufferingStartedEventArgs";

    static PyObject* _new_MediaPlaybackSessionBufferingStartedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackSessionBufferingStartedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackSessionBufferingStartedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlaybackSessionBufferingStartedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackSessionBufferingStartedEventArgs_get_IsPlaybackInterruption(py::wrapper::Windows::Media::Playback::MediaPlaybackSessionBufferingStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPlaybackInterruption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlaybackSessionBufferingStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackSessionBufferingStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackSessionBufferingStartedEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaPlaybackSessionBufferingStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackSessionBufferingStartedEventArgs[] = {
        { const_cast<char*>("is_playback_interruption"), (getter)MediaPlaybackSessionBufferingStartedEventArgs_get_IsPlaybackInterruption, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackSessionBufferingStartedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaPlaybackSessionBufferingStartedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaPlaybackSessionBufferingStartedEventArgs },
        { Py_tp_methods, _methods_MediaPlaybackSessionBufferingStartedEventArgs },
        { Py_tp_getset, _getset_MediaPlaybackSessionBufferingStartedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackSessionBufferingStartedEventArgs =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackSessionBufferingStartedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackSessionBufferingStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackSessionBufferingStartedEventArgs
    };

    // ----- MediaPlaybackSessionOutputDegradationPolicyState class --------------------
    constexpr const char* const _type_name_MediaPlaybackSessionOutputDegradationPolicyState = "MediaPlaybackSessionOutputDegradationPolicyState";

    static PyObject* _new_MediaPlaybackSessionOutputDegradationPolicyState(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackSessionOutputDegradationPolicyState);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackSessionOutputDegradationPolicyState(py::wrapper::Windows::Media::Playback::MediaPlaybackSessionOutputDegradationPolicyState* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackSessionOutputDegradationPolicyState_get_VideoConstrictionReason(py::wrapper::Windows::Media::Playback::MediaPlaybackSessionOutputDegradationPolicyState* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoConstrictionReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlaybackSessionOutputDegradationPolicyState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackSessionOutputDegradationPolicyState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackSessionOutputDegradationPolicyState[] = {
        { "_from", (PyCFunction)_from_MediaPlaybackSessionOutputDegradationPolicyState, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackSessionOutputDegradationPolicyState[] = {
        { const_cast<char*>("video_constriction_reason"), (getter)MediaPlaybackSessionOutputDegradationPolicyState_get_VideoConstrictionReason, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackSessionOutputDegradationPolicyState[] = 
    {
        { Py_tp_new, _new_MediaPlaybackSessionOutputDegradationPolicyState },
        { Py_tp_dealloc, _dealloc_MediaPlaybackSessionOutputDegradationPolicyState },
        { Py_tp_methods, _methods_MediaPlaybackSessionOutputDegradationPolicyState },
        { Py_tp_getset, _getset_MediaPlaybackSessionOutputDegradationPolicyState },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackSessionOutputDegradationPolicyState =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackSessionOutputDegradationPolicyState",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackSessionOutputDegradationPolicyState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackSessionOutputDegradationPolicyState
    };

    // ----- MediaPlaybackSphericalVideoProjection class --------------------
    constexpr const char* const _type_name_MediaPlaybackSphericalVideoProjection = "MediaPlaybackSphericalVideoProjection";

    static PyObject* _new_MediaPlaybackSphericalVideoProjection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackSphericalVideoProjection);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackSphericalVideoProjection(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackSphericalVideoProjection_get_ViewOrientation(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ViewOrientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSphericalVideoProjection_put_ViewOrientation(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);

            self->obj.ViewOrientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackSphericalVideoProjection_get_ProjectionMode(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProjectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSphericalVideoProjection_put_ProjectionMode(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::SphericalVideoProjectionMode>(arg);

            self->obj.ProjectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackSphericalVideoProjection_get_IsEnabled(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSphericalVideoProjection_put_IsEnabled(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackSphericalVideoProjection_get_HorizontalFieldOfViewInDegrees(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HorizontalFieldOfViewInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSphericalVideoProjection_put_HorizontalFieldOfViewInDegrees(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.HorizontalFieldOfViewInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackSphericalVideoProjection_get_FrameFormat(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackSphericalVideoProjection_put_FrameFormat(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::SphericalVideoFrameFormat>(arg);

            self->obj.FrameFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_MediaPlaybackSphericalVideoProjection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackSphericalVideoProjection[] = {
        { "_from", (PyCFunction)_from_MediaPlaybackSphericalVideoProjection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackSphericalVideoProjection[] = {
        { const_cast<char*>("view_orientation"), (getter)MediaPlaybackSphericalVideoProjection_get_ViewOrientation, (setter)MediaPlaybackSphericalVideoProjection_put_ViewOrientation, nullptr, nullptr },
        { const_cast<char*>("projection_mode"), (getter)MediaPlaybackSphericalVideoProjection_get_ProjectionMode, (setter)MediaPlaybackSphericalVideoProjection_put_ProjectionMode, nullptr, nullptr },
        { const_cast<char*>("is_enabled"), (getter)MediaPlaybackSphericalVideoProjection_get_IsEnabled, (setter)MediaPlaybackSphericalVideoProjection_put_IsEnabled, nullptr, nullptr },
        { const_cast<char*>("horizontal_field_of_view_in_degrees"), (getter)MediaPlaybackSphericalVideoProjection_get_HorizontalFieldOfViewInDegrees, (setter)MediaPlaybackSphericalVideoProjection_put_HorizontalFieldOfViewInDegrees, nullptr, nullptr },
        { const_cast<char*>("frame_format"), (getter)MediaPlaybackSphericalVideoProjection_get_FrameFormat, (setter)MediaPlaybackSphericalVideoProjection_put_FrameFormat, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackSphericalVideoProjection[] = 
    {
        { Py_tp_new, _new_MediaPlaybackSphericalVideoProjection },
        { Py_tp_dealloc, _dealloc_MediaPlaybackSphericalVideoProjection },
        { Py_tp_methods, _methods_MediaPlaybackSphericalVideoProjection },
        { Py_tp_getset, _getset_MediaPlaybackSphericalVideoProjection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackSphericalVideoProjection =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackSphericalVideoProjection",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackSphericalVideoProjection
    };

    // ----- MediaPlaybackTimedMetadataTrackList class --------------------
    constexpr const char* const _type_name_MediaPlaybackTimedMetadataTrackList = "MediaPlaybackTimedMetadataTrackList";

    static PyObject* _new_MediaPlaybackTimedMetadataTrackList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackTimedMetadataTrackList);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackTimedMetadataTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackTimedMetadataTrackList_First(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackTimedMetadataTrackList_GetAt(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackTimedMetadataTrackList_GetMany(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Media::Core::TimedMetadataTrack>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Media::Core::TimedMetadataTrack> param1 ( param1_count, py::empty_instance<winrt::Windows::Media::Core::TimedMetadataTrack>::get() );

                auto return_value = self->obj.GetMany(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackTimedMetadataTrackList_GetPresentationMode(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetPresentationMode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackTimedMetadataTrackList_IndexOf(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedMetadataTrack>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackTimedMetadataTrackList_SetPresentationMode(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Playback::TimedMetadataTrackPresentationMode>(args, 1);

                self->obj.SetPresentationMode(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackTimedMetadataTrackList_get_Size(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackTimedMetadataTrackList_add_PresentationModeChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList, winrt::Windows::Media::Playback::TimedMetadataPresentationModeChangedEventArgs>>(arg);

            return py::convert(self->obj.PresentationModeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackTimedMetadataTrackList_remove_PresentationModeChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PresentationModeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlaybackTimedMetadataTrackList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_MediaPlaybackTimedMetadataTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_MediaPlaybackTimedMetadataTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_MediaPlaybackTimedMetadataTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackTimedMetadataTrackList[] = {
        { "first", (PyCFunction)MediaPlaybackTimedMetadataTrackList_First, METH_VARARGS, nullptr },
        { "get_at", (PyCFunction)MediaPlaybackTimedMetadataTrackList_GetAt, METH_VARARGS, nullptr },
        { "get_many", (PyCFunction)MediaPlaybackTimedMetadataTrackList_GetMany, METH_VARARGS, nullptr },
        { "get_presentation_mode", (PyCFunction)MediaPlaybackTimedMetadataTrackList_GetPresentationMode, METH_VARARGS, nullptr },
        { "index_of", (PyCFunction)MediaPlaybackTimedMetadataTrackList_IndexOf, METH_VARARGS, nullptr },
        { "set_presentation_mode", (PyCFunction)MediaPlaybackTimedMetadataTrackList_SetPresentationMode, METH_VARARGS, nullptr },
        { "add_presentation_mode_changed", (PyCFunction)MediaPlaybackTimedMetadataTrackList_add_PresentationModeChanged, METH_O, nullptr },
        { "remove_presentation_mode_changed", (PyCFunction)MediaPlaybackTimedMetadataTrackList_remove_PresentationModeChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MediaPlaybackTimedMetadataTrackList, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackTimedMetadataTrackList[] = {
        { const_cast<char*>("size"), (getter)MediaPlaybackTimedMetadataTrackList_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackTimedMetadataTrackList[] = 
    {
        { Py_tp_new, _new_MediaPlaybackTimedMetadataTrackList },
        { Py_tp_dealloc, _dealloc_MediaPlaybackTimedMetadataTrackList },
        { Py_tp_methods, _methods_MediaPlaybackTimedMetadataTrackList },
        { Py_tp_getset, _getset_MediaPlaybackTimedMetadataTrackList },
        { Py_tp_iter, _iterator_MediaPlaybackTimedMetadataTrackList },
        { Py_sq_length, _seq_length_MediaPlaybackTimedMetadataTrackList },
        { Py_sq_item, _seq_item_MediaPlaybackTimedMetadataTrackList },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackTimedMetadataTrackList =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackTimedMetadataTrackList",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackTimedMetadataTrackList
    };

    // ----- MediaPlaybackVideoTrackList class --------------------
    constexpr const char* const _type_name_MediaPlaybackVideoTrackList = "MediaPlaybackVideoTrackList";

    static PyObject* _new_MediaPlaybackVideoTrackList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlaybackVideoTrackList);
        return nullptr;
    }

    static void _dealloc_MediaPlaybackVideoTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlaybackVideoTrackList_First(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackVideoTrackList_GetAt(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackVideoTrackList_GetMany(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Media::Core::VideoTrack>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Media::Core::VideoTrack> param1 ( param1_count, py::empty_instance<winrt::Windows::Media::Core::VideoTrack>::get() );

                auto return_value = self->obj.GetMany(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackVideoTrackList_IndexOf(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::VideoTrack>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackVideoTrackList_get_Size(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackVideoTrackList_get_SelectedIndex(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SelectedIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlaybackVideoTrackList_put_SelectedIndex(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SelectedIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlaybackVideoTrackList_add_SelectedIndexChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::ISingleSelectMediaTrackList, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SelectedIndexChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlaybackVideoTrackList_remove_SelectedIndexChanged(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SelectedIndexChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlaybackVideoTrackList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlaybackVideoTrackList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_MediaPlaybackVideoTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_MediaPlaybackVideoTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_MediaPlaybackVideoTrackList(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlaybackVideoTrackList[] = {
        { "first", (PyCFunction)MediaPlaybackVideoTrackList_First, METH_VARARGS, nullptr },
        { "get_at", (PyCFunction)MediaPlaybackVideoTrackList_GetAt, METH_VARARGS, nullptr },
        { "get_many", (PyCFunction)MediaPlaybackVideoTrackList_GetMany, METH_VARARGS, nullptr },
        { "index_of", (PyCFunction)MediaPlaybackVideoTrackList_IndexOf, METH_VARARGS, nullptr },
        { "add_selected_index_changed", (PyCFunction)MediaPlaybackVideoTrackList_add_SelectedIndexChanged, METH_O, nullptr },
        { "remove_selected_index_changed", (PyCFunction)MediaPlaybackVideoTrackList_remove_SelectedIndexChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MediaPlaybackVideoTrackList, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlaybackVideoTrackList[] = {
        { const_cast<char*>("size"), (getter)MediaPlaybackVideoTrackList_get_Size, nullptr, nullptr, nullptr },
        { const_cast<char*>("selected_index"), (getter)MediaPlaybackVideoTrackList_get_SelectedIndex, (setter)MediaPlaybackVideoTrackList_put_SelectedIndex, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlaybackVideoTrackList[] = 
    {
        { Py_tp_new, _new_MediaPlaybackVideoTrackList },
        { Py_tp_dealloc, _dealloc_MediaPlaybackVideoTrackList },
        { Py_tp_methods, _methods_MediaPlaybackVideoTrackList },
        { Py_tp_getset, _getset_MediaPlaybackVideoTrackList },
        { Py_tp_iter, _iterator_MediaPlaybackVideoTrackList },
        { Py_sq_length, _seq_length_MediaPlaybackVideoTrackList },
        { Py_sq_item, _seq_item_MediaPlaybackVideoTrackList },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlaybackVideoTrackList =
    {
        "_winrt_Windows_Media_Playback.MediaPlaybackVideoTrackList",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlaybackVideoTrackList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlaybackVideoTrackList
    };

    // ----- MediaPlayer class --------------------
    constexpr const char* const _type_name_MediaPlayer = "MediaPlayer";

    static PyObject* _new_MediaPlayer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Playback::MediaPlayer instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaPlayer(py::wrapper::Windows::Media::Playback::MediaPlayer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlayer_AddAudioEffect(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                self->obj.AddAudioEffect(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_AddVideoEffect(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                self->obj.AddVideoEffect(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_Close(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_CopyFrameToStereoscopicVideoSurfaces(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 1);

                self->obj.CopyFrameToStereoscopicVideoSurfaces(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_CopyFrameToVideoSurface(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);

                self->obj.CopyFrameToVideoSurface(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                self->obj.CopyFrameToVideoSurface(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_GetAsCastingSource(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsCastingSource());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_GetSurface(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Composition::Compositor>(args, 0);

                return py::convert(self->obj.GetSurface(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_Pause(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Pause();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_Play(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Play();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_RemoveAllEffects(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RemoveAllEffects();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_RenderSubtitlesToSurface(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);

                return py::convert(self->obj.RenderSubtitlesToSurface(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(self->obj.RenderSubtitlesToSurface(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_SetFileSource(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                self->obj.SetFileSource(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_SetMediaSource(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaSource>(args, 0);

                self->obj.SetMediaSource(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_SetStreamSource(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                self->obj.SetStreamSource(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_SetSurfaceSize(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                self->obj.SetSurfaceSize(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_SetUriSource(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                self->obj.SetUriSource(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_StepBackwardOneFrame(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.StepBackwardOneFrame();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_StepForwardOneFrame(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.StepForwardOneFrame();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_Volume(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Volume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_Volume(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Volume(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_Position(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_Position(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_PlaybackRate(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_PlaybackRate(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.PlaybackRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_IsLoopingEnabled(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLoopingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_IsLoopingEnabled(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLoopingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_IsMuted(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsMuted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_IsMuted(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMuted(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_AutoPlay(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoPlay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_AutoPlay(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoPlay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_CurrentState(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_NaturalDuration(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NaturalDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_PlaybackMediaMarkers(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackMediaMarkers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_IsProtected(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsProtected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_BufferingProgress(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BufferingProgress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_CanPause(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanPause());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_CanSeek(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanSeek());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_AudioDeviceType(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_AudioDeviceType(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaPlayerAudioDeviceType>(arg);

            self->obj.AudioDeviceType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_AudioCategory(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_AudioCategory(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::MediaPlayerAudioCategory>(arg);

            self->obj.AudioCategory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_SystemMediaTransportControls(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemMediaTransportControls());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_TimelineControllerPositionOffset(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimelineControllerPositionOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_TimelineControllerPositionOffset(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.TimelineControllerPositionOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_TimelineController(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimelineController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_TimelineController(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaTimelineController>(arg);

            self->obj.TimelineController(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_StereoscopicVideoRenderMode(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StereoscopicVideoRenderMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_StereoscopicVideoRenderMode(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::StereoscopicVideoRenderMode>(arg);

            self->obj.StereoscopicVideoRenderMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_RealTimePlayback(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RealTimePlayback());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_RealTimePlayback(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RealTimePlayback(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_AudioDevice(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_AudioDevice(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(arg);

            self->obj.AudioDevice(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_AudioBalance(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioBalance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_AudioBalance(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.AudioBalance(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_CommandManager(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CommandManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_BreakManager(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BreakManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_PlaybackSession(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackSession());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_IsVideoFrameServerEnabled(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVideoFrameServerEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_IsVideoFrameServerEnabled(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsVideoFrameServerEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_AudioStateMonitor(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioStateMonitor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_get_ProtectionManager(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtectionManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_ProtectionManager(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Protection::MediaProtectionManager>(arg);

            self->obj.ProtectionManager(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_get_Source(py::wrapper::Windows::Media::Playback::MediaPlayer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaPlayer_put_Source(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::IMediaPlaybackSource>(arg);

            self->obj.Source(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaPlayer_add_BufferingEnded(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.BufferingEnded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_BufferingEnded(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BufferingEnded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_BufferingStarted(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.BufferingStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_BufferingStarted(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BufferingStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_CurrentStateChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CurrentStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_CurrentStateChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CurrentStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_MediaEnded(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.MediaEnded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_MediaEnded(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MediaEnded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_MediaFailed(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Media::Playback::MediaPlayerFailedEventArgs>>(arg);

            return py::convert(self->obj.MediaFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_MediaFailed(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MediaFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_MediaOpened(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.MediaOpened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_MediaOpened(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MediaOpened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_MediaPlayerRateChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Media::Playback::MediaPlayerRateChangedEventArgs>>(arg);

            return py::convert(self->obj.MediaPlayerRateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_MediaPlayerRateChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MediaPlayerRateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_PlaybackMediaMarkerReached(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Media::Playback::PlaybackMediaMarkerReachedEventArgs>>(arg);

            return py::convert(self->obj.PlaybackMediaMarkerReached(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_PlaybackMediaMarkerReached(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlaybackMediaMarkerReached(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_SeekCompleted(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SeekCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_SeekCompleted(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SeekCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_VolumeChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VolumeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_VolumeChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VolumeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_IsMutedChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsMutedChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_IsMutedChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsMutedChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_SourceChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SourceChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_SourceChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_VideoFrameAvailable(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VideoFrameAvailable(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_VideoFrameAvailable(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VideoFrameAvailable(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_add_SubtitleFrameChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Playback::MediaPlayer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SubtitleFrameChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayer_remove_SubtitleFrameChanged(py::wrapper::Windows::Media::Playback::MediaPlayer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SubtitleFrameChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlayer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlayer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaPlayer(py::wrapper::Windows::Media::Playback::MediaPlayer* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_MediaPlayer(py::wrapper::Windows::Media::Playback::MediaPlayer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlayer[] = {
        { "add_audio_effect", (PyCFunction)MediaPlayer_AddAudioEffect, METH_VARARGS, nullptr },
        { "add_video_effect", (PyCFunction)MediaPlayer_AddVideoEffect, METH_VARARGS, nullptr },
        { "close", (PyCFunction)MediaPlayer_Close, METH_VARARGS, nullptr },
        { "copy_frame_to_stereoscopic_video_surfaces", (PyCFunction)MediaPlayer_CopyFrameToStereoscopicVideoSurfaces, METH_VARARGS, nullptr },
        { "copy_frame_to_video_surface", (PyCFunction)MediaPlayer_CopyFrameToVideoSurface, METH_VARARGS, nullptr },
        { "get_as_casting_source", (PyCFunction)MediaPlayer_GetAsCastingSource, METH_VARARGS, nullptr },
        { "get_surface", (PyCFunction)MediaPlayer_GetSurface, METH_VARARGS, nullptr },
        { "pause", (PyCFunction)MediaPlayer_Pause, METH_VARARGS, nullptr },
        { "play", (PyCFunction)MediaPlayer_Play, METH_VARARGS, nullptr },
        { "remove_all_effects", (PyCFunction)MediaPlayer_RemoveAllEffects, METH_VARARGS, nullptr },
        { "render_subtitles_to_surface", (PyCFunction)MediaPlayer_RenderSubtitlesToSurface, METH_VARARGS, nullptr },
        { "set_file_source", (PyCFunction)MediaPlayer_SetFileSource, METH_VARARGS, nullptr },
        { "set_media_source", (PyCFunction)MediaPlayer_SetMediaSource, METH_VARARGS, nullptr },
        { "set_stream_source", (PyCFunction)MediaPlayer_SetStreamSource, METH_VARARGS, nullptr },
        { "set_surface_size", (PyCFunction)MediaPlayer_SetSurfaceSize, METH_VARARGS, nullptr },
        { "set_uri_source", (PyCFunction)MediaPlayer_SetUriSource, METH_VARARGS, nullptr },
        { "step_backward_one_frame", (PyCFunction)MediaPlayer_StepBackwardOneFrame, METH_VARARGS, nullptr },
        { "step_forward_one_frame", (PyCFunction)MediaPlayer_StepForwardOneFrame, METH_VARARGS, nullptr },
        { "add_buffering_ended", (PyCFunction)MediaPlayer_add_BufferingEnded, METH_O, nullptr },
        { "remove_buffering_ended", (PyCFunction)MediaPlayer_remove_BufferingEnded, METH_O, nullptr },
        { "add_buffering_started", (PyCFunction)MediaPlayer_add_BufferingStarted, METH_O, nullptr },
        { "remove_buffering_started", (PyCFunction)MediaPlayer_remove_BufferingStarted, METH_O, nullptr },
        { "add_current_state_changed", (PyCFunction)MediaPlayer_add_CurrentStateChanged, METH_O, nullptr },
        { "remove_current_state_changed", (PyCFunction)MediaPlayer_remove_CurrentStateChanged, METH_O, nullptr },
        { "add_media_ended", (PyCFunction)MediaPlayer_add_MediaEnded, METH_O, nullptr },
        { "remove_media_ended", (PyCFunction)MediaPlayer_remove_MediaEnded, METH_O, nullptr },
        { "add_media_failed", (PyCFunction)MediaPlayer_add_MediaFailed, METH_O, nullptr },
        { "remove_media_failed", (PyCFunction)MediaPlayer_remove_MediaFailed, METH_O, nullptr },
        { "add_media_opened", (PyCFunction)MediaPlayer_add_MediaOpened, METH_O, nullptr },
        { "remove_media_opened", (PyCFunction)MediaPlayer_remove_MediaOpened, METH_O, nullptr },
        { "add_media_player_rate_changed", (PyCFunction)MediaPlayer_add_MediaPlayerRateChanged, METH_O, nullptr },
        { "remove_media_player_rate_changed", (PyCFunction)MediaPlayer_remove_MediaPlayerRateChanged, METH_O, nullptr },
        { "add_playback_media_marker_reached", (PyCFunction)MediaPlayer_add_PlaybackMediaMarkerReached, METH_O, nullptr },
        { "remove_playback_media_marker_reached", (PyCFunction)MediaPlayer_remove_PlaybackMediaMarkerReached, METH_O, nullptr },
        { "add_seek_completed", (PyCFunction)MediaPlayer_add_SeekCompleted, METH_O, nullptr },
        { "remove_seek_completed", (PyCFunction)MediaPlayer_remove_SeekCompleted, METH_O, nullptr },
        { "add_volume_changed", (PyCFunction)MediaPlayer_add_VolumeChanged, METH_O, nullptr },
        { "remove_volume_changed", (PyCFunction)MediaPlayer_remove_VolumeChanged, METH_O, nullptr },
        { "add_is_muted_changed", (PyCFunction)MediaPlayer_add_IsMutedChanged, METH_O, nullptr },
        { "remove_is_muted_changed", (PyCFunction)MediaPlayer_remove_IsMutedChanged, METH_O, nullptr },
        { "add_source_changed", (PyCFunction)MediaPlayer_add_SourceChanged, METH_O, nullptr },
        { "remove_source_changed", (PyCFunction)MediaPlayer_remove_SourceChanged, METH_O, nullptr },
        { "add_video_frame_available", (PyCFunction)MediaPlayer_add_VideoFrameAvailable, METH_O, nullptr },
        { "remove_video_frame_available", (PyCFunction)MediaPlayer_remove_VideoFrameAvailable, METH_O, nullptr },
        { "add_subtitle_frame_changed", (PyCFunction)MediaPlayer_add_SubtitleFrameChanged, METH_O, nullptr },
        { "remove_subtitle_frame_changed", (PyCFunction)MediaPlayer_remove_SubtitleFrameChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MediaPlayer, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_MediaPlayer, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_MediaPlayer, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlayer[] = {
        { const_cast<char*>("volume"), (getter)MediaPlayer_get_Volume, (setter)MediaPlayer_put_Volume, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)MediaPlayer_get_Position, (setter)MediaPlayer_put_Position, nullptr, nullptr },
        { const_cast<char*>("playback_rate"), (getter)MediaPlayer_get_PlaybackRate, (setter)MediaPlayer_put_PlaybackRate, nullptr, nullptr },
        { const_cast<char*>("is_looping_enabled"), (getter)MediaPlayer_get_IsLoopingEnabled, (setter)MediaPlayer_put_IsLoopingEnabled, nullptr, nullptr },
        { const_cast<char*>("is_muted"), (getter)MediaPlayer_get_IsMuted, (setter)MediaPlayer_put_IsMuted, nullptr, nullptr },
        { const_cast<char*>("auto_play"), (getter)MediaPlayer_get_AutoPlay, (setter)MediaPlayer_put_AutoPlay, nullptr, nullptr },
        { const_cast<char*>("current_state"), (getter)MediaPlayer_get_CurrentState, nullptr, nullptr, nullptr },
        { const_cast<char*>("natural_duration"), (getter)MediaPlayer_get_NaturalDuration, nullptr, nullptr, nullptr },
        { const_cast<char*>("playback_media_markers"), (getter)MediaPlayer_get_PlaybackMediaMarkers, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_protected"), (getter)MediaPlayer_get_IsProtected, nullptr, nullptr, nullptr },
        { const_cast<char*>("buffering_progress"), (getter)MediaPlayer_get_BufferingProgress, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_pause"), (getter)MediaPlayer_get_CanPause, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_seek"), (getter)MediaPlayer_get_CanSeek, nullptr, nullptr, nullptr },
        { const_cast<char*>("audio_device_type"), (getter)MediaPlayer_get_AudioDeviceType, (setter)MediaPlayer_put_AudioDeviceType, nullptr, nullptr },
        { const_cast<char*>("audio_category"), (getter)MediaPlayer_get_AudioCategory, (setter)MediaPlayer_put_AudioCategory, nullptr, nullptr },
        { const_cast<char*>("system_media_transport_controls"), (getter)MediaPlayer_get_SystemMediaTransportControls, nullptr, nullptr, nullptr },
        { const_cast<char*>("timeline_controller_position_offset"), (getter)MediaPlayer_get_TimelineControllerPositionOffset, (setter)MediaPlayer_put_TimelineControllerPositionOffset, nullptr, nullptr },
        { const_cast<char*>("timeline_controller"), (getter)MediaPlayer_get_TimelineController, (setter)MediaPlayer_put_TimelineController, nullptr, nullptr },
        { const_cast<char*>("stereoscopic_video_render_mode"), (getter)MediaPlayer_get_StereoscopicVideoRenderMode, (setter)MediaPlayer_put_StereoscopicVideoRenderMode, nullptr, nullptr },
        { const_cast<char*>("real_time_playback"), (getter)MediaPlayer_get_RealTimePlayback, (setter)MediaPlayer_put_RealTimePlayback, nullptr, nullptr },
        { const_cast<char*>("audio_device"), (getter)MediaPlayer_get_AudioDevice, (setter)MediaPlayer_put_AudioDevice, nullptr, nullptr },
        { const_cast<char*>("audio_balance"), (getter)MediaPlayer_get_AudioBalance, (setter)MediaPlayer_put_AudioBalance, nullptr, nullptr },
        { const_cast<char*>("command_manager"), (getter)MediaPlayer_get_CommandManager, nullptr, nullptr, nullptr },
        { const_cast<char*>("break_manager"), (getter)MediaPlayer_get_BreakManager, nullptr, nullptr, nullptr },
        { const_cast<char*>("playback_session"), (getter)MediaPlayer_get_PlaybackSession, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_video_frame_server_enabled"), (getter)MediaPlayer_get_IsVideoFrameServerEnabled, (setter)MediaPlayer_put_IsVideoFrameServerEnabled, nullptr, nullptr },
        { const_cast<char*>("audio_state_monitor"), (getter)MediaPlayer_get_AudioStateMonitor, nullptr, nullptr, nullptr },
        { const_cast<char*>("protection_manager"), (getter)MediaPlayer_get_ProtectionManager, (setter)MediaPlayer_put_ProtectionManager, nullptr, nullptr },
        { const_cast<char*>("source"), (getter)MediaPlayer_get_Source, (setter)MediaPlayer_put_Source, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlayer[] = 
    {
        { Py_tp_new, _new_MediaPlayer },
        { Py_tp_dealloc, _dealloc_MediaPlayer },
        { Py_tp_methods, _methods_MediaPlayer },
        { Py_tp_getset, _getset_MediaPlayer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlayer =
    {
        "_winrt_Windows_Media_Playback.MediaPlayer",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlayer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlayer
    };

    // ----- MediaPlayerDataReceivedEventArgs class --------------------
    constexpr const char* const _type_name_MediaPlayerDataReceivedEventArgs = "MediaPlayerDataReceivedEventArgs";

    static PyObject* _new_MediaPlayerDataReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlayerDataReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaPlayerDataReceivedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlayerDataReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlayerDataReceivedEventArgs_get_Data(py::wrapper::Windows::Media::Playback::MediaPlayerDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlayerDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlayerDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlayerDataReceivedEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaPlayerDataReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlayerDataReceivedEventArgs[] = {
        { const_cast<char*>("data"), (getter)MediaPlayerDataReceivedEventArgs_get_Data, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlayerDataReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaPlayerDataReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaPlayerDataReceivedEventArgs },
        { Py_tp_methods, _methods_MediaPlayerDataReceivedEventArgs },
        { Py_tp_getset, _getset_MediaPlayerDataReceivedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlayerDataReceivedEventArgs =
    {
        "_winrt_Windows_Media_Playback.MediaPlayerDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlayerDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlayerDataReceivedEventArgs
    };

    // ----- MediaPlayerFailedEventArgs class --------------------
    constexpr const char* const _type_name_MediaPlayerFailedEventArgs = "MediaPlayerFailedEventArgs";

    static PyObject* _new_MediaPlayerFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlayerFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaPlayerFailedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlayerFailedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlayerFailedEventArgs_get_Error(py::wrapper::Windows::Media::Playback::MediaPlayerFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayerFailedEventArgs_get_ErrorMessage(py::wrapper::Windows::Media::Playback::MediaPlayerFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayerFailedEventArgs_get_ExtendedErrorCode(py::wrapper::Windows::Media::Playback::MediaPlayerFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlayerFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlayerFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlayerFailedEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaPlayerFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlayerFailedEventArgs[] = {
        { const_cast<char*>("error"), (getter)MediaPlayerFailedEventArgs_get_Error, nullptr, nullptr, nullptr },
        { const_cast<char*>("error_message"), (getter)MediaPlayerFailedEventArgs_get_ErrorMessage, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_error_code"), (getter)MediaPlayerFailedEventArgs_get_ExtendedErrorCode, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlayerFailedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaPlayerFailedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaPlayerFailedEventArgs },
        { Py_tp_methods, _methods_MediaPlayerFailedEventArgs },
        { Py_tp_getset, _getset_MediaPlayerFailedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlayerFailedEventArgs =
    {
        "_winrt_Windows_Media_Playback.MediaPlayerFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlayerFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlayerFailedEventArgs
    };

    // ----- MediaPlayerRateChangedEventArgs class --------------------
    constexpr const char* const _type_name_MediaPlayerRateChangedEventArgs = "MediaPlayerRateChangedEventArgs";

    static PyObject* _new_MediaPlayerRateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlayerRateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaPlayerRateChangedEventArgs(py::wrapper::Windows::Media::Playback::MediaPlayerRateChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlayerRateChangedEventArgs_get_NewRate(py::wrapper::Windows::Media::Playback::MediaPlayerRateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NewRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlayerRateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlayerRateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlayerRateChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaPlayerRateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlayerRateChangedEventArgs[] = {
        { const_cast<char*>("new_rate"), (getter)MediaPlayerRateChangedEventArgs_get_NewRate, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlayerRateChangedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaPlayerRateChangedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaPlayerRateChangedEventArgs },
        { Py_tp_methods, _methods_MediaPlayerRateChangedEventArgs },
        { Py_tp_getset, _getset_MediaPlayerRateChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlayerRateChangedEventArgs =
    {
        "_winrt_Windows_Media_Playback.MediaPlayerRateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlayerRateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlayerRateChangedEventArgs
    };

    // ----- MediaPlayerSurface class --------------------
    constexpr const char* const _type_name_MediaPlayerSurface = "MediaPlayerSurface";

    static PyObject* _new_MediaPlayerSurface(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaPlayerSurface);
        return nullptr;
    }

    static void _dealloc_MediaPlayerSurface(py::wrapper::Windows::Media::Playback::MediaPlayerSurface* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPlayerSurface_Close(py::wrapper::Windows::Media::Playback::MediaPlayerSurface* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPlayerSurface_get_CompositionSurface(py::wrapper::Windows::Media::Playback::MediaPlayerSurface* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CompositionSurface());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayerSurface_get_Compositor(py::wrapper::Windows::Media::Playback::MediaPlayerSurface* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Compositor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaPlayerSurface_get_MediaPlayer(py::wrapper::Windows::Media::Playback::MediaPlayerSurface* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaPlayer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPlayerSurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::MediaPlayerSurface>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaPlayerSurface(py::wrapper::Windows::Media::Playback::MediaPlayerSurface* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_MediaPlayerSurface(py::wrapper::Windows::Media::Playback::MediaPlayerSurface* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlayerSurface[] = {
        { "close", (PyCFunction)MediaPlayerSurface_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaPlayerSurface, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_MediaPlayerSurface, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_MediaPlayerSurface, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPlayerSurface[] = {
        { const_cast<char*>("composition_surface"), (getter)MediaPlayerSurface_get_CompositionSurface, nullptr, nullptr, nullptr },
        { const_cast<char*>("compositor"), (getter)MediaPlayerSurface_get_Compositor, nullptr, nullptr, nullptr },
        { const_cast<char*>("media_player"), (getter)MediaPlayerSurface_get_MediaPlayer, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPlayerSurface[] = 
    {
        { Py_tp_new, _new_MediaPlayerSurface },
        { Py_tp_dealloc, _dealloc_MediaPlayerSurface },
        { Py_tp_methods, _methods_MediaPlayerSurface },
        { Py_tp_getset, _getset_MediaPlayerSurface },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPlayerSurface =
    {
        "_winrt_Windows_Media_Playback.MediaPlayerSurface",
        sizeof(py::wrapper::Windows::Media::Playback::MediaPlayerSurface),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlayerSurface
    };

    // ----- PlaybackMediaMarker class --------------------
    constexpr const char* const _type_name_PlaybackMediaMarker = "PlaybackMediaMarker";

    static PyObject* _new_PlaybackMediaMarker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                winrt::Windows::Media::Playback::PlaybackMediaMarker instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::Media::Playback::PlaybackMediaMarker instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlaybackMediaMarker(py::wrapper::Windows::Media::Playback::PlaybackMediaMarker* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlaybackMediaMarker_get_MediaMarkerType(py::wrapper::Windows::Media::Playback::PlaybackMediaMarker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaMarkerType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaybackMediaMarker_get_Text(py::wrapper::Windows::Media::Playback::PlaybackMediaMarker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaybackMediaMarker_get_Time(py::wrapper::Windows::Media::Playback::PlaybackMediaMarker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Time());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlaybackMediaMarker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::PlaybackMediaMarker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlaybackMediaMarker[] = {
        { "_from", (PyCFunction)_from_PlaybackMediaMarker, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlaybackMediaMarker[] = {
        { const_cast<char*>("media_marker_type"), (getter)PlaybackMediaMarker_get_MediaMarkerType, nullptr, nullptr, nullptr },
        { const_cast<char*>("text"), (getter)PlaybackMediaMarker_get_Text, nullptr, nullptr, nullptr },
        { const_cast<char*>("time"), (getter)PlaybackMediaMarker_get_Time, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlaybackMediaMarker[] = 
    {
        { Py_tp_new, _new_PlaybackMediaMarker },
        { Py_tp_dealloc, _dealloc_PlaybackMediaMarker },
        { Py_tp_methods, _methods_PlaybackMediaMarker },
        { Py_tp_getset, _getset_PlaybackMediaMarker },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlaybackMediaMarker =
    {
        "_winrt_Windows_Media_Playback.PlaybackMediaMarker",
        sizeof(py::wrapper::Windows::Media::Playback::PlaybackMediaMarker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlaybackMediaMarker
    };

    // ----- PlaybackMediaMarkerReachedEventArgs class --------------------
    constexpr const char* const _type_name_PlaybackMediaMarkerReachedEventArgs = "PlaybackMediaMarkerReachedEventArgs";

    static PyObject* _new_PlaybackMediaMarkerReachedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlaybackMediaMarkerReachedEventArgs);
        return nullptr;
    }

    static void _dealloc_PlaybackMediaMarkerReachedEventArgs(py::wrapper::Windows::Media::Playback::PlaybackMediaMarkerReachedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlaybackMediaMarkerReachedEventArgs_get_PlaybackMediaMarker(py::wrapper::Windows::Media::Playback::PlaybackMediaMarkerReachedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackMediaMarker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlaybackMediaMarkerReachedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::PlaybackMediaMarkerReachedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlaybackMediaMarkerReachedEventArgs[] = {
        { "_from", (PyCFunction)_from_PlaybackMediaMarkerReachedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlaybackMediaMarkerReachedEventArgs[] = {
        { const_cast<char*>("playback_media_marker"), (getter)PlaybackMediaMarkerReachedEventArgs_get_PlaybackMediaMarker, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlaybackMediaMarkerReachedEventArgs[] = 
    {
        { Py_tp_new, _new_PlaybackMediaMarkerReachedEventArgs },
        { Py_tp_dealloc, _dealloc_PlaybackMediaMarkerReachedEventArgs },
        { Py_tp_methods, _methods_PlaybackMediaMarkerReachedEventArgs },
        { Py_tp_getset, _getset_PlaybackMediaMarkerReachedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlaybackMediaMarkerReachedEventArgs =
    {
        "_winrt_Windows_Media_Playback.PlaybackMediaMarkerReachedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::PlaybackMediaMarkerReachedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlaybackMediaMarkerReachedEventArgs
    };

    // ----- PlaybackMediaMarkerSequence class --------------------
    constexpr const char* const _type_name_PlaybackMediaMarkerSequence = "PlaybackMediaMarkerSequence";

    static PyObject* _new_PlaybackMediaMarkerSequence(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlaybackMediaMarkerSequence);
        return nullptr;
    }

    static void _dealloc_PlaybackMediaMarkerSequence(py::wrapper::Windows::Media::Playback::PlaybackMediaMarkerSequence* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlaybackMediaMarkerSequence_Clear(py::wrapper::Windows::Media::Playback::PlaybackMediaMarkerSequence* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlaybackMediaMarkerSequence_First(py::wrapper::Windows::Media::Playback::PlaybackMediaMarkerSequence* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlaybackMediaMarkerSequence_Insert(py::wrapper::Windows::Media::Playback::PlaybackMediaMarkerSequence* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Playback::PlaybackMediaMarker>(args, 0);

                self->obj.Insert(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlaybackMediaMarkerSequence_get_Size(py::wrapper::Windows::Media::Playback::PlaybackMediaMarkerSequence* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlaybackMediaMarkerSequence(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::PlaybackMediaMarkerSequence>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PlaybackMediaMarkerSequence(py::wrapper::Windows::Media::Playback::PlaybackMediaMarkerSequence* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlaybackMediaMarkerSequence[] = {
        { "clear", (PyCFunction)PlaybackMediaMarkerSequence_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)PlaybackMediaMarkerSequence_First, METH_VARARGS, nullptr },
        { "insert", (PyCFunction)PlaybackMediaMarkerSequence_Insert, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlaybackMediaMarkerSequence, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlaybackMediaMarkerSequence[] = {
        { const_cast<char*>("size"), (getter)PlaybackMediaMarkerSequence_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlaybackMediaMarkerSequence[] = 
    {
        { Py_tp_new, _new_PlaybackMediaMarkerSequence },
        { Py_tp_dealloc, _dealloc_PlaybackMediaMarkerSequence },
        { Py_tp_methods, _methods_PlaybackMediaMarkerSequence },
        { Py_tp_getset, _getset_PlaybackMediaMarkerSequence },
        { Py_tp_iter, _iterator_PlaybackMediaMarkerSequence },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlaybackMediaMarkerSequence =
    {
        "_winrt_Windows_Media_Playback.PlaybackMediaMarkerSequence",
        sizeof(py::wrapper::Windows::Media::Playback::PlaybackMediaMarkerSequence),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlaybackMediaMarkerSequence
    };

    // ----- TimedMetadataPresentationModeChangedEventArgs class --------------------
    constexpr const char* const _type_name_TimedMetadataPresentationModeChangedEventArgs = "TimedMetadataPresentationModeChangedEventArgs";

    static PyObject* _new_TimedMetadataPresentationModeChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TimedMetadataPresentationModeChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_TimedMetadataPresentationModeChangedEventArgs(py::wrapper::Windows::Media::Playback::TimedMetadataPresentationModeChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedMetadataPresentationModeChangedEventArgs_get_NewPresentationMode(py::wrapper::Windows::Media::Playback::TimedMetadataPresentationModeChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NewPresentationMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataPresentationModeChangedEventArgs_get_OldPresentationMode(py::wrapper::Windows::Media::Playback::TimedMetadataPresentationModeChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OldPresentationMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataPresentationModeChangedEventArgs_get_Track(py::wrapper::Windows::Media::Playback::TimedMetadataPresentationModeChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Track());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedMetadataPresentationModeChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::TimedMetadataPresentationModeChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataPresentationModeChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_TimedMetadataPresentationModeChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TimedMetadataPresentationModeChangedEventArgs[] = {
        { const_cast<char*>("new_presentation_mode"), (getter)TimedMetadataPresentationModeChangedEventArgs_get_NewPresentationMode, nullptr, nullptr, nullptr },
        { const_cast<char*>("old_presentation_mode"), (getter)TimedMetadataPresentationModeChangedEventArgs_get_OldPresentationMode, nullptr, nullptr, nullptr },
        { const_cast<char*>("track"), (getter)TimedMetadataPresentationModeChangedEventArgs_get_Track, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TimedMetadataPresentationModeChangedEventArgs[] = 
    {
        { Py_tp_new, _new_TimedMetadataPresentationModeChangedEventArgs },
        { Py_tp_dealloc, _dealloc_TimedMetadataPresentationModeChangedEventArgs },
        { Py_tp_methods, _methods_TimedMetadataPresentationModeChangedEventArgs },
        { Py_tp_getset, _getset_TimedMetadataPresentationModeChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimedMetadataPresentationModeChangedEventArgs =
    {
        "_winrt_Windows_Media_Playback.TimedMetadataPresentationModeChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Playback::TimedMetadataPresentationModeChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataPresentationModeChangedEventArgs
    };

    // ----- IMediaEnginePlaybackSource interface --------------------
    constexpr const char* const _type_name_IMediaEnginePlaybackSource = "IMediaEnginePlaybackSource";

    static PyObject* _new_IMediaEnginePlaybackSource(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IMediaEnginePlaybackSource);
        return nullptr;
    }

    static void _dealloc_IMediaEnginePlaybackSource(py::wrapper::Windows::Media::Playback::IMediaEnginePlaybackSource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IMediaEnginePlaybackSource_SetPlaybackSource(py::wrapper::Windows::Media::Playback::IMediaEnginePlaybackSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Playback::IMediaPlaybackSource>(args, 0);

                self->obj.SetPlaybackSource(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMediaEnginePlaybackSource_get_CurrentItem(py::wrapper::Windows::Media::Playback::IMediaEnginePlaybackSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IMediaEnginePlaybackSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::IMediaEnginePlaybackSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaEnginePlaybackSource[] = {
        { "set_playback_source", (PyCFunction)IMediaEnginePlaybackSource_SetPlaybackSource, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IMediaEnginePlaybackSource, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IMediaEnginePlaybackSource[] = {
        { const_cast<char*>("current_item"), (getter)IMediaEnginePlaybackSource_get_CurrentItem, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IMediaEnginePlaybackSource[] = 
    {
        { Py_tp_new, _new_IMediaEnginePlaybackSource },
        { Py_tp_dealloc, _dealloc_IMediaEnginePlaybackSource },
        { Py_tp_methods, _methods_IMediaEnginePlaybackSource },
        { Py_tp_getset, _getset_IMediaEnginePlaybackSource },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IMediaEnginePlaybackSource =
    {
        "_winrt_Windows_Media_Playback.IMediaEnginePlaybackSource",
        sizeof(py::wrapper::Windows::Media::Playback::IMediaEnginePlaybackSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaEnginePlaybackSource
    };

    // ----- IMediaPlaybackSource interface --------------------
    constexpr const char* const _type_name_IMediaPlaybackSource = "IMediaPlaybackSource";

    static PyObject* _new_IMediaPlaybackSource(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IMediaPlaybackSource);
        return nullptr;
    }

    static void _dealloc_IMediaPlaybackSource(py::wrapper::Windows::Media::Playback::IMediaPlaybackSource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_IMediaPlaybackSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Playback::IMediaPlaybackSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaPlaybackSource[] = {
        { "_from", (PyCFunction)_from_IMediaPlaybackSource, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IMediaPlaybackSource[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IMediaPlaybackSource[] = 
    {
        { Py_tp_new, _new_IMediaPlaybackSource },
        { Py_tp_dealloc, _dealloc_IMediaPlaybackSource },
        { Py_tp_methods, _methods_IMediaPlaybackSource },
        { Py_tp_getset, _getset_IMediaPlaybackSource },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IMediaPlaybackSource =
    {
        "_winrt_Windows_Media_Playback.IMediaPlaybackSource",
        sizeof(py::wrapper::Windows::Media::Playback::IMediaPlaybackSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaPlaybackSource
    };

    // ----- Windows.Media.Playback Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Media::Playback::BackgroundMediaPlayer>::python_type = py::register_python_type(module, _type_name_BackgroundMediaPlayer, &_type_spec_BackgroundMediaPlayer, nullptr);
            py::winrt_type<winrt::Windows::Media::Playback::CurrentMediaPlaybackItemChangedEventArgs>::python_type = py::register_python_type(module, _type_name_CurrentMediaPlaybackItemChangedEventArgs, &_type_spec_CurrentMediaPlaybackItemChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaBreak>::python_type = py::register_python_type(module, _type_name_MediaBreak, &_type_spec_MediaBreak, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaBreakEndedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaBreakEndedEventArgs, &_type_spec_MediaBreakEndedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaBreakManager>::python_type = py::register_python_type(module, _type_name_MediaBreakManager, &_type_spec_MediaBreakManager, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaBreakSchedule>::python_type = py::register_python_type(module, _type_name_MediaBreakSchedule, &_type_spec_MediaBreakSchedule, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaBreakSeekedOverEventArgs>::python_type = py::register_python_type(module, _type_name_MediaBreakSeekedOverEventArgs, &_type_spec_MediaBreakSeekedOverEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaBreakSkippedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaBreakSkippedEventArgs, &_type_spec_MediaBreakSkippedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaBreakStartedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaBreakStartedEventArgs, &_type_spec_MediaBreakStartedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaItemDisplayProperties>::python_type = py::register_python_type(module, _type_name_MediaItemDisplayProperties, &_type_spec_MediaItemDisplayProperties, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackAudioTrackList>::python_type = py::register_python_type(module, _type_name_MediaPlaybackAudioTrackList, &_type_spec_MediaPlaybackAudioTrackList, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManager>::python_type = py::register_python_type(module, _type_name_MediaPlaybackCommandManager, &_type_spec_MediaPlaybackCommandManager, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs, &_type_spec_MediaPlaybackCommandManagerAutoRepeatModeReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerCommandBehavior>::python_type = py::register_python_type(module, _type_name_MediaPlaybackCommandManagerCommandBehavior, &_type_spec_MediaPlaybackCommandManagerCommandBehavior, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerFastForwardReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaPlaybackCommandManagerFastForwardReceivedEventArgs, &_type_spec_MediaPlaybackCommandManagerFastForwardReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerNextReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaPlaybackCommandManagerNextReceivedEventArgs, &_type_spec_MediaPlaybackCommandManagerNextReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPauseReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaPlaybackCommandManagerPauseReceivedEventArgs, &_type_spec_MediaPlaybackCommandManagerPauseReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPlayReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaPlaybackCommandManagerPlayReceivedEventArgs, &_type_spec_MediaPlaybackCommandManagerPlayReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPositionReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaPlaybackCommandManagerPositionReceivedEventArgs, &_type_spec_MediaPlaybackCommandManagerPositionReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerPreviousReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaPlaybackCommandManagerPreviousReceivedEventArgs, &_type_spec_MediaPlaybackCommandManagerPreviousReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerRateReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaPlaybackCommandManagerRateReceivedEventArgs, &_type_spec_MediaPlaybackCommandManagerRateReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerRewindReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaPlaybackCommandManagerRewindReceivedEventArgs, &_type_spec_MediaPlaybackCommandManagerRewindReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackCommandManagerShuffleReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaPlaybackCommandManagerShuffleReceivedEventArgs, &_type_spec_MediaPlaybackCommandManagerShuffleReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackItem>::python_type = py::register_python_type(module, _type_name_MediaPlaybackItem, &_type_spec_MediaPlaybackItem, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackItemError>::python_type = py::register_python_type(module, _type_name_MediaPlaybackItemError, &_type_spec_MediaPlaybackItemError, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackItemFailedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaPlaybackItemFailedEventArgs, &_type_spec_MediaPlaybackItemFailedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackItemOpenedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaPlaybackItemOpenedEventArgs, &_type_spec_MediaPlaybackItemOpenedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackList>::python_type = py::register_python_type(module, _type_name_MediaPlaybackList, &_type_spec_MediaPlaybackList, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackSession>::python_type = py::register_python_type(module, _type_name_MediaPlaybackSession, &_type_spec_MediaPlaybackSession, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackSessionBufferingStartedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaPlaybackSessionBufferingStartedEventArgs, &_type_spec_MediaPlaybackSessionBufferingStartedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackSessionOutputDegradationPolicyState>::python_type = py::register_python_type(module, _type_name_MediaPlaybackSessionOutputDegradationPolicyState, &_type_spec_MediaPlaybackSessionOutputDegradationPolicyState, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackSphericalVideoProjection>::python_type = py::register_python_type(module, _type_name_MediaPlaybackSphericalVideoProjection, &_type_spec_MediaPlaybackSphericalVideoProjection, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackTimedMetadataTrackList>::python_type = py::register_python_type(module, _type_name_MediaPlaybackTimedMetadataTrackList, &_type_spec_MediaPlaybackTimedMetadataTrackList, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlaybackVideoTrackList>::python_type = py::register_python_type(module, _type_name_MediaPlaybackVideoTrackList, &_type_spec_MediaPlaybackVideoTrackList, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlayer>::python_type = py::register_python_type(module, _type_name_MediaPlayer, &_type_spec_MediaPlayer, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlayerDataReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaPlayerDataReceivedEventArgs, &_type_spec_MediaPlayerDataReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlayerFailedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaPlayerFailedEventArgs, &_type_spec_MediaPlayerFailedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlayerRateChangedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaPlayerRateChangedEventArgs, &_type_spec_MediaPlayerRateChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::MediaPlayerSurface>::python_type = py::register_python_type(module, _type_name_MediaPlayerSurface, &_type_spec_MediaPlayerSurface, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::PlaybackMediaMarker>::python_type = py::register_python_type(module, _type_name_PlaybackMediaMarker, &_type_spec_PlaybackMediaMarker, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::PlaybackMediaMarkerReachedEventArgs>::python_type = py::register_python_type(module, _type_name_PlaybackMediaMarkerReachedEventArgs, &_type_spec_PlaybackMediaMarkerReachedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::PlaybackMediaMarkerSequence>::python_type = py::register_python_type(module, _type_name_PlaybackMediaMarkerSequence, &_type_spec_PlaybackMediaMarkerSequence, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::TimedMetadataPresentationModeChangedEventArgs>::python_type = py::register_python_type(module, _type_name_TimedMetadataPresentationModeChangedEventArgs, &_type_spec_TimedMetadataPresentationModeChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::IMediaEnginePlaybackSource>::python_type = py::register_python_type(module, _type_name_IMediaEnginePlaybackSource, &_type_spec_IMediaEnginePlaybackSource, bases.get());
            py::winrt_type<winrt::Windows::Media::Playback::IMediaPlaybackSource>::python_type = py::register_python_type(module, _type_name_IMediaPlaybackSource, &_type_spec_IMediaPlaybackSource, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Media.Playback");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Media_Playback",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Media::Playback

PyMODINIT_FUNC
PyInit__winrt_Windows_Media_Playback (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Media::Playback::module_def);
}
