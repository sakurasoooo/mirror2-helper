// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Graphics.Imaging.h"

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapBuffer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapDecoder>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapEncoder>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapFrame>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapPropertySet>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapTransform>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapTypedValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::ImageStream>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::PixelDataProvider>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::SoftwareBitmap>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::IBitmapFrame>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapBounds>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapSize>::python_type;

PyObject* py::converter<winrt::Windows::Graphics::Imaging::BitmapBounds>::convert(winrt::Windows::Graphics::Imaging::BitmapBounds instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapBounds>());
}
winrt::Windows::Graphics::Imaging::BitmapBounds py::converter<winrt::Windows::Graphics::Imaging::BitmapBounds>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapBounds>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Graphics::Imaging::BitmapBounds return_value{};

    PyObject* py_X = PyDict_GetItemString(obj, "x");
    if (!py_X) { throw winrt::hresult_invalid_argument(); }
    return_value.X = converter<uint32_t>::convert_to(py_X);

    PyObject* py_Y = PyDict_GetItemString(obj, "y");
    if (!py_Y) { throw winrt::hresult_invalid_argument(); }
    return_value.Y = converter<uint32_t>::convert_to(py_Y);

    PyObject* py_Width = PyDict_GetItemString(obj, "width");
    if (!py_Width) { throw winrt::hresult_invalid_argument(); }
    return_value.Width = converter<uint32_t>::convert_to(py_Width);

    PyObject* py_Height = PyDict_GetItemString(obj, "height");
    if (!py_Height) { throw winrt::hresult_invalid_argument(); }
    return_value.Height = converter<uint32_t>::convert_to(py_Height);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>::convert(winrt::Windows::Graphics::Imaging::BitmapPlaneDescription instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>());
}
winrt::Windows::Graphics::Imaging::BitmapPlaneDescription py::converter<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Graphics::Imaging::BitmapPlaneDescription return_value{};

    PyObject* py_StartIndex = PyDict_GetItemString(obj, "start_index");
    if (!py_StartIndex) { throw winrt::hresult_invalid_argument(); }
    return_value.StartIndex = converter<int32_t>::convert_to(py_StartIndex);

    PyObject* py_Width = PyDict_GetItemString(obj, "width");
    if (!py_Width) { throw winrt::hresult_invalid_argument(); }
    return_value.Width = converter<int32_t>::convert_to(py_Width);

    PyObject* py_Height = PyDict_GetItemString(obj, "height");
    if (!py_Height) { throw winrt::hresult_invalid_argument(); }
    return_value.Height = converter<int32_t>::convert_to(py_Height);

    PyObject* py_Stride = PyDict_GetItemString(obj, "stride");
    if (!py_Stride) { throw winrt::hresult_invalid_argument(); }
    return_value.Stride = converter<int32_t>::convert_to(py_Stride);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Graphics::Imaging::BitmapSize>::convert(winrt::Windows::Graphics::Imaging::BitmapSize instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapSize>());
}
winrt::Windows::Graphics::Imaging::BitmapSize py::converter<winrt::Windows::Graphics::Imaging::BitmapSize>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapSize>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapSize>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Graphics::Imaging::BitmapSize return_value{};

    PyObject* py_Width = PyDict_GetItemString(obj, "width");
    if (!py_Width) { throw winrt::hresult_invalid_argument(); }
    return_value.Width = converter<uint32_t>::convert_to(py_Width);

    PyObject* py_Height = PyDict_GetItemString(obj, "height");
    if (!py_Height) { throw winrt::hresult_invalid_argument(); }
    return_value.Height = converter<uint32_t>::convert_to(py_Height);

    return return_value;
}

namespace py::cpp::Windows::Graphics::Imaging
{
    // ----- BitmapBuffer class --------------------
    constexpr const char* const _type_name_BitmapBuffer = "BitmapBuffer";

    static PyObject* _new_BitmapBuffer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BitmapBuffer);
        return nullptr;
    }

    static void _dealloc_BitmapBuffer(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BitmapBuffer_Close(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapBuffer_CreateReference(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapBuffer_GetPlaneCount(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPlaneCount());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapBuffer_GetPlaneDescription(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.GetPlaneDescription(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_BitmapBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_BitmapBuffer(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_BitmapBuffer(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapBuffer[] = {
        { "close", (PyCFunction)BitmapBuffer_Close, METH_VARARGS, nullptr },
        { "create_reference", (PyCFunction)BitmapBuffer_CreateReference, METH_VARARGS, nullptr },
        { "get_plane_count", (PyCFunction)BitmapBuffer_GetPlaneCount, METH_VARARGS, nullptr },
        { "get_plane_description", (PyCFunction)BitmapBuffer_GetPlaneDescription, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_BitmapBuffer, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_BitmapBuffer, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_BitmapBuffer, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BitmapBuffer[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_BitmapBuffer[] = 
    {
        { Py_tp_new, _new_BitmapBuffer },
        { Py_tp_dealloc, _dealloc_BitmapBuffer },
        { Py_tp_methods, _methods_BitmapBuffer },
        { Py_tp_getset, _getset_BitmapBuffer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BitmapBuffer =
    {
        "_winrt_Windows_Graphics_Imaging.BitmapBuffer",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapBuffer
    };

    // ----- BitmapCodecInformation class --------------------
    constexpr const char* const _type_name_BitmapCodecInformation = "BitmapCodecInformation";

    static PyObject* _new_BitmapCodecInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BitmapCodecInformation);
        return nullptr;
    }

    static void _dealloc_BitmapCodecInformation(py::wrapper::Windows::Graphics::Imaging::BitmapCodecInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BitmapCodecInformation_get_CodecId(py::wrapper::Windows::Graphics::Imaging::BitmapCodecInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CodecId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapCodecInformation_get_FileExtensions(py::wrapper::Windows::Graphics::Imaging::BitmapCodecInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileExtensions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapCodecInformation_get_FriendlyName(py::wrapper::Windows::Graphics::Imaging::BitmapCodecInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapCodecInformation_get_MimeTypes(py::wrapper::Windows::Graphics::Imaging::BitmapCodecInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MimeTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BitmapCodecInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapCodecInformation[] = {
        { "_from", (PyCFunction)_from_BitmapCodecInformation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BitmapCodecInformation[] = {
        { const_cast<char*>("codec_id"), (getter)BitmapCodecInformation_get_CodecId, nullptr, nullptr, nullptr },
        { const_cast<char*>("file_extensions"), (getter)BitmapCodecInformation_get_FileExtensions, nullptr, nullptr, nullptr },
        { const_cast<char*>("friendly_name"), (getter)BitmapCodecInformation_get_FriendlyName, nullptr, nullptr, nullptr },
        { const_cast<char*>("mime_types"), (getter)BitmapCodecInformation_get_MimeTypes, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BitmapCodecInformation[] = 
    {
        { Py_tp_new, _new_BitmapCodecInformation },
        { Py_tp_dealloc, _dealloc_BitmapCodecInformation },
        { Py_tp_methods, _methods_BitmapCodecInformation },
        { Py_tp_getset, _getset_BitmapCodecInformation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BitmapCodecInformation =
    {
        "_winrt_Windows_Graphics_Imaging.BitmapCodecInformation",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapCodecInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapCodecInformation
    };

    // ----- BitmapDecoder class --------------------
    constexpr const char* const _type_name_BitmapDecoder = "BitmapDecoder";

    static PyObject* _new_BitmapDecoder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BitmapDecoder);
        return nullptr;
    }

    static void _dealloc_BitmapDecoder(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BitmapDecoder_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::CreateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::CreateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_GetDecoderInformationEnumerator(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::GetDecoderInformationEnumerator());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_GetFrameAsync(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetFrameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_GetPixelDataAsync(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPixelDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

                return py::convert(self->obj.GetPixelDataAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_GetPreviewAsync(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPreviewAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_GetSoftwareBitmapAsync(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSoftwareBitmapAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);

                return py::convert(self->obj.GetSoftwareBitmapAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

                return py::convert(self->obj.GetSoftwareBitmapAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_GetThumbnailAsync(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetThumbnailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_BitmapContainerProperties(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapContainerProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_DecoderInformation(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecoderInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_FrameCount(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_BitmapAlphaMode(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_BitmapPixelFormat(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_BitmapProperties(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_DpiX(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_DpiY(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_OrientedPixelHeight(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OrientedPixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_OrientedPixelWidth(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OrientedPixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_PixelHeight(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_PixelWidth(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_BmpDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::BmpDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_GifDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::GifDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_IcoDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::IcoDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_JpegDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::JpegDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_JpegXRDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::JpegXRDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_PngDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::PngDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_TiffDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::TiffDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_HeifDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::HeifDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_WebpDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::WebpDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BitmapDecoder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapDecoder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapDecoder[] = {
        { "create_async", (PyCFunction)BitmapDecoder_CreateAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_decoder_information_enumerator", (PyCFunction)BitmapDecoder_GetDecoderInformationEnumerator, METH_VARARGS | METH_STATIC, nullptr },
        { "get_frame_async", (PyCFunction)BitmapDecoder_GetFrameAsync, METH_VARARGS, nullptr },
        { "get_pixel_data_async", (PyCFunction)BitmapDecoder_GetPixelDataAsync, METH_VARARGS, nullptr },
        { "get_preview_async", (PyCFunction)BitmapDecoder_GetPreviewAsync, METH_VARARGS, nullptr },
        { "get_software_bitmap_async", (PyCFunction)BitmapDecoder_GetSoftwareBitmapAsync, METH_VARARGS, nullptr },
        { "get_thumbnail_async", (PyCFunction)BitmapDecoder_GetThumbnailAsync, METH_VARARGS, nullptr },
        { "get_bmp_decoder_id", (PyCFunction)BitmapDecoder_get_BmpDecoderId, METH_NOARGS | METH_STATIC, nullptr },
        { "get_gif_decoder_id", (PyCFunction)BitmapDecoder_get_GifDecoderId, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ico_decoder_id", (PyCFunction)BitmapDecoder_get_IcoDecoderId, METH_NOARGS | METH_STATIC, nullptr },
        { "get_jpeg_decoder_id", (PyCFunction)BitmapDecoder_get_JpegDecoderId, METH_NOARGS | METH_STATIC, nullptr },
        { "get_jpeg_x_r_decoder_id", (PyCFunction)BitmapDecoder_get_JpegXRDecoderId, METH_NOARGS | METH_STATIC, nullptr },
        { "get_png_decoder_id", (PyCFunction)BitmapDecoder_get_PngDecoderId, METH_NOARGS | METH_STATIC, nullptr },
        { "get_tiff_decoder_id", (PyCFunction)BitmapDecoder_get_TiffDecoderId, METH_NOARGS | METH_STATIC, nullptr },
        { "get_heif_decoder_id", (PyCFunction)BitmapDecoder_get_HeifDecoderId, METH_NOARGS | METH_STATIC, nullptr },
        { "get_webp_decoder_id", (PyCFunction)BitmapDecoder_get_WebpDecoderId, METH_NOARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_BitmapDecoder, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BitmapDecoder[] = {
        { const_cast<char*>("bitmap_container_properties"), (getter)BitmapDecoder_get_BitmapContainerProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("decoder_information"), (getter)BitmapDecoder_get_DecoderInformation, nullptr, nullptr, nullptr },
        { const_cast<char*>("frame_count"), (getter)BitmapDecoder_get_FrameCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("bitmap_alpha_mode"), (getter)BitmapDecoder_get_BitmapAlphaMode, nullptr, nullptr, nullptr },
        { const_cast<char*>("bitmap_pixel_format"), (getter)BitmapDecoder_get_BitmapPixelFormat, nullptr, nullptr, nullptr },
        { const_cast<char*>("bitmap_properties"), (getter)BitmapDecoder_get_BitmapProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("dpi_x"), (getter)BitmapDecoder_get_DpiX, nullptr, nullptr, nullptr },
        { const_cast<char*>("dpi_y"), (getter)BitmapDecoder_get_DpiY, nullptr, nullptr, nullptr },
        { const_cast<char*>("oriented_pixel_height"), (getter)BitmapDecoder_get_OrientedPixelHeight, nullptr, nullptr, nullptr },
        { const_cast<char*>("oriented_pixel_width"), (getter)BitmapDecoder_get_OrientedPixelWidth, nullptr, nullptr, nullptr },
        { const_cast<char*>("pixel_height"), (getter)BitmapDecoder_get_PixelHeight, nullptr, nullptr, nullptr },
        { const_cast<char*>("pixel_width"), (getter)BitmapDecoder_get_PixelWidth, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BitmapDecoder[] = 
    {
        { Py_tp_new, _new_BitmapDecoder },
        { Py_tp_dealloc, _dealloc_BitmapDecoder },
        { Py_tp_methods, _methods_BitmapDecoder },
        { Py_tp_getset, _getset_BitmapDecoder },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BitmapDecoder =
    {
        "_winrt_Windows_Graphics_Imaging.BitmapDecoder",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapDecoder
    };

    // ----- BitmapEncoder class --------------------
    constexpr const char* const _type_name_BitmapEncoder = "BitmapEncoder";

    static PyObject* _new_BitmapEncoder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BitmapEncoder);
        return nullptr;
    }

    static void _dealloc_BitmapEncoder(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BitmapEncoder_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::CreateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Graphics::Imaging::BitmapTypedValue>>>(args, 2);

                return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::CreateAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_CreateForInPlacePropertyEncodingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapDecoder>(args, 0);

                return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::CreateForInPlacePropertyEncodingAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_CreateForTranscodingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapDecoder>(args, 1);

                return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::CreateForTranscodingAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_FlushAsync(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_GetEncoderInformationEnumerator(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::GetEncoderInformationEnumerator());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_GoToNextFrameAsync(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GoToNextFrameAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Graphics::Imaging::BitmapTypedValue>>>(args, 0);

                return py::convert(self->obj.GoToNextFrameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_SetPixelData(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<double>(args, 4);
                auto param5 = py::convert_to<double>(args, 5);
                auto param6 = py::convert_to<winrt::array_view<uint8_t>>(args, 6);

                self->obj.SetPixelData(param0, param1, param2, param3, param4, param5, param6);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_SetSoftwareBitmap(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);

                self->obj.SetSoftwareBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_IsThumbnailGenerated(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsThumbnailGenerated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapEncoder_put_IsThumbnailGenerated(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsThumbnailGenerated(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapEncoder_get_GeneratedThumbnailWidth(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.GeneratedThumbnailWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapEncoder_put_GeneratedThumbnailWidth(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.GeneratedThumbnailWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapEncoder_get_GeneratedThumbnailHeight(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.GeneratedThumbnailHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapEncoder_put_GeneratedThumbnailHeight(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.GeneratedThumbnailHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapEncoder_get_BitmapContainerProperties(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapContainerProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_BitmapProperties(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_BitmapTransform(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_EncoderInformation(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncoderInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_BmpEncoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::BmpEncoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_GifEncoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::GifEncoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_JpegEncoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::JpegEncoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_JpegXREncoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::JpegXREncoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_PngEncoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::PngEncoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_TiffEncoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::TiffEncoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_HeifEncoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::HeifEncoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BitmapEncoder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapEncoder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapEncoder[] = {
        { "create_async", (PyCFunction)BitmapEncoder_CreateAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "create_for_in_place_property_encoding_async", (PyCFunction)BitmapEncoder_CreateForInPlacePropertyEncodingAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "create_for_transcoding_async", (PyCFunction)BitmapEncoder_CreateForTranscodingAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "flush_async", (PyCFunction)BitmapEncoder_FlushAsync, METH_VARARGS, nullptr },
        { "get_encoder_information_enumerator", (PyCFunction)BitmapEncoder_GetEncoderInformationEnumerator, METH_VARARGS | METH_STATIC, nullptr },
        { "go_to_next_frame_async", (PyCFunction)BitmapEncoder_GoToNextFrameAsync, METH_VARARGS, nullptr },
        { "set_pixel_data", (PyCFunction)BitmapEncoder_SetPixelData, METH_VARARGS, nullptr },
        { "set_software_bitmap", (PyCFunction)BitmapEncoder_SetSoftwareBitmap, METH_VARARGS, nullptr },
        { "get_bmp_encoder_id", (PyCFunction)BitmapEncoder_get_BmpEncoderId, METH_NOARGS | METH_STATIC, nullptr },
        { "get_gif_encoder_id", (PyCFunction)BitmapEncoder_get_GifEncoderId, METH_NOARGS | METH_STATIC, nullptr },
        { "get_jpeg_encoder_id", (PyCFunction)BitmapEncoder_get_JpegEncoderId, METH_NOARGS | METH_STATIC, nullptr },
        { "get_jpeg_x_r_encoder_id", (PyCFunction)BitmapEncoder_get_JpegXREncoderId, METH_NOARGS | METH_STATIC, nullptr },
        { "get_png_encoder_id", (PyCFunction)BitmapEncoder_get_PngEncoderId, METH_NOARGS | METH_STATIC, nullptr },
        { "get_tiff_encoder_id", (PyCFunction)BitmapEncoder_get_TiffEncoderId, METH_NOARGS | METH_STATIC, nullptr },
        { "get_heif_encoder_id", (PyCFunction)BitmapEncoder_get_HeifEncoderId, METH_NOARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_BitmapEncoder, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BitmapEncoder[] = {
        { const_cast<char*>("is_thumbnail_generated"), (getter)BitmapEncoder_get_IsThumbnailGenerated, (setter)BitmapEncoder_put_IsThumbnailGenerated, nullptr, nullptr },
        { const_cast<char*>("generated_thumbnail_width"), (getter)BitmapEncoder_get_GeneratedThumbnailWidth, (setter)BitmapEncoder_put_GeneratedThumbnailWidth, nullptr, nullptr },
        { const_cast<char*>("generated_thumbnail_height"), (getter)BitmapEncoder_get_GeneratedThumbnailHeight, (setter)BitmapEncoder_put_GeneratedThumbnailHeight, nullptr, nullptr },
        { const_cast<char*>("bitmap_container_properties"), (getter)BitmapEncoder_get_BitmapContainerProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("bitmap_properties"), (getter)BitmapEncoder_get_BitmapProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("bitmap_transform"), (getter)BitmapEncoder_get_BitmapTransform, nullptr, nullptr, nullptr },
        { const_cast<char*>("encoder_information"), (getter)BitmapEncoder_get_EncoderInformation, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BitmapEncoder[] = 
    {
        { Py_tp_new, _new_BitmapEncoder },
        { Py_tp_dealloc, _dealloc_BitmapEncoder },
        { Py_tp_methods, _methods_BitmapEncoder },
        { Py_tp_getset, _getset_BitmapEncoder },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BitmapEncoder =
    {
        "_winrt_Windows_Graphics_Imaging.BitmapEncoder",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapEncoder
    };

    // ----- BitmapFrame class --------------------
    constexpr const char* const _type_name_BitmapFrame = "BitmapFrame";

    static PyObject* _new_BitmapFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BitmapFrame);
        return nullptr;
    }

    static void _dealloc_BitmapFrame(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BitmapFrame_GetPixelDataAsync(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPixelDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

                return py::convert(self->obj.GetPixelDataAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_GetSoftwareBitmapAsync(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSoftwareBitmapAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);

                return py::convert(self->obj.GetSoftwareBitmapAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

                return py::convert(self->obj.GetSoftwareBitmapAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_GetThumbnailAsync(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetThumbnailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_BitmapAlphaMode(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_BitmapPixelFormat(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_BitmapProperties(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_DpiX(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_DpiY(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_OrientedPixelHeight(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OrientedPixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_OrientedPixelWidth(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OrientedPixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_PixelHeight(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_PixelWidth(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BitmapFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapFrame[] = {
        { "get_pixel_data_async", (PyCFunction)BitmapFrame_GetPixelDataAsync, METH_VARARGS, nullptr },
        { "get_software_bitmap_async", (PyCFunction)BitmapFrame_GetSoftwareBitmapAsync, METH_VARARGS, nullptr },
        { "get_thumbnail_async", (PyCFunction)BitmapFrame_GetThumbnailAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_BitmapFrame, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BitmapFrame[] = {
        { const_cast<char*>("bitmap_alpha_mode"), (getter)BitmapFrame_get_BitmapAlphaMode, nullptr, nullptr, nullptr },
        { const_cast<char*>("bitmap_pixel_format"), (getter)BitmapFrame_get_BitmapPixelFormat, nullptr, nullptr, nullptr },
        { const_cast<char*>("bitmap_properties"), (getter)BitmapFrame_get_BitmapProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("dpi_x"), (getter)BitmapFrame_get_DpiX, nullptr, nullptr, nullptr },
        { const_cast<char*>("dpi_y"), (getter)BitmapFrame_get_DpiY, nullptr, nullptr, nullptr },
        { const_cast<char*>("oriented_pixel_height"), (getter)BitmapFrame_get_OrientedPixelHeight, nullptr, nullptr, nullptr },
        { const_cast<char*>("oriented_pixel_width"), (getter)BitmapFrame_get_OrientedPixelWidth, nullptr, nullptr, nullptr },
        { const_cast<char*>("pixel_height"), (getter)BitmapFrame_get_PixelHeight, nullptr, nullptr, nullptr },
        { const_cast<char*>("pixel_width"), (getter)BitmapFrame_get_PixelWidth, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BitmapFrame[] = 
    {
        { Py_tp_new, _new_BitmapFrame },
        { Py_tp_dealloc, _dealloc_BitmapFrame },
        { Py_tp_methods, _methods_BitmapFrame },
        { Py_tp_getset, _getset_BitmapFrame },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BitmapFrame =
    {
        "_winrt_Windows_Graphics_Imaging.BitmapFrame",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapFrame
    };

    // ----- BitmapProperties class --------------------
    constexpr const char* const _type_name_BitmapProperties = "BitmapProperties";

    static PyObject* _new_BitmapProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BitmapProperties);
        return nullptr;
    }

    static void _dealloc_BitmapProperties(py::wrapper::Windows::Graphics::Imaging::BitmapProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BitmapProperties_GetPropertiesAsync(py::wrapper::Windows::Graphics::Imaging::BitmapProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetPropertiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapProperties_SetPropertiesAsync(py::wrapper::Windows::Graphics::Imaging::BitmapProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Graphics::Imaging::BitmapTypedValue>>>(args, 0);

                return py::convert(self->obj.SetPropertiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_BitmapProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapProperties[] = {
        { "get_properties_async", (PyCFunction)BitmapProperties_GetPropertiesAsync, METH_VARARGS, nullptr },
        { "set_properties_async", (PyCFunction)BitmapProperties_SetPropertiesAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_BitmapProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BitmapProperties[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_BitmapProperties[] = 
    {
        { Py_tp_new, _new_BitmapProperties },
        { Py_tp_dealloc, _dealloc_BitmapProperties },
        { Py_tp_methods, _methods_BitmapProperties },
        { Py_tp_getset, _getset_BitmapProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BitmapProperties =
    {
        "_winrt_Windows_Graphics_Imaging.BitmapProperties",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapProperties
    };

    // ----- BitmapPropertiesView class --------------------
    constexpr const char* const _type_name_BitmapPropertiesView = "BitmapPropertiesView";

    static PyObject* _new_BitmapPropertiesView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BitmapPropertiesView);
        return nullptr;
    }

    static void _dealloc_BitmapPropertiesView(py::wrapper::Windows::Graphics::Imaging::BitmapPropertiesView* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BitmapPropertiesView_GetPropertiesAsync(py::wrapper::Windows::Graphics::Imaging::BitmapPropertiesView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetPropertiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_BitmapPropertiesView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapPropertiesView[] = {
        { "get_properties_async", (PyCFunction)BitmapPropertiesView_GetPropertiesAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_BitmapPropertiesView, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BitmapPropertiesView[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_BitmapPropertiesView[] = 
    {
        { Py_tp_new, _new_BitmapPropertiesView },
        { Py_tp_dealloc, _dealloc_BitmapPropertiesView },
        { Py_tp_methods, _methods_BitmapPropertiesView },
        { Py_tp_getset, _getset_BitmapPropertiesView },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BitmapPropertiesView =
    {
        "_winrt_Windows_Graphics_Imaging.BitmapPropertiesView",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapPropertiesView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapPropertiesView
    };

    // ----- BitmapPropertySet class --------------------
    constexpr const char* const _type_name_BitmapPropertySet = "BitmapPropertySet";

    static PyObject* _new_BitmapPropertySet(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Imaging::BitmapPropertySet instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BitmapPropertySet(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BitmapPropertySet_Clear(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapPropertySet_First(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapPropertySet_GetView(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapPropertySet_HasKey(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapPropertySet_Insert(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTypedValue>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapPropertySet_Lookup(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapPropertySet_Remove(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapPropertySet_get_Size(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BitmapPropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapPropertySet>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_BitmapPropertySet(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _map_length_BitmapPropertySet(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_BitmapPropertySet(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* key) noexcept
    {
        try
        {
            return py::convert(self->obj.Lookup(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_BitmapPropertySet(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            if (value == nullptr) { self->obj.Remove(_key); }
            else { self->obj.Insert(_key, py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTypedValue>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_BitmapPropertySet[] = {
        { "clear", (PyCFunction)BitmapPropertySet_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)BitmapPropertySet_First, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)BitmapPropertySet_GetView, METH_VARARGS, nullptr },
        { "has_key", (PyCFunction)BitmapPropertySet_HasKey, METH_VARARGS, nullptr },
        { "insert", (PyCFunction)BitmapPropertySet_Insert, METH_VARARGS, nullptr },
        { "lookup", (PyCFunction)BitmapPropertySet_Lookup, METH_VARARGS, nullptr },
        { "remove", (PyCFunction)BitmapPropertySet_Remove, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_BitmapPropertySet, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BitmapPropertySet[] = {
        { const_cast<char*>("size"), (getter)BitmapPropertySet_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BitmapPropertySet[] = 
    {
        { Py_tp_new, _new_BitmapPropertySet },
        { Py_tp_dealloc, _dealloc_BitmapPropertySet },
        { Py_tp_methods, _methods_BitmapPropertySet },
        { Py_tp_getset, _getset_BitmapPropertySet },
        { Py_tp_iter, _iterator_BitmapPropertySet },
        { Py_mp_length, _map_length_BitmapPropertySet },
        { Py_mp_subscript, _map_subscript_BitmapPropertySet },
        { Py_mp_ass_subscript, _map_assign_BitmapPropertySet },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BitmapPropertySet =
    {
        "_winrt_Windows_Graphics_Imaging.BitmapPropertySet",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapPropertySet
    };

    // ----- BitmapTransform class --------------------
    constexpr const char* const _type_name_BitmapTransform = "BitmapTransform";

    static PyObject* _new_BitmapTransform(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Imaging::BitmapTransform instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BitmapTransform(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BitmapTransform_get_ScaledWidth(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScaledWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapTransform_put_ScaledWidth(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ScaledWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapTransform_get_ScaledHeight(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScaledHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapTransform_put_ScaledHeight(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ScaledHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapTransform_get_Rotation(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Rotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapTransform_put_Rotation(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapRotation>(arg);

            self->obj.Rotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapTransform_get_InterpolationMode(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterpolationMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapTransform_put_InterpolationMode(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapInterpolationMode>(arg);

            self->obj.InterpolationMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapTransform_get_Flip(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Flip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapTransform_put_Flip(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFlip>(arg);

            self->obj.Flip(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapTransform_get_Bounds(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapTransform_put_Bounds(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapBounds>(arg);

            self->obj.Bounds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_BitmapTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapTransform[] = {
        { "_from", (PyCFunction)_from_BitmapTransform, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BitmapTransform[] = {
        { const_cast<char*>("scaled_width"), (getter)BitmapTransform_get_ScaledWidth, (setter)BitmapTransform_put_ScaledWidth, nullptr, nullptr },
        { const_cast<char*>("scaled_height"), (getter)BitmapTransform_get_ScaledHeight, (setter)BitmapTransform_put_ScaledHeight, nullptr, nullptr },
        { const_cast<char*>("rotation"), (getter)BitmapTransform_get_Rotation, (setter)BitmapTransform_put_Rotation, nullptr, nullptr },
        { const_cast<char*>("interpolation_mode"), (getter)BitmapTransform_get_InterpolationMode, (setter)BitmapTransform_put_InterpolationMode, nullptr, nullptr },
        { const_cast<char*>("flip"), (getter)BitmapTransform_get_Flip, (setter)BitmapTransform_put_Flip, nullptr, nullptr },
        { const_cast<char*>("bounds"), (getter)BitmapTransform_get_Bounds, (setter)BitmapTransform_put_Bounds, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BitmapTransform[] = 
    {
        { Py_tp_new, _new_BitmapTransform },
        { Py_tp_dealloc, _dealloc_BitmapTransform },
        { Py_tp_methods, _methods_BitmapTransform },
        { Py_tp_getset, _getset_BitmapTransform },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BitmapTransform =
    {
        "_winrt_Windows_Graphics_Imaging.BitmapTransform",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapTransform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapTransform
    };

    // ----- BitmapTypedValue class --------------------
    constexpr const char* const _type_name_BitmapTypedValue = "BitmapTypedValue";

    static PyObject* _new_BitmapTypedValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::PropertyType>(args, 1);

                winrt::Windows::Graphics::Imaging::BitmapTypedValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BitmapTypedValue(py::wrapper::Windows::Graphics::Imaging::BitmapTypedValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BitmapTypedValue_get_Type(py::wrapper::Windows::Graphics::Imaging::BitmapTypedValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapTypedValue_get_Value(py::wrapper::Windows::Graphics::Imaging::BitmapTypedValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BitmapTypedValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapTypedValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapTypedValue[] = {
        { "_from", (PyCFunction)_from_BitmapTypedValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BitmapTypedValue[] = {
        { const_cast<char*>("type"), (getter)BitmapTypedValue_get_Type, nullptr, nullptr, nullptr },
        { const_cast<char*>("value"), (getter)BitmapTypedValue_get_Value, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BitmapTypedValue[] = 
    {
        { Py_tp_new, _new_BitmapTypedValue },
        { Py_tp_dealloc, _dealloc_BitmapTypedValue },
        { Py_tp_methods, _methods_BitmapTypedValue },
        { Py_tp_getset, _getset_BitmapTypedValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BitmapTypedValue =
    {
        "_winrt_Windows_Graphics_Imaging.BitmapTypedValue",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapTypedValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapTypedValue
    };

    // ----- ImageStream class --------------------
    constexpr const char* const _type_name_ImageStream = "ImageStream";

    static PyObject* _new_ImageStream(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ImageStream);
        return nullptr;
    }

    static void _dealloc_ImageStream(py::wrapper::Windows::Graphics::Imaging::ImageStream* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ImageStream_CloneStream(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CloneStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_Close(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_FlushAsync(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_GetInputStreamAt(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetInputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_GetOutputStreamAt(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetOutputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_ReadAsync(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_Seek(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_WriteAsync(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_get_ContentType(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageStream_get_Size(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageStream_put_Size(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageStream_get_CanRead(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageStream_get_CanWrite(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageStream_get_Position(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ImageStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::ImageStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ImageStream(py::wrapper::Windows::Graphics::Imaging::ImageStream* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_ImageStream(py::wrapper::Windows::Graphics::Imaging::ImageStream* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageStream[] = {
        { "clone_stream", (PyCFunction)ImageStream_CloneStream, METH_VARARGS, nullptr },
        { "close", (PyCFunction)ImageStream_Close, METH_VARARGS, nullptr },
        { "flush_async", (PyCFunction)ImageStream_FlushAsync, METH_VARARGS, nullptr },
        { "get_input_stream_at", (PyCFunction)ImageStream_GetInputStreamAt, METH_VARARGS, nullptr },
        { "get_output_stream_at", (PyCFunction)ImageStream_GetOutputStreamAt, METH_VARARGS, nullptr },
        { "read_async", (PyCFunction)ImageStream_ReadAsync, METH_VARARGS, nullptr },
        { "seek", (PyCFunction)ImageStream_Seek, METH_VARARGS, nullptr },
        { "write_async", (PyCFunction)ImageStream_WriteAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ImageStream, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_ImageStream, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_ImageStream, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ImageStream[] = {
        { const_cast<char*>("content_type"), (getter)ImageStream_get_ContentType, nullptr, nullptr, nullptr },
        { const_cast<char*>("size"), (getter)ImageStream_get_Size, (setter)ImageStream_put_Size, nullptr, nullptr },
        { const_cast<char*>("can_read"), (getter)ImageStream_get_CanRead, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_write"), (getter)ImageStream_get_CanWrite, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)ImageStream_get_Position, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ImageStream[] = 
    {
        { Py_tp_new, _new_ImageStream },
        { Py_tp_dealloc, _dealloc_ImageStream },
        { Py_tp_methods, _methods_ImageStream },
        { Py_tp_getset, _getset_ImageStream },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ImageStream =
    {
        "_winrt_Windows_Graphics_Imaging.ImageStream",
        sizeof(py::wrapper::Windows::Graphics::Imaging::ImageStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageStream
    };

    // ----- PixelDataProvider class --------------------
    constexpr const char* const _type_name_PixelDataProvider = "PixelDataProvider";

    static PyObject* _new_PixelDataProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PixelDataProvider);
        return nullptr;
    }

    static void _dealloc_PixelDataProvider(py::wrapper::Windows::Graphics::Imaging::PixelDataProvider* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PixelDataProvider_DetachPixelData(py::wrapper::Windows::Graphics::Imaging::PixelDataProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DetachPixelData());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_PixelDataProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::PixelDataProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PixelDataProvider[] = {
        { "detach_pixel_data", (PyCFunction)PixelDataProvider_DetachPixelData, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PixelDataProvider, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PixelDataProvider[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PixelDataProvider[] = 
    {
        { Py_tp_new, _new_PixelDataProvider },
        { Py_tp_dealloc, _dealloc_PixelDataProvider },
        { Py_tp_methods, _methods_PixelDataProvider },
        { Py_tp_getset, _getset_PixelDataProvider },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PixelDataProvider =
    {
        "_winrt_Windows_Graphics_Imaging.PixelDataProvider",
        sizeof(py::wrapper::Windows::Graphics::Imaging::PixelDataProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PixelDataProvider
    };

    // ----- SoftwareBitmap class --------------------
    constexpr const char* const _type_name_SoftwareBitmap = "SoftwareBitmap";

    static PyObject* _new_SoftwareBitmap(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                winrt::Windows::Graphics::Imaging::SoftwareBitmap instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 3);

                winrt::Windows::Graphics::Imaging::SoftwareBitmap instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SoftwareBitmap(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SoftwareBitmap_Close(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_Convert(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 1);

                return py::convert(winrt::Windows::Graphics::Imaging::SoftwareBitmap::Convert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 2);

                return py::convert(winrt::Windows::Graphics::Imaging::SoftwareBitmap::Convert(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_Copy(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);

                return py::convert(winrt::Windows::Graphics::Imaging::SoftwareBitmap::Copy(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_CopyFromBuffer(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.CopyFromBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_CopyTo(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);

                self->obj.CopyTo(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_CopyToBuffer(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.CopyToBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_CreateCopyFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                return py::convert(winrt::Windows::Graphics::Imaging::SoftwareBitmap::CreateCopyFromBuffer(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 4);

                return py::convert(winrt::Windows::Graphics::Imaging::SoftwareBitmap::CreateCopyFromBuffer(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_CreateCopyFromSurfaceAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);

                return py::convert(winrt::Windows::Graphics::Imaging::SoftwareBitmap::CreateCopyFromSurfaceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);

                return py::convert(winrt::Windows::Graphics::Imaging::SoftwareBitmap::CreateCopyFromSurfaceAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_GetReadOnlyView(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetReadOnlyView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_LockBuffer(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapBufferAccessMode>(args, 0);

                return py::convert(self->obj.LockBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_get_DpiY(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SoftwareBitmap_put_DpiY(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DpiY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SoftwareBitmap_get_DpiX(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SoftwareBitmap_put_DpiX(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DpiX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SoftwareBitmap_get_BitmapAlphaMode(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_get_BitmapPixelFormat(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_get_IsReadOnly(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_get_PixelHeight(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_get_PixelWidth(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SoftwareBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::SoftwareBitmap>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_SoftwareBitmap(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_SoftwareBitmap(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SoftwareBitmap[] = {
        { "close", (PyCFunction)SoftwareBitmap_Close, METH_VARARGS, nullptr },
        { "convert", (PyCFunction)SoftwareBitmap_Convert, METH_VARARGS | METH_STATIC, nullptr },
        { "copy", (PyCFunction)SoftwareBitmap_Copy, METH_VARARGS | METH_STATIC, nullptr },
        { "copy_from_buffer", (PyCFunction)SoftwareBitmap_CopyFromBuffer, METH_VARARGS, nullptr },
        { "copy_to", (PyCFunction)SoftwareBitmap_CopyTo, METH_VARARGS, nullptr },
        { "copy_to_buffer", (PyCFunction)SoftwareBitmap_CopyToBuffer, METH_VARARGS, nullptr },
        { "create_copy_from_buffer", (PyCFunction)SoftwareBitmap_CreateCopyFromBuffer, METH_VARARGS | METH_STATIC, nullptr },
        { "create_copy_from_surface_async", (PyCFunction)SoftwareBitmap_CreateCopyFromSurfaceAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_read_only_view", (PyCFunction)SoftwareBitmap_GetReadOnlyView, METH_VARARGS, nullptr },
        { "lock_buffer", (PyCFunction)SoftwareBitmap_LockBuffer, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_SoftwareBitmap, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_SoftwareBitmap, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_SoftwareBitmap, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SoftwareBitmap[] = {
        { const_cast<char*>("dpi_y"), (getter)SoftwareBitmap_get_DpiY, (setter)SoftwareBitmap_put_DpiY, nullptr, nullptr },
        { const_cast<char*>("dpi_x"), (getter)SoftwareBitmap_get_DpiX, (setter)SoftwareBitmap_put_DpiX, nullptr, nullptr },
        { const_cast<char*>("bitmap_alpha_mode"), (getter)SoftwareBitmap_get_BitmapAlphaMode, nullptr, nullptr, nullptr },
        { const_cast<char*>("bitmap_pixel_format"), (getter)SoftwareBitmap_get_BitmapPixelFormat, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_read_only"), (getter)SoftwareBitmap_get_IsReadOnly, nullptr, nullptr, nullptr },
        { const_cast<char*>("pixel_height"), (getter)SoftwareBitmap_get_PixelHeight, nullptr, nullptr, nullptr },
        { const_cast<char*>("pixel_width"), (getter)SoftwareBitmap_get_PixelWidth, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SoftwareBitmap[] = 
    {
        { Py_tp_new, _new_SoftwareBitmap },
        { Py_tp_dealloc, _dealloc_SoftwareBitmap },
        { Py_tp_methods, _methods_SoftwareBitmap },
        { Py_tp_getset, _getset_SoftwareBitmap },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SoftwareBitmap =
    {
        "_winrt_Windows_Graphics_Imaging.SoftwareBitmap",
        sizeof(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SoftwareBitmap
    };

    // ----- IBitmapFrame interface --------------------
    constexpr const char* const _type_name_IBitmapFrame = "IBitmapFrame";

    static PyObject* _new_IBitmapFrame(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IBitmapFrame);
        return nullptr;
    }

    static void _dealloc_IBitmapFrame(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IBitmapFrame_GetPixelDataAsync(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPixelDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

                return py::convert(self->obj.GetPixelDataAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_GetThumbnailAsync(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetThumbnailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_BitmapAlphaMode(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_BitmapPixelFormat(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_BitmapProperties(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_DpiX(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_DpiY(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_OrientedPixelHeight(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OrientedPixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_OrientedPixelWidth(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OrientedPixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_PixelHeight(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_PixelWidth(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IBitmapFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::IBitmapFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBitmapFrame[] = {
        { "get_pixel_data_async", (PyCFunction)IBitmapFrame_GetPixelDataAsync, METH_VARARGS, nullptr },
        { "get_thumbnail_async", (PyCFunction)IBitmapFrame_GetThumbnailAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IBitmapFrame, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IBitmapFrame[] = {
        { const_cast<char*>("bitmap_alpha_mode"), (getter)IBitmapFrame_get_BitmapAlphaMode, nullptr, nullptr, nullptr },
        { const_cast<char*>("bitmap_pixel_format"), (getter)IBitmapFrame_get_BitmapPixelFormat, nullptr, nullptr, nullptr },
        { const_cast<char*>("bitmap_properties"), (getter)IBitmapFrame_get_BitmapProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("dpi_x"), (getter)IBitmapFrame_get_DpiX, nullptr, nullptr, nullptr },
        { const_cast<char*>("dpi_y"), (getter)IBitmapFrame_get_DpiY, nullptr, nullptr, nullptr },
        { const_cast<char*>("oriented_pixel_height"), (getter)IBitmapFrame_get_OrientedPixelHeight, nullptr, nullptr, nullptr },
        { const_cast<char*>("oriented_pixel_width"), (getter)IBitmapFrame_get_OrientedPixelWidth, nullptr, nullptr, nullptr },
        { const_cast<char*>("pixel_height"), (getter)IBitmapFrame_get_PixelHeight, nullptr, nullptr, nullptr },
        { const_cast<char*>("pixel_width"), (getter)IBitmapFrame_get_PixelWidth, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IBitmapFrame[] = 
    {
        { Py_tp_new, _new_IBitmapFrame },
        { Py_tp_dealloc, _dealloc_IBitmapFrame },
        { Py_tp_methods, _methods_IBitmapFrame },
        { Py_tp_getset, _getset_IBitmapFrame },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IBitmapFrame =
    {
        "_winrt_Windows_Graphics_Imaging.IBitmapFrame",
        sizeof(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBitmapFrame
    };

    // ----- IBitmapFrameWithSoftwareBitmap interface --------------------
    constexpr const char* const _type_name_IBitmapFrameWithSoftwareBitmap = "IBitmapFrameWithSoftwareBitmap";

    static PyObject* _new_IBitmapFrameWithSoftwareBitmap(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IBitmapFrameWithSoftwareBitmap);
        return nullptr;
    }

    static void _dealloc_IBitmapFrameWithSoftwareBitmap(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_GetPixelDataAsync(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPixelDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

                return py::convert(self->obj.GetPixelDataAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_GetSoftwareBitmapAsync(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSoftwareBitmapAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);

                return py::convert(self->obj.GetSoftwareBitmapAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

                return py::convert(self->obj.GetSoftwareBitmapAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_GetThumbnailAsync(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetThumbnailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_BitmapAlphaMode(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_BitmapPixelFormat(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_BitmapProperties(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_DpiX(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_DpiY(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_OrientedPixelHeight(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OrientedPixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_OrientedPixelWidth(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OrientedPixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_PixelHeight(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_PixelWidth(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IBitmapFrameWithSoftwareBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBitmapFrameWithSoftwareBitmap[] = {
        { "get_software_bitmap_async", (PyCFunction)IBitmapFrameWithSoftwareBitmap_GetSoftwareBitmapAsync, METH_VARARGS, nullptr },
        { "get_pixel_data_async", (PyCFunction)IBitmapFrameWithSoftwareBitmap_GetPixelDataAsync, METH_VARARGS, nullptr },
        { "get_thumbnail_async", (PyCFunction)IBitmapFrameWithSoftwareBitmap_GetThumbnailAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IBitmapFrameWithSoftwareBitmap, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IBitmapFrameWithSoftwareBitmap[] = {
        { const_cast<char*>("bitmap_alpha_mode"), (getter)IBitmapFrameWithSoftwareBitmap_get_BitmapAlphaMode, nullptr, nullptr, nullptr },
        { const_cast<char*>("bitmap_pixel_format"), (getter)IBitmapFrameWithSoftwareBitmap_get_BitmapPixelFormat, nullptr, nullptr, nullptr },
        { const_cast<char*>("bitmap_properties"), (getter)IBitmapFrameWithSoftwareBitmap_get_BitmapProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("dpi_x"), (getter)IBitmapFrameWithSoftwareBitmap_get_DpiX, nullptr, nullptr, nullptr },
        { const_cast<char*>("dpi_y"), (getter)IBitmapFrameWithSoftwareBitmap_get_DpiY, nullptr, nullptr, nullptr },
        { const_cast<char*>("oriented_pixel_height"), (getter)IBitmapFrameWithSoftwareBitmap_get_OrientedPixelHeight, nullptr, nullptr, nullptr },
        { const_cast<char*>("oriented_pixel_width"), (getter)IBitmapFrameWithSoftwareBitmap_get_OrientedPixelWidth, nullptr, nullptr, nullptr },
        { const_cast<char*>("pixel_height"), (getter)IBitmapFrameWithSoftwareBitmap_get_PixelHeight, nullptr, nullptr, nullptr },
        { const_cast<char*>("pixel_width"), (getter)IBitmapFrameWithSoftwareBitmap_get_PixelWidth, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IBitmapFrameWithSoftwareBitmap[] = 
    {
        { Py_tp_new, _new_IBitmapFrameWithSoftwareBitmap },
        { Py_tp_dealloc, _dealloc_IBitmapFrameWithSoftwareBitmap },
        { Py_tp_methods, _methods_IBitmapFrameWithSoftwareBitmap },
        { Py_tp_getset, _getset_IBitmapFrameWithSoftwareBitmap },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IBitmapFrameWithSoftwareBitmap =
    {
        "_winrt_Windows_Graphics_Imaging.IBitmapFrameWithSoftwareBitmap",
        sizeof(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBitmapFrameWithSoftwareBitmap
    };

    // ----- IBitmapPropertiesView interface --------------------
    constexpr const char* const _type_name_IBitmapPropertiesView = "IBitmapPropertiesView";

    static PyObject* _new_IBitmapPropertiesView(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IBitmapPropertiesView);
        return nullptr;
    }

    static void _dealloc_IBitmapPropertiesView(py::wrapper::Windows::Graphics::Imaging::IBitmapPropertiesView* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IBitmapPropertiesView_GetPropertiesAsync(py::wrapper::Windows::Graphics::Imaging::IBitmapPropertiesView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetPropertiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IBitmapPropertiesView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBitmapPropertiesView[] = {
        { "get_properties_async", (PyCFunction)IBitmapPropertiesView_GetPropertiesAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IBitmapPropertiesView, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IBitmapPropertiesView[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IBitmapPropertiesView[] = 
    {
        { Py_tp_new, _new_IBitmapPropertiesView },
        { Py_tp_dealloc, _dealloc_IBitmapPropertiesView },
        { Py_tp_methods, _methods_IBitmapPropertiesView },
        { Py_tp_getset, _getset_IBitmapPropertiesView },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IBitmapPropertiesView =
    {
        "_winrt_Windows_Graphics_Imaging.IBitmapPropertiesView",
        sizeof(py::wrapper::Windows::Graphics::Imaging::IBitmapPropertiesView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBitmapPropertiesView
    };

    // ----- BitmapBounds struct --------------------
    constexpr const char* const _type_name_BitmapBounds = "BitmapBounds";

    PyObject* _new_BitmapBounds(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Graphics::Imaging::BitmapBounds return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapBounds>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint32_t _X{};
        uint32_t _Y{};
        uint32_t _Width{};
        uint32_t _Height{};

        static const char* kwlist[] = {"x", "y", "width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIII", const_cast<char**>(kwlist), &_X, &_Y, &_Width, &_Height))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Graphics::Imaging::BitmapBounds return_value{ _X, _Y, _Width, _Height };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_BitmapBounds(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self)
    {
    }

    static PyObject* BitmapBounds_get_X(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapBounds_set_X(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.X = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapBounds_get_Y(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapBounds_set_Y(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Y = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapBounds_get_Width(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapBounds_set_Width(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapBounds_get_Height(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapBounds_set_Height(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BitmapBounds[] = {
        { const_cast<char*>("x"), (getter)BitmapBounds_get_X, (setter)BitmapBounds_set_X, nullptr, nullptr },
        { const_cast<char*>("y"), (getter)BitmapBounds_get_Y, (setter)BitmapBounds_set_Y, nullptr, nullptr },
        { const_cast<char*>("width"), (getter)BitmapBounds_get_Width, (setter)BitmapBounds_set_Width, nullptr, nullptr },
        { const_cast<char*>("height"), (getter)BitmapBounds_get_Height, (setter)BitmapBounds_set_Height, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BitmapBounds[] = 
    {
        { Py_tp_new, _new_BitmapBounds },
        { Py_tp_dealloc, _dealloc_BitmapBounds },
        { Py_tp_getset, _getset_BitmapBounds },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BitmapBounds =
    {
        "_winrt_Windows_Graphics_Imaging.BitmapBounds",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapBounds),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapBounds
    };

    // ----- BitmapPlaneDescription struct --------------------
    constexpr const char* const _type_name_BitmapPlaneDescription = "BitmapPlaneDescription";

    PyObject* _new_BitmapPlaneDescription(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Graphics::Imaging::BitmapPlaneDescription return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        int32_t _StartIndex{};
        int32_t _Width{};
        int32_t _Height{};
        int32_t _Stride{};

        static const char* kwlist[] = {"start_index", "width", "height", "stride", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "iiii", const_cast<char**>(kwlist), &_StartIndex, &_Width, &_Height, &_Stride))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Graphics::Imaging::BitmapPlaneDescription return_value{ _StartIndex, _Width, _Height, _Stride };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_BitmapPlaneDescription(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self)
    {
    }

    static PyObject* BitmapPlaneDescription_get_StartIndex(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartIndex);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapPlaneDescription_set_StartIndex(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.StartIndex = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapPlaneDescription_get_Width(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapPlaneDescription_set_Width(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapPlaneDescription_get_Height(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapPlaneDescription_set_Height(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapPlaneDescription_get_Stride(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Stride);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapPlaneDescription_set_Stride(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Stride = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BitmapPlaneDescription[] = {
        { const_cast<char*>("start_index"), (getter)BitmapPlaneDescription_get_StartIndex, (setter)BitmapPlaneDescription_set_StartIndex, nullptr, nullptr },
        { const_cast<char*>("width"), (getter)BitmapPlaneDescription_get_Width, (setter)BitmapPlaneDescription_set_Width, nullptr, nullptr },
        { const_cast<char*>("height"), (getter)BitmapPlaneDescription_get_Height, (setter)BitmapPlaneDescription_set_Height, nullptr, nullptr },
        { const_cast<char*>("stride"), (getter)BitmapPlaneDescription_get_Stride, (setter)BitmapPlaneDescription_set_Stride, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BitmapPlaneDescription[] = 
    {
        { Py_tp_new, _new_BitmapPlaneDescription },
        { Py_tp_dealloc, _dealloc_BitmapPlaneDescription },
        { Py_tp_getset, _getset_BitmapPlaneDescription },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BitmapPlaneDescription =
    {
        "_winrt_Windows_Graphics_Imaging.BitmapPlaneDescription",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapPlaneDescription
    };

    // ----- BitmapSize struct --------------------
    constexpr const char* const _type_name_BitmapSize = "BitmapSize";

    PyObject* _new_BitmapSize(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Graphics::Imaging::BitmapSize return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapSize>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint32_t _Width{};
        uint32_t _Height{};

        static const char* kwlist[] = {"width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "II", const_cast<char**>(kwlist), &_Width, &_Height))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Graphics::Imaging::BitmapSize return_value{ _Width, _Height };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_BitmapSize(py::wrapper::Windows::Graphics::Imaging::BitmapSize* self)
    {
    }

    static PyObject* BitmapSize_get_Width(py::wrapper::Windows::Graphics::Imaging::BitmapSize* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapSize_set_Width(py::wrapper::Windows::Graphics::Imaging::BitmapSize* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapSize_get_Height(py::wrapper::Windows::Graphics::Imaging::BitmapSize* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapSize_set_Height(py::wrapper::Windows::Graphics::Imaging::BitmapSize* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BitmapSize[] = {
        { const_cast<char*>("width"), (getter)BitmapSize_get_Width, (setter)BitmapSize_set_Width, nullptr, nullptr },
        { const_cast<char*>("height"), (getter)BitmapSize_get_Height, (setter)BitmapSize_set_Height, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BitmapSize[] = 
    {
        { Py_tp_new, _new_BitmapSize },
        { Py_tp_dealloc, _dealloc_BitmapSize },
        { Py_tp_getset, _getset_BitmapSize },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BitmapSize =
    {
        "_winrt_Windows_Graphics_Imaging.BitmapSize",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapSize),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapSize
    };

    // ----- Windows.Graphics.Imaging Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapBuffer>::python_type = py::register_python_type(module, _type_name_BitmapBuffer, &_type_spec_BitmapBuffer, bases.get());
            py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>::python_type = py::register_python_type(module, _type_name_BitmapCodecInformation, &_type_spec_BitmapCodecInformation, bases.get());
            py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapDecoder>::python_type = py::register_python_type(module, _type_name_BitmapDecoder, &_type_spec_BitmapDecoder, bases.get());
            py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapEncoder>::python_type = py::register_python_type(module, _type_name_BitmapEncoder, &_type_spec_BitmapEncoder, bases.get());
            py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapFrame>::python_type = py::register_python_type(module, _type_name_BitmapFrame, &_type_spec_BitmapFrame, bases.get());
            py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapProperties>::python_type = py::register_python_type(module, _type_name_BitmapProperties, &_type_spec_BitmapProperties, bases.get());
            py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>::python_type = py::register_python_type(module, _type_name_BitmapPropertiesView, &_type_spec_BitmapPropertiesView, bases.get());
            py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapPropertySet>::python_type = py::register_python_type(module, _type_name_BitmapPropertySet, &_type_spec_BitmapPropertySet, bases.get());
            py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapTransform>::python_type = py::register_python_type(module, _type_name_BitmapTransform, &_type_spec_BitmapTransform, bases.get());
            py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapTypedValue>::python_type = py::register_python_type(module, _type_name_BitmapTypedValue, &_type_spec_BitmapTypedValue, bases.get());
            py::winrt_type<winrt::Windows::Graphics::Imaging::ImageStream>::python_type = py::register_python_type(module, _type_name_ImageStream, &_type_spec_ImageStream, bases.get());
            py::winrt_type<winrt::Windows::Graphics::Imaging::PixelDataProvider>::python_type = py::register_python_type(module, _type_name_PixelDataProvider, &_type_spec_PixelDataProvider, bases.get());
            py::winrt_type<winrt::Windows::Graphics::Imaging::SoftwareBitmap>::python_type = py::register_python_type(module, _type_name_SoftwareBitmap, &_type_spec_SoftwareBitmap, bases.get());
            py::winrt_type<winrt::Windows::Graphics::Imaging::IBitmapFrame>::python_type = py::register_python_type(module, _type_name_IBitmapFrame, &_type_spec_IBitmapFrame, bases.get());
            py::winrt_type<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>::python_type = py::register_python_type(module, _type_name_IBitmapFrameWithSoftwareBitmap, &_type_spec_IBitmapFrameWithSoftwareBitmap, bases.get());
            py::winrt_type<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>::python_type = py::register_python_type(module, _type_name_IBitmapPropertiesView, &_type_spec_IBitmapPropertiesView, bases.get());
            py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapBounds>::python_type = py::register_python_type(module, _type_name_BitmapBounds, &_type_spec_BitmapBounds, bases.get());
            py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>::python_type = py::register_python_type(module, _type_name_BitmapPlaneDescription, &_type_spec_BitmapPlaneDescription, bases.get());
            py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapSize>::python_type = py::register_python_type(module, _type_name_BitmapSize, &_type_spec_BitmapSize, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Graphics.Imaging");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Graphics_Imaging",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Graphics::Imaging

PyMODINIT_FUNC
PyInit__winrt_Windows_Graphics_Imaging (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Graphics::Imaging::module_def);
}
