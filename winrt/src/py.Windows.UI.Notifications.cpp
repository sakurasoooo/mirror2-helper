// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.UI.Notifications.h"

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::AdaptiveNotificationText>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::BadgeNotification>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::BadgeUpdateManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::BadgeUpdateManagerForUser>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::BadgeUpdater>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::KnownNotificationBindings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::Notification>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::NotificationBinding>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::NotificationData>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::NotificationVisual>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ScheduledTileNotification>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ScheduledToastNotification>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ShownTileNotification>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::TileFlyoutNotification>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::TileFlyoutUpdateManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::TileFlyoutUpdater>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::TileNotification>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::TileUpdateManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::TileUpdateManagerForUser>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::TileUpdater>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastActivatedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastCollection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastCollectionManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastDismissedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastFailedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastNotification>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastNotificationActionTriggerDetail>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastNotificationHistory>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastNotificationManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastNotificationManagerForUser>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastNotifier>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::UserNotification>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::UserNotificationChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::IAdaptiveNotificationContent>::python_type;

namespace py::cpp::Windows::UI::Notifications
{
    // ----- AdaptiveNotificationText class --------------------
    constexpr const char* const _type_name_AdaptiveNotificationText = "AdaptiveNotificationText";

    static PyObject* _new_AdaptiveNotificationText(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Notifications::AdaptiveNotificationText instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AdaptiveNotificationText(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdaptiveNotificationText_get_Hints(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Hints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveNotificationText_get_Kind(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveNotificationText_get_Text(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveNotificationText_put_Text(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveNotificationText_get_Language(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveNotificationText_put_Language(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AdaptiveNotificationText(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::AdaptiveNotificationText>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveNotificationText[] = {
        { "_from", (PyCFunction)_from_AdaptiveNotificationText, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AdaptiveNotificationText[] = {
        { const_cast<char*>("hints"), (getter)AdaptiveNotificationText_get_Hints, nullptr, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)AdaptiveNotificationText_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("text"), (getter)AdaptiveNotificationText_get_Text, (setter)AdaptiveNotificationText_put_Text, nullptr, nullptr },
        { const_cast<char*>("language"), (getter)AdaptiveNotificationText_get_Language, (setter)AdaptiveNotificationText_put_Language, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AdaptiveNotificationText[] = 
    {
        { Py_tp_new, _new_AdaptiveNotificationText },
        { Py_tp_dealloc, _dealloc_AdaptiveNotificationText },
        { Py_tp_methods, _methods_AdaptiveNotificationText },
        { Py_tp_getset, _getset_AdaptiveNotificationText },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AdaptiveNotificationText =
    {
        "_winrt_Windows_UI_Notifications.AdaptiveNotificationText",
        sizeof(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveNotificationText
    };

    // ----- BadgeNotification class --------------------
    constexpr const char* const _type_name_BadgeNotification = "BadgeNotification";

    static PyObject* _new_BadgeNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);

                winrt::Windows::UI::Notifications::BadgeNotification instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BadgeNotification(py::wrapper::Windows::UI::Notifications::BadgeNotification* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BadgeNotification_get_ExpirationTime(py::wrapper::Windows::UI::Notifications::BadgeNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpirationTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BadgeNotification_put_ExpirationTime(py::wrapper::Windows::UI::Notifications::BadgeNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ExpirationTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BadgeNotification_get_Content(py::wrapper::Windows::UI::Notifications::BadgeNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BadgeNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::BadgeNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BadgeNotification[] = {
        { "_from", (PyCFunction)_from_BadgeNotification, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BadgeNotification[] = {
        { const_cast<char*>("expiration_time"), (getter)BadgeNotification_get_ExpirationTime, (setter)BadgeNotification_put_ExpirationTime, nullptr, nullptr },
        { const_cast<char*>("content"), (getter)BadgeNotification_get_Content, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BadgeNotification[] = 
    {
        { Py_tp_new, _new_BadgeNotification },
        { Py_tp_dealloc, _dealloc_BadgeNotification },
        { Py_tp_methods, _methods_BadgeNotification },
        { Py_tp_getset, _getset_BadgeNotification },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BadgeNotification =
    {
        "_winrt_Windows_UI_Notifications.BadgeNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::BadgeNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BadgeNotification
    };

    // ----- BadgeUpdateManager class --------------------
    constexpr const char* const _type_name_BadgeUpdateManager = "BadgeUpdateManager";

    static PyObject* _new_BadgeUpdateManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BadgeUpdateManager);
        return nullptr;
    }

    static PyObject* BadgeUpdateManager_CreateBadgeUpdaterForApplication(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::Notifications::BadgeUpdateManager::CreateBadgeUpdaterForApplication());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::BadgeUpdateManager::CreateBadgeUpdaterForApplication(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdateManager_CreateBadgeUpdaterForSecondaryTile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::BadgeUpdateManager::CreateBadgeUpdaterForSecondaryTile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdateManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::BadgeUpdateManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdateManager_GetTemplateContent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::BadgeTemplateType>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::BadgeUpdateManager::GetTemplateContent(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_BadgeUpdateManager[] = {
        { "create_badge_updater_for_application", (PyCFunction)BadgeUpdateManager_CreateBadgeUpdaterForApplication, METH_VARARGS | METH_STATIC, nullptr },
        { "create_badge_updater_for_secondary_tile", (PyCFunction)BadgeUpdateManager_CreateBadgeUpdaterForSecondaryTile, METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", (PyCFunction)BadgeUpdateManager_GetForUser, METH_VARARGS | METH_STATIC, nullptr },
        { "get_template_content", (PyCFunction)BadgeUpdateManager_GetTemplateContent, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BadgeUpdateManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_BadgeUpdateManager[] = 
    {
        { Py_tp_new, _new_BadgeUpdateManager },
        { Py_tp_methods, _methods_BadgeUpdateManager },
        { Py_tp_getset, _getset_BadgeUpdateManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BadgeUpdateManager =
    {
        "_winrt_Windows_UI_Notifications.BadgeUpdateManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BadgeUpdateManager
    };

    // ----- BadgeUpdateManagerForUser class --------------------
    constexpr const char* const _type_name_BadgeUpdateManagerForUser = "BadgeUpdateManagerForUser";

    static PyObject* _new_BadgeUpdateManagerForUser(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BadgeUpdateManagerForUser);
        return nullptr;
    }

    static void _dealloc_BadgeUpdateManagerForUser(py::wrapper::Windows::UI::Notifications::BadgeUpdateManagerForUser* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BadgeUpdateManagerForUser_CreateBadgeUpdaterForApplication(py::wrapper::Windows::UI::Notifications::BadgeUpdateManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateBadgeUpdaterForApplication());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateBadgeUpdaterForApplication(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdateManagerForUser_CreateBadgeUpdaterForSecondaryTile(py::wrapper::Windows::UI::Notifications::BadgeUpdateManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateBadgeUpdaterForSecondaryTile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdateManagerForUser_get_User(py::wrapper::Windows::UI::Notifications::BadgeUpdateManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BadgeUpdateManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::BadgeUpdateManagerForUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BadgeUpdateManagerForUser[] = {
        { "create_badge_updater_for_application", (PyCFunction)BadgeUpdateManagerForUser_CreateBadgeUpdaterForApplication, METH_VARARGS, nullptr },
        { "create_badge_updater_for_secondary_tile", (PyCFunction)BadgeUpdateManagerForUser_CreateBadgeUpdaterForSecondaryTile, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_BadgeUpdateManagerForUser, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BadgeUpdateManagerForUser[] = {
        { const_cast<char*>("user"), (getter)BadgeUpdateManagerForUser_get_User, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BadgeUpdateManagerForUser[] = 
    {
        { Py_tp_new, _new_BadgeUpdateManagerForUser },
        { Py_tp_dealloc, _dealloc_BadgeUpdateManagerForUser },
        { Py_tp_methods, _methods_BadgeUpdateManagerForUser },
        { Py_tp_getset, _getset_BadgeUpdateManagerForUser },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BadgeUpdateManagerForUser =
    {
        "_winrt_Windows_UI_Notifications.BadgeUpdateManagerForUser",
        sizeof(py::wrapper::Windows::UI::Notifications::BadgeUpdateManagerForUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BadgeUpdateManagerForUser
    };

    // ----- BadgeUpdater class --------------------
    constexpr const char* const _type_name_BadgeUpdater = "BadgeUpdater";

    static PyObject* _new_BadgeUpdater(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BadgeUpdater);
        return nullptr;
    }

    static void _dealloc_BadgeUpdater(py::wrapper::Windows::UI::Notifications::BadgeUpdater* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BadgeUpdater_Clear(py::wrapper::Windows::UI::Notifications::BadgeUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdater_StartPeriodicUpdate(py::wrapper::Windows::UI::Notifications::BadgeUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 1);

                self->obj.StartPeriodicUpdate(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 2);

                self->obj.StartPeriodicUpdate(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdater_StopPeriodicUpdate(py::wrapper::Windows::UI::Notifications::BadgeUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.StopPeriodicUpdate();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdater_Update(py::wrapper::Windows::UI::Notifications::BadgeUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::BadgeNotification>(args, 0);

                self->obj.Update(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_BadgeUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::BadgeUpdater>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BadgeUpdater[] = {
        { "clear", (PyCFunction)BadgeUpdater_Clear, METH_VARARGS, nullptr },
        { "start_periodic_update", (PyCFunction)BadgeUpdater_StartPeriodicUpdate, METH_VARARGS, nullptr },
        { "stop_periodic_update", (PyCFunction)BadgeUpdater_StopPeriodicUpdate, METH_VARARGS, nullptr },
        { "update", (PyCFunction)BadgeUpdater_Update, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_BadgeUpdater, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BadgeUpdater[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_BadgeUpdater[] = 
    {
        { Py_tp_new, _new_BadgeUpdater },
        { Py_tp_dealloc, _dealloc_BadgeUpdater },
        { Py_tp_methods, _methods_BadgeUpdater },
        { Py_tp_getset, _getset_BadgeUpdater },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BadgeUpdater =
    {
        "_winrt_Windows_UI_Notifications.BadgeUpdater",
        sizeof(py::wrapper::Windows::UI::Notifications::BadgeUpdater),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BadgeUpdater
    };

    // ----- KnownAdaptiveNotificationHints class --------------------
    constexpr const char* const _type_name_KnownAdaptiveNotificationHints = "KnownAdaptiveNotificationHints";

    static PyObject* _new_KnownAdaptiveNotificationHints(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KnownAdaptiveNotificationHints);
        return nullptr;
    }

    static PyObject* KnownAdaptiveNotificationHints_get_Align(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints::Align());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationHints_get_MaxLines(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints::MaxLines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationHints_get_MinLines(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints::MinLines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationHints_get_Style(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints::Style());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationHints_get_TextStacking(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints::TextStacking());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationHints_get_Wrap(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints::Wrap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownAdaptiveNotificationHints[] = {
        { "get_align", (PyCFunction)KnownAdaptiveNotificationHints_get_Align, METH_NOARGS | METH_STATIC, nullptr },
        { "get_max_lines", (PyCFunction)KnownAdaptiveNotificationHints_get_MaxLines, METH_NOARGS | METH_STATIC, nullptr },
        { "get_min_lines", (PyCFunction)KnownAdaptiveNotificationHints_get_MinLines, METH_NOARGS | METH_STATIC, nullptr },
        { "get_style", (PyCFunction)KnownAdaptiveNotificationHints_get_Style, METH_NOARGS | METH_STATIC, nullptr },
        { "get_text_stacking", (PyCFunction)KnownAdaptiveNotificationHints_get_TextStacking, METH_NOARGS | METH_STATIC, nullptr },
        { "get_wrap", (PyCFunction)KnownAdaptiveNotificationHints_get_Wrap, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_KnownAdaptiveNotificationHints[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_KnownAdaptiveNotificationHints[] = 
    {
        { Py_tp_new, _new_KnownAdaptiveNotificationHints },
        { Py_tp_methods, _methods_KnownAdaptiveNotificationHints },
        { Py_tp_getset, _getset_KnownAdaptiveNotificationHints },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_KnownAdaptiveNotificationHints =
    {
        "_winrt_Windows_UI_Notifications.KnownAdaptiveNotificationHints",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownAdaptiveNotificationHints
    };

    // ----- KnownAdaptiveNotificationTextStyles class --------------------
    constexpr const char* const _type_name_KnownAdaptiveNotificationTextStyles = "KnownAdaptiveNotificationTextStyles";

    static PyObject* _new_KnownAdaptiveNotificationTextStyles(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KnownAdaptiveNotificationTextStyles);
        return nullptr;
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_Base(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::Base());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_BaseSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::BaseSubtle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_Body(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_BodySubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::BodySubtle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_Caption(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::Caption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_CaptionSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::CaptionSubtle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_Header(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::Header());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_HeaderNumeral(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::HeaderNumeral());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_HeaderNumeralSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::HeaderNumeralSubtle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_HeaderSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::HeaderSubtle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_Subheader(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::Subheader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_SubheaderNumeral(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::SubheaderNumeral());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_SubheaderNumeralSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::SubheaderNumeralSubtle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_SubheaderSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::SubheaderSubtle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_Subtitle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::Subtitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_SubtitleSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::SubtitleSubtle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_Title(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_TitleNumeral(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::TitleNumeral());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_TitleSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::TitleSubtle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownAdaptiveNotificationTextStyles[] = {
        { "get_base", (PyCFunction)KnownAdaptiveNotificationTextStyles_get_Base, METH_NOARGS | METH_STATIC, nullptr },
        { "get_base_subtle", (PyCFunction)KnownAdaptiveNotificationTextStyles_get_BaseSubtle, METH_NOARGS | METH_STATIC, nullptr },
        { "get_body", (PyCFunction)KnownAdaptiveNotificationTextStyles_get_Body, METH_NOARGS | METH_STATIC, nullptr },
        { "get_body_subtle", (PyCFunction)KnownAdaptiveNotificationTextStyles_get_BodySubtle, METH_NOARGS | METH_STATIC, nullptr },
        { "get_caption", (PyCFunction)KnownAdaptiveNotificationTextStyles_get_Caption, METH_NOARGS | METH_STATIC, nullptr },
        { "get_caption_subtle", (PyCFunction)KnownAdaptiveNotificationTextStyles_get_CaptionSubtle, METH_NOARGS | METH_STATIC, nullptr },
        { "get_header", (PyCFunction)KnownAdaptiveNotificationTextStyles_get_Header, METH_NOARGS | METH_STATIC, nullptr },
        { "get_header_numeral", (PyCFunction)KnownAdaptiveNotificationTextStyles_get_HeaderNumeral, METH_NOARGS | METH_STATIC, nullptr },
        { "get_header_numeral_subtle", (PyCFunction)KnownAdaptiveNotificationTextStyles_get_HeaderNumeralSubtle, METH_NOARGS | METH_STATIC, nullptr },
        { "get_header_subtle", (PyCFunction)KnownAdaptiveNotificationTextStyles_get_HeaderSubtle, METH_NOARGS | METH_STATIC, nullptr },
        { "get_subheader", (PyCFunction)KnownAdaptiveNotificationTextStyles_get_Subheader, METH_NOARGS | METH_STATIC, nullptr },
        { "get_subheader_numeral", (PyCFunction)KnownAdaptiveNotificationTextStyles_get_SubheaderNumeral, METH_NOARGS | METH_STATIC, nullptr },
        { "get_subheader_numeral_subtle", (PyCFunction)KnownAdaptiveNotificationTextStyles_get_SubheaderNumeralSubtle, METH_NOARGS | METH_STATIC, nullptr },
        { "get_subheader_subtle", (PyCFunction)KnownAdaptiveNotificationTextStyles_get_SubheaderSubtle, METH_NOARGS | METH_STATIC, nullptr },
        { "get_subtitle", (PyCFunction)KnownAdaptiveNotificationTextStyles_get_Subtitle, METH_NOARGS | METH_STATIC, nullptr },
        { "get_subtitle_subtle", (PyCFunction)KnownAdaptiveNotificationTextStyles_get_SubtitleSubtle, METH_NOARGS | METH_STATIC, nullptr },
        { "get_title", (PyCFunction)KnownAdaptiveNotificationTextStyles_get_Title, METH_NOARGS | METH_STATIC, nullptr },
        { "get_title_numeral", (PyCFunction)KnownAdaptiveNotificationTextStyles_get_TitleNumeral, METH_NOARGS | METH_STATIC, nullptr },
        { "get_title_subtle", (PyCFunction)KnownAdaptiveNotificationTextStyles_get_TitleSubtle, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_KnownAdaptiveNotificationTextStyles[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_KnownAdaptiveNotificationTextStyles[] = 
    {
        { Py_tp_new, _new_KnownAdaptiveNotificationTextStyles },
        { Py_tp_methods, _methods_KnownAdaptiveNotificationTextStyles },
        { Py_tp_getset, _getset_KnownAdaptiveNotificationTextStyles },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_KnownAdaptiveNotificationTextStyles =
    {
        "_winrt_Windows_UI_Notifications.KnownAdaptiveNotificationTextStyles",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownAdaptiveNotificationTextStyles
    };

    // ----- KnownNotificationBindings class --------------------
    constexpr const char* const _type_name_KnownNotificationBindings = "KnownNotificationBindings";

    static PyObject* _new_KnownNotificationBindings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KnownNotificationBindings);
        return nullptr;
    }

    static PyObject* KnownNotificationBindings_get_ToastGeneric(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownNotificationBindings::ToastGeneric());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownNotificationBindings[] = {
        { "get_toast_generic", (PyCFunction)KnownNotificationBindings_get_ToastGeneric, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_KnownNotificationBindings[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_KnownNotificationBindings[] = 
    {
        { Py_tp_new, _new_KnownNotificationBindings },
        { Py_tp_methods, _methods_KnownNotificationBindings },
        { Py_tp_getset, _getset_KnownNotificationBindings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_KnownNotificationBindings =
    {
        "_winrt_Windows_UI_Notifications.KnownNotificationBindings",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownNotificationBindings
    };

    // ----- Notification class --------------------
    constexpr const char* const _type_name_Notification = "Notification";

    static PyObject* _new_Notification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Notifications::Notification instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Notification(py::wrapper::Windows::UI::Notifications::Notification* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Notification_get_Visual(py::wrapper::Windows::UI::Notifications::Notification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Visual());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Notification_put_Visual(py::wrapper::Windows::UI::Notifications::Notification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationVisual>(arg);

            self->obj.Visual(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Notification_get_ExpirationTime(py::wrapper::Windows::UI::Notifications::Notification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpirationTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Notification_put_ExpirationTime(py::wrapper::Windows::UI::Notifications::Notification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ExpirationTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_Notification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::Notification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Notification[] = {
        { "_from", (PyCFunction)_from_Notification, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_Notification[] = {
        { const_cast<char*>("visual"), (getter)Notification_get_Visual, (setter)Notification_put_Visual, nullptr, nullptr },
        { const_cast<char*>("expiration_time"), (getter)Notification_get_ExpirationTime, (setter)Notification_put_ExpirationTime, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Notification[] = 
    {
        { Py_tp_new, _new_Notification },
        { Py_tp_dealloc, _dealloc_Notification },
        { Py_tp_methods, _methods_Notification },
        { Py_tp_getset, _getset_Notification },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Notification =
    {
        "_winrt_Windows_UI_Notifications.Notification",
        sizeof(py::wrapper::Windows::UI::Notifications::Notification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Notification
    };

    // ----- NotificationBinding class --------------------
    constexpr const char* const _type_name_NotificationBinding = "NotificationBinding";

    static PyObject* _new_NotificationBinding(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_NotificationBinding);
        return nullptr;
    }

    static void _dealloc_NotificationBinding(py::wrapper::Windows::UI::Notifications::NotificationBinding* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* NotificationBinding_GetTextElements(py::wrapper::Windows::UI::Notifications::NotificationBinding* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetTextElements());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NotificationBinding_get_Template(py::wrapper::Windows::UI::Notifications::NotificationBinding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Template());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NotificationBinding_put_Template(py::wrapper::Windows::UI::Notifications::NotificationBinding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Template(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NotificationBinding_get_Language(py::wrapper::Windows::UI::Notifications::NotificationBinding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NotificationBinding_put_Language(py::wrapper::Windows::UI::Notifications::NotificationBinding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NotificationBinding_get_Hints(py::wrapper::Windows::UI::Notifications::NotificationBinding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Hints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NotificationBinding(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::NotificationBinding>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NotificationBinding[] = {
        { "get_text_elements", (PyCFunction)NotificationBinding_GetTextElements, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_NotificationBinding, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_NotificationBinding[] = {
        { const_cast<char*>("template"), (getter)NotificationBinding_get_Template, (setter)NotificationBinding_put_Template, nullptr, nullptr },
        { const_cast<char*>("language"), (getter)NotificationBinding_get_Language, (setter)NotificationBinding_put_Language, nullptr, nullptr },
        { const_cast<char*>("hints"), (getter)NotificationBinding_get_Hints, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_NotificationBinding[] = 
    {
        { Py_tp_new, _new_NotificationBinding },
        { Py_tp_dealloc, _dealloc_NotificationBinding },
        { Py_tp_methods, _methods_NotificationBinding },
        { Py_tp_getset, _getset_NotificationBinding },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NotificationBinding =
    {
        "_winrt_Windows_UI_Notifications.NotificationBinding",
        sizeof(py::wrapper::Windows::UI::Notifications::NotificationBinding),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NotificationBinding
    };

    // ----- NotificationData class --------------------
    constexpr const char* const _type_name_NotificationData = "NotificationData";

    static PyObject* _new_NotificationData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                winrt::Windows::UI::Notifications::NotificationData instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);

                winrt::Windows::UI::Notifications::NotificationData instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Notifications::NotificationData instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NotificationData(py::wrapper::Windows::UI::Notifications::NotificationData* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* NotificationData_get_SequenceNumber(py::wrapper::Windows::UI::Notifications::NotificationData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SequenceNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NotificationData_put_SequenceNumber(py::wrapper::Windows::UI::Notifications::NotificationData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.SequenceNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NotificationData_get_Values(py::wrapper::Windows::UI::Notifications::NotificationData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Values());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NotificationData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::NotificationData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NotificationData[] = {
        { "_from", (PyCFunction)_from_NotificationData, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_NotificationData[] = {
        { const_cast<char*>("sequence_number"), (getter)NotificationData_get_SequenceNumber, (setter)NotificationData_put_SequenceNumber, nullptr, nullptr },
        { const_cast<char*>("values"), (getter)NotificationData_get_Values, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_NotificationData[] = 
    {
        { Py_tp_new, _new_NotificationData },
        { Py_tp_dealloc, _dealloc_NotificationData },
        { Py_tp_methods, _methods_NotificationData },
        { Py_tp_getset, _getset_NotificationData },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NotificationData =
    {
        "_winrt_Windows_UI_Notifications.NotificationData",
        sizeof(py::wrapper::Windows::UI::Notifications::NotificationData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NotificationData
    };

    // ----- NotificationVisual class --------------------
    constexpr const char* const _type_name_NotificationVisual = "NotificationVisual";

    static PyObject* _new_NotificationVisual(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_NotificationVisual);
        return nullptr;
    }

    static void _dealloc_NotificationVisual(py::wrapper::Windows::UI::Notifications::NotificationVisual* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* NotificationVisual_GetBinding(py::wrapper::Windows::UI::Notifications::NotificationVisual* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetBinding(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NotificationVisual_get_Language(py::wrapper::Windows::UI::Notifications::NotificationVisual* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NotificationVisual_put_Language(py::wrapper::Windows::UI::Notifications::NotificationVisual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NotificationVisual_get_Bindings(py::wrapper::Windows::UI::Notifications::NotificationVisual* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bindings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NotificationVisual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::NotificationVisual>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NotificationVisual[] = {
        { "get_binding", (PyCFunction)NotificationVisual_GetBinding, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_NotificationVisual, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_NotificationVisual[] = {
        { const_cast<char*>("language"), (getter)NotificationVisual_get_Language, (setter)NotificationVisual_put_Language, nullptr, nullptr },
        { const_cast<char*>("bindings"), (getter)NotificationVisual_get_Bindings, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_NotificationVisual[] = 
    {
        { Py_tp_new, _new_NotificationVisual },
        { Py_tp_dealloc, _dealloc_NotificationVisual },
        { Py_tp_methods, _methods_NotificationVisual },
        { Py_tp_getset, _getset_NotificationVisual },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NotificationVisual =
    {
        "_winrt_Windows_UI_Notifications.NotificationVisual",
        sizeof(py::wrapper::Windows::UI::Notifications::NotificationVisual),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NotificationVisual
    };

    // ----- ScheduledTileNotification class --------------------
    constexpr const char* const _type_name_ScheduledTileNotification = "ScheduledTileNotification";

    static PyObject* _new_ScheduledTileNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                winrt::Windows::UI::Notifications::ScheduledTileNotification instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScheduledTileNotification(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ScheduledTileNotification_get_Tag(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledTileNotification_put_Tag(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledTileNotification_get_Id(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledTileNotification_put_Id(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledTileNotification_get_ExpirationTime(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpirationTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledTileNotification_put_ExpirationTime(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ExpirationTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledTileNotification_get_Content(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScheduledTileNotification_get_DeliveryTime(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeliveryTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ScheduledTileNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ScheduledTileNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScheduledTileNotification[] = {
        { "_from", (PyCFunction)_from_ScheduledTileNotification, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ScheduledTileNotification[] = {
        { const_cast<char*>("tag"), (getter)ScheduledTileNotification_get_Tag, (setter)ScheduledTileNotification_put_Tag, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)ScheduledTileNotification_get_Id, (setter)ScheduledTileNotification_put_Id, nullptr, nullptr },
        { const_cast<char*>("expiration_time"), (getter)ScheduledTileNotification_get_ExpirationTime, (setter)ScheduledTileNotification_put_ExpirationTime, nullptr, nullptr },
        { const_cast<char*>("content"), (getter)ScheduledTileNotification_get_Content, nullptr, nullptr, nullptr },
        { const_cast<char*>("delivery_time"), (getter)ScheduledTileNotification_get_DeliveryTime, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ScheduledTileNotification[] = 
    {
        { Py_tp_new, _new_ScheduledTileNotification },
        { Py_tp_dealloc, _dealloc_ScheduledTileNotification },
        { Py_tp_methods, _methods_ScheduledTileNotification },
        { Py_tp_getset, _getset_ScheduledTileNotification },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ScheduledTileNotification =
    {
        "_winrt_Windows_UI_Notifications.ScheduledTileNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScheduledTileNotification
    };

    // ----- ScheduledToastNotification class --------------------
    constexpr const char* const _type_name_ScheduledToastNotification = "ScheduledToastNotification";

    static PyObject* _new_ScheduledToastNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                winrt::Windows::UI::Notifications::ScheduledToastNotification instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                winrt::Windows::UI::Notifications::ScheduledToastNotification instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScheduledToastNotification(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ScheduledToastNotification_get_Id(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotification_put_Id(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledToastNotification_get_Content(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScheduledToastNotification_get_DeliveryTime(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeliveryTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScheduledToastNotification_get_MaximumSnoozeCount(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaximumSnoozeCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScheduledToastNotification_get_SnoozeInterval(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SnoozeInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScheduledToastNotification_get_Tag(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotification_put_Tag(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledToastNotification_get_SuppressPopup(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuppressPopup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotification_put_SuppressPopup(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SuppressPopup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledToastNotification_get_Group(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotification_put_Group(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Group(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledToastNotification_get_RemoteId(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotification_put_RemoteId(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledToastNotification_get_NotificationMirroring(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NotificationMirroring());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotification_put_NotificationMirroring(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationMirroring>(arg);

            self->obj.NotificationMirroring(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledToastNotification_get_ExpirationTime(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpirationTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotification_put_ExpirationTime(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ExpirationTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ScheduledToastNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ScheduledToastNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScheduledToastNotification[] = {
        { "_from", (PyCFunction)_from_ScheduledToastNotification, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ScheduledToastNotification[] = {
        { const_cast<char*>("id"), (getter)ScheduledToastNotification_get_Id, (setter)ScheduledToastNotification_put_Id, nullptr, nullptr },
        { const_cast<char*>("content"), (getter)ScheduledToastNotification_get_Content, nullptr, nullptr, nullptr },
        { const_cast<char*>("delivery_time"), (getter)ScheduledToastNotification_get_DeliveryTime, nullptr, nullptr, nullptr },
        { const_cast<char*>("maximum_snooze_count"), (getter)ScheduledToastNotification_get_MaximumSnoozeCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("snooze_interval"), (getter)ScheduledToastNotification_get_SnoozeInterval, nullptr, nullptr, nullptr },
        { const_cast<char*>("tag"), (getter)ScheduledToastNotification_get_Tag, (setter)ScheduledToastNotification_put_Tag, nullptr, nullptr },
        { const_cast<char*>("suppress_popup"), (getter)ScheduledToastNotification_get_SuppressPopup, (setter)ScheduledToastNotification_put_SuppressPopup, nullptr, nullptr },
        { const_cast<char*>("group"), (getter)ScheduledToastNotification_get_Group, (setter)ScheduledToastNotification_put_Group, nullptr, nullptr },
        { const_cast<char*>("remote_id"), (getter)ScheduledToastNotification_get_RemoteId, (setter)ScheduledToastNotification_put_RemoteId, nullptr, nullptr },
        { const_cast<char*>("notification_mirroring"), (getter)ScheduledToastNotification_get_NotificationMirroring, (setter)ScheduledToastNotification_put_NotificationMirroring, nullptr, nullptr },
        { const_cast<char*>("expiration_time"), (getter)ScheduledToastNotification_get_ExpirationTime, (setter)ScheduledToastNotification_put_ExpirationTime, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ScheduledToastNotification[] = 
    {
        { Py_tp_new, _new_ScheduledToastNotification },
        { Py_tp_dealloc, _dealloc_ScheduledToastNotification },
        { Py_tp_methods, _methods_ScheduledToastNotification },
        { Py_tp_getset, _getset_ScheduledToastNotification },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ScheduledToastNotification =
    {
        "_winrt_Windows_UI_Notifications.ScheduledToastNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScheduledToastNotification
    };

    // ----- ScheduledToastNotificationShowingEventArgs class --------------------
    constexpr const char* const _type_name_ScheduledToastNotificationShowingEventArgs = "ScheduledToastNotificationShowingEventArgs";

    static PyObject* _new_ScheduledToastNotificationShowingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ScheduledToastNotificationShowingEventArgs);
        return nullptr;
    }

    static void _dealloc_ScheduledToastNotificationShowingEventArgs(py::wrapper::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ScheduledToastNotificationShowingEventArgs_GetDeferral(py::wrapper::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScheduledToastNotificationShowingEventArgs_get_Cancel(py::wrapper::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Cancel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotificationShowingEventArgs_put_Cancel(py::wrapper::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Cancel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledToastNotificationShowingEventArgs_get_ScheduledToastNotification(py::wrapper::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScheduledToastNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ScheduledToastNotificationShowingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScheduledToastNotificationShowingEventArgs[] = {
        { "get_deferral", (PyCFunction)ScheduledToastNotificationShowingEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ScheduledToastNotificationShowingEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ScheduledToastNotificationShowingEventArgs[] = {
        { const_cast<char*>("cancel"), (getter)ScheduledToastNotificationShowingEventArgs_get_Cancel, (setter)ScheduledToastNotificationShowingEventArgs_put_Cancel, nullptr, nullptr },
        { const_cast<char*>("scheduled_toast_notification"), (getter)ScheduledToastNotificationShowingEventArgs_get_ScheduledToastNotification, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ScheduledToastNotificationShowingEventArgs[] = 
    {
        { Py_tp_new, _new_ScheduledToastNotificationShowingEventArgs },
        { Py_tp_dealloc, _dealloc_ScheduledToastNotificationShowingEventArgs },
        { Py_tp_methods, _methods_ScheduledToastNotificationShowingEventArgs },
        { Py_tp_getset, _getset_ScheduledToastNotificationShowingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ScheduledToastNotificationShowingEventArgs =
    {
        "_winrt_Windows_UI_Notifications.ScheduledToastNotificationShowingEventArgs",
        sizeof(py::wrapper::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScheduledToastNotificationShowingEventArgs
    };

    // ----- ShownTileNotification class --------------------
    constexpr const char* const _type_name_ShownTileNotification = "ShownTileNotification";

    static PyObject* _new_ShownTileNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ShownTileNotification);
        return nullptr;
    }

    static void _dealloc_ShownTileNotification(py::wrapper::Windows::UI::Notifications::ShownTileNotification* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ShownTileNotification_get_Arguments(py::wrapper::Windows::UI::Notifications::ShownTileNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ShownTileNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ShownTileNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShownTileNotification[] = {
        { "_from", (PyCFunction)_from_ShownTileNotification, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ShownTileNotification[] = {
        { const_cast<char*>("arguments"), (getter)ShownTileNotification_get_Arguments, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ShownTileNotification[] = 
    {
        { Py_tp_new, _new_ShownTileNotification },
        { Py_tp_dealloc, _dealloc_ShownTileNotification },
        { Py_tp_methods, _methods_ShownTileNotification },
        { Py_tp_getset, _getset_ShownTileNotification },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ShownTileNotification =
    {
        "_winrt_Windows_UI_Notifications.ShownTileNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::ShownTileNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShownTileNotification
    };

    // ----- TileFlyoutNotification class --------------------
    constexpr const char* const _type_name_TileFlyoutNotification = "TileFlyoutNotification";

    static PyObject* _new_TileFlyoutNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);

                winrt::Windows::UI::Notifications::TileFlyoutNotification instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TileFlyoutNotification(py::wrapper::Windows::UI::Notifications::TileFlyoutNotification* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TileFlyoutNotification_get_ExpirationTime(py::wrapper::Windows::UI::Notifications::TileFlyoutNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpirationTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TileFlyoutNotification_put_ExpirationTime(py::wrapper::Windows::UI::Notifications::TileFlyoutNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ExpirationTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TileFlyoutNotification_get_Content(py::wrapper::Windows::UI::Notifications::TileFlyoutNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TileFlyoutNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::TileFlyoutNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileFlyoutNotification[] = {
        { "_from", (PyCFunction)_from_TileFlyoutNotification, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TileFlyoutNotification[] = {
        { const_cast<char*>("expiration_time"), (getter)TileFlyoutNotification_get_ExpirationTime, (setter)TileFlyoutNotification_put_ExpirationTime, nullptr, nullptr },
        { const_cast<char*>("content"), (getter)TileFlyoutNotification_get_Content, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TileFlyoutNotification[] = 
    {
        { Py_tp_new, _new_TileFlyoutNotification },
        { Py_tp_dealloc, _dealloc_TileFlyoutNotification },
        { Py_tp_methods, _methods_TileFlyoutNotification },
        { Py_tp_getset, _getset_TileFlyoutNotification },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TileFlyoutNotification =
    {
        "_winrt_Windows_UI_Notifications.TileFlyoutNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::TileFlyoutNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileFlyoutNotification
    };

    // ----- TileFlyoutUpdateManager class --------------------
    constexpr const char* const _type_name_TileFlyoutUpdateManager = "TileFlyoutUpdateManager";

    static PyObject* _new_TileFlyoutUpdateManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TileFlyoutUpdateManager);
        return nullptr;
    }

    static PyObject* TileFlyoutUpdateManager_CreateTileFlyoutUpdaterForApplication(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::Notifications::TileFlyoutUpdateManager::CreateTileFlyoutUpdaterForApplication());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::TileFlyoutUpdateManager::CreateTileFlyoutUpdaterForApplication(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileFlyoutUpdateManager_CreateTileFlyoutUpdaterForSecondaryTile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::TileFlyoutUpdateManager::CreateTileFlyoutUpdaterForSecondaryTile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileFlyoutUpdateManager_GetTemplateContent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileFlyoutTemplateType>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::TileFlyoutUpdateManager::GetTemplateContent(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileFlyoutUpdateManager[] = {
        { "create_tile_flyout_updater_for_application", (PyCFunction)TileFlyoutUpdateManager_CreateTileFlyoutUpdaterForApplication, METH_VARARGS | METH_STATIC, nullptr },
        { "create_tile_flyout_updater_for_secondary_tile", (PyCFunction)TileFlyoutUpdateManager_CreateTileFlyoutUpdaterForSecondaryTile, METH_VARARGS | METH_STATIC, nullptr },
        { "get_template_content", (PyCFunction)TileFlyoutUpdateManager_GetTemplateContent, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TileFlyoutUpdateManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_TileFlyoutUpdateManager[] = 
    {
        { Py_tp_new, _new_TileFlyoutUpdateManager },
        { Py_tp_methods, _methods_TileFlyoutUpdateManager },
        { Py_tp_getset, _getset_TileFlyoutUpdateManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TileFlyoutUpdateManager =
    {
        "_winrt_Windows_UI_Notifications.TileFlyoutUpdateManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileFlyoutUpdateManager
    };

    // ----- TileFlyoutUpdater class --------------------
    constexpr const char* const _type_name_TileFlyoutUpdater = "TileFlyoutUpdater";

    static PyObject* _new_TileFlyoutUpdater(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TileFlyoutUpdater);
        return nullptr;
    }

    static void _dealloc_TileFlyoutUpdater(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TileFlyoutUpdater_Clear(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileFlyoutUpdater_StartPeriodicUpdate(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 1);

                self->obj.StartPeriodicUpdate(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 2);

                self->obj.StartPeriodicUpdate(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileFlyoutUpdater_StopPeriodicUpdate(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.StopPeriodicUpdate();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileFlyoutUpdater_Update(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileFlyoutNotification>(args, 0);

                self->obj.Update(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileFlyoutUpdater_get_Setting(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Setting());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TileFlyoutUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::TileFlyoutUpdater>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileFlyoutUpdater[] = {
        { "clear", (PyCFunction)TileFlyoutUpdater_Clear, METH_VARARGS, nullptr },
        { "start_periodic_update", (PyCFunction)TileFlyoutUpdater_StartPeriodicUpdate, METH_VARARGS, nullptr },
        { "stop_periodic_update", (PyCFunction)TileFlyoutUpdater_StopPeriodicUpdate, METH_VARARGS, nullptr },
        { "update", (PyCFunction)TileFlyoutUpdater_Update, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_TileFlyoutUpdater, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TileFlyoutUpdater[] = {
        { const_cast<char*>("setting"), (getter)TileFlyoutUpdater_get_Setting, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TileFlyoutUpdater[] = 
    {
        { Py_tp_new, _new_TileFlyoutUpdater },
        { Py_tp_dealloc, _dealloc_TileFlyoutUpdater },
        { Py_tp_methods, _methods_TileFlyoutUpdater },
        { Py_tp_getset, _getset_TileFlyoutUpdater },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TileFlyoutUpdater =
    {
        "_winrt_Windows_UI_Notifications.TileFlyoutUpdater",
        sizeof(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileFlyoutUpdater
    };

    // ----- TileNotification class --------------------
    constexpr const char* const _type_name_TileNotification = "TileNotification";

    static PyObject* _new_TileNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);

                winrt::Windows::UI::Notifications::TileNotification instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TileNotification(py::wrapper::Windows::UI::Notifications::TileNotification* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TileNotification_get_Tag(py::wrapper::Windows::UI::Notifications::TileNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TileNotification_put_Tag(py::wrapper::Windows::UI::Notifications::TileNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TileNotification_get_ExpirationTime(py::wrapper::Windows::UI::Notifications::TileNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpirationTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TileNotification_put_ExpirationTime(py::wrapper::Windows::UI::Notifications::TileNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ExpirationTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TileNotification_get_Content(py::wrapper::Windows::UI::Notifications::TileNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TileNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::TileNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileNotification[] = {
        { "_from", (PyCFunction)_from_TileNotification, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TileNotification[] = {
        { const_cast<char*>("tag"), (getter)TileNotification_get_Tag, (setter)TileNotification_put_Tag, nullptr, nullptr },
        { const_cast<char*>("expiration_time"), (getter)TileNotification_get_ExpirationTime, (setter)TileNotification_put_ExpirationTime, nullptr, nullptr },
        { const_cast<char*>("content"), (getter)TileNotification_get_Content, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TileNotification[] = 
    {
        { Py_tp_new, _new_TileNotification },
        { Py_tp_dealloc, _dealloc_TileNotification },
        { Py_tp_methods, _methods_TileNotification },
        { Py_tp_getset, _getset_TileNotification },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TileNotification =
    {
        "_winrt_Windows_UI_Notifications.TileNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::TileNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileNotification
    };

    // ----- TileUpdateManager class --------------------
    constexpr const char* const _type_name_TileUpdateManager = "TileUpdateManager";

    static PyObject* _new_TileUpdateManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TileUpdateManager);
        return nullptr;
    }

    static PyObject* TileUpdateManager_CreateTileUpdaterForApplication(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::Notifications::TileUpdateManager::CreateTileUpdaterForApplication());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::TileUpdateManager::CreateTileUpdaterForApplication(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdateManager_CreateTileUpdaterForSecondaryTile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::TileUpdateManager::CreateTileUpdaterForSecondaryTile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdateManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::TileUpdateManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdateManager_GetTemplateContent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileTemplateType>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::TileUpdateManager::GetTemplateContent(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileUpdateManager[] = {
        { "create_tile_updater_for_application", (PyCFunction)TileUpdateManager_CreateTileUpdaterForApplication, METH_VARARGS | METH_STATIC, nullptr },
        { "create_tile_updater_for_secondary_tile", (PyCFunction)TileUpdateManager_CreateTileUpdaterForSecondaryTile, METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", (PyCFunction)TileUpdateManager_GetForUser, METH_VARARGS | METH_STATIC, nullptr },
        { "get_template_content", (PyCFunction)TileUpdateManager_GetTemplateContent, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TileUpdateManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_TileUpdateManager[] = 
    {
        { Py_tp_new, _new_TileUpdateManager },
        { Py_tp_methods, _methods_TileUpdateManager },
        { Py_tp_getset, _getset_TileUpdateManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TileUpdateManager =
    {
        "_winrt_Windows_UI_Notifications.TileUpdateManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileUpdateManager
    };

    // ----- TileUpdateManagerForUser class --------------------
    constexpr const char* const _type_name_TileUpdateManagerForUser = "TileUpdateManagerForUser";

    static PyObject* _new_TileUpdateManagerForUser(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TileUpdateManagerForUser);
        return nullptr;
    }

    static void _dealloc_TileUpdateManagerForUser(py::wrapper::Windows::UI::Notifications::TileUpdateManagerForUser* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TileUpdateManagerForUser_CreateTileUpdaterForApplication(py::wrapper::Windows::UI::Notifications::TileUpdateManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateTileUpdaterForApplication(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdateManagerForUser_CreateTileUpdaterForApplicationForUser(py::wrapper::Windows::UI::Notifications::TileUpdateManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateTileUpdaterForApplicationForUser());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdateManagerForUser_CreateTileUpdaterForSecondaryTile(py::wrapper::Windows::UI::Notifications::TileUpdateManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateTileUpdaterForSecondaryTile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdateManagerForUser_get_User(py::wrapper::Windows::UI::Notifications::TileUpdateManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TileUpdateManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::TileUpdateManagerForUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileUpdateManagerForUser[] = {
        { "create_tile_updater_for_application", (PyCFunction)TileUpdateManagerForUser_CreateTileUpdaterForApplication, METH_VARARGS, nullptr },
        { "create_tile_updater_for_application_for_user", (PyCFunction)TileUpdateManagerForUser_CreateTileUpdaterForApplicationForUser, METH_VARARGS, nullptr },
        { "create_tile_updater_for_secondary_tile", (PyCFunction)TileUpdateManagerForUser_CreateTileUpdaterForSecondaryTile, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_TileUpdateManagerForUser, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TileUpdateManagerForUser[] = {
        { const_cast<char*>("user"), (getter)TileUpdateManagerForUser_get_User, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TileUpdateManagerForUser[] = 
    {
        { Py_tp_new, _new_TileUpdateManagerForUser },
        { Py_tp_dealloc, _dealloc_TileUpdateManagerForUser },
        { Py_tp_methods, _methods_TileUpdateManagerForUser },
        { Py_tp_getset, _getset_TileUpdateManagerForUser },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TileUpdateManagerForUser =
    {
        "_winrt_Windows_UI_Notifications.TileUpdateManagerForUser",
        sizeof(py::wrapper::Windows::UI::Notifications::TileUpdateManagerForUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileUpdateManagerForUser
    };

    // ----- TileUpdater class --------------------
    constexpr const char* const _type_name_TileUpdater = "TileUpdater";

    static PyObject* _new_TileUpdater(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TileUpdater);
        return nullptr;
    }

    static void _dealloc_TileUpdater(py::wrapper::Windows::UI::Notifications::TileUpdater* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TileUpdater_AddToSchedule(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ScheduledTileNotification>(args, 0);

                self->obj.AddToSchedule(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_Clear(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_EnableNotificationQueue(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.EnableNotificationQueue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_EnableNotificationQueueForSquare150x150(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.EnableNotificationQueueForSquare150x150(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_EnableNotificationQueueForSquare310x310(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.EnableNotificationQueueForSquare310x310(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_EnableNotificationQueueForWide310x150(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.EnableNotificationQueueForWide310x150(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_GetScheduledTileNotifications(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetScheduledTileNotifications());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_RemoveFromSchedule(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ScheduledTileNotification>(args, 0);

                self->obj.RemoveFromSchedule(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_StartPeriodicUpdate(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 1);

                self->obj.StartPeriodicUpdate(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 2);

                self->obj.StartPeriodicUpdate(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_StartPeriodicUpdateBatch(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 1);

                self->obj.StartPeriodicUpdateBatch(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 2);

                self->obj.StartPeriodicUpdateBatch(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_StopPeriodicUpdate(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.StopPeriodicUpdate();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_Update(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileNotification>(args, 0);

                self->obj.Update(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_get_Setting(py::wrapper::Windows::UI::Notifications::TileUpdater* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Setting());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TileUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::TileUpdater>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileUpdater[] = {
        { "add_to_schedule", (PyCFunction)TileUpdater_AddToSchedule, METH_VARARGS, nullptr },
        { "clear", (PyCFunction)TileUpdater_Clear, METH_VARARGS, nullptr },
        { "enable_notification_queue", (PyCFunction)TileUpdater_EnableNotificationQueue, METH_VARARGS, nullptr },
        { "enable_notification_queue_for_square150x150", (PyCFunction)TileUpdater_EnableNotificationQueueForSquare150x150, METH_VARARGS, nullptr },
        { "enable_notification_queue_for_square310x310", (PyCFunction)TileUpdater_EnableNotificationQueueForSquare310x310, METH_VARARGS, nullptr },
        { "enable_notification_queue_for_wide310x150", (PyCFunction)TileUpdater_EnableNotificationQueueForWide310x150, METH_VARARGS, nullptr },
        { "get_scheduled_tile_notifications", (PyCFunction)TileUpdater_GetScheduledTileNotifications, METH_VARARGS, nullptr },
        { "remove_from_schedule", (PyCFunction)TileUpdater_RemoveFromSchedule, METH_VARARGS, nullptr },
        { "start_periodic_update", (PyCFunction)TileUpdater_StartPeriodicUpdate, METH_VARARGS, nullptr },
        { "start_periodic_update_batch", (PyCFunction)TileUpdater_StartPeriodicUpdateBatch, METH_VARARGS, nullptr },
        { "stop_periodic_update", (PyCFunction)TileUpdater_StopPeriodicUpdate, METH_VARARGS, nullptr },
        { "update", (PyCFunction)TileUpdater_Update, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_TileUpdater, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TileUpdater[] = {
        { const_cast<char*>("setting"), (getter)TileUpdater_get_Setting, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TileUpdater[] = 
    {
        { Py_tp_new, _new_TileUpdater },
        { Py_tp_dealloc, _dealloc_TileUpdater },
        { Py_tp_methods, _methods_TileUpdater },
        { Py_tp_getset, _getset_TileUpdater },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TileUpdater =
    {
        "_winrt_Windows_UI_Notifications.TileUpdater",
        sizeof(py::wrapper::Windows::UI::Notifications::TileUpdater),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileUpdater
    };

    // ----- ToastActivatedEventArgs class --------------------
    constexpr const char* const _type_name_ToastActivatedEventArgs = "ToastActivatedEventArgs";

    static PyObject* _new_ToastActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ToastActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ToastActivatedEventArgs(py::wrapper::Windows::UI::Notifications::ToastActivatedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ToastActivatedEventArgs_get_Arguments(py::wrapper::Windows::UI::Notifications::ToastActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastActivatedEventArgs_get_UserInput(py::wrapper::Windows::UI::Notifications::ToastActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ToastActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastActivatedEventArgs[] = {
        { "_from", (PyCFunction)_from_ToastActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ToastActivatedEventArgs[] = {
        { const_cast<char*>("arguments"), (getter)ToastActivatedEventArgs_get_Arguments, nullptr, nullptr, nullptr },
        { const_cast<char*>("user_input"), (getter)ToastActivatedEventArgs_get_UserInput, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ToastActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_ToastActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_ToastActivatedEventArgs },
        { Py_tp_methods, _methods_ToastActivatedEventArgs },
        { Py_tp_getset, _getset_ToastActivatedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ToastActivatedEventArgs =
    {
        "_winrt_Windows_UI_Notifications.ToastActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastActivatedEventArgs
    };

    // ----- ToastCollection class --------------------
    constexpr const char* const _type_name_ToastCollection = "ToastCollection";

    static PyObject* _new_ToastCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);

                winrt::Windows::UI::Notifications::ToastCollection instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToastCollection(py::wrapper::Windows::UI::Notifications::ToastCollection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ToastCollection_get_LaunchArgs(py::wrapper::Windows::UI::Notifications::ToastCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LaunchArgs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastCollection_put_LaunchArgs(py::wrapper::Windows::UI::Notifications::ToastCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.LaunchArgs(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastCollection_get_Icon(py::wrapper::Windows::UI::Notifications::ToastCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastCollection_put_Icon(py::wrapper::Windows::UI::Notifications::ToastCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Icon(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastCollection_get_DisplayName(py::wrapper::Windows::UI::Notifications::ToastCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastCollection_put_DisplayName(py::wrapper::Windows::UI::Notifications::ToastCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastCollection_get_Id(py::wrapper::Windows::UI::Notifications::ToastCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ToastCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastCollection[] = {
        { "_from", (PyCFunction)_from_ToastCollection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ToastCollection[] = {
        { const_cast<char*>("launch_args"), (getter)ToastCollection_get_LaunchArgs, (setter)ToastCollection_put_LaunchArgs, nullptr, nullptr },
        { const_cast<char*>("icon"), (getter)ToastCollection_get_Icon, (setter)ToastCollection_put_Icon, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)ToastCollection_get_DisplayName, (setter)ToastCollection_put_DisplayName, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)ToastCollection_get_Id, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ToastCollection[] = 
    {
        { Py_tp_new, _new_ToastCollection },
        { Py_tp_dealloc, _dealloc_ToastCollection },
        { Py_tp_methods, _methods_ToastCollection },
        { Py_tp_getset, _getset_ToastCollection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ToastCollection =
    {
        "_winrt_Windows_UI_Notifications.ToastCollection",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastCollection
    };

    // ----- ToastCollectionManager class --------------------
    constexpr const char* const _type_name_ToastCollectionManager = "ToastCollectionManager";

    static PyObject* _new_ToastCollectionManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ToastCollectionManager);
        return nullptr;
    }

    static void _dealloc_ToastCollectionManager(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ToastCollectionManager_FindAllToastCollectionsAsync(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindAllToastCollectionsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastCollectionManager_GetToastCollectionAsync(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetToastCollectionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastCollectionManager_RemoveAllToastCollectionsAsync(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RemoveAllToastCollectionsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastCollectionManager_RemoveToastCollectionAsync(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RemoveToastCollectionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastCollectionManager_SaveToastCollectionAsync(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastCollection>(args, 0);

                return py::convert(self->obj.SaveToastCollectionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastCollectionManager_get_AppId(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastCollectionManager_get_User(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ToastCollectionManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastCollectionManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastCollectionManager[] = {
        { "find_all_toast_collections_async", (PyCFunction)ToastCollectionManager_FindAllToastCollectionsAsync, METH_VARARGS, nullptr },
        { "get_toast_collection_async", (PyCFunction)ToastCollectionManager_GetToastCollectionAsync, METH_VARARGS, nullptr },
        { "remove_all_toast_collections_async", (PyCFunction)ToastCollectionManager_RemoveAllToastCollectionsAsync, METH_VARARGS, nullptr },
        { "remove_toast_collection_async", (PyCFunction)ToastCollectionManager_RemoveToastCollectionAsync, METH_VARARGS, nullptr },
        { "save_toast_collection_async", (PyCFunction)ToastCollectionManager_SaveToastCollectionAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ToastCollectionManager, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ToastCollectionManager[] = {
        { const_cast<char*>("app_id"), (getter)ToastCollectionManager_get_AppId, nullptr, nullptr, nullptr },
        { const_cast<char*>("user"), (getter)ToastCollectionManager_get_User, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ToastCollectionManager[] = 
    {
        { Py_tp_new, _new_ToastCollectionManager },
        { Py_tp_dealloc, _dealloc_ToastCollectionManager },
        { Py_tp_methods, _methods_ToastCollectionManager },
        { Py_tp_getset, _getset_ToastCollectionManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ToastCollectionManager =
    {
        "_winrt_Windows_UI_Notifications.ToastCollectionManager",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastCollectionManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastCollectionManager
    };

    // ----- ToastDismissedEventArgs class --------------------
    constexpr const char* const _type_name_ToastDismissedEventArgs = "ToastDismissedEventArgs";

    static PyObject* _new_ToastDismissedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ToastDismissedEventArgs);
        return nullptr;
    }

    static void _dealloc_ToastDismissedEventArgs(py::wrapper::Windows::UI::Notifications::ToastDismissedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ToastDismissedEventArgs_get_Reason(py::wrapper::Windows::UI::Notifications::ToastDismissedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ToastDismissedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastDismissedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastDismissedEventArgs[] = {
        { "_from", (PyCFunction)_from_ToastDismissedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ToastDismissedEventArgs[] = {
        { const_cast<char*>("reason"), (getter)ToastDismissedEventArgs_get_Reason, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ToastDismissedEventArgs[] = 
    {
        { Py_tp_new, _new_ToastDismissedEventArgs },
        { Py_tp_dealloc, _dealloc_ToastDismissedEventArgs },
        { Py_tp_methods, _methods_ToastDismissedEventArgs },
        { Py_tp_getset, _getset_ToastDismissedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ToastDismissedEventArgs =
    {
        "_winrt_Windows_UI_Notifications.ToastDismissedEventArgs",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastDismissedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastDismissedEventArgs
    };

    // ----- ToastFailedEventArgs class --------------------
    constexpr const char* const _type_name_ToastFailedEventArgs = "ToastFailedEventArgs";

    static PyObject* _new_ToastFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ToastFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_ToastFailedEventArgs(py::wrapper::Windows::UI::Notifications::ToastFailedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ToastFailedEventArgs_get_ErrorCode(py::wrapper::Windows::UI::Notifications::ToastFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ToastFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastFailedEventArgs[] = {
        { "_from", (PyCFunction)_from_ToastFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ToastFailedEventArgs[] = {
        { const_cast<char*>("error_code"), (getter)ToastFailedEventArgs_get_ErrorCode, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ToastFailedEventArgs[] = 
    {
        { Py_tp_new, _new_ToastFailedEventArgs },
        { Py_tp_dealloc, _dealloc_ToastFailedEventArgs },
        { Py_tp_methods, _methods_ToastFailedEventArgs },
        { Py_tp_getset, _getset_ToastFailedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ToastFailedEventArgs =
    {
        "_winrt_Windows_UI_Notifications.ToastFailedEventArgs",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastFailedEventArgs
    };

    // ----- ToastNotification class --------------------
    constexpr const char* const _type_name_ToastNotification = "ToastNotification";

    static PyObject* _new_ToastNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);

                winrt::Windows::UI::Notifications::ToastNotification instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToastNotification(py::wrapper::Windows::UI::Notifications::ToastNotification* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ToastNotification_get_ExpirationTime(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpirationTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_ExpirationTime(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ExpirationTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_Content(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotification_get_Tag(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_Tag(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_SuppressPopup(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuppressPopup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_SuppressPopup(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SuppressPopup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_Group(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_Group(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Group(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_RemoteId(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_RemoteId(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_NotificationMirroring(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NotificationMirroring());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_NotificationMirroring(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationMirroring>(arg);

            self->obj.NotificationMirroring(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_Priority(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Priority());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_Priority(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotificationPriority>(arg);

            self->obj.Priority(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_Data(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_Data(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationData>(arg);

            self->obj.Data(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_ExpiresOnReboot(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpiresOnReboot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_ExpiresOnReboot(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ExpiresOnReboot(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_add_Activated(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Notifications::ToastNotification, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Activated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotification_remove_Activated(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Activated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotification_add_Dismissed(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Notifications::ToastNotification, winrt::Windows::UI::Notifications::ToastDismissedEventArgs>>(arg);

            return py::convert(self->obj.Dismissed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotification_remove_Dismissed(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Dismissed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotification_add_Failed(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Notifications::ToastNotification, winrt::Windows::UI::Notifications::ToastFailedEventArgs>>(arg);

            return py::convert(self->obj.Failed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotification_remove_Failed(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Failed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ToastNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotification[] = {
        { "add_activated", (PyCFunction)ToastNotification_add_Activated, METH_O, nullptr },
        { "remove_activated", (PyCFunction)ToastNotification_remove_Activated, METH_O, nullptr },
        { "add_dismissed", (PyCFunction)ToastNotification_add_Dismissed, METH_O, nullptr },
        { "remove_dismissed", (PyCFunction)ToastNotification_remove_Dismissed, METH_O, nullptr },
        { "add_failed", (PyCFunction)ToastNotification_add_Failed, METH_O, nullptr },
        { "remove_failed", (PyCFunction)ToastNotification_remove_Failed, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ToastNotification, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ToastNotification[] = {
        { const_cast<char*>("expiration_time"), (getter)ToastNotification_get_ExpirationTime, (setter)ToastNotification_put_ExpirationTime, nullptr, nullptr },
        { const_cast<char*>("content"), (getter)ToastNotification_get_Content, nullptr, nullptr, nullptr },
        { const_cast<char*>("tag"), (getter)ToastNotification_get_Tag, (setter)ToastNotification_put_Tag, nullptr, nullptr },
        { const_cast<char*>("suppress_popup"), (getter)ToastNotification_get_SuppressPopup, (setter)ToastNotification_put_SuppressPopup, nullptr, nullptr },
        { const_cast<char*>("group"), (getter)ToastNotification_get_Group, (setter)ToastNotification_put_Group, nullptr, nullptr },
        { const_cast<char*>("remote_id"), (getter)ToastNotification_get_RemoteId, (setter)ToastNotification_put_RemoteId, nullptr, nullptr },
        { const_cast<char*>("notification_mirroring"), (getter)ToastNotification_get_NotificationMirroring, (setter)ToastNotification_put_NotificationMirroring, nullptr, nullptr },
        { const_cast<char*>("priority"), (getter)ToastNotification_get_Priority, (setter)ToastNotification_put_Priority, nullptr, nullptr },
        { const_cast<char*>("data"), (getter)ToastNotification_get_Data, (setter)ToastNotification_put_Data, nullptr, nullptr },
        { const_cast<char*>("expires_on_reboot"), (getter)ToastNotification_get_ExpiresOnReboot, (setter)ToastNotification_put_ExpiresOnReboot, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ToastNotification[] = 
    {
        { Py_tp_new, _new_ToastNotification },
        { Py_tp_dealloc, _dealloc_ToastNotification },
        { Py_tp_methods, _methods_ToastNotification },
        { Py_tp_getset, _getset_ToastNotification },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ToastNotification =
    {
        "_winrt_Windows_UI_Notifications.ToastNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotification
    };

    // ----- ToastNotificationActionTriggerDetail class --------------------
    constexpr const char* const _type_name_ToastNotificationActionTriggerDetail = "ToastNotificationActionTriggerDetail";

    static PyObject* _new_ToastNotificationActionTriggerDetail(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ToastNotificationActionTriggerDetail);
        return nullptr;
    }

    static void _dealloc_ToastNotificationActionTriggerDetail(py::wrapper::Windows::UI::Notifications::ToastNotificationActionTriggerDetail* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ToastNotificationActionTriggerDetail_get_Argument(py::wrapper::Windows::UI::Notifications::ToastNotificationActionTriggerDetail* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Argument());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationActionTriggerDetail_get_UserInput(py::wrapper::Windows::UI::Notifications::ToastNotificationActionTriggerDetail* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ToastNotificationActionTriggerDetail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastNotificationActionTriggerDetail>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationActionTriggerDetail[] = {
        { "_from", (PyCFunction)_from_ToastNotificationActionTriggerDetail, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ToastNotificationActionTriggerDetail[] = {
        { const_cast<char*>("argument"), (getter)ToastNotificationActionTriggerDetail_get_Argument, nullptr, nullptr, nullptr },
        { const_cast<char*>("user_input"), (getter)ToastNotificationActionTriggerDetail_get_UserInput, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ToastNotificationActionTriggerDetail[] = 
    {
        { Py_tp_new, _new_ToastNotificationActionTriggerDetail },
        { Py_tp_dealloc, _dealloc_ToastNotificationActionTriggerDetail },
        { Py_tp_methods, _methods_ToastNotificationActionTriggerDetail },
        { Py_tp_getset, _getset_ToastNotificationActionTriggerDetail },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ToastNotificationActionTriggerDetail =
    {
        "_winrt_Windows_UI_Notifications.ToastNotificationActionTriggerDetail",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastNotificationActionTriggerDetail),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationActionTriggerDetail
    };

    // ----- ToastNotificationHistory class --------------------
    constexpr const char* const _type_name_ToastNotificationHistory = "ToastNotificationHistory";

    static PyObject* _new_ToastNotificationHistory(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ToastNotificationHistory);
        return nullptr;
    }

    static void _dealloc_ToastNotificationHistory(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ToastNotificationHistory_Clear(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Clear(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationHistory_GetHistory(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetHistory());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetHistory(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationHistory_Remove(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Remove(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                self->obj.Remove(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationHistory_RemoveGroup(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.RemoveGroup(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.RemoveGroup(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ToastNotificationHistory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastNotificationHistory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationHistory[] = {
        { "clear", (PyCFunction)ToastNotificationHistory_Clear, METH_VARARGS, nullptr },
        { "get_history", (PyCFunction)ToastNotificationHistory_GetHistory, METH_VARARGS, nullptr },
        { "remove", (PyCFunction)ToastNotificationHistory_Remove, METH_VARARGS, nullptr },
        { "remove_group", (PyCFunction)ToastNotificationHistory_RemoveGroup, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ToastNotificationHistory, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ToastNotificationHistory[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ToastNotificationHistory[] = 
    {
        { Py_tp_new, _new_ToastNotificationHistory },
        { Py_tp_dealloc, _dealloc_ToastNotificationHistory },
        { Py_tp_methods, _methods_ToastNotificationHistory },
        { Py_tp_getset, _getset_ToastNotificationHistory },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ToastNotificationHistory =
    {
        "_winrt_Windows_UI_Notifications.ToastNotificationHistory",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationHistory
    };

    // ----- ToastNotificationHistoryChangedTriggerDetail class --------------------
    constexpr const char* const _type_name_ToastNotificationHistoryChangedTriggerDetail = "ToastNotificationHistoryChangedTriggerDetail";

    static PyObject* _new_ToastNotificationHistoryChangedTriggerDetail(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ToastNotificationHistoryChangedTriggerDetail);
        return nullptr;
    }

    static void _dealloc_ToastNotificationHistoryChangedTriggerDetail(py::wrapper::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ToastNotificationHistoryChangedTriggerDetail_get_ChangeType(py::wrapper::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationHistoryChangedTriggerDetail_get_CollectionId(py::wrapper::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CollectionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ToastNotificationHistoryChangedTriggerDetail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationHistoryChangedTriggerDetail[] = {
        { "_from", (PyCFunction)_from_ToastNotificationHistoryChangedTriggerDetail, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ToastNotificationHistoryChangedTriggerDetail[] = {
        { const_cast<char*>("change_type"), (getter)ToastNotificationHistoryChangedTriggerDetail_get_ChangeType, nullptr, nullptr, nullptr },
        { const_cast<char*>("collection_id"), (getter)ToastNotificationHistoryChangedTriggerDetail_get_CollectionId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ToastNotificationHistoryChangedTriggerDetail[] = 
    {
        { Py_tp_new, _new_ToastNotificationHistoryChangedTriggerDetail },
        { Py_tp_dealloc, _dealloc_ToastNotificationHistoryChangedTriggerDetail },
        { Py_tp_methods, _methods_ToastNotificationHistoryChangedTriggerDetail },
        { Py_tp_getset, _getset_ToastNotificationHistoryChangedTriggerDetail },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ToastNotificationHistoryChangedTriggerDetail =
    {
        "_winrt_Windows_UI_Notifications.ToastNotificationHistoryChangedTriggerDetail",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationHistoryChangedTriggerDetail
    };

    // ----- ToastNotificationManager class --------------------
    constexpr const char* const _type_name_ToastNotificationManager = "ToastNotificationManager";

    static PyObject* _new_ToastNotificationManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ToastNotificationManager);
        return nullptr;
    }

    static PyObject* ToastNotificationManager_ConfigureNotificationMirroring(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationMirroring>(args, 0);

                winrt::Windows::UI::Notifications::ToastNotificationManager::ConfigureNotificationMirroring(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManager_CreateToastNotifier(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::Notifications::ToastNotificationManager::CreateToastNotifier());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::ToastNotificationManager::CreateToastNotifier(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::Notifications::ToastNotificationManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::ToastNotificationManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManager_GetTemplateContent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastTemplateType>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::ToastNotificationManager::GetTemplateContent(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManager_get_History(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Notifications::ToastNotificationManager::History());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationManager[] = {
        { "configure_notification_mirroring", (PyCFunction)ToastNotificationManager_ConfigureNotificationMirroring, METH_VARARGS | METH_STATIC, nullptr },
        { "create_toast_notifier", (PyCFunction)ToastNotificationManager_CreateToastNotifier, METH_VARARGS | METH_STATIC, nullptr },
        { "get_default", (PyCFunction)ToastNotificationManager_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", (PyCFunction)ToastNotificationManager_GetForUser, METH_VARARGS | METH_STATIC, nullptr },
        { "get_template_content", (PyCFunction)ToastNotificationManager_GetTemplateContent, METH_VARARGS | METH_STATIC, nullptr },
        { "get_history", (PyCFunction)ToastNotificationManager_get_History, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ToastNotificationManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ToastNotificationManager[] = 
    {
        { Py_tp_new, _new_ToastNotificationManager },
        { Py_tp_methods, _methods_ToastNotificationManager },
        { Py_tp_getset, _getset_ToastNotificationManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ToastNotificationManager =
    {
        "_winrt_Windows_UI_Notifications.ToastNotificationManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationManager
    };

    // ----- ToastNotificationManagerForUser class --------------------
    constexpr const char* const _type_name_ToastNotificationManagerForUser = "ToastNotificationManagerForUser";

    static PyObject* _new_ToastNotificationManagerForUser(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ToastNotificationManagerForUser);
        return nullptr;
    }

    static void _dealloc_ToastNotificationManagerForUser(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ToastNotificationManagerForUser_CreateToastNotifier(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateToastNotifier());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateToastNotifier(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_GetHistoryForToastCollectionIdAsync(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetHistoryForToastCollectionIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_GetToastCollectionManager(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetToastCollectionManager());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetToastCollectionManager(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_GetToastNotifierForToastCollectionIdAsync(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetToastNotifierForToastCollectionIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_get_History(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.History());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_get_User(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ToastNotificationManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastNotificationManagerForUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationManagerForUser[] = {
        { "create_toast_notifier", (PyCFunction)ToastNotificationManagerForUser_CreateToastNotifier, METH_VARARGS, nullptr },
        { "get_history_for_toast_collection_id_async", (PyCFunction)ToastNotificationManagerForUser_GetHistoryForToastCollectionIdAsync, METH_VARARGS, nullptr },
        { "get_toast_collection_manager", (PyCFunction)ToastNotificationManagerForUser_GetToastCollectionManager, METH_VARARGS, nullptr },
        { "get_toast_notifier_for_toast_collection_id_async", (PyCFunction)ToastNotificationManagerForUser_GetToastNotifierForToastCollectionIdAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ToastNotificationManagerForUser, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ToastNotificationManagerForUser[] = {
        { const_cast<char*>("history"), (getter)ToastNotificationManagerForUser_get_History, nullptr, nullptr, nullptr },
        { const_cast<char*>("user"), (getter)ToastNotificationManagerForUser_get_User, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ToastNotificationManagerForUser[] = 
    {
        { Py_tp_new, _new_ToastNotificationManagerForUser },
        { Py_tp_dealloc, _dealloc_ToastNotificationManagerForUser },
        { Py_tp_methods, _methods_ToastNotificationManagerForUser },
        { Py_tp_getset, _getset_ToastNotificationManagerForUser },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ToastNotificationManagerForUser =
    {
        "_winrt_Windows_UI_Notifications.ToastNotificationManagerForUser",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationManagerForUser
    };

    // ----- ToastNotifier class --------------------
    constexpr const char* const _type_name_ToastNotifier = "ToastNotifier";

    static PyObject* _new_ToastNotifier(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ToastNotifier);
        return nullptr;
    }

    static void _dealloc_ToastNotifier(py::wrapper::Windows::UI::Notifications::ToastNotifier* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ToastNotifier_AddToSchedule(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ScheduledToastNotification>(args, 0);

                self->obj.AddToSchedule(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_GetScheduledToastNotifications(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetScheduledToastNotifications());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_Hide(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(args, 0);

                self->obj.Hide(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_RemoveFromSchedule(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ScheduledToastNotification>(args, 0);

                self->obj.RemoveFromSchedule(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_Show(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(args, 0);

                self->obj.Show(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_Update(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationData>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.Update(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationData>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.Update(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_get_Setting(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Setting());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_add_ScheduledToastNotificationShowing(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Notifications::ToastNotifier, winrt::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs>>(arg);

            return py::convert(self->obj.ScheduledToastNotificationShowing(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_remove_ScheduledToastNotificationShowing(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ScheduledToastNotificationShowing(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ToastNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastNotifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotifier[] = {
        { "add_to_schedule", (PyCFunction)ToastNotifier_AddToSchedule, METH_VARARGS, nullptr },
        { "get_scheduled_toast_notifications", (PyCFunction)ToastNotifier_GetScheduledToastNotifications, METH_VARARGS, nullptr },
        { "hide", (PyCFunction)ToastNotifier_Hide, METH_VARARGS, nullptr },
        { "remove_from_schedule", (PyCFunction)ToastNotifier_RemoveFromSchedule, METH_VARARGS, nullptr },
        { "show", (PyCFunction)ToastNotifier_Show, METH_VARARGS, nullptr },
        { "update", (PyCFunction)ToastNotifier_Update, METH_VARARGS, nullptr },
        { "add_scheduled_toast_notification_showing", (PyCFunction)ToastNotifier_add_ScheduledToastNotificationShowing, METH_O, nullptr },
        { "remove_scheduled_toast_notification_showing", (PyCFunction)ToastNotifier_remove_ScheduledToastNotificationShowing, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ToastNotifier, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ToastNotifier[] = {
        { const_cast<char*>("setting"), (getter)ToastNotifier_get_Setting, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ToastNotifier[] = 
    {
        { Py_tp_new, _new_ToastNotifier },
        { Py_tp_dealloc, _dealloc_ToastNotifier },
        { Py_tp_methods, _methods_ToastNotifier },
        { Py_tp_getset, _getset_ToastNotifier },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ToastNotifier =
    {
        "_winrt_Windows_UI_Notifications.ToastNotifier",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastNotifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotifier
    };

    // ----- UserNotification class --------------------
    constexpr const char* const _type_name_UserNotification = "UserNotification";

    static PyObject* _new_UserNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UserNotification);
        return nullptr;
    }

    static void _dealloc_UserNotification(py::wrapper::Windows::UI::Notifications::UserNotification* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UserNotification_get_AppInfo(py::wrapper::Windows::UI::Notifications::UserNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserNotification_get_CreationTime(py::wrapper::Windows::UI::Notifications::UserNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CreationTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserNotification_get_Id(py::wrapper::Windows::UI::Notifications::UserNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserNotification_get_Notification(py::wrapper::Windows::UI::Notifications::UserNotification* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Notification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UserNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::UserNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserNotification[] = {
        { "_from", (PyCFunction)_from_UserNotification, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UserNotification[] = {
        { const_cast<char*>("app_info"), (getter)UserNotification_get_AppInfo, nullptr, nullptr, nullptr },
        { const_cast<char*>("creation_time"), (getter)UserNotification_get_CreationTime, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)UserNotification_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("notification"), (getter)UserNotification_get_Notification, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UserNotification[] = 
    {
        { Py_tp_new, _new_UserNotification },
        { Py_tp_dealloc, _dealloc_UserNotification },
        { Py_tp_methods, _methods_UserNotification },
        { Py_tp_getset, _getset_UserNotification },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UserNotification =
    {
        "_winrt_Windows_UI_Notifications.UserNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::UserNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserNotification
    };

    // ----- UserNotificationChangedEventArgs class --------------------
    constexpr const char* const _type_name_UserNotificationChangedEventArgs = "UserNotificationChangedEventArgs";

    static PyObject* _new_UserNotificationChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UserNotificationChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_UserNotificationChangedEventArgs(py::wrapper::Windows::UI::Notifications::UserNotificationChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UserNotificationChangedEventArgs_get_ChangeKind(py::wrapper::Windows::UI::Notifications::UserNotificationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserNotificationChangedEventArgs_get_UserNotificationId(py::wrapper::Windows::UI::Notifications::UserNotificationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserNotificationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UserNotificationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::UserNotificationChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserNotificationChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_UserNotificationChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UserNotificationChangedEventArgs[] = {
        { const_cast<char*>("change_kind"), (getter)UserNotificationChangedEventArgs_get_ChangeKind, nullptr, nullptr, nullptr },
        { const_cast<char*>("user_notification_id"), (getter)UserNotificationChangedEventArgs_get_UserNotificationId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UserNotificationChangedEventArgs[] = 
    {
        { Py_tp_new, _new_UserNotificationChangedEventArgs },
        { Py_tp_dealloc, _dealloc_UserNotificationChangedEventArgs },
        { Py_tp_methods, _methods_UserNotificationChangedEventArgs },
        { Py_tp_getset, _getset_UserNotificationChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UserNotificationChangedEventArgs =
    {
        "_winrt_Windows_UI_Notifications.UserNotificationChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Notifications::UserNotificationChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserNotificationChangedEventArgs
    };

    // ----- IAdaptiveNotificationContent interface --------------------
    constexpr const char* const _type_name_IAdaptiveNotificationContent = "IAdaptiveNotificationContent";

    static PyObject* _new_IAdaptiveNotificationContent(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IAdaptiveNotificationContent);
        return nullptr;
    }

    static void _dealloc_IAdaptiveNotificationContent(py::wrapper::Windows::UI::Notifications::IAdaptiveNotificationContent* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IAdaptiveNotificationContent_get_Hints(py::wrapper::Windows::UI::Notifications::IAdaptiveNotificationContent* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Hints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAdaptiveNotificationContent_get_Kind(py::wrapper::Windows::UI::Notifications::IAdaptiveNotificationContent* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IAdaptiveNotificationContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::IAdaptiveNotificationContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAdaptiveNotificationContent[] = {
        { "_from", (PyCFunction)_from_IAdaptiveNotificationContent, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IAdaptiveNotificationContent[] = {
        { const_cast<char*>("hints"), (getter)IAdaptiveNotificationContent_get_Hints, nullptr, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)IAdaptiveNotificationContent_get_Kind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IAdaptiveNotificationContent[] = 
    {
        { Py_tp_new, _new_IAdaptiveNotificationContent },
        { Py_tp_dealloc, _dealloc_IAdaptiveNotificationContent },
        { Py_tp_methods, _methods_IAdaptiveNotificationContent },
        { Py_tp_getset, _getset_IAdaptiveNotificationContent },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IAdaptiveNotificationContent =
    {
        "_winrt_Windows_UI_Notifications.IAdaptiveNotificationContent",
        sizeof(py::wrapper::Windows::UI::Notifications::IAdaptiveNotificationContent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAdaptiveNotificationContent
    };

    // ----- Windows.UI.Notifications Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::UI::Notifications::AdaptiveNotificationText>::python_type = py::register_python_type(module, _type_name_AdaptiveNotificationText, &_type_spec_AdaptiveNotificationText, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::BadgeNotification>::python_type = py::register_python_type(module, _type_name_BadgeNotification, &_type_spec_BadgeNotification, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::BadgeUpdateManager>::python_type = py::register_python_type(module, _type_name_BadgeUpdateManager, &_type_spec_BadgeUpdateManager, nullptr);
            py::winrt_type<winrt::Windows::UI::Notifications::BadgeUpdateManagerForUser>::python_type = py::register_python_type(module, _type_name_BadgeUpdateManagerForUser, &_type_spec_BadgeUpdateManagerForUser, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::BadgeUpdater>::python_type = py::register_python_type(module, _type_name_BadgeUpdater, &_type_spec_BadgeUpdater, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints>::python_type = py::register_python_type(module, _type_name_KnownAdaptiveNotificationHints, &_type_spec_KnownAdaptiveNotificationHints, nullptr);
            py::winrt_type<winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles>::python_type = py::register_python_type(module, _type_name_KnownAdaptiveNotificationTextStyles, &_type_spec_KnownAdaptiveNotificationTextStyles, nullptr);
            py::winrt_type<winrt::Windows::UI::Notifications::KnownNotificationBindings>::python_type = py::register_python_type(module, _type_name_KnownNotificationBindings, &_type_spec_KnownNotificationBindings, nullptr);
            py::winrt_type<winrt::Windows::UI::Notifications::Notification>::python_type = py::register_python_type(module, _type_name_Notification, &_type_spec_Notification, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::NotificationBinding>::python_type = py::register_python_type(module, _type_name_NotificationBinding, &_type_spec_NotificationBinding, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::NotificationData>::python_type = py::register_python_type(module, _type_name_NotificationData, &_type_spec_NotificationData, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::NotificationVisual>::python_type = py::register_python_type(module, _type_name_NotificationVisual, &_type_spec_NotificationVisual, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::ScheduledTileNotification>::python_type = py::register_python_type(module, _type_name_ScheduledTileNotification, &_type_spec_ScheduledTileNotification, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::ScheduledToastNotification>::python_type = py::register_python_type(module, _type_name_ScheduledToastNotification, &_type_spec_ScheduledToastNotification, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs>::python_type = py::register_python_type(module, _type_name_ScheduledToastNotificationShowingEventArgs, &_type_spec_ScheduledToastNotificationShowingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::ShownTileNotification>::python_type = py::register_python_type(module, _type_name_ShownTileNotification, &_type_spec_ShownTileNotification, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::TileFlyoutNotification>::python_type = py::register_python_type(module, _type_name_TileFlyoutNotification, &_type_spec_TileFlyoutNotification, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::TileFlyoutUpdateManager>::python_type = py::register_python_type(module, _type_name_TileFlyoutUpdateManager, &_type_spec_TileFlyoutUpdateManager, nullptr);
            py::winrt_type<winrt::Windows::UI::Notifications::TileFlyoutUpdater>::python_type = py::register_python_type(module, _type_name_TileFlyoutUpdater, &_type_spec_TileFlyoutUpdater, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::TileNotification>::python_type = py::register_python_type(module, _type_name_TileNotification, &_type_spec_TileNotification, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::TileUpdateManager>::python_type = py::register_python_type(module, _type_name_TileUpdateManager, &_type_spec_TileUpdateManager, nullptr);
            py::winrt_type<winrt::Windows::UI::Notifications::TileUpdateManagerForUser>::python_type = py::register_python_type(module, _type_name_TileUpdateManagerForUser, &_type_spec_TileUpdateManagerForUser, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::TileUpdater>::python_type = py::register_python_type(module, _type_name_TileUpdater, &_type_spec_TileUpdater, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::ToastActivatedEventArgs>::python_type = py::register_python_type(module, _type_name_ToastActivatedEventArgs, &_type_spec_ToastActivatedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::ToastCollection>::python_type = py::register_python_type(module, _type_name_ToastCollection, &_type_spec_ToastCollection, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::ToastCollectionManager>::python_type = py::register_python_type(module, _type_name_ToastCollectionManager, &_type_spec_ToastCollectionManager, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::ToastDismissedEventArgs>::python_type = py::register_python_type(module, _type_name_ToastDismissedEventArgs, &_type_spec_ToastDismissedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::ToastFailedEventArgs>::python_type = py::register_python_type(module, _type_name_ToastFailedEventArgs, &_type_spec_ToastFailedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::ToastNotification>::python_type = py::register_python_type(module, _type_name_ToastNotification, &_type_spec_ToastNotification, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::ToastNotificationActionTriggerDetail>::python_type = py::register_python_type(module, _type_name_ToastNotificationActionTriggerDetail, &_type_spec_ToastNotificationActionTriggerDetail, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::ToastNotificationHistory>::python_type = py::register_python_type(module, _type_name_ToastNotificationHistory, &_type_spec_ToastNotificationHistory, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail>::python_type = py::register_python_type(module, _type_name_ToastNotificationHistoryChangedTriggerDetail, &_type_spec_ToastNotificationHistoryChangedTriggerDetail, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::ToastNotificationManager>::python_type = py::register_python_type(module, _type_name_ToastNotificationManager, &_type_spec_ToastNotificationManager, nullptr);
            py::winrt_type<winrt::Windows::UI::Notifications::ToastNotificationManagerForUser>::python_type = py::register_python_type(module, _type_name_ToastNotificationManagerForUser, &_type_spec_ToastNotificationManagerForUser, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::ToastNotifier>::python_type = py::register_python_type(module, _type_name_ToastNotifier, &_type_spec_ToastNotifier, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::UserNotification>::python_type = py::register_python_type(module, _type_name_UserNotification, &_type_spec_UserNotification, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::UserNotificationChangedEventArgs>::python_type = py::register_python_type(module, _type_name_UserNotificationChangedEventArgs, &_type_spec_UserNotificationChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Notifications::IAdaptiveNotificationContent>::python_type = py::register_python_type(module, _type_name_IAdaptiveNotificationContent, &_type_spec_IAdaptiveNotificationContent, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.UI.Notifications");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_UI_Notifications",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::UI::Notifications

PyMODINIT_FUNC
PyInit__winrt_Windows_UI_Notifications (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::UI::Notifications::module_def);
}
