// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Media.PlayTo.h"

PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::CurrentTimeChangeRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::MuteChangeRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToConnection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToConnectionErrorEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToConnectionStateChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToConnectionTransferredEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToReceiver>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToSource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToSourceDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToSourceRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToSourceRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlaybackRateChangeRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::SourceChangeRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::VolumeChangeRequestedEventArgs>::python_type;

namespace py::cpp::Windows::Media::PlayTo
{
    // ----- CurrentTimeChangeRequestedEventArgs class --------------------
    constexpr const char* const _type_name_CurrentTimeChangeRequestedEventArgs = "CurrentTimeChangeRequestedEventArgs";

    static PyObject* _new_CurrentTimeChangeRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CurrentTimeChangeRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_CurrentTimeChangeRequestedEventArgs(py::wrapper::Windows::Media::PlayTo::CurrentTimeChangeRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CurrentTimeChangeRequestedEventArgs_get_Time(py::wrapper::Windows::Media::PlayTo::CurrentTimeChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Time());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CurrentTimeChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::CurrentTimeChangeRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CurrentTimeChangeRequestedEventArgs[] = {
        { "_from", (PyCFunction)_from_CurrentTimeChangeRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CurrentTimeChangeRequestedEventArgs[] = {
        { const_cast<char*>("time"), (getter)CurrentTimeChangeRequestedEventArgs_get_Time, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CurrentTimeChangeRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_CurrentTimeChangeRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_CurrentTimeChangeRequestedEventArgs },
        { Py_tp_methods, _methods_CurrentTimeChangeRequestedEventArgs },
        { Py_tp_getset, _getset_CurrentTimeChangeRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CurrentTimeChangeRequestedEventArgs =
    {
        "_winrt_Windows_Media_PlayTo.CurrentTimeChangeRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::PlayTo::CurrentTimeChangeRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CurrentTimeChangeRequestedEventArgs
    };

    // ----- MuteChangeRequestedEventArgs class --------------------
    constexpr const char* const _type_name_MuteChangeRequestedEventArgs = "MuteChangeRequestedEventArgs";

    static PyObject* _new_MuteChangeRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MuteChangeRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_MuteChangeRequestedEventArgs(py::wrapper::Windows::Media::PlayTo::MuteChangeRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MuteChangeRequestedEventArgs_get_Mute(py::wrapper::Windows::Media::PlayTo::MuteChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mute());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MuteChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::MuteChangeRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MuteChangeRequestedEventArgs[] = {
        { "_from", (PyCFunction)_from_MuteChangeRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MuteChangeRequestedEventArgs[] = {
        { const_cast<char*>("mute"), (getter)MuteChangeRequestedEventArgs_get_Mute, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MuteChangeRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_MuteChangeRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_MuteChangeRequestedEventArgs },
        { Py_tp_methods, _methods_MuteChangeRequestedEventArgs },
        { Py_tp_getset, _getset_MuteChangeRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MuteChangeRequestedEventArgs =
    {
        "_winrt_Windows_Media_PlayTo.MuteChangeRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::PlayTo::MuteChangeRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MuteChangeRequestedEventArgs
    };

    // ----- PlayToConnection class --------------------
    constexpr const char* const _type_name_PlayToConnection = "PlayToConnection";

    static PyObject* _new_PlayToConnection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayToConnection);
        return nullptr;
    }

    static void _dealloc_PlayToConnection(py::wrapper::Windows::Media::PlayTo::PlayToConnection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToConnection_get_State(py::wrapper::Windows::Media::PlayTo::PlayToConnection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToConnection_add_Error(py::wrapper::Windows::Media::PlayTo::PlayToConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToConnection, winrt::Windows::Media::PlayTo::PlayToConnectionErrorEventArgs>>(arg);

            return py::convert(self->obj.Error(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToConnection_remove_Error(py::wrapper::Windows::Media::PlayTo::PlayToConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Error(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToConnection_add_StateChanged(py::wrapper::Windows::Media::PlayTo::PlayToConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToConnection, winrt::Windows::Media::PlayTo::PlayToConnectionStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToConnection_remove_StateChanged(py::wrapper::Windows::Media::PlayTo::PlayToConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToConnection_add_Transferred(py::wrapper::Windows::Media::PlayTo::PlayToConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToConnection, winrt::Windows::Media::PlayTo::PlayToConnectionTransferredEventArgs>>(arg);

            return py::convert(self->obj.Transferred(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToConnection_remove_Transferred(py::wrapper::Windows::Media::PlayTo::PlayToConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Transferred(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayToConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToConnection[] = {
        { "add_error", (PyCFunction)PlayToConnection_add_Error, METH_O, nullptr },
        { "remove_error", (PyCFunction)PlayToConnection_remove_Error, METH_O, nullptr },
        { "add_state_changed", (PyCFunction)PlayToConnection_add_StateChanged, METH_O, nullptr },
        { "remove_state_changed", (PyCFunction)PlayToConnection_remove_StateChanged, METH_O, nullptr },
        { "add_transferred", (PyCFunction)PlayToConnection_add_Transferred, METH_O, nullptr },
        { "remove_transferred", (PyCFunction)PlayToConnection_remove_Transferred, METH_O, nullptr },
        { "_from", (PyCFunction)_from_PlayToConnection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayToConnection[] = {
        { const_cast<char*>("state"), (getter)PlayToConnection_get_State, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayToConnection[] = 
    {
        { Py_tp_new, _new_PlayToConnection },
        { Py_tp_dealloc, _dealloc_PlayToConnection },
        { Py_tp_methods, _methods_PlayToConnection },
        { Py_tp_getset, _getset_PlayToConnection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToConnection =
    {
        "_winrt_Windows_Media_PlayTo.PlayToConnection",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToConnection
    };

    // ----- PlayToConnectionErrorEventArgs class --------------------
    constexpr const char* const _type_name_PlayToConnectionErrorEventArgs = "PlayToConnectionErrorEventArgs";

    static PyObject* _new_PlayToConnectionErrorEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayToConnectionErrorEventArgs);
        return nullptr;
    }

    static void _dealloc_PlayToConnectionErrorEventArgs(py::wrapper::Windows::Media::PlayTo::PlayToConnectionErrorEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToConnectionErrorEventArgs_get_Code(py::wrapper::Windows::Media::PlayTo::PlayToConnectionErrorEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Code());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToConnectionErrorEventArgs_get_Message(py::wrapper::Windows::Media::PlayTo::PlayToConnectionErrorEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayToConnectionErrorEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToConnectionErrorEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToConnectionErrorEventArgs[] = {
        { "_from", (PyCFunction)_from_PlayToConnectionErrorEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayToConnectionErrorEventArgs[] = {
        { const_cast<char*>("code"), (getter)PlayToConnectionErrorEventArgs_get_Code, nullptr, nullptr, nullptr },
        { const_cast<char*>("message"), (getter)PlayToConnectionErrorEventArgs_get_Message, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayToConnectionErrorEventArgs[] = 
    {
        { Py_tp_new, _new_PlayToConnectionErrorEventArgs },
        { Py_tp_dealloc, _dealloc_PlayToConnectionErrorEventArgs },
        { Py_tp_methods, _methods_PlayToConnectionErrorEventArgs },
        { Py_tp_getset, _getset_PlayToConnectionErrorEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToConnectionErrorEventArgs =
    {
        "_winrt_Windows_Media_PlayTo.PlayToConnectionErrorEventArgs",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToConnectionErrorEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToConnectionErrorEventArgs
    };

    // ----- PlayToConnectionStateChangedEventArgs class --------------------
    constexpr const char* const _type_name_PlayToConnectionStateChangedEventArgs = "PlayToConnectionStateChangedEventArgs";

    static PyObject* _new_PlayToConnectionStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayToConnectionStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_PlayToConnectionStateChangedEventArgs(py::wrapper::Windows::Media::PlayTo::PlayToConnectionStateChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToConnectionStateChangedEventArgs_get_CurrentState(py::wrapper::Windows::Media::PlayTo::PlayToConnectionStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToConnectionStateChangedEventArgs_get_PreviousState(py::wrapper::Windows::Media::PlayTo::PlayToConnectionStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayToConnectionStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToConnectionStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToConnectionStateChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_PlayToConnectionStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayToConnectionStateChangedEventArgs[] = {
        { const_cast<char*>("current_state"), (getter)PlayToConnectionStateChangedEventArgs_get_CurrentState, nullptr, nullptr, nullptr },
        { const_cast<char*>("previous_state"), (getter)PlayToConnectionStateChangedEventArgs_get_PreviousState, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayToConnectionStateChangedEventArgs[] = 
    {
        { Py_tp_new, _new_PlayToConnectionStateChangedEventArgs },
        { Py_tp_dealloc, _dealloc_PlayToConnectionStateChangedEventArgs },
        { Py_tp_methods, _methods_PlayToConnectionStateChangedEventArgs },
        { Py_tp_getset, _getset_PlayToConnectionStateChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToConnectionStateChangedEventArgs =
    {
        "_winrt_Windows_Media_PlayTo.PlayToConnectionStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToConnectionStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToConnectionStateChangedEventArgs
    };

    // ----- PlayToConnectionTransferredEventArgs class --------------------
    constexpr const char* const _type_name_PlayToConnectionTransferredEventArgs = "PlayToConnectionTransferredEventArgs";

    static PyObject* _new_PlayToConnectionTransferredEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayToConnectionTransferredEventArgs);
        return nullptr;
    }

    static void _dealloc_PlayToConnectionTransferredEventArgs(py::wrapper::Windows::Media::PlayTo::PlayToConnectionTransferredEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToConnectionTransferredEventArgs_get_CurrentSource(py::wrapper::Windows::Media::PlayTo::PlayToConnectionTransferredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToConnectionTransferredEventArgs_get_PreviousSource(py::wrapper::Windows::Media::PlayTo::PlayToConnectionTransferredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayToConnectionTransferredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToConnectionTransferredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToConnectionTransferredEventArgs[] = {
        { "_from", (PyCFunction)_from_PlayToConnectionTransferredEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayToConnectionTransferredEventArgs[] = {
        { const_cast<char*>("current_source"), (getter)PlayToConnectionTransferredEventArgs_get_CurrentSource, nullptr, nullptr, nullptr },
        { const_cast<char*>("previous_source"), (getter)PlayToConnectionTransferredEventArgs_get_PreviousSource, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayToConnectionTransferredEventArgs[] = 
    {
        { Py_tp_new, _new_PlayToConnectionTransferredEventArgs },
        { Py_tp_dealloc, _dealloc_PlayToConnectionTransferredEventArgs },
        { Py_tp_methods, _methods_PlayToConnectionTransferredEventArgs },
        { Py_tp_getset, _getset_PlayToConnectionTransferredEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToConnectionTransferredEventArgs =
    {
        "_winrt_Windows_Media_PlayTo.PlayToConnectionTransferredEventArgs",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToConnectionTransferredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToConnectionTransferredEventArgs
    };

    // ----- PlayToManager class --------------------
    constexpr const char* const _type_name_PlayToManager = "PlayToManager";

    static PyObject* _new_PlayToManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayToManager);
        return nullptr;
    }

    static void _dealloc_PlayToManager(py::wrapper::Windows::Media::PlayTo::PlayToManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToManager_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::PlayTo::PlayToManager::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToManager_ShowPlayToUI(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::PlayTo::PlayToManager::ShowPlayToUI();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToManager_get_DefaultSourceSelection(py::wrapper::Windows::Media::PlayTo::PlayToManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DefaultSourceSelection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayToManager_put_DefaultSourceSelection(py::wrapper::Windows::Media::PlayTo::PlayToManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DefaultSourceSelection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayToManager_add_SourceRequested(py::wrapper::Windows::Media::PlayTo::PlayToManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToManager, winrt::Windows::Media::PlayTo::PlayToSourceRequestedEventArgs>>(arg);

            return py::convert(self->obj.SourceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToManager_remove_SourceRequested(py::wrapper::Windows::Media::PlayTo::PlayToManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToManager_add_SourceSelected(py::wrapper::Windows::Media::PlayTo::PlayToManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToManager, winrt::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs>>(arg);

            return py::convert(self->obj.SourceSelected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToManager_remove_SourceSelected(py::wrapper::Windows::Media::PlayTo::PlayToManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceSelected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayToManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToManager[] = {
        { "get_for_current_view", (PyCFunction)PlayToManager_GetForCurrentView, METH_VARARGS | METH_STATIC, nullptr },
        { "show_play_to_u_i", (PyCFunction)PlayToManager_ShowPlayToUI, METH_VARARGS | METH_STATIC, nullptr },
        { "add_source_requested", (PyCFunction)PlayToManager_add_SourceRequested, METH_O, nullptr },
        { "remove_source_requested", (PyCFunction)PlayToManager_remove_SourceRequested, METH_O, nullptr },
        { "add_source_selected", (PyCFunction)PlayToManager_add_SourceSelected, METH_O, nullptr },
        { "remove_source_selected", (PyCFunction)PlayToManager_remove_SourceSelected, METH_O, nullptr },
        { "_from", (PyCFunction)_from_PlayToManager, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayToManager[] = {
        { const_cast<char*>("default_source_selection"), (getter)PlayToManager_get_DefaultSourceSelection, (setter)PlayToManager_put_DefaultSourceSelection, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayToManager[] = 
    {
        { Py_tp_new, _new_PlayToManager },
        { Py_tp_dealloc, _dealloc_PlayToManager },
        { Py_tp_methods, _methods_PlayToManager },
        { Py_tp_getset, _getset_PlayToManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToManager =
    {
        "_winrt_Windows_Media_PlayTo.PlayToManager",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToManager
    };

    // ----- PlayToReceiver class --------------------
    constexpr const char* const _type_name_PlayToReceiver = "PlayToReceiver";

    static PyObject* _new_PlayToReceiver(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::PlayTo::PlayToReceiver instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayToReceiver(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToReceiver_NotifyDurationChange(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.NotifyDurationChange(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifyEnded(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyEnded();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifyError(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyError();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifyLoadedMetadata(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyLoadedMetadata();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifyPaused(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyPaused();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifyPlaying(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyPlaying();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifyRateChange(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.NotifyRateChange(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifySeeked(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifySeeked();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifySeeking(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifySeeking();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifyStopped(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyStopped();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifyTimeUpdate(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.NotifyTimeUpdate(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifyVolumeChange(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.NotifyVolumeChange(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_StartAsync(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_StopAsync(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StopAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_get_SupportsVideo(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportsVideo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayToReceiver_put_SupportsVideo(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SupportsVideo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayToReceiver_get_SupportsImage(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportsImage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayToReceiver_put_SupportsImage(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SupportsImage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayToReceiver_get_SupportsAudio(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportsAudio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayToReceiver_put_SupportsAudio(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SupportsAudio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayToReceiver_get_FriendlyName(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayToReceiver_put_FriendlyName(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayToReceiver_get_Properties(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_add_CurrentTimeChangeRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToReceiver, winrt::Windows::Media::PlayTo::CurrentTimeChangeRequestedEventArgs>>(arg);

            return py::convert(self->obj.CurrentTimeChangeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_remove_CurrentTimeChangeRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CurrentTimeChangeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_add_MuteChangeRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToReceiver, winrt::Windows::Media::PlayTo::MuteChangeRequestedEventArgs>>(arg);

            return py::convert(self->obj.MuteChangeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_remove_MuteChangeRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MuteChangeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_add_PauseRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToReceiver, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.PauseRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_remove_PauseRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PauseRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_add_PlayRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToReceiver, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.PlayRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_remove_PlayRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlayRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_add_PlaybackRateChangeRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToReceiver, winrt::Windows::Media::PlayTo::PlaybackRateChangeRequestedEventArgs>>(arg);

            return py::convert(self->obj.PlaybackRateChangeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_remove_PlaybackRateChangeRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlaybackRateChangeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_add_SourceChangeRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToReceiver, winrt::Windows::Media::PlayTo::SourceChangeRequestedEventArgs>>(arg);

            return py::convert(self->obj.SourceChangeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_remove_SourceChangeRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceChangeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_add_StopRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToReceiver, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StopRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_remove_StopRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StopRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_add_TimeUpdateRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToReceiver, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.TimeUpdateRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_remove_TimeUpdateRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TimeUpdateRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_add_VolumeChangeRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToReceiver, winrt::Windows::Media::PlayTo::VolumeChangeRequestedEventArgs>>(arg);

            return py::convert(self->obj.VolumeChangeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_remove_VolumeChangeRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VolumeChangeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayToReceiver(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToReceiver>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToReceiver[] = {
        { "notify_duration_change", (PyCFunction)PlayToReceiver_NotifyDurationChange, METH_VARARGS, nullptr },
        { "notify_ended", (PyCFunction)PlayToReceiver_NotifyEnded, METH_VARARGS, nullptr },
        { "notify_error", (PyCFunction)PlayToReceiver_NotifyError, METH_VARARGS, nullptr },
        { "notify_loaded_metadata", (PyCFunction)PlayToReceiver_NotifyLoadedMetadata, METH_VARARGS, nullptr },
        { "notify_paused", (PyCFunction)PlayToReceiver_NotifyPaused, METH_VARARGS, nullptr },
        { "notify_playing", (PyCFunction)PlayToReceiver_NotifyPlaying, METH_VARARGS, nullptr },
        { "notify_rate_change", (PyCFunction)PlayToReceiver_NotifyRateChange, METH_VARARGS, nullptr },
        { "notify_seeked", (PyCFunction)PlayToReceiver_NotifySeeked, METH_VARARGS, nullptr },
        { "notify_seeking", (PyCFunction)PlayToReceiver_NotifySeeking, METH_VARARGS, nullptr },
        { "notify_stopped", (PyCFunction)PlayToReceiver_NotifyStopped, METH_VARARGS, nullptr },
        { "notify_time_update", (PyCFunction)PlayToReceiver_NotifyTimeUpdate, METH_VARARGS, nullptr },
        { "notify_volume_change", (PyCFunction)PlayToReceiver_NotifyVolumeChange, METH_VARARGS, nullptr },
        { "start_async", (PyCFunction)PlayToReceiver_StartAsync, METH_VARARGS, nullptr },
        { "stop_async", (PyCFunction)PlayToReceiver_StopAsync, METH_VARARGS, nullptr },
        { "add_current_time_change_requested", (PyCFunction)PlayToReceiver_add_CurrentTimeChangeRequested, METH_O, nullptr },
        { "remove_current_time_change_requested", (PyCFunction)PlayToReceiver_remove_CurrentTimeChangeRequested, METH_O, nullptr },
        { "add_mute_change_requested", (PyCFunction)PlayToReceiver_add_MuteChangeRequested, METH_O, nullptr },
        { "remove_mute_change_requested", (PyCFunction)PlayToReceiver_remove_MuteChangeRequested, METH_O, nullptr },
        { "add_pause_requested", (PyCFunction)PlayToReceiver_add_PauseRequested, METH_O, nullptr },
        { "remove_pause_requested", (PyCFunction)PlayToReceiver_remove_PauseRequested, METH_O, nullptr },
        { "add_play_requested", (PyCFunction)PlayToReceiver_add_PlayRequested, METH_O, nullptr },
        { "remove_play_requested", (PyCFunction)PlayToReceiver_remove_PlayRequested, METH_O, nullptr },
        { "add_playback_rate_change_requested", (PyCFunction)PlayToReceiver_add_PlaybackRateChangeRequested, METH_O, nullptr },
        { "remove_playback_rate_change_requested", (PyCFunction)PlayToReceiver_remove_PlaybackRateChangeRequested, METH_O, nullptr },
        { "add_source_change_requested", (PyCFunction)PlayToReceiver_add_SourceChangeRequested, METH_O, nullptr },
        { "remove_source_change_requested", (PyCFunction)PlayToReceiver_remove_SourceChangeRequested, METH_O, nullptr },
        { "add_stop_requested", (PyCFunction)PlayToReceiver_add_StopRequested, METH_O, nullptr },
        { "remove_stop_requested", (PyCFunction)PlayToReceiver_remove_StopRequested, METH_O, nullptr },
        { "add_time_update_requested", (PyCFunction)PlayToReceiver_add_TimeUpdateRequested, METH_O, nullptr },
        { "remove_time_update_requested", (PyCFunction)PlayToReceiver_remove_TimeUpdateRequested, METH_O, nullptr },
        { "add_volume_change_requested", (PyCFunction)PlayToReceiver_add_VolumeChangeRequested, METH_O, nullptr },
        { "remove_volume_change_requested", (PyCFunction)PlayToReceiver_remove_VolumeChangeRequested, METH_O, nullptr },
        { "_from", (PyCFunction)_from_PlayToReceiver, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayToReceiver[] = {
        { const_cast<char*>("supports_video"), (getter)PlayToReceiver_get_SupportsVideo, (setter)PlayToReceiver_put_SupportsVideo, nullptr, nullptr },
        { const_cast<char*>("supports_image"), (getter)PlayToReceiver_get_SupportsImage, (setter)PlayToReceiver_put_SupportsImage, nullptr, nullptr },
        { const_cast<char*>("supports_audio"), (getter)PlayToReceiver_get_SupportsAudio, (setter)PlayToReceiver_put_SupportsAudio, nullptr, nullptr },
        { const_cast<char*>("friendly_name"), (getter)PlayToReceiver_get_FriendlyName, (setter)PlayToReceiver_put_FriendlyName, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)PlayToReceiver_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayToReceiver[] = 
    {
        { Py_tp_new, _new_PlayToReceiver },
        { Py_tp_dealloc, _dealloc_PlayToReceiver },
        { Py_tp_methods, _methods_PlayToReceiver },
        { Py_tp_getset, _getset_PlayToReceiver },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToReceiver =
    {
        "_winrt_Windows_Media_PlayTo.PlayToReceiver",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToReceiver),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToReceiver
    };

    // ----- PlayToSource class --------------------
    constexpr const char* const _type_name_PlayToSource = "PlayToSource";

    static PyObject* _new_PlayToSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayToSource);
        return nullptr;
    }

    static void _dealloc_PlayToSource(py::wrapper::Windows::Media::PlayTo::PlayToSource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToSource_PlayNext(py::wrapper::Windows::Media::PlayTo::PlayToSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.PlayNext();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToSource_get_Next(py::wrapper::Windows::Media::PlayTo::PlayToSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Next());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayToSource_put_Next(py::wrapper::Windows::Media::PlayTo::PlayToSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::PlayTo::PlayToSource>(arg);

            self->obj.Next(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayToSource_get_Connection(py::wrapper::Windows::Media::PlayTo::PlayToSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Connection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToSource_get_PreferredSourceUri(py::wrapper::Windows::Media::PlayTo::PlayToSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreferredSourceUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayToSource_put_PreferredSourceUri(py::wrapper::Windows::Media::PlayTo::PlayToSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.PreferredSourceUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_PlayToSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToSource[] = {
        { "play_next", (PyCFunction)PlayToSource_PlayNext, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlayToSource, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayToSource[] = {
        { const_cast<char*>("next"), (getter)PlayToSource_get_Next, (setter)PlayToSource_put_Next, nullptr, nullptr },
        { const_cast<char*>("connection"), (getter)PlayToSource_get_Connection, nullptr, nullptr, nullptr },
        { const_cast<char*>("preferred_source_uri"), (getter)PlayToSource_get_PreferredSourceUri, (setter)PlayToSource_put_PreferredSourceUri, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayToSource[] = 
    {
        { Py_tp_new, _new_PlayToSource },
        { Py_tp_dealloc, _dealloc_PlayToSource },
        { Py_tp_methods, _methods_PlayToSource },
        { Py_tp_getset, _getset_PlayToSource },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToSource =
    {
        "_winrt_Windows_Media_PlayTo.PlayToSource",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToSource
    };

    // ----- PlayToSourceDeferral class --------------------
    constexpr const char* const _type_name_PlayToSourceDeferral = "PlayToSourceDeferral";

    static PyObject* _new_PlayToSourceDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayToSourceDeferral);
        return nullptr;
    }

    static void _dealloc_PlayToSourceDeferral(py::wrapper::Windows::Media::PlayTo::PlayToSourceDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToSourceDeferral_Complete(py::wrapper::Windows::Media::PlayTo::PlayToSourceDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_PlayToSourceDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToSourceDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToSourceDeferral[] = {
        { "complete", (PyCFunction)PlayToSourceDeferral_Complete, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlayToSourceDeferral, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayToSourceDeferral[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayToSourceDeferral[] = 
    {
        { Py_tp_new, _new_PlayToSourceDeferral },
        { Py_tp_dealloc, _dealloc_PlayToSourceDeferral },
        { Py_tp_methods, _methods_PlayToSourceDeferral },
        { Py_tp_getset, _getset_PlayToSourceDeferral },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToSourceDeferral =
    {
        "_winrt_Windows_Media_PlayTo.PlayToSourceDeferral",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToSourceDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToSourceDeferral
    };

    // ----- PlayToSourceRequest class --------------------
    constexpr const char* const _type_name_PlayToSourceRequest = "PlayToSourceRequest";

    static PyObject* _new_PlayToSourceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayToSourceRequest);
        return nullptr;
    }

    static void _dealloc_PlayToSourceRequest(py::wrapper::Windows::Media::PlayTo::PlayToSourceRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToSourceRequest_DisplayErrorString(py::wrapper::Windows::Media::PlayTo::PlayToSourceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.DisplayErrorString(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToSourceRequest_GetDeferral(py::wrapper::Windows::Media::PlayTo::PlayToSourceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToSourceRequest_SetSource(py::wrapper::Windows::Media::PlayTo::PlayToSourceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::PlayTo::PlayToSource>(args, 0);

                self->obj.SetSource(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToSourceRequest_get_Deadline(py::wrapper::Windows::Media::PlayTo::PlayToSourceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayToSourceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToSourceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToSourceRequest[] = {
        { "display_error_string", (PyCFunction)PlayToSourceRequest_DisplayErrorString, METH_VARARGS, nullptr },
        { "get_deferral", (PyCFunction)PlayToSourceRequest_GetDeferral, METH_VARARGS, nullptr },
        { "set_source", (PyCFunction)PlayToSourceRequest_SetSource, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlayToSourceRequest, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayToSourceRequest[] = {
        { const_cast<char*>("deadline"), (getter)PlayToSourceRequest_get_Deadline, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayToSourceRequest[] = 
    {
        { Py_tp_new, _new_PlayToSourceRequest },
        { Py_tp_dealloc, _dealloc_PlayToSourceRequest },
        { Py_tp_methods, _methods_PlayToSourceRequest },
        { Py_tp_getset, _getset_PlayToSourceRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToSourceRequest =
    {
        "_winrt_Windows_Media_PlayTo.PlayToSourceRequest",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToSourceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToSourceRequest
    };

    // ----- PlayToSourceRequestedEventArgs class --------------------
    constexpr const char* const _type_name_PlayToSourceRequestedEventArgs = "PlayToSourceRequestedEventArgs";

    static PyObject* _new_PlayToSourceRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayToSourceRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_PlayToSourceRequestedEventArgs(py::wrapper::Windows::Media::PlayTo::PlayToSourceRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToSourceRequestedEventArgs_get_SourceRequest(py::wrapper::Windows::Media::PlayTo::PlayToSourceRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceRequest());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayToSourceRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToSourceRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToSourceRequestedEventArgs[] = {
        { "_from", (PyCFunction)_from_PlayToSourceRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayToSourceRequestedEventArgs[] = {
        { const_cast<char*>("source_request"), (getter)PlayToSourceRequestedEventArgs_get_SourceRequest, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayToSourceRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_PlayToSourceRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_PlayToSourceRequestedEventArgs },
        { Py_tp_methods, _methods_PlayToSourceRequestedEventArgs },
        { Py_tp_getset, _getset_PlayToSourceRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToSourceRequestedEventArgs =
    {
        "_winrt_Windows_Media_PlayTo.PlayToSourceRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToSourceRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToSourceRequestedEventArgs
    };

    // ----- PlayToSourceSelectedEventArgs class --------------------
    constexpr const char* const _type_name_PlayToSourceSelectedEventArgs = "PlayToSourceSelectedEventArgs";

    static PyObject* _new_PlayToSourceSelectedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayToSourceSelectedEventArgs);
        return nullptr;
    }

    static void _dealloc_PlayToSourceSelectedEventArgs(py::wrapper::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToSourceSelectedEventArgs_get_FriendlyName(py::wrapper::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToSourceSelectedEventArgs_get_Icon(py::wrapper::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToSourceSelectedEventArgs_get_SupportsAudio(py::wrapper::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportsAudio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToSourceSelectedEventArgs_get_SupportsImage(py::wrapper::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportsImage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToSourceSelectedEventArgs_get_SupportsVideo(py::wrapper::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportsVideo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayToSourceSelectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToSourceSelectedEventArgs[] = {
        { "_from", (PyCFunction)_from_PlayToSourceSelectedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayToSourceSelectedEventArgs[] = {
        { const_cast<char*>("friendly_name"), (getter)PlayToSourceSelectedEventArgs_get_FriendlyName, nullptr, nullptr, nullptr },
        { const_cast<char*>("icon"), (getter)PlayToSourceSelectedEventArgs_get_Icon, nullptr, nullptr, nullptr },
        { const_cast<char*>("supports_audio"), (getter)PlayToSourceSelectedEventArgs_get_SupportsAudio, nullptr, nullptr, nullptr },
        { const_cast<char*>("supports_image"), (getter)PlayToSourceSelectedEventArgs_get_SupportsImage, nullptr, nullptr, nullptr },
        { const_cast<char*>("supports_video"), (getter)PlayToSourceSelectedEventArgs_get_SupportsVideo, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayToSourceSelectedEventArgs[] = 
    {
        { Py_tp_new, _new_PlayToSourceSelectedEventArgs },
        { Py_tp_dealloc, _dealloc_PlayToSourceSelectedEventArgs },
        { Py_tp_methods, _methods_PlayToSourceSelectedEventArgs },
        { Py_tp_getset, _getset_PlayToSourceSelectedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToSourceSelectedEventArgs =
    {
        "_winrt_Windows_Media_PlayTo.PlayToSourceSelectedEventArgs",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToSourceSelectedEventArgs
    };

    // ----- PlaybackRateChangeRequestedEventArgs class --------------------
    constexpr const char* const _type_name_PlaybackRateChangeRequestedEventArgs = "PlaybackRateChangeRequestedEventArgs";

    static PyObject* _new_PlaybackRateChangeRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlaybackRateChangeRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_PlaybackRateChangeRequestedEventArgs(py::wrapper::Windows::Media::PlayTo::PlaybackRateChangeRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlaybackRateChangeRequestedEventArgs_get_Rate(py::wrapper::Windows::Media::PlayTo::PlaybackRateChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Rate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlaybackRateChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlaybackRateChangeRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlaybackRateChangeRequestedEventArgs[] = {
        { "_from", (PyCFunction)_from_PlaybackRateChangeRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlaybackRateChangeRequestedEventArgs[] = {
        { const_cast<char*>("rate"), (getter)PlaybackRateChangeRequestedEventArgs_get_Rate, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlaybackRateChangeRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_PlaybackRateChangeRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_PlaybackRateChangeRequestedEventArgs },
        { Py_tp_methods, _methods_PlaybackRateChangeRequestedEventArgs },
        { Py_tp_getset, _getset_PlaybackRateChangeRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlaybackRateChangeRequestedEventArgs =
    {
        "_winrt_Windows_Media_PlayTo.PlaybackRateChangeRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlaybackRateChangeRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlaybackRateChangeRequestedEventArgs
    };

    // ----- SourceChangeRequestedEventArgs class --------------------
    constexpr const char* const _type_name_SourceChangeRequestedEventArgs = "SourceChangeRequestedEventArgs";

    static PyObject* _new_SourceChangeRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SourceChangeRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_SourceChangeRequestedEventArgs(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SourceChangeRequestedEventArgs_get_Album(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Album());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SourceChangeRequestedEventArgs_get_Author(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Author());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SourceChangeRequestedEventArgs_get_Date(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Date());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SourceChangeRequestedEventArgs_get_Description(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SourceChangeRequestedEventArgs_get_Genre(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Genre());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SourceChangeRequestedEventArgs_get_Properties(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SourceChangeRequestedEventArgs_get_Rating(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Rating());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SourceChangeRequestedEventArgs_get_Stream(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Stream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SourceChangeRequestedEventArgs_get_Thumbnail(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SourceChangeRequestedEventArgs_get_Title(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SourceChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::SourceChangeRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SourceChangeRequestedEventArgs[] = {
        { "_from", (PyCFunction)_from_SourceChangeRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SourceChangeRequestedEventArgs[] = {
        { const_cast<char*>("album"), (getter)SourceChangeRequestedEventArgs_get_Album, nullptr, nullptr, nullptr },
        { const_cast<char*>("author"), (getter)SourceChangeRequestedEventArgs_get_Author, nullptr, nullptr, nullptr },
        { const_cast<char*>("date"), (getter)SourceChangeRequestedEventArgs_get_Date, nullptr, nullptr, nullptr },
        { const_cast<char*>("description"), (getter)SourceChangeRequestedEventArgs_get_Description, nullptr, nullptr, nullptr },
        { const_cast<char*>("genre"), (getter)SourceChangeRequestedEventArgs_get_Genre, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)SourceChangeRequestedEventArgs_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("rating"), (getter)SourceChangeRequestedEventArgs_get_Rating, nullptr, nullptr, nullptr },
        { const_cast<char*>("stream"), (getter)SourceChangeRequestedEventArgs_get_Stream, nullptr, nullptr, nullptr },
        { const_cast<char*>("thumbnail"), (getter)SourceChangeRequestedEventArgs_get_Thumbnail, nullptr, nullptr, nullptr },
        { const_cast<char*>("title"), (getter)SourceChangeRequestedEventArgs_get_Title, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SourceChangeRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_SourceChangeRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_SourceChangeRequestedEventArgs },
        { Py_tp_methods, _methods_SourceChangeRequestedEventArgs },
        { Py_tp_getset, _getset_SourceChangeRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SourceChangeRequestedEventArgs =
    {
        "_winrt_Windows_Media_PlayTo.SourceChangeRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SourceChangeRequestedEventArgs
    };

    // ----- VolumeChangeRequestedEventArgs class --------------------
    constexpr const char* const _type_name_VolumeChangeRequestedEventArgs = "VolumeChangeRequestedEventArgs";

    static PyObject* _new_VolumeChangeRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VolumeChangeRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_VolumeChangeRequestedEventArgs(py::wrapper::Windows::Media::PlayTo::VolumeChangeRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VolumeChangeRequestedEventArgs_get_Volume(py::wrapper::Windows::Media::PlayTo::VolumeChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Volume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VolumeChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::VolumeChangeRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VolumeChangeRequestedEventArgs[] = {
        { "_from", (PyCFunction)_from_VolumeChangeRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VolumeChangeRequestedEventArgs[] = {
        { const_cast<char*>("volume"), (getter)VolumeChangeRequestedEventArgs_get_Volume, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VolumeChangeRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_VolumeChangeRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_VolumeChangeRequestedEventArgs },
        { Py_tp_methods, _methods_VolumeChangeRequestedEventArgs },
        { Py_tp_getset, _getset_VolumeChangeRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VolumeChangeRequestedEventArgs =
    {
        "_winrt_Windows_Media_PlayTo.VolumeChangeRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::PlayTo::VolumeChangeRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VolumeChangeRequestedEventArgs
    };

    // ----- Windows.Media.PlayTo Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Media::PlayTo::CurrentTimeChangeRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_CurrentTimeChangeRequestedEventArgs, &_type_spec_CurrentTimeChangeRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::MuteChangeRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_MuteChangeRequestedEventArgs, &_type_spec_MuteChangeRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToConnection>::python_type = py::register_python_type(module, _type_name_PlayToConnection, &_type_spec_PlayToConnection, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToConnectionErrorEventArgs>::python_type = py::register_python_type(module, _type_name_PlayToConnectionErrorEventArgs, &_type_spec_PlayToConnectionErrorEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToConnectionStateChangedEventArgs>::python_type = py::register_python_type(module, _type_name_PlayToConnectionStateChangedEventArgs, &_type_spec_PlayToConnectionStateChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToConnectionTransferredEventArgs>::python_type = py::register_python_type(module, _type_name_PlayToConnectionTransferredEventArgs, &_type_spec_PlayToConnectionTransferredEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToManager>::python_type = py::register_python_type(module, _type_name_PlayToManager, &_type_spec_PlayToManager, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToReceiver>::python_type = py::register_python_type(module, _type_name_PlayToReceiver, &_type_spec_PlayToReceiver, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToSource>::python_type = py::register_python_type(module, _type_name_PlayToSource, &_type_spec_PlayToSource, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToSourceDeferral>::python_type = py::register_python_type(module, _type_name_PlayToSourceDeferral, &_type_spec_PlayToSourceDeferral, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToSourceRequest>::python_type = py::register_python_type(module, _type_name_PlayToSourceRequest, &_type_spec_PlayToSourceRequest, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToSourceRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_PlayToSourceRequestedEventArgs, &_type_spec_PlayToSourceRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs>::python_type = py::register_python_type(module, _type_name_PlayToSourceSelectedEventArgs, &_type_spec_PlayToSourceSelectedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlaybackRateChangeRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_PlaybackRateChangeRequestedEventArgs, &_type_spec_PlaybackRateChangeRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::SourceChangeRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_SourceChangeRequestedEventArgs, &_type_spec_SourceChangeRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::VolumeChangeRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_VolumeChangeRequestedEventArgs, &_type_spec_VolumeChangeRequestedEventArgs, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Media.PlayTo");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Media_PlayTo",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Media::PlayTo

PyMODINIT_FUNC
PyInit__winrt_Windows_Media_PlayTo (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Media::PlayTo::module_def);
}
