// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.ApplicationModel.h"

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::AppDisplayInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::AppInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::AppInstallerInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::AppInstance>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DesignMode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::EnteredBackgroundEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::LeavingBackgroundEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::LimitedAccessFeatureRequestResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::LimitedAccessFeatures>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Package>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalog>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageContentGroup>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageContentGroupStagingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageId>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageInstallingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageStagingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageStatus>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageStatusChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageUninstallingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageUpdateAvailabilityResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageUpdatingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::StartupTask>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::SuspendingDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::SuspendingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::SuspendingOperation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::IEnteredBackgroundEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ILeavingBackgroundEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ISuspendingDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ISuspendingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ISuspendingOperation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageInstallProgress>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageVersion>::python_type;

PyObject* py::converter<winrt::Windows::ApplicationModel::PackageInstallProgress>::convert(winrt::Windows::ApplicationModel::PackageInstallProgress instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::ApplicationModel::PackageInstallProgress>());
}
winrt::Windows::ApplicationModel::PackageInstallProgress py::converter<winrt::Windows::ApplicationModel::PackageInstallProgress>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::ApplicationModel::PackageInstallProgress>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::ApplicationModel::PackageInstallProgress>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::ApplicationModel::PackageInstallProgress return_value{};

    PyObject* py_PercentComplete = PyDict_GetItemString(obj, "percent_complete");
    if (!py_PercentComplete) { throw winrt::hresult_invalid_argument(); }
    return_value.PercentComplete = converter<uint32_t>::convert_to(py_PercentComplete);

    return return_value;
}

PyObject* py::converter<winrt::Windows::ApplicationModel::PackageVersion>::convert(winrt::Windows::ApplicationModel::PackageVersion instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::ApplicationModel::PackageVersion>());
}
winrt::Windows::ApplicationModel::PackageVersion py::converter<winrt::Windows::ApplicationModel::PackageVersion>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::ApplicationModel::PackageVersion>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::ApplicationModel::PackageVersion>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::ApplicationModel::PackageVersion return_value{};

    PyObject* py_Major = PyDict_GetItemString(obj, "major");
    if (!py_Major) { throw winrt::hresult_invalid_argument(); }
    return_value.Major = converter<uint16_t>::convert_to(py_Major);

    PyObject* py_Minor = PyDict_GetItemString(obj, "minor");
    if (!py_Minor) { throw winrt::hresult_invalid_argument(); }
    return_value.Minor = converter<uint16_t>::convert_to(py_Minor);

    PyObject* py_Build = PyDict_GetItemString(obj, "build");
    if (!py_Build) { throw winrt::hresult_invalid_argument(); }
    return_value.Build = converter<uint16_t>::convert_to(py_Build);

    PyObject* py_Revision = PyDict_GetItemString(obj, "revision");
    if (!py_Revision) { throw winrt::hresult_invalid_argument(); }
    return_value.Revision = converter<uint16_t>::convert_to(py_Revision);

    return return_value;
}

namespace py::cpp::Windows::ApplicationModel
{
    // ----- AppDisplayInfo class --------------------
    constexpr const char* const _type_name_AppDisplayInfo = "AppDisplayInfo";

    static PyObject* _new_AppDisplayInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppDisplayInfo);
        return nullptr;
    }

    static void _dealloc_AppDisplayInfo(py::wrapper::Windows::ApplicationModel::AppDisplayInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppDisplayInfo_GetLogo(py::wrapper::Windows::ApplicationModel::AppDisplayInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                return py::convert(self->obj.GetLogo(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDisplayInfo_get_Description(py::wrapper::Windows::ApplicationModel::AppDisplayInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDisplayInfo_get_DisplayName(py::wrapper::Windows::ApplicationModel::AppDisplayInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppDisplayInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::AppDisplayInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppDisplayInfo[] = {
        { "get_logo", (PyCFunction)AppDisplayInfo_GetLogo, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AppDisplayInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppDisplayInfo[] = {
        { const_cast<char*>("description"), (getter)AppDisplayInfo_get_Description, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)AppDisplayInfo_get_DisplayName, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppDisplayInfo[] = 
    {
        { Py_tp_new, _new_AppDisplayInfo },
        { Py_tp_dealloc, _dealloc_AppDisplayInfo },
        { Py_tp_methods, _methods_AppDisplayInfo },
        { Py_tp_getset, _getset_AppDisplayInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppDisplayInfo =
    {
        "_winrt_Windows_ApplicationModel.AppDisplayInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::AppDisplayInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppDisplayInfo
    };

    // ----- AppInfo class --------------------
    constexpr const char* const _type_name_AppInfo = "AppInfo";

    static PyObject* _new_AppInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppInfo);
        return nullptr;
    }

    static void _dealloc_AppInfo(py::wrapper::Windows::ApplicationModel::AppInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppInfo_GetFromAppUserModelId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::AppInfo::GetFromAppUserModelId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInfo_GetFromAppUserModelIdForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::AppInfo::GetFromAppUserModelIdForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_AppUserModelId(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppUserModelId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_DisplayInfo(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_Id(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_PackageFamilyName(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_Package(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_ExecutionContext(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExecutionContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_SupportedFileExtensions(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedFileExtensions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_Current(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::AppInfo::Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::AppInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppInfo[] = {
        { "get_from_app_user_model_id", (PyCFunction)AppInfo_GetFromAppUserModelId, METH_VARARGS | METH_STATIC, nullptr },
        { "get_from_app_user_model_id_for_user", (PyCFunction)AppInfo_GetFromAppUserModelIdForUser, METH_VARARGS | METH_STATIC, nullptr },
        { "get_current", (PyCFunction)AppInfo_get_Current, METH_NOARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_AppInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppInfo[] = {
        { const_cast<char*>("app_user_model_id"), (getter)AppInfo_get_AppUserModelId, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_info"), (getter)AppInfo_get_DisplayInfo, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)AppInfo_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("package_family_name"), (getter)AppInfo_get_PackageFamilyName, nullptr, nullptr, nullptr },
        { const_cast<char*>("package"), (getter)AppInfo_get_Package, nullptr, nullptr, nullptr },
        { const_cast<char*>("execution_context"), (getter)AppInfo_get_ExecutionContext, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_file_extensions"), (getter)AppInfo_get_SupportedFileExtensions, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppInfo[] = 
    {
        { Py_tp_new, _new_AppInfo },
        { Py_tp_dealloc, _dealloc_AppInfo },
        { Py_tp_methods, _methods_AppInfo },
        { Py_tp_getset, _getset_AppInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppInfo =
    {
        "_winrt_Windows_ApplicationModel.AppInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::AppInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppInfo
    };

    // ----- AppInstallerInfo class --------------------
    constexpr const char* const _type_name_AppInstallerInfo = "AppInstallerInfo";

    static PyObject* _new_AppInstallerInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppInstallerInfo);
        return nullptr;
    }

    static void _dealloc_AppInstallerInfo(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppInstallerInfo_get_Uri(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_AutomaticBackgroundTask(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutomaticBackgroundTask());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_DependencyPackageUris(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DependencyPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_ForceUpdateFromAnyVersion(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForceUpdateFromAnyVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_HoursBetweenUpdateChecks(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HoursBetweenUpdateChecks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_IsAutoRepairEnabled(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAutoRepairEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_LastChecked(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastChecked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_OnLaunch(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OnLaunch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_OptionalPackageUris(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OptionalPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_PausedUntil(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PausedUntil());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_PolicySource(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PolicySource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_RepairUris(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RepairUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_ShowPrompt(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShowPrompt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_UpdateBlocksActivation(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateBlocksActivation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_UpdateUris(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_Version(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppInstallerInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::AppInstallerInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppInstallerInfo[] = {
        { "_from", (PyCFunction)_from_AppInstallerInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppInstallerInfo[] = {
        { const_cast<char*>("uri"), (getter)AppInstallerInfo_get_Uri, nullptr, nullptr, nullptr },
        { const_cast<char*>("automatic_background_task"), (getter)AppInstallerInfo_get_AutomaticBackgroundTask, nullptr, nullptr, nullptr },
        { const_cast<char*>("dependency_package_uris"), (getter)AppInstallerInfo_get_DependencyPackageUris, nullptr, nullptr, nullptr },
        { const_cast<char*>("force_update_from_any_version"), (getter)AppInstallerInfo_get_ForceUpdateFromAnyVersion, nullptr, nullptr, nullptr },
        { const_cast<char*>("hours_between_update_checks"), (getter)AppInstallerInfo_get_HoursBetweenUpdateChecks, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_auto_repair_enabled"), (getter)AppInstallerInfo_get_IsAutoRepairEnabled, nullptr, nullptr, nullptr },
        { const_cast<char*>("last_checked"), (getter)AppInstallerInfo_get_LastChecked, nullptr, nullptr, nullptr },
        { const_cast<char*>("on_launch"), (getter)AppInstallerInfo_get_OnLaunch, nullptr, nullptr, nullptr },
        { const_cast<char*>("optional_package_uris"), (getter)AppInstallerInfo_get_OptionalPackageUris, nullptr, nullptr, nullptr },
        { const_cast<char*>("paused_until"), (getter)AppInstallerInfo_get_PausedUntil, nullptr, nullptr, nullptr },
        { const_cast<char*>("policy_source"), (getter)AppInstallerInfo_get_PolicySource, nullptr, nullptr, nullptr },
        { const_cast<char*>("repair_uris"), (getter)AppInstallerInfo_get_RepairUris, nullptr, nullptr, nullptr },
        { const_cast<char*>("show_prompt"), (getter)AppInstallerInfo_get_ShowPrompt, nullptr, nullptr, nullptr },
        { const_cast<char*>("update_blocks_activation"), (getter)AppInstallerInfo_get_UpdateBlocksActivation, nullptr, nullptr, nullptr },
        { const_cast<char*>("update_uris"), (getter)AppInstallerInfo_get_UpdateUris, nullptr, nullptr, nullptr },
        { const_cast<char*>("version"), (getter)AppInstallerInfo_get_Version, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppInstallerInfo[] = 
    {
        { Py_tp_new, _new_AppInstallerInfo },
        { Py_tp_dealloc, _dealloc_AppInstallerInfo },
        { Py_tp_methods, _methods_AppInstallerInfo },
        { Py_tp_getset, _getset_AppInstallerInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppInstallerInfo =
    {
        "_winrt_Windows_ApplicationModel.AppInstallerInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::AppInstallerInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppInstallerInfo
    };

    // ----- AppInstance class --------------------
    constexpr const char* const _type_name_AppInstance = "AppInstance";

    static PyObject* _new_AppInstance(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppInstance);
        return nullptr;
    }

    static void _dealloc_AppInstance(py::wrapper::Windows::ApplicationModel::AppInstance* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppInstance_FindOrRegisterInstanceForKey(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::AppInstance::FindOrRegisterInstanceForKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstance_GetActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::AppInstance::GetActivatedEventArgs());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstance_GetInstances(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::AppInstance::GetInstances());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstance_RedirectActivationTo(py::wrapper::Windows::ApplicationModel::AppInstance* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RedirectActivationTo();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstance_Unregister(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::AppInstance::Unregister();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstance_get_IsCurrentInstance(py::wrapper::Windows::ApplicationModel::AppInstance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCurrentInstance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstance_get_Key(py::wrapper::Windows::ApplicationModel::AppInstance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Key());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstance_get_RecommendedInstance(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::AppInstance::RecommendedInstance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppInstance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::AppInstance>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppInstance[] = {
        { "find_or_register_instance_for_key", (PyCFunction)AppInstance_FindOrRegisterInstanceForKey, METH_VARARGS | METH_STATIC, nullptr },
        { "get_activated_event_args", (PyCFunction)AppInstance_GetActivatedEventArgs, METH_VARARGS | METH_STATIC, nullptr },
        { "get_instances", (PyCFunction)AppInstance_GetInstances, METH_VARARGS | METH_STATIC, nullptr },
        { "redirect_activation_to", (PyCFunction)AppInstance_RedirectActivationTo, METH_VARARGS, nullptr },
        { "unregister", (PyCFunction)AppInstance_Unregister, METH_VARARGS | METH_STATIC, nullptr },
        { "get_recommended_instance", (PyCFunction)AppInstance_get_RecommendedInstance, METH_NOARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_AppInstance, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppInstance[] = {
        { const_cast<char*>("is_current_instance"), (getter)AppInstance_get_IsCurrentInstance, nullptr, nullptr, nullptr },
        { const_cast<char*>("key"), (getter)AppInstance_get_Key, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppInstance[] = 
    {
        { Py_tp_new, _new_AppInstance },
        { Py_tp_dealloc, _dealloc_AppInstance },
        { Py_tp_methods, _methods_AppInstance },
        { Py_tp_getset, _getset_AppInstance },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppInstance =
    {
        "_winrt_Windows_ApplicationModel.AppInstance",
        sizeof(py::wrapper::Windows::ApplicationModel::AppInstance),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppInstance
    };

    // ----- DesignMode class --------------------
    constexpr const char* const _type_name_DesignMode = "DesignMode";

    static PyObject* _new_DesignMode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DesignMode);
        return nullptr;
    }

    static PyObject* DesignMode_get_DesignModeEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::DesignMode::DesignModeEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DesignMode_get_DesignMode2Enabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::DesignMode::DesignMode2Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DesignMode[] = {
        { "get_design_mode_enabled", (PyCFunction)DesignMode_get_DesignModeEnabled, METH_NOARGS | METH_STATIC, nullptr },
        { "get_design_mode2_enabled", (PyCFunction)DesignMode_get_DesignMode2Enabled, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DesignMode[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_DesignMode[] = 
    {
        { Py_tp_new, _new_DesignMode },
        { Py_tp_methods, _methods_DesignMode },
        { Py_tp_getset, _getset_DesignMode },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DesignMode =
    {
        "_winrt_Windows_ApplicationModel.DesignMode",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DesignMode
    };

    // ----- EnteredBackgroundEventArgs class --------------------
    constexpr const char* const _type_name_EnteredBackgroundEventArgs = "EnteredBackgroundEventArgs";

    static PyObject* _new_EnteredBackgroundEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EnteredBackgroundEventArgs);
        return nullptr;
    }

    static void _dealloc_EnteredBackgroundEventArgs(py::wrapper::Windows::ApplicationModel::EnteredBackgroundEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EnteredBackgroundEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::EnteredBackgroundEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_EnteredBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::EnteredBackgroundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EnteredBackgroundEventArgs[] = {
        { "get_deferral", (PyCFunction)EnteredBackgroundEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_EnteredBackgroundEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EnteredBackgroundEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_EnteredBackgroundEventArgs[] = 
    {
        { Py_tp_new, _new_EnteredBackgroundEventArgs },
        { Py_tp_dealloc, _dealloc_EnteredBackgroundEventArgs },
        { Py_tp_methods, _methods_EnteredBackgroundEventArgs },
        { Py_tp_getset, _getset_EnteredBackgroundEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EnteredBackgroundEventArgs =
    {
        "_winrt_Windows_ApplicationModel.EnteredBackgroundEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::EnteredBackgroundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EnteredBackgroundEventArgs
    };

    // ----- LeavingBackgroundEventArgs class --------------------
    constexpr const char* const _type_name_LeavingBackgroundEventArgs = "LeavingBackgroundEventArgs";

    static PyObject* _new_LeavingBackgroundEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LeavingBackgroundEventArgs);
        return nullptr;
    }

    static void _dealloc_LeavingBackgroundEventArgs(py::wrapper::Windows::ApplicationModel::LeavingBackgroundEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LeavingBackgroundEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::LeavingBackgroundEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_LeavingBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::LeavingBackgroundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LeavingBackgroundEventArgs[] = {
        { "get_deferral", (PyCFunction)LeavingBackgroundEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_LeavingBackgroundEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LeavingBackgroundEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_LeavingBackgroundEventArgs[] = 
    {
        { Py_tp_new, _new_LeavingBackgroundEventArgs },
        { Py_tp_dealloc, _dealloc_LeavingBackgroundEventArgs },
        { Py_tp_methods, _methods_LeavingBackgroundEventArgs },
        { Py_tp_getset, _getset_LeavingBackgroundEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LeavingBackgroundEventArgs =
    {
        "_winrt_Windows_ApplicationModel.LeavingBackgroundEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::LeavingBackgroundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LeavingBackgroundEventArgs
    };

    // ----- LimitedAccessFeatureRequestResult class --------------------
    constexpr const char* const _type_name_LimitedAccessFeatureRequestResult = "LimitedAccessFeatureRequestResult";

    static PyObject* _new_LimitedAccessFeatureRequestResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LimitedAccessFeatureRequestResult);
        return nullptr;
    }

    static void _dealloc_LimitedAccessFeatureRequestResult(py::wrapper::Windows::ApplicationModel::LimitedAccessFeatureRequestResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LimitedAccessFeatureRequestResult_get_EstimatedRemovalDate(py::wrapper::Windows::ApplicationModel::LimitedAccessFeatureRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EstimatedRemovalDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LimitedAccessFeatureRequestResult_get_FeatureId(py::wrapper::Windows::ApplicationModel::LimitedAccessFeatureRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FeatureId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LimitedAccessFeatureRequestResult_get_Status(py::wrapper::Windows::ApplicationModel::LimitedAccessFeatureRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LimitedAccessFeatureRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::LimitedAccessFeatureRequestResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LimitedAccessFeatureRequestResult[] = {
        { "_from", (PyCFunction)_from_LimitedAccessFeatureRequestResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LimitedAccessFeatureRequestResult[] = {
        { const_cast<char*>("estimated_removal_date"), (getter)LimitedAccessFeatureRequestResult_get_EstimatedRemovalDate, nullptr, nullptr, nullptr },
        { const_cast<char*>("feature_id"), (getter)LimitedAccessFeatureRequestResult_get_FeatureId, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)LimitedAccessFeatureRequestResult_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LimitedAccessFeatureRequestResult[] = 
    {
        { Py_tp_new, _new_LimitedAccessFeatureRequestResult },
        { Py_tp_dealloc, _dealloc_LimitedAccessFeatureRequestResult },
        { Py_tp_methods, _methods_LimitedAccessFeatureRequestResult },
        { Py_tp_getset, _getset_LimitedAccessFeatureRequestResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LimitedAccessFeatureRequestResult =
    {
        "_winrt_Windows_ApplicationModel.LimitedAccessFeatureRequestResult",
        sizeof(py::wrapper::Windows::ApplicationModel::LimitedAccessFeatureRequestResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LimitedAccessFeatureRequestResult
    };

    // ----- LimitedAccessFeatures class --------------------
    constexpr const char* const _type_name_LimitedAccessFeatures = "LimitedAccessFeatures";

    static PyObject* _new_LimitedAccessFeatures(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LimitedAccessFeatures);
        return nullptr;
    }

    static PyObject* LimitedAccessFeatures_TryUnlockFeature(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::ApplicationModel::LimitedAccessFeatures::TryUnlockFeature(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_LimitedAccessFeatures[] = {
        { "try_unlock_feature", (PyCFunction)LimitedAccessFeatures_TryUnlockFeature, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LimitedAccessFeatures[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_LimitedAccessFeatures[] = 
    {
        { Py_tp_new, _new_LimitedAccessFeatures },
        { Py_tp_methods, _methods_LimitedAccessFeatures },
        { Py_tp_getset, _getset_LimitedAccessFeatures },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LimitedAccessFeatures =
    {
        "_winrt_Windows_ApplicationModel.LimitedAccessFeatures",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LimitedAccessFeatures
    };

    // ----- Package class --------------------
    constexpr const char* const _type_name_Package = "Package";

    static PyObject* _new_Package(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_Package);
        return nullptr;
    }

    static void _dealloc_Package(py::wrapper::Windows::ApplicationModel::Package* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Package_CheckUpdateAvailabilityAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CheckUpdateAvailabilityAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetAppInstallerInfo(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAppInstallerInfo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetAppListEntries(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAppListEntries());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetAppListEntriesAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAppListEntriesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetContentGroupAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetContentGroupAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetContentGroupsAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetContentGroupsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetLogoAsRandomAccessStreamReference(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                return py::convert(self->obj.GetLogoAsRandomAccessStreamReference(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetThumbnailToken(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetThumbnailToken());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_Launch(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Launch(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_SetInUseAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetInUseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_StageContentGroupsAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.StageContentGroupsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.StageContentGroupsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_VerifyContentIntegrityAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.VerifyContentIntegrityAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_get_Dependencies(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Dependencies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_Id(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_InstalledLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstalledLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsFramework(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsFramework());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_Description(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_DisplayName(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsBundle(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBundle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsDevelopmentMode(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDevelopmentMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsResourcePackage(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsResourcePackage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_Logo(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_PublisherDisplayName(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PublisherDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_InstalledDate(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstalledDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_Status(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsOptional(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOptional());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_SignatureKind(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignatureKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_EffectiveLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectiveLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_MutableLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MutableLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_EffectiveExternalLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectiveExternalLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_EffectiveExternalPath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectiveExternalPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_EffectivePath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectivePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_InstalledPath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstalledPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsStub(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStub());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_MachineExternalLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MachineExternalLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_MachineExternalPath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MachineExternalPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_MutablePath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MutablePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_UserExternalLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserExternalLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_UserExternalPath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserExternalPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_InstallDate(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstallDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_Current(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Package::Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Package(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Package>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Package[] = {
        { "check_update_availability_async", (PyCFunction)Package_CheckUpdateAvailabilityAsync, METH_VARARGS, nullptr },
        { "get_app_installer_info", (PyCFunction)Package_GetAppInstallerInfo, METH_VARARGS, nullptr },
        { "get_app_list_entries", (PyCFunction)Package_GetAppListEntries, METH_VARARGS, nullptr },
        { "get_app_list_entries_async", (PyCFunction)Package_GetAppListEntriesAsync, METH_VARARGS, nullptr },
        { "get_content_group_async", (PyCFunction)Package_GetContentGroupAsync, METH_VARARGS, nullptr },
        { "get_content_groups_async", (PyCFunction)Package_GetContentGroupsAsync, METH_VARARGS, nullptr },
        { "get_logo_as_random_access_stream_reference", (PyCFunction)Package_GetLogoAsRandomAccessStreamReference, METH_VARARGS, nullptr },
        { "get_thumbnail_token", (PyCFunction)Package_GetThumbnailToken, METH_VARARGS, nullptr },
        { "launch", (PyCFunction)Package_Launch, METH_VARARGS, nullptr },
        { "set_in_use_async", (PyCFunction)Package_SetInUseAsync, METH_VARARGS, nullptr },
        { "stage_content_groups_async", (PyCFunction)Package_StageContentGroupsAsync, METH_VARARGS, nullptr },
        { "verify_content_integrity_async", (PyCFunction)Package_VerifyContentIntegrityAsync, METH_VARARGS, nullptr },
        { "get_current", (PyCFunction)Package_get_Current, METH_NOARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_Package, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_Package[] = {
        { const_cast<char*>("dependencies"), (getter)Package_get_Dependencies, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)Package_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("installed_location"), (getter)Package_get_InstalledLocation, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_framework"), (getter)Package_get_IsFramework, nullptr, nullptr, nullptr },
        { const_cast<char*>("description"), (getter)Package_get_Description, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)Package_get_DisplayName, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_bundle"), (getter)Package_get_IsBundle, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_development_mode"), (getter)Package_get_IsDevelopmentMode, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_resource_package"), (getter)Package_get_IsResourcePackage, nullptr, nullptr, nullptr },
        { const_cast<char*>("logo"), (getter)Package_get_Logo, nullptr, nullptr, nullptr },
        { const_cast<char*>("publisher_display_name"), (getter)Package_get_PublisherDisplayName, nullptr, nullptr, nullptr },
        { const_cast<char*>("installed_date"), (getter)Package_get_InstalledDate, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)Package_get_Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_optional"), (getter)Package_get_IsOptional, nullptr, nullptr, nullptr },
        { const_cast<char*>("signature_kind"), (getter)Package_get_SignatureKind, nullptr, nullptr, nullptr },
        { const_cast<char*>("effective_location"), (getter)Package_get_EffectiveLocation, nullptr, nullptr, nullptr },
        { const_cast<char*>("mutable_location"), (getter)Package_get_MutableLocation, nullptr, nullptr, nullptr },
        { const_cast<char*>("effective_external_location"), (getter)Package_get_EffectiveExternalLocation, nullptr, nullptr, nullptr },
        { const_cast<char*>("effective_external_path"), (getter)Package_get_EffectiveExternalPath, nullptr, nullptr, nullptr },
        { const_cast<char*>("effective_path"), (getter)Package_get_EffectivePath, nullptr, nullptr, nullptr },
        { const_cast<char*>("installed_path"), (getter)Package_get_InstalledPath, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_stub"), (getter)Package_get_IsStub, nullptr, nullptr, nullptr },
        { const_cast<char*>("machine_external_location"), (getter)Package_get_MachineExternalLocation, nullptr, nullptr, nullptr },
        { const_cast<char*>("machine_external_path"), (getter)Package_get_MachineExternalPath, nullptr, nullptr, nullptr },
        { const_cast<char*>("mutable_path"), (getter)Package_get_MutablePath, nullptr, nullptr, nullptr },
        { const_cast<char*>("user_external_location"), (getter)Package_get_UserExternalLocation, nullptr, nullptr, nullptr },
        { const_cast<char*>("user_external_path"), (getter)Package_get_UserExternalPath, nullptr, nullptr, nullptr },
        { const_cast<char*>("install_date"), (getter)Package_get_InstallDate, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Package[] = 
    {
        { Py_tp_new, _new_Package },
        { Py_tp_dealloc, _dealloc_Package },
        { Py_tp_methods, _methods_Package },
        { Py_tp_getset, _getset_Package },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Package =
    {
        "_winrt_Windows_ApplicationModel.Package",
        sizeof(py::wrapper::Windows::ApplicationModel::Package),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Package
    };

    // ----- PackageCatalog class --------------------
    constexpr const char* const _type_name_PackageCatalog = "PackageCatalog";

    static PyObject* _new_PackageCatalog(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageCatalog);
        return nullptr;
    }

    static void _dealloc_PackageCatalog(py::wrapper::Windows::ApplicationModel::PackageCatalog* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageCatalog_AddOptionalPackageAsync(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.AddOptionalPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_AddResourcePackageAsync(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::AddResourcePackageOptions>(args, 2);

                return py::convert(self->obj.AddResourcePackageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_OpenForCurrentPackage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::PackageCatalog::OpenForCurrentPackage());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_OpenForCurrentUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::PackageCatalog::OpenForCurrentUser());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_RemoveOptionalPackagesAsync(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.RemoveOptionalPackagesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_RemoveResourcePackagesAsync(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Package>>(args, 0);

                return py::convert(self->obj.RemoveResourcePackagesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageInstalling(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageInstallingEventArgs>>(arg);

            return py::convert(self->obj.PackageInstalling(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageInstalling(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageInstalling(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageStaging(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageStagingEventArgs>>(arg);

            return py::convert(self->obj.PackageStaging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageStaging(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageStaging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageStatusChanged(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageStatusChangedEventArgs>>(arg);

            return py::convert(self->obj.PackageStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageStatusChanged(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageUninstalling(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageUninstallingEventArgs>>(arg);

            return py::convert(self->obj.PackageUninstalling(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageUninstalling(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageUninstalling(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageUpdating(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageUpdatingEventArgs>>(arg);

            return py::convert(self->obj.PackageUpdating(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageUpdating(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageUpdating(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageContentGroupStaging(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageContentGroupStagingEventArgs>>(arg);

            return py::convert(self->obj.PackageContentGroupStaging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageContentGroupStaging(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageContentGroupStaging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageCatalog(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageCatalog>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageCatalog[] = {
        { "add_optional_package_async", (PyCFunction)PackageCatalog_AddOptionalPackageAsync, METH_VARARGS, nullptr },
        { "add_resource_package_async", (PyCFunction)PackageCatalog_AddResourcePackageAsync, METH_VARARGS, nullptr },
        { "open_for_current_package", (PyCFunction)PackageCatalog_OpenForCurrentPackage, METH_VARARGS | METH_STATIC, nullptr },
        { "open_for_current_user", (PyCFunction)PackageCatalog_OpenForCurrentUser, METH_VARARGS | METH_STATIC, nullptr },
        { "remove_optional_packages_async", (PyCFunction)PackageCatalog_RemoveOptionalPackagesAsync, METH_VARARGS, nullptr },
        { "remove_resource_packages_async", (PyCFunction)PackageCatalog_RemoveResourcePackagesAsync, METH_VARARGS, nullptr },
        { "add_package_installing", (PyCFunction)PackageCatalog_add_PackageInstalling, METH_O, nullptr },
        { "remove_package_installing", (PyCFunction)PackageCatalog_remove_PackageInstalling, METH_O, nullptr },
        { "add_package_staging", (PyCFunction)PackageCatalog_add_PackageStaging, METH_O, nullptr },
        { "remove_package_staging", (PyCFunction)PackageCatalog_remove_PackageStaging, METH_O, nullptr },
        { "add_package_status_changed", (PyCFunction)PackageCatalog_add_PackageStatusChanged, METH_O, nullptr },
        { "remove_package_status_changed", (PyCFunction)PackageCatalog_remove_PackageStatusChanged, METH_O, nullptr },
        { "add_package_uninstalling", (PyCFunction)PackageCatalog_add_PackageUninstalling, METH_O, nullptr },
        { "remove_package_uninstalling", (PyCFunction)PackageCatalog_remove_PackageUninstalling, METH_O, nullptr },
        { "add_package_updating", (PyCFunction)PackageCatalog_add_PackageUpdating, METH_O, nullptr },
        { "remove_package_updating", (PyCFunction)PackageCatalog_remove_PackageUpdating, METH_O, nullptr },
        { "add_package_content_group_staging", (PyCFunction)PackageCatalog_add_PackageContentGroupStaging, METH_O, nullptr },
        { "remove_package_content_group_staging", (PyCFunction)PackageCatalog_remove_PackageContentGroupStaging, METH_O, nullptr },
        { "_from", (PyCFunction)_from_PackageCatalog, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PackageCatalog[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageCatalog[] = 
    {
        { Py_tp_new, _new_PackageCatalog },
        { Py_tp_dealloc, _dealloc_PackageCatalog },
        { Py_tp_methods, _methods_PackageCatalog },
        { Py_tp_getset, _getset_PackageCatalog },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageCatalog =
    {
        "_winrt_Windows_ApplicationModel.PackageCatalog",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageCatalog),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageCatalog
    };

    // ----- PackageCatalogAddOptionalPackageResult class --------------------
    constexpr const char* const _type_name_PackageCatalogAddOptionalPackageResult = "PackageCatalogAddOptionalPackageResult";

    static PyObject* _new_PackageCatalogAddOptionalPackageResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageCatalogAddOptionalPackageResult);
        return nullptr;
    }

    static void _dealloc_PackageCatalogAddOptionalPackageResult(py::wrapper::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageCatalogAddOptionalPackageResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalogAddOptionalPackageResult_get_Package(py::wrapper::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageCatalogAddOptionalPackageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageCatalogAddOptionalPackageResult[] = {
        { "_from", (PyCFunction)_from_PackageCatalogAddOptionalPackageResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PackageCatalogAddOptionalPackageResult[] = {
        { const_cast<char*>("extended_error"), (getter)PackageCatalogAddOptionalPackageResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("package"), (getter)PackageCatalogAddOptionalPackageResult_get_Package, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageCatalogAddOptionalPackageResult[] = 
    {
        { Py_tp_new, _new_PackageCatalogAddOptionalPackageResult },
        { Py_tp_dealloc, _dealloc_PackageCatalogAddOptionalPackageResult },
        { Py_tp_methods, _methods_PackageCatalogAddOptionalPackageResult },
        { Py_tp_getset, _getset_PackageCatalogAddOptionalPackageResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageCatalogAddOptionalPackageResult =
    {
        "_winrt_Windows_ApplicationModel.PackageCatalogAddOptionalPackageResult",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageCatalogAddOptionalPackageResult
    };

    // ----- PackageCatalogAddResourcePackageResult class --------------------
    constexpr const char* const _type_name_PackageCatalogAddResourcePackageResult = "PackageCatalogAddResourcePackageResult";

    static PyObject* _new_PackageCatalogAddResourcePackageResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageCatalogAddResourcePackageResult);
        return nullptr;
    }

    static void _dealloc_PackageCatalogAddResourcePackageResult(py::wrapper::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageCatalogAddResourcePackageResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalogAddResourcePackageResult_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalogAddResourcePackageResult_get_Package(py::wrapper::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageCatalogAddResourcePackageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageCatalogAddResourcePackageResult[] = {
        { "_from", (PyCFunction)_from_PackageCatalogAddResourcePackageResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PackageCatalogAddResourcePackageResult[] = {
        { const_cast<char*>("extended_error"), (getter)PackageCatalogAddResourcePackageResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_complete"), (getter)PackageCatalogAddResourcePackageResult_get_IsComplete, nullptr, nullptr, nullptr },
        { const_cast<char*>("package"), (getter)PackageCatalogAddResourcePackageResult_get_Package, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageCatalogAddResourcePackageResult[] = 
    {
        { Py_tp_new, _new_PackageCatalogAddResourcePackageResult },
        { Py_tp_dealloc, _dealloc_PackageCatalogAddResourcePackageResult },
        { Py_tp_methods, _methods_PackageCatalogAddResourcePackageResult },
        { Py_tp_getset, _getset_PackageCatalogAddResourcePackageResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageCatalogAddResourcePackageResult =
    {
        "_winrt_Windows_ApplicationModel.PackageCatalogAddResourcePackageResult",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageCatalogAddResourcePackageResult
    };

    // ----- PackageCatalogRemoveOptionalPackagesResult class --------------------
    constexpr const char* const _type_name_PackageCatalogRemoveOptionalPackagesResult = "PackageCatalogRemoveOptionalPackagesResult";

    static PyObject* _new_PackageCatalogRemoveOptionalPackagesResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageCatalogRemoveOptionalPackagesResult);
        return nullptr;
    }

    static void _dealloc_PackageCatalogRemoveOptionalPackagesResult(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageCatalogRemoveOptionalPackagesResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalogRemoveOptionalPackagesResult_get_PackagesRemoved(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackagesRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageCatalogRemoveOptionalPackagesResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageCatalogRemoveOptionalPackagesResult[] = {
        { "_from", (PyCFunction)_from_PackageCatalogRemoveOptionalPackagesResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PackageCatalogRemoveOptionalPackagesResult[] = {
        { const_cast<char*>("extended_error"), (getter)PackageCatalogRemoveOptionalPackagesResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("packages_removed"), (getter)PackageCatalogRemoveOptionalPackagesResult_get_PackagesRemoved, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageCatalogRemoveOptionalPackagesResult[] = 
    {
        { Py_tp_new, _new_PackageCatalogRemoveOptionalPackagesResult },
        { Py_tp_dealloc, _dealloc_PackageCatalogRemoveOptionalPackagesResult },
        { Py_tp_methods, _methods_PackageCatalogRemoveOptionalPackagesResult },
        { Py_tp_getset, _getset_PackageCatalogRemoveOptionalPackagesResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageCatalogRemoveOptionalPackagesResult =
    {
        "_winrt_Windows_ApplicationModel.PackageCatalogRemoveOptionalPackagesResult",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageCatalogRemoveOptionalPackagesResult
    };

    // ----- PackageCatalogRemoveResourcePackagesResult class --------------------
    constexpr const char* const _type_name_PackageCatalogRemoveResourcePackagesResult = "PackageCatalogRemoveResourcePackagesResult";

    static PyObject* _new_PackageCatalogRemoveResourcePackagesResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageCatalogRemoveResourcePackagesResult);
        return nullptr;
    }

    static void _dealloc_PackageCatalogRemoveResourcePackagesResult(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageCatalogRemoveResourcePackagesResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalogRemoveResourcePackagesResult_get_PackagesRemoved(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackagesRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageCatalogRemoveResourcePackagesResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageCatalogRemoveResourcePackagesResult[] = {
        { "_from", (PyCFunction)_from_PackageCatalogRemoveResourcePackagesResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PackageCatalogRemoveResourcePackagesResult[] = {
        { const_cast<char*>("extended_error"), (getter)PackageCatalogRemoveResourcePackagesResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("packages_removed"), (getter)PackageCatalogRemoveResourcePackagesResult_get_PackagesRemoved, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageCatalogRemoveResourcePackagesResult[] = 
    {
        { Py_tp_new, _new_PackageCatalogRemoveResourcePackagesResult },
        { Py_tp_dealloc, _dealloc_PackageCatalogRemoveResourcePackagesResult },
        { Py_tp_methods, _methods_PackageCatalogRemoveResourcePackagesResult },
        { Py_tp_getset, _getset_PackageCatalogRemoveResourcePackagesResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageCatalogRemoveResourcePackagesResult =
    {
        "_winrt_Windows_ApplicationModel.PackageCatalogRemoveResourcePackagesResult",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageCatalogRemoveResourcePackagesResult
    };

    // ----- PackageContentGroup class --------------------
    constexpr const char* const _type_name_PackageContentGroup = "PackageContentGroup";

    static PyObject* _new_PackageContentGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageContentGroup);
        return nullptr;
    }

    static void _dealloc_PackageContentGroup(py::wrapper::Windows::ApplicationModel::PackageContentGroup* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageContentGroup_get_IsRequired(py::wrapper::Windows::ApplicationModel::PackageContentGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroup_get_Name(py::wrapper::Windows::ApplicationModel::PackageContentGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroup_get_Package(py::wrapper::Windows::ApplicationModel::PackageContentGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroup_get_State(py::wrapper::Windows::ApplicationModel::PackageContentGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroup_get_RequiredGroupName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::PackageContentGroup::RequiredGroupName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageContentGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageContentGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageContentGroup[] = {
        { "get_required_group_name", (PyCFunction)PackageContentGroup_get_RequiredGroupName, METH_NOARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_PackageContentGroup, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PackageContentGroup[] = {
        { const_cast<char*>("is_required"), (getter)PackageContentGroup_get_IsRequired, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)PackageContentGroup_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("package"), (getter)PackageContentGroup_get_Package, nullptr, nullptr, nullptr },
        { const_cast<char*>("state"), (getter)PackageContentGroup_get_State, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageContentGroup[] = 
    {
        { Py_tp_new, _new_PackageContentGroup },
        { Py_tp_dealloc, _dealloc_PackageContentGroup },
        { Py_tp_methods, _methods_PackageContentGroup },
        { Py_tp_getset, _getset_PackageContentGroup },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageContentGroup =
    {
        "_winrt_Windows_ApplicationModel.PackageContentGroup",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageContentGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageContentGroup
    };

    // ----- PackageContentGroupStagingEventArgs class --------------------
    constexpr const char* const _type_name_PackageContentGroupStagingEventArgs = "PackageContentGroupStagingEventArgs";

    static PyObject* _new_PackageContentGroupStagingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageContentGroupStagingEventArgs);
        return nullptr;
    }

    static void _dealloc_PackageContentGroupStagingEventArgs(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_ActivityId(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_ContentGroupName(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentGroupName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_ErrorCode(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_IsContentGroupRequired(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsContentGroupRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_Package(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageContentGroupStagingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageContentGroupStagingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageContentGroupStagingEventArgs[] = {
        { "_from", (PyCFunction)_from_PackageContentGroupStagingEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PackageContentGroupStagingEventArgs[] = {
        { const_cast<char*>("activity_id"), (getter)PackageContentGroupStagingEventArgs_get_ActivityId, nullptr, nullptr, nullptr },
        { const_cast<char*>("content_group_name"), (getter)PackageContentGroupStagingEventArgs_get_ContentGroupName, nullptr, nullptr, nullptr },
        { const_cast<char*>("error_code"), (getter)PackageContentGroupStagingEventArgs_get_ErrorCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_complete"), (getter)PackageContentGroupStagingEventArgs_get_IsComplete, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_content_group_required"), (getter)PackageContentGroupStagingEventArgs_get_IsContentGroupRequired, nullptr, nullptr, nullptr },
        { const_cast<char*>("package"), (getter)PackageContentGroupStagingEventArgs_get_Package, nullptr, nullptr, nullptr },
        { const_cast<char*>("progress"), (getter)PackageContentGroupStagingEventArgs_get_Progress, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageContentGroupStagingEventArgs[] = 
    {
        { Py_tp_new, _new_PackageContentGroupStagingEventArgs },
        { Py_tp_dealloc, _dealloc_PackageContentGroupStagingEventArgs },
        { Py_tp_methods, _methods_PackageContentGroupStagingEventArgs },
        { Py_tp_getset, _getset_PackageContentGroupStagingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageContentGroupStagingEventArgs =
    {
        "_winrt_Windows_ApplicationModel.PackageContentGroupStagingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageContentGroupStagingEventArgs
    };

    // ----- PackageId class --------------------
    constexpr const char* const _type_name_PackageId = "PackageId";

    static PyObject* _new_PackageId(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageId);
        return nullptr;
    }

    static void _dealloc_PackageId(py::wrapper::Windows::ApplicationModel::PackageId* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageId_get_Architecture(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Architecture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_FamilyName(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_FullName(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FullName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_Name(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_Publisher(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Publisher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_PublisherId(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PublisherId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_ResourceId(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_Version(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_Author(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Author());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_ProductId(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageId>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageId[] = {
        { "_from", (PyCFunction)_from_PackageId, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PackageId[] = {
        { const_cast<char*>("architecture"), (getter)PackageId_get_Architecture, nullptr, nullptr, nullptr },
        { const_cast<char*>("family_name"), (getter)PackageId_get_FamilyName, nullptr, nullptr, nullptr },
        { const_cast<char*>("full_name"), (getter)PackageId_get_FullName, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)PackageId_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("publisher"), (getter)PackageId_get_Publisher, nullptr, nullptr, nullptr },
        { const_cast<char*>("publisher_id"), (getter)PackageId_get_PublisherId, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_id"), (getter)PackageId_get_ResourceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("version"), (getter)PackageId_get_Version, nullptr, nullptr, nullptr },
        { const_cast<char*>("author"), (getter)PackageId_get_Author, nullptr, nullptr, nullptr },
        { const_cast<char*>("product_id"), (getter)PackageId_get_ProductId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageId[] = 
    {
        { Py_tp_new, _new_PackageId },
        { Py_tp_dealloc, _dealloc_PackageId },
        { Py_tp_methods, _methods_PackageId },
        { Py_tp_getset, _getset_PackageId },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageId =
    {
        "_winrt_Windows_ApplicationModel.PackageId",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageId
    };

    // ----- PackageInstallingEventArgs class --------------------
    constexpr const char* const _type_name_PackageInstallingEventArgs = "PackageInstallingEventArgs";

    static PyObject* _new_PackageInstallingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageInstallingEventArgs);
        return nullptr;
    }

    static void _dealloc_PackageInstallingEventArgs(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageInstallingEventArgs_get_ActivityId(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageInstallingEventArgs_get_ErrorCode(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageInstallingEventArgs_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageInstallingEventArgs_get_Package(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageInstallingEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageInstallingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageInstallingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageInstallingEventArgs[] = {
        { "_from", (PyCFunction)_from_PackageInstallingEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PackageInstallingEventArgs[] = {
        { const_cast<char*>("activity_id"), (getter)PackageInstallingEventArgs_get_ActivityId, nullptr, nullptr, nullptr },
        { const_cast<char*>("error_code"), (getter)PackageInstallingEventArgs_get_ErrorCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_complete"), (getter)PackageInstallingEventArgs_get_IsComplete, nullptr, nullptr, nullptr },
        { const_cast<char*>("package"), (getter)PackageInstallingEventArgs_get_Package, nullptr, nullptr, nullptr },
        { const_cast<char*>("progress"), (getter)PackageInstallingEventArgs_get_Progress, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageInstallingEventArgs[] = 
    {
        { Py_tp_new, _new_PackageInstallingEventArgs },
        { Py_tp_dealloc, _dealloc_PackageInstallingEventArgs },
        { Py_tp_methods, _methods_PackageInstallingEventArgs },
        { Py_tp_getset, _getset_PackageInstallingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageInstallingEventArgs =
    {
        "_winrt_Windows_ApplicationModel.PackageInstallingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageInstallingEventArgs
    };

    // ----- PackageStagingEventArgs class --------------------
    constexpr const char* const _type_name_PackageStagingEventArgs = "PackageStagingEventArgs";

    static PyObject* _new_PackageStagingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageStagingEventArgs);
        return nullptr;
    }

    static void _dealloc_PackageStagingEventArgs(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageStagingEventArgs_get_ActivityId(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStagingEventArgs_get_ErrorCode(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStagingEventArgs_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStagingEventArgs_get_Package(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStagingEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageStagingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageStagingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageStagingEventArgs[] = {
        { "_from", (PyCFunction)_from_PackageStagingEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PackageStagingEventArgs[] = {
        { const_cast<char*>("activity_id"), (getter)PackageStagingEventArgs_get_ActivityId, nullptr, nullptr, nullptr },
        { const_cast<char*>("error_code"), (getter)PackageStagingEventArgs_get_ErrorCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_complete"), (getter)PackageStagingEventArgs_get_IsComplete, nullptr, nullptr, nullptr },
        { const_cast<char*>("package"), (getter)PackageStagingEventArgs_get_Package, nullptr, nullptr, nullptr },
        { const_cast<char*>("progress"), (getter)PackageStagingEventArgs_get_Progress, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageStagingEventArgs[] = 
    {
        { Py_tp_new, _new_PackageStagingEventArgs },
        { Py_tp_dealloc, _dealloc_PackageStagingEventArgs },
        { Py_tp_methods, _methods_PackageStagingEventArgs },
        { Py_tp_getset, _getset_PackageStagingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageStagingEventArgs =
    {
        "_winrt_Windows_ApplicationModel.PackageStagingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageStagingEventArgs
    };

    // ----- PackageStatus class --------------------
    constexpr const char* const _type_name_PackageStatus = "PackageStatus";

    static PyObject* _new_PackageStatus(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageStatus);
        return nullptr;
    }

    static void _dealloc_PackageStatus(py::wrapper::Windows::ApplicationModel::PackageStatus* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageStatus_VerifyIsOK(py::wrapper::Windows::ApplicationModel::PackageStatus* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.VerifyIsOK());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_DataOffline(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DataOffline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_DependencyIssue(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DependencyIssue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_DeploymentInProgress(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeploymentInProgress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_Disabled(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Disabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_LicenseIssue(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LicenseIssue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_Modified(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Modified());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_NeedsRemediation(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NeedsRemediation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_NotAvailable(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NotAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_PackageOffline(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageOffline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_Servicing(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Servicing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_Tampered(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tampered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_IsPartiallyStaged(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPartiallyStaged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageStatus[] = {
        { "verify_is_o_k", (PyCFunction)PackageStatus_VerifyIsOK, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PackageStatus, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PackageStatus[] = {
        { const_cast<char*>("data_offline"), (getter)PackageStatus_get_DataOffline, nullptr, nullptr, nullptr },
        { const_cast<char*>("dependency_issue"), (getter)PackageStatus_get_DependencyIssue, nullptr, nullptr, nullptr },
        { const_cast<char*>("deployment_in_progress"), (getter)PackageStatus_get_DeploymentInProgress, nullptr, nullptr, nullptr },
        { const_cast<char*>("disabled"), (getter)PackageStatus_get_Disabled, nullptr, nullptr, nullptr },
        { const_cast<char*>("license_issue"), (getter)PackageStatus_get_LicenseIssue, nullptr, nullptr, nullptr },
        { const_cast<char*>("modified"), (getter)PackageStatus_get_Modified, nullptr, nullptr, nullptr },
        { const_cast<char*>("needs_remediation"), (getter)PackageStatus_get_NeedsRemediation, nullptr, nullptr, nullptr },
        { const_cast<char*>("not_available"), (getter)PackageStatus_get_NotAvailable, nullptr, nullptr, nullptr },
        { const_cast<char*>("package_offline"), (getter)PackageStatus_get_PackageOffline, nullptr, nullptr, nullptr },
        { const_cast<char*>("servicing"), (getter)PackageStatus_get_Servicing, nullptr, nullptr, nullptr },
        { const_cast<char*>("tampered"), (getter)PackageStatus_get_Tampered, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_partially_staged"), (getter)PackageStatus_get_IsPartiallyStaged, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageStatus[] = 
    {
        { Py_tp_new, _new_PackageStatus },
        { Py_tp_dealloc, _dealloc_PackageStatus },
        { Py_tp_methods, _methods_PackageStatus },
        { Py_tp_getset, _getset_PackageStatus },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageStatus =
    {
        "_winrt_Windows_ApplicationModel.PackageStatus",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageStatus
    };

    // ----- PackageStatusChangedEventArgs class --------------------
    constexpr const char* const _type_name_PackageStatusChangedEventArgs = "PackageStatusChangedEventArgs";

    static PyObject* _new_PackageStatusChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageStatusChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_PackageStatusChangedEventArgs(py::wrapper::Windows::ApplicationModel::PackageStatusChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageStatusChangedEventArgs_get_Package(py::wrapper::Windows::ApplicationModel::PackageStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageStatusChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageStatusChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_PackageStatusChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PackageStatusChangedEventArgs[] = {
        { const_cast<char*>("package"), (getter)PackageStatusChangedEventArgs_get_Package, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageStatusChangedEventArgs[] = 
    {
        { Py_tp_new, _new_PackageStatusChangedEventArgs },
        { Py_tp_dealloc, _dealloc_PackageStatusChangedEventArgs },
        { Py_tp_methods, _methods_PackageStatusChangedEventArgs },
        { Py_tp_getset, _getset_PackageStatusChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageStatusChangedEventArgs =
    {
        "_winrt_Windows_ApplicationModel.PackageStatusChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageStatusChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageStatusChangedEventArgs
    };

    // ----- PackageUninstallingEventArgs class --------------------
    constexpr const char* const _type_name_PackageUninstallingEventArgs = "PackageUninstallingEventArgs";

    static PyObject* _new_PackageUninstallingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageUninstallingEventArgs);
        return nullptr;
    }

    static void _dealloc_PackageUninstallingEventArgs(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageUninstallingEventArgs_get_ActivityId(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUninstallingEventArgs_get_ErrorCode(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUninstallingEventArgs_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUninstallingEventArgs_get_Package(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUninstallingEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageUninstallingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageUninstallingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageUninstallingEventArgs[] = {
        { "_from", (PyCFunction)_from_PackageUninstallingEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PackageUninstallingEventArgs[] = {
        { const_cast<char*>("activity_id"), (getter)PackageUninstallingEventArgs_get_ActivityId, nullptr, nullptr, nullptr },
        { const_cast<char*>("error_code"), (getter)PackageUninstallingEventArgs_get_ErrorCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_complete"), (getter)PackageUninstallingEventArgs_get_IsComplete, nullptr, nullptr, nullptr },
        { const_cast<char*>("package"), (getter)PackageUninstallingEventArgs_get_Package, nullptr, nullptr, nullptr },
        { const_cast<char*>("progress"), (getter)PackageUninstallingEventArgs_get_Progress, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageUninstallingEventArgs[] = 
    {
        { Py_tp_new, _new_PackageUninstallingEventArgs },
        { Py_tp_dealloc, _dealloc_PackageUninstallingEventArgs },
        { Py_tp_methods, _methods_PackageUninstallingEventArgs },
        { Py_tp_getset, _getset_PackageUninstallingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageUninstallingEventArgs =
    {
        "_winrt_Windows_ApplicationModel.PackageUninstallingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageUninstallingEventArgs
    };

    // ----- PackageUpdateAvailabilityResult class --------------------
    constexpr const char* const _type_name_PackageUpdateAvailabilityResult = "PackageUpdateAvailabilityResult";

    static PyObject* _new_PackageUpdateAvailabilityResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageUpdateAvailabilityResult);
        return nullptr;
    }

    static void _dealloc_PackageUpdateAvailabilityResult(py::wrapper::Windows::ApplicationModel::PackageUpdateAvailabilityResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageUpdateAvailabilityResult_get_Availability(py::wrapper::Windows::ApplicationModel::PackageUpdateAvailabilityResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Availability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdateAvailabilityResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::PackageUpdateAvailabilityResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageUpdateAvailabilityResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageUpdateAvailabilityResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageUpdateAvailabilityResult[] = {
        { "_from", (PyCFunction)_from_PackageUpdateAvailabilityResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PackageUpdateAvailabilityResult[] = {
        { const_cast<char*>("availability"), (getter)PackageUpdateAvailabilityResult_get_Availability, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_error"), (getter)PackageUpdateAvailabilityResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageUpdateAvailabilityResult[] = 
    {
        { Py_tp_new, _new_PackageUpdateAvailabilityResult },
        { Py_tp_dealloc, _dealloc_PackageUpdateAvailabilityResult },
        { Py_tp_methods, _methods_PackageUpdateAvailabilityResult },
        { Py_tp_getset, _getset_PackageUpdateAvailabilityResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageUpdateAvailabilityResult =
    {
        "_winrt_Windows_ApplicationModel.PackageUpdateAvailabilityResult",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageUpdateAvailabilityResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageUpdateAvailabilityResult
    };

    // ----- PackageUpdatingEventArgs class --------------------
    constexpr const char* const _type_name_PackageUpdatingEventArgs = "PackageUpdatingEventArgs";

    static PyObject* _new_PackageUpdatingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageUpdatingEventArgs);
        return nullptr;
    }

    static void _dealloc_PackageUpdatingEventArgs(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageUpdatingEventArgs_get_ActivityId(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdatingEventArgs_get_ErrorCode(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdatingEventArgs_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdatingEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdatingEventArgs_get_SourcePackage(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourcePackage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdatingEventArgs_get_TargetPackage(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TargetPackage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageUpdatingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageUpdatingEventArgs[] = {
        { "_from", (PyCFunction)_from_PackageUpdatingEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PackageUpdatingEventArgs[] = {
        { const_cast<char*>("activity_id"), (getter)PackageUpdatingEventArgs_get_ActivityId, nullptr, nullptr, nullptr },
        { const_cast<char*>("error_code"), (getter)PackageUpdatingEventArgs_get_ErrorCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_complete"), (getter)PackageUpdatingEventArgs_get_IsComplete, nullptr, nullptr, nullptr },
        { const_cast<char*>("progress"), (getter)PackageUpdatingEventArgs_get_Progress, nullptr, nullptr, nullptr },
        { const_cast<char*>("source_package"), (getter)PackageUpdatingEventArgs_get_SourcePackage, nullptr, nullptr, nullptr },
        { const_cast<char*>("target_package"), (getter)PackageUpdatingEventArgs_get_TargetPackage, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageUpdatingEventArgs[] = 
    {
        { Py_tp_new, _new_PackageUpdatingEventArgs },
        { Py_tp_dealloc, _dealloc_PackageUpdatingEventArgs },
        { Py_tp_methods, _methods_PackageUpdatingEventArgs },
        { Py_tp_getset, _getset_PackageUpdatingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageUpdatingEventArgs =
    {
        "_winrt_Windows_ApplicationModel.PackageUpdatingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageUpdatingEventArgs
    };

    // ----- StartupTask class --------------------
    constexpr const char* const _type_name_StartupTask = "StartupTask";

    static PyObject* _new_StartupTask(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StartupTask);
        return nullptr;
    }

    static void _dealloc_StartupTask(py::wrapper::Windows::ApplicationModel::StartupTask* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StartupTask_Disable(py::wrapper::Windows::ApplicationModel::StartupTask* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Disable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartupTask_GetAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::StartupTask::GetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartupTask_GetForCurrentPackageAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::StartupTask::GetForCurrentPackageAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartupTask_RequestEnableAsync(py::wrapper::Windows::ApplicationModel::StartupTask* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestEnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartupTask_get_State(py::wrapper::Windows::ApplicationModel::StartupTask* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StartupTask_get_TaskId(py::wrapper::Windows::ApplicationModel::StartupTask* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StartupTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::StartupTask>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StartupTask[] = {
        { "disable", (PyCFunction)StartupTask_Disable, METH_VARARGS, nullptr },
        { "get_async", (PyCFunction)StartupTask_GetAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_current_package_async", (PyCFunction)StartupTask_GetForCurrentPackageAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "request_enable_async", (PyCFunction)StartupTask_RequestEnableAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_StartupTask, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StartupTask[] = {
        { const_cast<char*>("state"), (getter)StartupTask_get_State, nullptr, nullptr, nullptr },
        { const_cast<char*>("task_id"), (getter)StartupTask_get_TaskId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StartupTask[] = 
    {
        { Py_tp_new, _new_StartupTask },
        { Py_tp_dealloc, _dealloc_StartupTask },
        { Py_tp_methods, _methods_StartupTask },
        { Py_tp_getset, _getset_StartupTask },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StartupTask =
    {
        "_winrt_Windows_ApplicationModel.StartupTask",
        sizeof(py::wrapper::Windows::ApplicationModel::StartupTask),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StartupTask
    };

    // ----- SuspendingDeferral class --------------------
    constexpr const char* const _type_name_SuspendingDeferral = "SuspendingDeferral";

    static PyObject* _new_SuspendingDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SuspendingDeferral);
        return nullptr;
    }

    static void _dealloc_SuspendingDeferral(py::wrapper::Windows::ApplicationModel::SuspendingDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SuspendingDeferral_Complete(py::wrapper::Windows::ApplicationModel::SuspendingDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_SuspendingDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::SuspendingDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SuspendingDeferral[] = {
        { "complete", (PyCFunction)SuspendingDeferral_Complete, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_SuspendingDeferral, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SuspendingDeferral[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_SuspendingDeferral[] = 
    {
        { Py_tp_new, _new_SuspendingDeferral },
        { Py_tp_dealloc, _dealloc_SuspendingDeferral },
        { Py_tp_methods, _methods_SuspendingDeferral },
        { Py_tp_getset, _getset_SuspendingDeferral },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SuspendingDeferral =
    {
        "_winrt_Windows_ApplicationModel.SuspendingDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::SuspendingDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SuspendingDeferral
    };

    // ----- SuspendingEventArgs class --------------------
    constexpr const char* const _type_name_SuspendingEventArgs = "SuspendingEventArgs";

    static PyObject* _new_SuspendingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SuspendingEventArgs);
        return nullptr;
    }

    static void _dealloc_SuspendingEventArgs(py::wrapper::Windows::ApplicationModel::SuspendingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SuspendingEventArgs_get_SuspendingOperation(py::wrapper::Windows::ApplicationModel::SuspendingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuspendingOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SuspendingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::SuspendingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SuspendingEventArgs[] = {
        { "_from", (PyCFunction)_from_SuspendingEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SuspendingEventArgs[] = {
        { const_cast<char*>("suspending_operation"), (getter)SuspendingEventArgs_get_SuspendingOperation, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SuspendingEventArgs[] = 
    {
        { Py_tp_new, _new_SuspendingEventArgs },
        { Py_tp_dealloc, _dealloc_SuspendingEventArgs },
        { Py_tp_methods, _methods_SuspendingEventArgs },
        { Py_tp_getset, _getset_SuspendingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SuspendingEventArgs =
    {
        "_winrt_Windows_ApplicationModel.SuspendingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::SuspendingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SuspendingEventArgs
    };

    // ----- SuspendingOperation class --------------------
    constexpr const char* const _type_name_SuspendingOperation = "SuspendingOperation";

    static PyObject* _new_SuspendingOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SuspendingOperation);
        return nullptr;
    }

    static void _dealloc_SuspendingOperation(py::wrapper::Windows::ApplicationModel::SuspendingOperation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SuspendingOperation_GetDeferral(py::wrapper::Windows::ApplicationModel::SuspendingOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SuspendingOperation_get_Deadline(py::wrapper::Windows::ApplicationModel::SuspendingOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SuspendingOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::SuspendingOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SuspendingOperation[] = {
        { "get_deferral", (PyCFunction)SuspendingOperation_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_SuspendingOperation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SuspendingOperation[] = {
        { const_cast<char*>("deadline"), (getter)SuspendingOperation_get_Deadline, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SuspendingOperation[] = 
    {
        { Py_tp_new, _new_SuspendingOperation },
        { Py_tp_dealloc, _dealloc_SuspendingOperation },
        { Py_tp_methods, _methods_SuspendingOperation },
        { Py_tp_getset, _getset_SuspendingOperation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SuspendingOperation =
    {
        "_winrt_Windows_ApplicationModel.SuspendingOperation",
        sizeof(py::wrapper::Windows::ApplicationModel::SuspendingOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SuspendingOperation
    };

    // ----- IEnteredBackgroundEventArgs interface --------------------
    constexpr const char* const _type_name_IEnteredBackgroundEventArgs = "IEnteredBackgroundEventArgs";

    static PyObject* _new_IEnteredBackgroundEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IEnteredBackgroundEventArgs);
        return nullptr;
    }

    static void _dealloc_IEnteredBackgroundEventArgs(py::wrapper::Windows::ApplicationModel::IEnteredBackgroundEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IEnteredBackgroundEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::IEnteredBackgroundEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IEnteredBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::IEnteredBackgroundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IEnteredBackgroundEventArgs[] = {
        { "get_deferral", (PyCFunction)IEnteredBackgroundEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IEnteredBackgroundEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IEnteredBackgroundEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IEnteredBackgroundEventArgs[] = 
    {
        { Py_tp_new, _new_IEnteredBackgroundEventArgs },
        { Py_tp_dealloc, _dealloc_IEnteredBackgroundEventArgs },
        { Py_tp_methods, _methods_IEnteredBackgroundEventArgs },
        { Py_tp_getset, _getset_IEnteredBackgroundEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IEnteredBackgroundEventArgs =
    {
        "_winrt_Windows_ApplicationModel.IEnteredBackgroundEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::IEnteredBackgroundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IEnteredBackgroundEventArgs
    };

    // ----- ILeavingBackgroundEventArgs interface --------------------
    constexpr const char* const _type_name_ILeavingBackgroundEventArgs = "ILeavingBackgroundEventArgs";

    static PyObject* _new_ILeavingBackgroundEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ILeavingBackgroundEventArgs);
        return nullptr;
    }

    static void _dealloc_ILeavingBackgroundEventArgs(py::wrapper::Windows::ApplicationModel::ILeavingBackgroundEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ILeavingBackgroundEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::ILeavingBackgroundEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ILeavingBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ILeavingBackgroundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILeavingBackgroundEventArgs[] = {
        { "get_deferral", (PyCFunction)ILeavingBackgroundEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ILeavingBackgroundEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ILeavingBackgroundEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ILeavingBackgroundEventArgs[] = 
    {
        { Py_tp_new, _new_ILeavingBackgroundEventArgs },
        { Py_tp_dealloc, _dealloc_ILeavingBackgroundEventArgs },
        { Py_tp_methods, _methods_ILeavingBackgroundEventArgs },
        { Py_tp_getset, _getset_ILeavingBackgroundEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ILeavingBackgroundEventArgs =
    {
        "_winrt_Windows_ApplicationModel.ILeavingBackgroundEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ILeavingBackgroundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILeavingBackgroundEventArgs
    };

    // ----- ISuspendingDeferral interface --------------------
    constexpr const char* const _type_name_ISuspendingDeferral = "ISuspendingDeferral";

    static PyObject* _new_ISuspendingDeferral(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ISuspendingDeferral);
        return nullptr;
    }

    static void _dealloc_ISuspendingDeferral(py::wrapper::Windows::ApplicationModel::ISuspendingDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ISuspendingDeferral_Complete(py::wrapper::Windows::ApplicationModel::ISuspendingDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ISuspendingDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ISuspendingDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISuspendingDeferral[] = {
        { "complete", (PyCFunction)ISuspendingDeferral_Complete, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ISuspendingDeferral, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ISuspendingDeferral[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ISuspendingDeferral[] = 
    {
        { Py_tp_new, _new_ISuspendingDeferral },
        { Py_tp_dealloc, _dealloc_ISuspendingDeferral },
        { Py_tp_methods, _methods_ISuspendingDeferral },
        { Py_tp_getset, _getset_ISuspendingDeferral },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ISuspendingDeferral =
    {
        "_winrt_Windows_ApplicationModel.ISuspendingDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::ISuspendingDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISuspendingDeferral
    };

    // ----- ISuspendingEventArgs interface --------------------
    constexpr const char* const _type_name_ISuspendingEventArgs = "ISuspendingEventArgs";

    static PyObject* _new_ISuspendingEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ISuspendingEventArgs);
        return nullptr;
    }

    static void _dealloc_ISuspendingEventArgs(py::wrapper::Windows::ApplicationModel::ISuspendingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ISuspendingEventArgs_get_SuspendingOperation(py::wrapper::Windows::ApplicationModel::ISuspendingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuspendingOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ISuspendingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ISuspendingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISuspendingEventArgs[] = {
        { "_from", (PyCFunction)_from_ISuspendingEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ISuspendingEventArgs[] = {
        { const_cast<char*>("suspending_operation"), (getter)ISuspendingEventArgs_get_SuspendingOperation, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ISuspendingEventArgs[] = 
    {
        { Py_tp_new, _new_ISuspendingEventArgs },
        { Py_tp_dealloc, _dealloc_ISuspendingEventArgs },
        { Py_tp_methods, _methods_ISuspendingEventArgs },
        { Py_tp_getset, _getset_ISuspendingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ISuspendingEventArgs =
    {
        "_winrt_Windows_ApplicationModel.ISuspendingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ISuspendingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISuspendingEventArgs
    };

    // ----- ISuspendingOperation interface --------------------
    constexpr const char* const _type_name_ISuspendingOperation = "ISuspendingOperation";

    static PyObject* _new_ISuspendingOperation(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ISuspendingOperation);
        return nullptr;
    }

    static void _dealloc_ISuspendingOperation(py::wrapper::Windows::ApplicationModel::ISuspendingOperation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ISuspendingOperation_GetDeferral(py::wrapper::Windows::ApplicationModel::ISuspendingOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISuspendingOperation_get_Deadline(py::wrapper::Windows::ApplicationModel::ISuspendingOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ISuspendingOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ISuspendingOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISuspendingOperation[] = {
        { "get_deferral", (PyCFunction)ISuspendingOperation_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ISuspendingOperation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ISuspendingOperation[] = {
        { const_cast<char*>("deadline"), (getter)ISuspendingOperation_get_Deadline, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ISuspendingOperation[] = 
    {
        { Py_tp_new, _new_ISuspendingOperation },
        { Py_tp_dealloc, _dealloc_ISuspendingOperation },
        { Py_tp_methods, _methods_ISuspendingOperation },
        { Py_tp_getset, _getset_ISuspendingOperation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ISuspendingOperation =
    {
        "_winrt_Windows_ApplicationModel.ISuspendingOperation",
        sizeof(py::wrapper::Windows::ApplicationModel::ISuspendingOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISuspendingOperation
    };

    // ----- PackageInstallProgress struct --------------------
    constexpr const char* const _type_name_PackageInstallProgress = "PackageInstallProgress";

    PyObject* _new_PackageInstallProgress(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::ApplicationModel::PackageInstallProgress return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::ApplicationModel::PackageInstallProgress>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint32_t _PercentComplete{};

        static const char* kwlist[] = {"percent_complete", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "I", const_cast<char**>(kwlist), &_PercentComplete))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::ApplicationModel::PackageInstallProgress return_value{ _PercentComplete };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_PackageInstallProgress(py::wrapper::Windows::ApplicationModel::PackageInstallProgress* self)
    {
    }

    static PyObject* PackageInstallProgress_get_PercentComplete(py::wrapper::Windows::ApplicationModel::PackageInstallProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PercentComplete);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageInstallProgress_set_PercentComplete(py::wrapper::Windows::ApplicationModel::PackageInstallProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PercentComplete = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_PackageInstallProgress[] = {
        { const_cast<char*>("percent_complete"), (getter)PackageInstallProgress_get_PercentComplete, (setter)PackageInstallProgress_set_PercentComplete, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageInstallProgress[] = 
    {
        { Py_tp_new, _new_PackageInstallProgress },
        { Py_tp_dealloc, _dealloc_PackageInstallProgress },
        { Py_tp_getset, _getset_PackageInstallProgress },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageInstallProgress =
    {
        "_winrt_Windows_ApplicationModel.PackageInstallProgress",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageInstallProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageInstallProgress
    };

    // ----- PackageVersion struct --------------------
    constexpr const char* const _type_name_PackageVersion = "PackageVersion";

    PyObject* _new_PackageVersion(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::ApplicationModel::PackageVersion return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::ApplicationModel::PackageVersion>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint16_t _Major{};
        uint16_t _Minor{};
        uint16_t _Build{};
        uint16_t _Revision{};

        static const char* kwlist[] = {"major", "minor", "build", "revision", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "HHHH", const_cast<char**>(kwlist), &_Major, &_Minor, &_Build, &_Revision))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::ApplicationModel::PackageVersion return_value{ _Major, _Minor, _Build, _Revision };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_PackageVersion(py::wrapper::Windows::ApplicationModel::PackageVersion* self)
    {
    }

    static PyObject* PackageVersion_get_Major(py::wrapper::Windows::ApplicationModel::PackageVersion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Major);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageVersion_set_Major(py::wrapper::Windows::ApplicationModel::PackageVersion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Major = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PackageVersion_get_Minor(py::wrapper::Windows::ApplicationModel::PackageVersion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Minor);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageVersion_set_Minor(py::wrapper::Windows::ApplicationModel::PackageVersion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Minor = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PackageVersion_get_Build(py::wrapper::Windows::ApplicationModel::PackageVersion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Build);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageVersion_set_Build(py::wrapper::Windows::ApplicationModel::PackageVersion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Build = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PackageVersion_get_Revision(py::wrapper::Windows::ApplicationModel::PackageVersion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Revision);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageVersion_set_Revision(py::wrapper::Windows::ApplicationModel::PackageVersion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Revision = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_PackageVersion[] = {
        { const_cast<char*>("major"), (getter)PackageVersion_get_Major, (setter)PackageVersion_set_Major, nullptr, nullptr },
        { const_cast<char*>("minor"), (getter)PackageVersion_get_Minor, (setter)PackageVersion_set_Minor, nullptr, nullptr },
        { const_cast<char*>("build"), (getter)PackageVersion_get_Build, (setter)PackageVersion_set_Build, nullptr, nullptr },
        { const_cast<char*>("revision"), (getter)PackageVersion_get_Revision, (setter)PackageVersion_set_Revision, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageVersion[] = 
    {
        { Py_tp_new, _new_PackageVersion },
        { Py_tp_dealloc, _dealloc_PackageVersion },
        { Py_tp_getset, _getset_PackageVersion },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageVersion =
    {
        "_winrt_Windows_ApplicationModel.PackageVersion",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageVersion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageVersion
    };

    // ----- Windows.ApplicationModel Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::ApplicationModel::AppDisplayInfo>::python_type = py::register_python_type(module, _type_name_AppDisplayInfo, &_type_spec_AppDisplayInfo, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::AppInfo>::python_type = py::register_python_type(module, _type_name_AppInfo, &_type_spec_AppInfo, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::AppInstallerInfo>::python_type = py::register_python_type(module, _type_name_AppInstallerInfo, &_type_spec_AppInstallerInfo, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::AppInstance>::python_type = py::register_python_type(module, _type_name_AppInstance, &_type_spec_AppInstance, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DesignMode>::python_type = py::register_python_type(module, _type_name_DesignMode, &_type_spec_DesignMode, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::EnteredBackgroundEventArgs>::python_type = py::register_python_type(module, _type_name_EnteredBackgroundEventArgs, &_type_spec_EnteredBackgroundEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::LeavingBackgroundEventArgs>::python_type = py::register_python_type(module, _type_name_LeavingBackgroundEventArgs, &_type_spec_LeavingBackgroundEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::LimitedAccessFeatureRequestResult>::python_type = py::register_python_type(module, _type_name_LimitedAccessFeatureRequestResult, &_type_spec_LimitedAccessFeatureRequestResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::LimitedAccessFeatures>::python_type = py::register_python_type(module, _type_name_LimitedAccessFeatures, &_type_spec_LimitedAccessFeatures, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Package>::python_type = py::register_python_type(module, _type_name_Package, &_type_spec_Package, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalog>::python_type = py::register_python_type(module, _type_name_PackageCatalog, &_type_spec_PackageCatalog, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult>::python_type = py::register_python_type(module, _type_name_PackageCatalogAddOptionalPackageResult, &_type_spec_PackageCatalogAddOptionalPackageResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult>::python_type = py::register_python_type(module, _type_name_PackageCatalogAddResourcePackageResult, &_type_spec_PackageCatalogAddResourcePackageResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult>::python_type = py::register_python_type(module, _type_name_PackageCatalogRemoveOptionalPackagesResult, &_type_spec_PackageCatalogRemoveOptionalPackagesResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult>::python_type = py::register_python_type(module, _type_name_PackageCatalogRemoveResourcePackagesResult, &_type_spec_PackageCatalogRemoveResourcePackagesResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageContentGroup>::python_type = py::register_python_type(module, _type_name_PackageContentGroup, &_type_spec_PackageContentGroup, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageContentGroupStagingEventArgs>::python_type = py::register_python_type(module, _type_name_PackageContentGroupStagingEventArgs, &_type_spec_PackageContentGroupStagingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageId>::python_type = py::register_python_type(module, _type_name_PackageId, &_type_spec_PackageId, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageInstallingEventArgs>::python_type = py::register_python_type(module, _type_name_PackageInstallingEventArgs, &_type_spec_PackageInstallingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageStagingEventArgs>::python_type = py::register_python_type(module, _type_name_PackageStagingEventArgs, &_type_spec_PackageStagingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageStatus>::python_type = py::register_python_type(module, _type_name_PackageStatus, &_type_spec_PackageStatus, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageStatusChangedEventArgs>::python_type = py::register_python_type(module, _type_name_PackageStatusChangedEventArgs, &_type_spec_PackageStatusChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageUninstallingEventArgs>::python_type = py::register_python_type(module, _type_name_PackageUninstallingEventArgs, &_type_spec_PackageUninstallingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageUpdateAvailabilityResult>::python_type = py::register_python_type(module, _type_name_PackageUpdateAvailabilityResult, &_type_spec_PackageUpdateAvailabilityResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageUpdatingEventArgs>::python_type = py::register_python_type(module, _type_name_PackageUpdatingEventArgs, &_type_spec_PackageUpdatingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::StartupTask>::python_type = py::register_python_type(module, _type_name_StartupTask, &_type_spec_StartupTask, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::SuspendingDeferral>::python_type = py::register_python_type(module, _type_name_SuspendingDeferral, &_type_spec_SuspendingDeferral, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::SuspendingEventArgs>::python_type = py::register_python_type(module, _type_name_SuspendingEventArgs, &_type_spec_SuspendingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::SuspendingOperation>::python_type = py::register_python_type(module, _type_name_SuspendingOperation, &_type_spec_SuspendingOperation, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::IEnteredBackgroundEventArgs>::python_type = py::register_python_type(module, _type_name_IEnteredBackgroundEventArgs, &_type_spec_IEnteredBackgroundEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ILeavingBackgroundEventArgs>::python_type = py::register_python_type(module, _type_name_ILeavingBackgroundEventArgs, &_type_spec_ILeavingBackgroundEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ISuspendingDeferral>::python_type = py::register_python_type(module, _type_name_ISuspendingDeferral, &_type_spec_ISuspendingDeferral, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ISuspendingEventArgs>::python_type = py::register_python_type(module, _type_name_ISuspendingEventArgs, &_type_spec_ISuspendingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ISuspendingOperation>::python_type = py::register_python_type(module, _type_name_ISuspendingOperation, &_type_spec_ISuspendingOperation, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageInstallProgress>::python_type = py::register_python_type(module, _type_name_PackageInstallProgress, &_type_spec_PackageInstallProgress, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageVersion>::python_type = py::register_python_type(module, _type_name_PackageVersion, &_type_spec_PackageVersion, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_ApplicationModel",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::ApplicationModel

PyMODINIT_FUNC
PyInit__winrt_Windows_ApplicationModel (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::ApplicationModel::module_def);
}
