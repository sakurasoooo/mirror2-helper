// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Devices.Display.Core.h"

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayAdapter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayDevice>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayFence>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerResultWithState>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayModeInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayPath>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayScanout>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplaySource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayState>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayStateOperationResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplaySurface>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayTarget>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayTask>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayTaskPool>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayTaskResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayView>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayWireFormat>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>::python_type;

PyObject* py::converter<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>::convert(winrt::Windows::Devices::Display::Core::DisplayPresentationRate instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>());
}
winrt::Windows::Devices::Display::Core::DisplayPresentationRate py::converter<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Devices::Display::Core::DisplayPresentationRate return_value{};

    PyObject* py_VerticalSyncRate = PyDict_GetItemString(obj, "vertical_sync_rate");
    if (!py_VerticalSyncRate) { throw winrt::hresult_invalid_argument(); }
    return_value.VerticalSyncRate = converter<winrt::Windows::Foundation::Numerics::Rational>::convert_to(py_VerticalSyncRate);

    PyObject* py_VerticalSyncsPerPresentation = PyDict_GetItemString(obj, "vertical_syncs_per_presentation");
    if (!py_VerticalSyncsPerPresentation) { throw winrt::hresult_invalid_argument(); }
    return_value.VerticalSyncsPerPresentation = converter<int32_t>::convert_to(py_VerticalSyncsPerPresentation);

    return return_value;
}

namespace py::cpp::Windows::Devices::Display::Core
{
    // ----- DisplayAdapter class --------------------
    constexpr const char* const _type_name_DisplayAdapter = "DisplayAdapter";

    static PyObject* _new_DisplayAdapter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayAdapter);
        return nullptr;
    }

    static void _dealloc_DisplayAdapter(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayAdapter_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DisplayAdapterId>(args, 0);

                return py::convert(winrt::Windows::Devices::Display::Core::DisplayAdapter::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_DeviceInterfacePath(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceInterfacePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_Id(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_PciDeviceId(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PciDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_PciRevision(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PciRevision());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_PciSubSystemId(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PciSubSystemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_PciVendorId(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PciVendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_SourceCount(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayAdapter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayAdapter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayAdapter[] = {
        { "from_id", (PyCFunction)DisplayAdapter_FromId, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_DisplayAdapter, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplayAdapter[] = {
        { const_cast<char*>("device_interface_path"), (getter)DisplayAdapter_get_DeviceInterfacePath, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)DisplayAdapter_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("pci_device_id"), (getter)DisplayAdapter_get_PciDeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("pci_revision"), (getter)DisplayAdapter_get_PciRevision, nullptr, nullptr, nullptr },
        { const_cast<char*>("pci_sub_system_id"), (getter)DisplayAdapter_get_PciSubSystemId, nullptr, nullptr, nullptr },
        { const_cast<char*>("pci_vendor_id"), (getter)DisplayAdapter_get_PciVendorId, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)DisplayAdapter_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("source_count"), (getter)DisplayAdapter_get_SourceCount, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayAdapter[] = 
    {
        { Py_tp_new, _new_DisplayAdapter },
        { Py_tp_dealloc, _dealloc_DisplayAdapter },
        { Py_tp_methods, _methods_DisplayAdapter },
        { Py_tp_getset, _getset_DisplayAdapter },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayAdapter =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayAdapter",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayAdapter
    };

    // ----- DisplayDevice class --------------------
    constexpr const char* const _type_name_DisplayDevice = "DisplayDevice";

    static PyObject* _new_DisplayDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayDevice);
        return nullptr;
    }

    static void _dealloc_DisplayDevice(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayDevice_CreatePeriodicFence(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(self->obj.CreatePeriodicFence(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_CreatePrimary(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription>(args, 1);

                return py::convert(self->obj.CreatePrimary(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_CreateScanoutSource(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.CreateScanoutSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_CreateSimpleScanout(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplaySource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplaySurface>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                return py::convert(self->obj.CreateSimpleScanout(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_CreateSimpleScanoutWithDirtyRectsAndOptions(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplaySource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplaySurface>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Graphics::RectInt32>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayScanoutOptions>(args, 5);

                return py::convert(self->obj.CreateSimpleScanoutWithDirtyRectsAndOptions(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_CreateTaskPool(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateTaskPool());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_IsCapabilitySupported(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayDeviceCapability>(args, 0);

                return py::convert(self->obj.IsCapabilitySupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_WaitForVBlank(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplaySource>(args, 0);

                self->obj.WaitForVBlank(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_DisplayDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayDevice[] = {
        { "create_periodic_fence", (PyCFunction)DisplayDevice_CreatePeriodicFence, METH_VARARGS, nullptr },
        { "create_primary", (PyCFunction)DisplayDevice_CreatePrimary, METH_VARARGS, nullptr },
        { "create_scanout_source", (PyCFunction)DisplayDevice_CreateScanoutSource, METH_VARARGS, nullptr },
        { "create_simple_scanout", (PyCFunction)DisplayDevice_CreateSimpleScanout, METH_VARARGS, nullptr },
        { "create_simple_scanout_with_dirty_rects_and_options", (PyCFunction)DisplayDevice_CreateSimpleScanoutWithDirtyRectsAndOptions, METH_VARARGS, nullptr },
        { "create_task_pool", (PyCFunction)DisplayDevice_CreateTaskPool, METH_VARARGS, nullptr },
        { "is_capability_supported", (PyCFunction)DisplayDevice_IsCapabilitySupported, METH_VARARGS, nullptr },
        { "wait_for_v_blank", (PyCFunction)DisplayDevice_WaitForVBlank, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DisplayDevice, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplayDevice[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayDevice[] = 
    {
        { Py_tp_new, _new_DisplayDevice },
        { Py_tp_dealloc, _dealloc_DisplayDevice },
        { Py_tp_methods, _methods_DisplayDevice },
        { Py_tp_getset, _getset_DisplayDevice },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayDevice =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayDevice",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayDevice
    };

    // ----- DisplayFence class --------------------
    constexpr const char* const _type_name_DisplayFence = "DisplayFence";

    static PyObject* _new_DisplayFence(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayFence);
        return nullptr;
    }

    static void _dealloc_DisplayFence(py::wrapper::Windows::Devices::Display::Core::DisplayFence* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_DisplayFence(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayFence>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayFence[] = {
        { "_from", (PyCFunction)_from_DisplayFence, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplayFence[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayFence[] = 
    {
        { Py_tp_new, _new_DisplayFence },
        { Py_tp_dealloc, _dealloc_DisplayFence },
        { Py_tp_methods, _methods_DisplayFence },
        { Py_tp_getset, _getset_DisplayFence },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayFence =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayFence",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayFence),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayFence
    };

    // ----- DisplayManager class --------------------
    constexpr const char* const _type_name_DisplayManager = "DisplayManager";

    static PyObject* _new_DisplayManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayManager);
        return nullptr;
    }

    static void _dealloc_DisplayManager(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayManager_Close(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayManagerOptions>(args, 0);

                return py::convert(winrt::Windows::Devices::Display::Core::DisplayManager::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_CreateDisplayDevice(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayAdapter>(args, 0);

                return py::convert(self->obj.CreateDisplayDevice(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_GetCurrentAdapters(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentAdapters());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_GetCurrentTargets(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentTargets());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_ReleaseTarget(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                self->obj.ReleaseTarget(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_Start(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_Stop(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_TryAcquireTarget(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.TryAcquireTarget(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_TryAcquireTargetsAndCreateEmptyState(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Display::Core::DisplayTarget>>(args, 0);

                return py::convert(self->obj.TryAcquireTargetsAndCreateEmptyState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_TryAcquireTargetsAndCreateSubstate(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayState>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Display::Core::DisplayTarget>>(args, 1);

                return py::convert(self->obj.TryAcquireTargetsAndCreateSubstate(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_TryAcquireTargetsAndReadCurrentState(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Display::Core::DisplayTarget>>(args, 0);

                return py::convert(self->obj.TryAcquireTargetsAndReadCurrentState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_TryReadCurrentStateForAllTargets(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryReadCurrentStateForAllTargets());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_add_Changed(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Display::Core::DisplayManager, winrt::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs>>(arg);

            return py::convert(self->obj.Changed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_remove_Changed(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Changed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_add_Disabled(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Display::Core::DisplayManager, winrt::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs>>(arg);

            return py::convert(self->obj.Disabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_remove_Disabled(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Disabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_add_Enabled(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Display::Core::DisplayManager, winrt::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs>>(arg);

            return py::convert(self->obj.Enabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_remove_Enabled(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Enabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_add_PathsFailedOrInvalidated(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Display::Core::DisplayManager, winrt::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs>>(arg);

            return py::convert(self->obj.PathsFailedOrInvalidated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_remove_PathsFailedOrInvalidated(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PathsFailedOrInvalidated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_DisplayManager(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_DisplayManager(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManager[] = {
        { "close", (PyCFunction)DisplayManager_Close, METH_VARARGS, nullptr },
        { "create", (PyCFunction)DisplayManager_Create, METH_VARARGS | METH_STATIC, nullptr },
        { "create_display_device", (PyCFunction)DisplayManager_CreateDisplayDevice, METH_VARARGS, nullptr },
        { "get_current_adapters", (PyCFunction)DisplayManager_GetCurrentAdapters, METH_VARARGS, nullptr },
        { "get_current_targets", (PyCFunction)DisplayManager_GetCurrentTargets, METH_VARARGS, nullptr },
        { "release_target", (PyCFunction)DisplayManager_ReleaseTarget, METH_VARARGS, nullptr },
        { "start", (PyCFunction)DisplayManager_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)DisplayManager_Stop, METH_VARARGS, nullptr },
        { "try_acquire_target", (PyCFunction)DisplayManager_TryAcquireTarget, METH_VARARGS, nullptr },
        { "try_acquire_targets_and_create_empty_state", (PyCFunction)DisplayManager_TryAcquireTargetsAndCreateEmptyState, METH_VARARGS, nullptr },
        { "try_acquire_targets_and_create_substate", (PyCFunction)DisplayManager_TryAcquireTargetsAndCreateSubstate, METH_VARARGS, nullptr },
        { "try_acquire_targets_and_read_current_state", (PyCFunction)DisplayManager_TryAcquireTargetsAndReadCurrentState, METH_VARARGS, nullptr },
        { "try_read_current_state_for_all_targets", (PyCFunction)DisplayManager_TryReadCurrentStateForAllTargets, METH_VARARGS, nullptr },
        { "add_changed", (PyCFunction)DisplayManager_add_Changed, METH_O, nullptr },
        { "remove_changed", (PyCFunction)DisplayManager_remove_Changed, METH_O, nullptr },
        { "add_disabled", (PyCFunction)DisplayManager_add_Disabled, METH_O, nullptr },
        { "remove_disabled", (PyCFunction)DisplayManager_remove_Disabled, METH_O, nullptr },
        { "add_enabled", (PyCFunction)DisplayManager_add_Enabled, METH_O, nullptr },
        { "remove_enabled", (PyCFunction)DisplayManager_remove_Enabled, METH_O, nullptr },
        { "add_paths_failed_or_invalidated", (PyCFunction)DisplayManager_add_PathsFailedOrInvalidated, METH_O, nullptr },
        { "remove_paths_failed_or_invalidated", (PyCFunction)DisplayManager_remove_PathsFailedOrInvalidated, METH_O, nullptr },
        { "_from", (PyCFunction)_from_DisplayManager, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_DisplayManager, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_DisplayManager, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplayManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayManager[] = 
    {
        { Py_tp_new, _new_DisplayManager },
        { Py_tp_dealloc, _dealloc_DisplayManager },
        { Py_tp_methods, _methods_DisplayManager },
        { Py_tp_getset, _getset_DisplayManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayManager =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayManager",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManager
    };

    // ----- DisplayManagerChangedEventArgs class --------------------
    constexpr const char* const _type_name_DisplayManagerChangedEventArgs = "DisplayManagerChangedEventArgs";

    static PyObject* _new_DisplayManagerChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayManagerChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_DisplayManagerChangedEventArgs(py::wrapper::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayManagerChangedEventArgs_GetDeferral(py::wrapper::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManagerChangedEventArgs_get_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayManagerChangedEventArgs_put_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_DisplayManagerChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManagerChangedEventArgs[] = {
        { "get_deferral", (PyCFunction)DisplayManagerChangedEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DisplayManagerChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplayManagerChangedEventArgs[] = {
        { const_cast<char*>("handled"), (getter)DisplayManagerChangedEventArgs_get_Handled, (setter)DisplayManagerChangedEventArgs_put_Handled, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayManagerChangedEventArgs[] = 
    {
        { Py_tp_new, _new_DisplayManagerChangedEventArgs },
        { Py_tp_dealloc, _dealloc_DisplayManagerChangedEventArgs },
        { Py_tp_methods, _methods_DisplayManagerChangedEventArgs },
        { Py_tp_getset, _getset_DisplayManagerChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayManagerChangedEventArgs =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayManagerChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManagerChangedEventArgs
    };

    // ----- DisplayManagerDisabledEventArgs class --------------------
    constexpr const char* const _type_name_DisplayManagerDisabledEventArgs = "DisplayManagerDisabledEventArgs";

    static PyObject* _new_DisplayManagerDisabledEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayManagerDisabledEventArgs);
        return nullptr;
    }

    static void _dealloc_DisplayManagerDisabledEventArgs(py::wrapper::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayManagerDisabledEventArgs_GetDeferral(py::wrapper::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManagerDisabledEventArgs_get_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayManagerDisabledEventArgs_put_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_DisplayManagerDisabledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManagerDisabledEventArgs[] = {
        { "get_deferral", (PyCFunction)DisplayManagerDisabledEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DisplayManagerDisabledEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplayManagerDisabledEventArgs[] = {
        { const_cast<char*>("handled"), (getter)DisplayManagerDisabledEventArgs_get_Handled, (setter)DisplayManagerDisabledEventArgs_put_Handled, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayManagerDisabledEventArgs[] = 
    {
        { Py_tp_new, _new_DisplayManagerDisabledEventArgs },
        { Py_tp_dealloc, _dealloc_DisplayManagerDisabledEventArgs },
        { Py_tp_methods, _methods_DisplayManagerDisabledEventArgs },
        { Py_tp_getset, _getset_DisplayManagerDisabledEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayManagerDisabledEventArgs =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayManagerDisabledEventArgs",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManagerDisabledEventArgs
    };

    // ----- DisplayManagerEnabledEventArgs class --------------------
    constexpr const char* const _type_name_DisplayManagerEnabledEventArgs = "DisplayManagerEnabledEventArgs";

    static PyObject* _new_DisplayManagerEnabledEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayManagerEnabledEventArgs);
        return nullptr;
    }

    static void _dealloc_DisplayManagerEnabledEventArgs(py::wrapper::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayManagerEnabledEventArgs_GetDeferral(py::wrapper::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManagerEnabledEventArgs_get_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayManagerEnabledEventArgs_put_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_DisplayManagerEnabledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManagerEnabledEventArgs[] = {
        { "get_deferral", (PyCFunction)DisplayManagerEnabledEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DisplayManagerEnabledEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplayManagerEnabledEventArgs[] = {
        { const_cast<char*>("handled"), (getter)DisplayManagerEnabledEventArgs_get_Handled, (setter)DisplayManagerEnabledEventArgs_put_Handled, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayManagerEnabledEventArgs[] = 
    {
        { Py_tp_new, _new_DisplayManagerEnabledEventArgs },
        { Py_tp_dealloc, _dealloc_DisplayManagerEnabledEventArgs },
        { Py_tp_methods, _methods_DisplayManagerEnabledEventArgs },
        { Py_tp_getset, _getset_DisplayManagerEnabledEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayManagerEnabledEventArgs =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayManagerEnabledEventArgs",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManagerEnabledEventArgs
    };

    // ----- DisplayManagerPathsFailedOrInvalidatedEventArgs class --------------------
    constexpr const char* const _type_name_DisplayManagerPathsFailedOrInvalidatedEventArgs = "DisplayManagerPathsFailedOrInvalidatedEventArgs";

    static PyObject* _new_DisplayManagerPathsFailedOrInvalidatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayManagerPathsFailedOrInvalidatedEventArgs);
        return nullptr;
    }

    static void _dealloc_DisplayManagerPathsFailedOrInvalidatedEventArgs(py::wrapper::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayManagerPathsFailedOrInvalidatedEventArgs_GetDeferral(py::wrapper::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManagerPathsFailedOrInvalidatedEventArgs_get_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayManagerPathsFailedOrInvalidatedEventArgs_put_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_DisplayManagerPathsFailedOrInvalidatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManagerPathsFailedOrInvalidatedEventArgs[] = {
        { "get_deferral", (PyCFunction)DisplayManagerPathsFailedOrInvalidatedEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DisplayManagerPathsFailedOrInvalidatedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplayManagerPathsFailedOrInvalidatedEventArgs[] = {
        { const_cast<char*>("handled"), (getter)DisplayManagerPathsFailedOrInvalidatedEventArgs_get_Handled, (setter)DisplayManagerPathsFailedOrInvalidatedEventArgs_put_Handled, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayManagerPathsFailedOrInvalidatedEventArgs[] = 
    {
        { Py_tp_new, _new_DisplayManagerPathsFailedOrInvalidatedEventArgs },
        { Py_tp_dealloc, _dealloc_DisplayManagerPathsFailedOrInvalidatedEventArgs },
        { Py_tp_methods, _methods_DisplayManagerPathsFailedOrInvalidatedEventArgs },
        { Py_tp_getset, _getset_DisplayManagerPathsFailedOrInvalidatedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayManagerPathsFailedOrInvalidatedEventArgs =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayManagerPathsFailedOrInvalidatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManagerPathsFailedOrInvalidatedEventArgs
    };

    // ----- DisplayManagerResultWithState class --------------------
    constexpr const char* const _type_name_DisplayManagerResultWithState = "DisplayManagerResultWithState";

    static PyObject* _new_DisplayManagerResultWithState(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayManagerResultWithState);
        return nullptr;
    }

    static void _dealloc_DisplayManagerResultWithState(py::wrapper::Windows::Devices::Display::Core::DisplayManagerResultWithState* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayManagerResultWithState_get_ErrorCode(py::wrapper::Windows::Devices::Display::Core::DisplayManagerResultWithState* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManagerResultWithState_get_ExtendedErrorCode(py::wrapper::Windows::Devices::Display::Core::DisplayManagerResultWithState* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManagerResultWithState_get_State(py::wrapper::Windows::Devices::Display::Core::DisplayManagerResultWithState* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayManagerResultWithState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManagerResultWithState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManagerResultWithState[] = {
        { "_from", (PyCFunction)_from_DisplayManagerResultWithState, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplayManagerResultWithState[] = {
        { const_cast<char*>("error_code"), (getter)DisplayManagerResultWithState_get_ErrorCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_error_code"), (getter)DisplayManagerResultWithState_get_ExtendedErrorCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("state"), (getter)DisplayManagerResultWithState_get_State, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayManagerResultWithState[] = 
    {
        { Py_tp_new, _new_DisplayManagerResultWithState },
        { Py_tp_dealloc, _dealloc_DisplayManagerResultWithState },
        { Py_tp_methods, _methods_DisplayManagerResultWithState },
        { Py_tp_getset, _getset_DisplayManagerResultWithState },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayManagerResultWithState =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayManagerResultWithState",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManagerResultWithState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManagerResultWithState
    };

    // ----- DisplayModeInfo class --------------------
    constexpr const char* const _type_name_DisplayModeInfo = "DisplayModeInfo";

    static PyObject* _new_DisplayModeInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayModeInfo);
        return nullptr;
    }

    static void _dealloc_DisplayModeInfo(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayModeInfo_GetWireFormatSupportedBitsPerChannel(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatPixelEncoding>(args, 0);

                return py::convert(self->obj.GetWireFormatSupportedBitsPerChannel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_IsWireFormatSupported(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormat>(args, 0);

                return py::convert(self->obj.IsWireFormatSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_IsInterlaced(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInterlaced());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_IsStereo(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStereo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_PresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PresentationRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_SourcePixelFormat(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourcePixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_SourceResolution(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_TargetResolution(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TargetResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_PhysicalPresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhysicalPresentationRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayModeInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayModeInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayModeInfo[] = {
        { "get_wire_format_supported_bits_per_channel", (PyCFunction)DisplayModeInfo_GetWireFormatSupportedBitsPerChannel, METH_VARARGS, nullptr },
        { "is_wire_format_supported", (PyCFunction)DisplayModeInfo_IsWireFormatSupported, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DisplayModeInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplayModeInfo[] = {
        { const_cast<char*>("is_interlaced"), (getter)DisplayModeInfo_get_IsInterlaced, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_stereo"), (getter)DisplayModeInfo_get_IsStereo, nullptr, nullptr, nullptr },
        { const_cast<char*>("presentation_rate"), (getter)DisplayModeInfo_get_PresentationRate, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)DisplayModeInfo_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("source_pixel_format"), (getter)DisplayModeInfo_get_SourcePixelFormat, nullptr, nullptr, nullptr },
        { const_cast<char*>("source_resolution"), (getter)DisplayModeInfo_get_SourceResolution, nullptr, nullptr, nullptr },
        { const_cast<char*>("target_resolution"), (getter)DisplayModeInfo_get_TargetResolution, nullptr, nullptr, nullptr },
        { const_cast<char*>("physical_presentation_rate"), (getter)DisplayModeInfo_get_PhysicalPresentationRate, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayModeInfo[] = 
    {
        { Py_tp_new, _new_DisplayModeInfo },
        { Py_tp_dealloc, _dealloc_DisplayModeInfo },
        { Py_tp_methods, _methods_DisplayModeInfo },
        { Py_tp_getset, _getset_DisplayModeInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayModeInfo =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayModeInfo",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayModeInfo
    };

    // ----- DisplayPath class --------------------
    constexpr const char* const _type_name_DisplayPath = "DisplayPath";

    static PyObject* _new_DisplayPath(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayPath);
        return nullptr;
    }

    static void _dealloc_DisplayPath(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayPath_ApplyPropertiesFromMode(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayModeInfo>(args, 0);

                self->obj.ApplyPropertiesFromMode(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayPath_FindModes(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayModeQueryOptions>(args, 0);

                return py::convert(self->obj.FindModes(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayPath_get_WireFormat(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WireFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_WireFormat(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormat>(arg);

            self->obj.WireFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_TargetResolution(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TargetResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_TargetResolution(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Graphics::SizeInt32>>(arg);

            self->obj.TargetResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_SourceResolution(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_SourceResolution(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Graphics::SizeInt32>>(arg);

            self->obj.SourceResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_SourcePixelFormat(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourcePixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_SourcePixelFormat(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(arg);

            self->obj.SourcePixelFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_Scaling(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Scaling());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_Scaling(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayPathScaling>(arg);

            self->obj.Scaling(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_Rotation(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Rotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_Rotation(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayRotation>(arg);

            self->obj.Rotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_PresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PresentationRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_PresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>>(arg);

            self->obj.PresentationRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_IsStereo(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStereo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_IsStereo(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsStereo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_IsInterlaced(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInterlaced());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_IsInterlaced(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.IsInterlaced(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPath_get_Status(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPath_get_Target(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Target());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPath_get_View(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.View());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPath_get_PhysicalPresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhysicalPresentationRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_PhysicalPresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>>(arg);

            self->obj.PhysicalPresentationRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_DisplayPath(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayPath>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayPath[] = {
        { "apply_properties_from_mode", (PyCFunction)DisplayPath_ApplyPropertiesFromMode, METH_VARARGS, nullptr },
        { "find_modes", (PyCFunction)DisplayPath_FindModes, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DisplayPath, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplayPath[] = {
        { const_cast<char*>("wire_format"), (getter)DisplayPath_get_WireFormat, (setter)DisplayPath_put_WireFormat, nullptr, nullptr },
        { const_cast<char*>("target_resolution"), (getter)DisplayPath_get_TargetResolution, (setter)DisplayPath_put_TargetResolution, nullptr, nullptr },
        { const_cast<char*>("source_resolution"), (getter)DisplayPath_get_SourceResolution, (setter)DisplayPath_put_SourceResolution, nullptr, nullptr },
        { const_cast<char*>("source_pixel_format"), (getter)DisplayPath_get_SourcePixelFormat, (setter)DisplayPath_put_SourcePixelFormat, nullptr, nullptr },
        { const_cast<char*>("scaling"), (getter)DisplayPath_get_Scaling, (setter)DisplayPath_put_Scaling, nullptr, nullptr },
        { const_cast<char*>("rotation"), (getter)DisplayPath_get_Rotation, (setter)DisplayPath_put_Rotation, nullptr, nullptr },
        { const_cast<char*>("presentation_rate"), (getter)DisplayPath_get_PresentationRate, (setter)DisplayPath_put_PresentationRate, nullptr, nullptr },
        { const_cast<char*>("is_stereo"), (getter)DisplayPath_get_IsStereo, (setter)DisplayPath_put_IsStereo, nullptr, nullptr },
        { const_cast<char*>("is_interlaced"), (getter)DisplayPath_get_IsInterlaced, (setter)DisplayPath_put_IsInterlaced, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)DisplayPath_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)DisplayPath_get_Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("target"), (getter)DisplayPath_get_Target, nullptr, nullptr, nullptr },
        { const_cast<char*>("view"), (getter)DisplayPath_get_View, nullptr, nullptr, nullptr },
        { const_cast<char*>("physical_presentation_rate"), (getter)DisplayPath_get_PhysicalPresentationRate, (setter)DisplayPath_put_PhysicalPresentationRate, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayPath[] = 
    {
        { Py_tp_new, _new_DisplayPath },
        { Py_tp_dealloc, _dealloc_DisplayPath },
        { Py_tp_methods, _methods_DisplayPath },
        { Py_tp_getset, _getset_DisplayPath },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayPath =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayPath",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayPath),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayPath
    };

    // ----- DisplayPrimaryDescription class --------------------
    constexpr const char* const _type_name_DisplayPrimaryDescription = "DisplayPrimaryDescription";

    static PyObject* _new_DisplayPrimaryDescription(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXColorSpace>(args, 3);
                auto param4 = py::convert_to<bool>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::Direct3DMultisampleDescription>(args, 5);

                winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription instance{ param0, param1, param2, param3, param4, param5 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DisplayPrimaryDescription(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayPrimaryDescription_CreateWithProperties(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::guid, winrt::Windows::Foundation::IInspectable>>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXColorSpace>(args, 4);
                auto param5 = py::convert_to<bool>(args, 5);
                auto param6 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::Direct3DMultisampleDescription>(args, 6);

                return py::convert(winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription::CreateWithProperties(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_ColorSpace(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorSpace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_Format(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_Height(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_IsStereo(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStereo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_MultisampleDescription(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MultisampleDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_Width(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayPrimaryDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayPrimaryDescription[] = {
        { "create_with_properties", (PyCFunction)DisplayPrimaryDescription_CreateWithProperties, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_DisplayPrimaryDescription, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplayPrimaryDescription[] = {
        { const_cast<char*>("color_space"), (getter)DisplayPrimaryDescription_get_ColorSpace, nullptr, nullptr, nullptr },
        { const_cast<char*>("format"), (getter)DisplayPrimaryDescription_get_Format, nullptr, nullptr, nullptr },
        { const_cast<char*>("height"), (getter)DisplayPrimaryDescription_get_Height, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_stereo"), (getter)DisplayPrimaryDescription_get_IsStereo, nullptr, nullptr, nullptr },
        { const_cast<char*>("multisample_description"), (getter)DisplayPrimaryDescription_get_MultisampleDescription, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)DisplayPrimaryDescription_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("width"), (getter)DisplayPrimaryDescription_get_Width, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayPrimaryDescription[] = 
    {
        { Py_tp_new, _new_DisplayPrimaryDescription },
        { Py_tp_dealloc, _dealloc_DisplayPrimaryDescription },
        { Py_tp_methods, _methods_DisplayPrimaryDescription },
        { Py_tp_getset, _getset_DisplayPrimaryDescription },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayPrimaryDescription =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayPrimaryDescription",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayPrimaryDescription
    };

    // ----- DisplayScanout class --------------------
    constexpr const char* const _type_name_DisplayScanout = "DisplayScanout";

    static PyObject* _new_DisplayScanout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayScanout);
        return nullptr;
    }

    static void _dealloc_DisplayScanout(py::wrapper::Windows::Devices::Display::Core::DisplayScanout* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_DisplayScanout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayScanout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayScanout[] = {
        { "_from", (PyCFunction)_from_DisplayScanout, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplayScanout[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayScanout[] = 
    {
        { Py_tp_new, _new_DisplayScanout },
        { Py_tp_dealloc, _dealloc_DisplayScanout },
        { Py_tp_methods, _methods_DisplayScanout },
        { Py_tp_getset, _getset_DisplayScanout },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayScanout =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayScanout",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayScanout),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayScanout
    };

    // ----- DisplaySource class --------------------
    constexpr const char* const _type_name_DisplaySource = "DisplaySource";

    static PyObject* _new_DisplaySource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplaySource);
        return nullptr;
    }

    static void _dealloc_DisplaySource(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplaySource_GetMetadata(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.GetMetadata(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplaySource_get_AdapterId(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdapterId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplaySource_get_SourceId(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplaySource_get_Status(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplaySource_add_StatusChanged(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Display::Core::DisplaySource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplaySource_remove_StatusChanged(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplaySource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplaySource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplaySource[] = {
        { "get_metadata", (PyCFunction)DisplaySource_GetMetadata, METH_VARARGS, nullptr },
        { "add_status_changed", (PyCFunction)DisplaySource_add_StatusChanged, METH_O, nullptr },
        { "remove_status_changed", (PyCFunction)DisplaySource_remove_StatusChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_DisplaySource, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplaySource[] = {
        { const_cast<char*>("adapter_id"), (getter)DisplaySource_get_AdapterId, nullptr, nullptr, nullptr },
        { const_cast<char*>("source_id"), (getter)DisplaySource_get_SourceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)DisplaySource_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplaySource[] = 
    {
        { Py_tp_new, _new_DisplaySource },
        { Py_tp_dealloc, _dealloc_DisplaySource },
        { Py_tp_methods, _methods_DisplaySource },
        { Py_tp_getset, _getset_DisplaySource },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplaySource =
    {
        "_winrt_Windows_Devices_Display_Core.DisplaySource",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplaySource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplaySource
    };

    // ----- DisplayState class --------------------
    constexpr const char* const _type_name_DisplayState = "DisplayState";

    static PyObject* _new_DisplayState(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayState);
        return nullptr;
    }

    static void _dealloc_DisplayState(py::wrapper::Windows::Devices::Display::Core::DisplayState* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayState_CanConnectTargetToView(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayView>(args, 1);

                return py::convert(self->obj.CanConnectTargetToView(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_Clone(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Clone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_ConnectTarget(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.ConnectTarget(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayView>(args, 1);

                return py::convert(self->obj.ConnectTarget(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_DisconnectTarget(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                self->obj.DisconnectTarget(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_GetPathForTarget(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.GetPathForTarget(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_GetViewForTarget(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.GetViewForTarget(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_TryApply(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayStateApplyOptions>(args, 0);

                return py::convert(self->obj.TryApply(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_TryFunctionalize(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayStateFunctionalizeOptions>(args, 0);

                return py::convert(self->obj.TryFunctionalize(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_get_IsReadOnly(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayState_get_IsStale(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayState_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayState_get_Targets(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Targets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayState_get_Views(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Views());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayState[] = {
        { "can_connect_target_to_view", (PyCFunction)DisplayState_CanConnectTargetToView, METH_VARARGS, nullptr },
        { "clone", (PyCFunction)DisplayState_Clone, METH_VARARGS, nullptr },
        { "connect_target", (PyCFunction)DisplayState_ConnectTarget, METH_VARARGS, nullptr },
        { "disconnect_target", (PyCFunction)DisplayState_DisconnectTarget, METH_VARARGS, nullptr },
        { "get_path_for_target", (PyCFunction)DisplayState_GetPathForTarget, METH_VARARGS, nullptr },
        { "get_view_for_target", (PyCFunction)DisplayState_GetViewForTarget, METH_VARARGS, nullptr },
        { "try_apply", (PyCFunction)DisplayState_TryApply, METH_VARARGS, nullptr },
        { "try_functionalize", (PyCFunction)DisplayState_TryFunctionalize, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DisplayState, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplayState[] = {
        { const_cast<char*>("is_read_only"), (getter)DisplayState_get_IsReadOnly, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_stale"), (getter)DisplayState_get_IsStale, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)DisplayState_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("targets"), (getter)DisplayState_get_Targets, nullptr, nullptr, nullptr },
        { const_cast<char*>("views"), (getter)DisplayState_get_Views, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayState[] = 
    {
        { Py_tp_new, _new_DisplayState },
        { Py_tp_dealloc, _dealloc_DisplayState },
        { Py_tp_methods, _methods_DisplayState },
        { Py_tp_getset, _getset_DisplayState },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayState =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayState",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayState
    };

    // ----- DisplayStateOperationResult class --------------------
    constexpr const char* const _type_name_DisplayStateOperationResult = "DisplayStateOperationResult";

    static PyObject* _new_DisplayStateOperationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayStateOperationResult);
        return nullptr;
    }

    static void _dealloc_DisplayStateOperationResult(py::wrapper::Windows::Devices::Display::Core::DisplayStateOperationResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayStateOperationResult_get_ExtendedErrorCode(py::wrapper::Windows::Devices::Display::Core::DisplayStateOperationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayStateOperationResult_get_Status(py::wrapper::Windows::Devices::Display::Core::DisplayStateOperationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayStateOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayStateOperationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayStateOperationResult[] = {
        { "_from", (PyCFunction)_from_DisplayStateOperationResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplayStateOperationResult[] = {
        { const_cast<char*>("extended_error_code"), (getter)DisplayStateOperationResult_get_ExtendedErrorCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)DisplayStateOperationResult_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayStateOperationResult[] = 
    {
        { Py_tp_new, _new_DisplayStateOperationResult },
        { Py_tp_dealloc, _dealloc_DisplayStateOperationResult },
        { Py_tp_methods, _methods_DisplayStateOperationResult },
        { Py_tp_getset, _getset_DisplayStateOperationResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayStateOperationResult =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayStateOperationResult",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayStateOperationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayStateOperationResult
    };

    // ----- DisplaySurface class --------------------
    constexpr const char* const _type_name_DisplaySurface = "DisplaySurface";

    static PyObject* _new_DisplaySurface(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplaySurface);
        return nullptr;
    }

    static void _dealloc_DisplaySurface(py::wrapper::Windows::Devices::Display::Core::DisplaySurface* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_DisplaySurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplaySurface>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplaySurface[] = {
        { "_from", (PyCFunction)_from_DisplaySurface, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplaySurface[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplaySurface[] = 
    {
        { Py_tp_new, _new_DisplaySurface },
        { Py_tp_dealloc, _dealloc_DisplaySurface },
        { Py_tp_methods, _methods_DisplaySurface },
        { Py_tp_getset, _getset_DisplaySurface },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplaySurface =
    {
        "_winrt_Windows_Devices_Display_Core.DisplaySurface",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplaySurface),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplaySurface
    };

    // ----- DisplayTarget class --------------------
    constexpr const char* const _type_name_DisplayTarget = "DisplayTarget";

    static PyObject* _new_DisplayTarget(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayTarget);
        return nullptr;
    }

    static void _dealloc_DisplayTarget(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayTarget_IsEqual(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_IsSame(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.IsSame(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_TryGetMonitor(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryGetMonitor());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_Adapter(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Adapter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_AdapterRelativeId(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdapterRelativeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_DeviceInterfacePath(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceInterfacePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_IsConnected(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_IsStale(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_IsVirtualModeEnabled(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVirtualModeEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_IsVirtualTopologyEnabled(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVirtualTopologyEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_MonitorPersistence(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MonitorPersistence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_StableMonitorId(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StableMonitorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_UsageKind(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UsageKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayTarget>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayTarget[] = {
        { "is_equal", (PyCFunction)DisplayTarget_IsEqual, METH_VARARGS, nullptr },
        { "is_same", (PyCFunction)DisplayTarget_IsSame, METH_VARARGS, nullptr },
        { "try_get_monitor", (PyCFunction)DisplayTarget_TryGetMonitor, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DisplayTarget, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplayTarget[] = {
        { const_cast<char*>("adapter"), (getter)DisplayTarget_get_Adapter, nullptr, nullptr, nullptr },
        { const_cast<char*>("adapter_relative_id"), (getter)DisplayTarget_get_AdapterRelativeId, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_interface_path"), (getter)DisplayTarget_get_DeviceInterfacePath, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_connected"), (getter)DisplayTarget_get_IsConnected, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_stale"), (getter)DisplayTarget_get_IsStale, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_virtual_mode_enabled"), (getter)DisplayTarget_get_IsVirtualModeEnabled, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_virtual_topology_enabled"), (getter)DisplayTarget_get_IsVirtualTopologyEnabled, nullptr, nullptr, nullptr },
        { const_cast<char*>("monitor_persistence"), (getter)DisplayTarget_get_MonitorPersistence, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)DisplayTarget_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("stable_monitor_id"), (getter)DisplayTarget_get_StableMonitorId, nullptr, nullptr, nullptr },
        { const_cast<char*>("usage_kind"), (getter)DisplayTarget_get_UsageKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayTarget[] = 
    {
        { Py_tp_new, _new_DisplayTarget },
        { Py_tp_dealloc, _dealloc_DisplayTarget },
        { Py_tp_methods, _methods_DisplayTarget },
        { Py_tp_getset, _getset_DisplayTarget },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayTarget =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayTarget",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayTarget),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayTarget
    };

    // ----- DisplayTask class --------------------
    constexpr const char* const _type_name_DisplayTask = "DisplayTask";

    static PyObject* _new_DisplayTask(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayTask);
        return nullptr;
    }

    static void _dealloc_DisplayTask(py::wrapper::Windows::Devices::Display::Core::DisplayTask* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayTask_SetScanout(py::wrapper::Windows::Devices::Display::Core::DisplayTask* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayScanout>(args, 0);

                self->obj.SetScanout(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTask_SetSignal(py::wrapper::Windows::Devices::Display::Core::DisplayTask* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTaskSignalKind>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayFence>(args, 1);

                self->obj.SetSignal(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTask_SetWait(py::wrapper::Windows::Devices::Display::Core::DisplayTask* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayFence>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);

                self->obj.SetWait(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_DisplayTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayTask>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayTask[] = {
        { "set_scanout", (PyCFunction)DisplayTask_SetScanout, METH_VARARGS, nullptr },
        { "set_signal", (PyCFunction)DisplayTask_SetSignal, METH_VARARGS, nullptr },
        { "set_wait", (PyCFunction)DisplayTask_SetWait, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DisplayTask, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplayTask[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayTask[] = 
    {
        { Py_tp_new, _new_DisplayTask },
        { Py_tp_dealloc, _dealloc_DisplayTask },
        { Py_tp_methods, _methods_DisplayTask },
        { Py_tp_getset, _getset_DisplayTask },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayTask =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayTask",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayTask),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayTask
    };

    // ----- DisplayTaskPool class --------------------
    constexpr const char* const _type_name_DisplayTaskPool = "DisplayTaskPool";

    static PyObject* _new_DisplayTaskPool(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayTaskPool);
        return nullptr;
    }

    static void _dealloc_DisplayTaskPool(py::wrapper::Windows::Devices::Display::Core::DisplayTaskPool* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayTaskPool_CreateTask(py::wrapper::Windows::Devices::Display::Core::DisplayTaskPool* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateTask());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTaskPool_ExecuteTask(py::wrapper::Windows::Devices::Display::Core::DisplayTaskPool* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTask>(args, 0);

                self->obj.ExecuteTask(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTaskPool_TryExecuteTask(py::wrapper::Windows::Devices::Display::Core::DisplayTaskPool* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTask>(args, 0);

                return py::convert(self->obj.TryExecuteTask(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_DisplayTaskPool(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayTaskPool>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayTaskPool[] = {
        { "create_task", (PyCFunction)DisplayTaskPool_CreateTask, METH_VARARGS, nullptr },
        { "execute_task", (PyCFunction)DisplayTaskPool_ExecuteTask, METH_VARARGS, nullptr },
        { "try_execute_task", (PyCFunction)DisplayTaskPool_TryExecuteTask, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DisplayTaskPool, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplayTaskPool[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayTaskPool[] = 
    {
        { Py_tp_new, _new_DisplayTaskPool },
        { Py_tp_dealloc, _dealloc_DisplayTaskPool },
        { Py_tp_methods, _methods_DisplayTaskPool },
        { Py_tp_getset, _getset_DisplayTaskPool },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayTaskPool =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayTaskPool",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayTaskPool),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayTaskPool
    };

    // ----- DisplayTaskResult class --------------------
    constexpr const char* const _type_name_DisplayTaskResult = "DisplayTaskResult";

    static PyObject* _new_DisplayTaskResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayTaskResult);
        return nullptr;
    }

    static void _dealloc_DisplayTaskResult(py::wrapper::Windows::Devices::Display::Core::DisplayTaskResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayTaskResult_get_PresentId(py::wrapper::Windows::Devices::Display::Core::DisplayTaskResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PresentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTaskResult_get_PresentStatus(py::wrapper::Windows::Devices::Display::Core::DisplayTaskResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PresentStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTaskResult_get_SourceStatus(py::wrapper::Windows::Devices::Display::Core::DisplayTaskResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayTaskResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayTaskResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayTaskResult[] = {
        { "_from", (PyCFunction)_from_DisplayTaskResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplayTaskResult[] = {
        { const_cast<char*>("present_id"), (getter)DisplayTaskResult_get_PresentId, nullptr, nullptr, nullptr },
        { const_cast<char*>("present_status"), (getter)DisplayTaskResult_get_PresentStatus, nullptr, nullptr, nullptr },
        { const_cast<char*>("source_status"), (getter)DisplayTaskResult_get_SourceStatus, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayTaskResult[] = 
    {
        { Py_tp_new, _new_DisplayTaskResult },
        { Py_tp_dealloc, _dealloc_DisplayTaskResult },
        { Py_tp_methods, _methods_DisplayTaskResult },
        { Py_tp_getset, _getset_DisplayTaskResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayTaskResult =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayTaskResult",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayTaskResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayTaskResult
    };

    // ----- DisplayView class --------------------
    constexpr const char* const _type_name_DisplayView = "DisplayView";

    static PyObject* _new_DisplayView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayView);
        return nullptr;
    }

    static void _dealloc_DisplayView(py::wrapper::Windows::Devices::Display::Core::DisplayView* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayView_SetPrimaryPath(py::wrapper::Windows::Devices::Display::Core::DisplayView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayPath>(args, 0);

                self->obj.SetPrimaryPath(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayView_get_ContentResolution(py::wrapper::Windows::Devices::Display::Core::DisplayView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayView_put_ContentResolution(py::wrapper::Windows::Devices::Display::Core::DisplayView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Graphics::SizeInt32>>(arg);

            self->obj.ContentResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayView_get_Paths(py::wrapper::Windows::Devices::Display::Core::DisplayView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Paths());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayView_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayView[] = {
        { "set_primary_path", (PyCFunction)DisplayView_SetPrimaryPath, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DisplayView, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplayView[] = {
        { const_cast<char*>("content_resolution"), (getter)DisplayView_get_ContentResolution, (setter)DisplayView_put_ContentResolution, nullptr, nullptr },
        { const_cast<char*>("paths"), (getter)DisplayView_get_Paths, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)DisplayView_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayView[] = 
    {
        { Py_tp_new, _new_DisplayView },
        { Py_tp_dealloc, _dealloc_DisplayView },
        { Py_tp_methods, _methods_DisplayView },
        { Py_tp_getset, _getset_DisplayView },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayView =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayView",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayView
    };

    // ----- DisplayWireFormat class --------------------
    constexpr const char* const _type_name_DisplayWireFormat = "DisplayWireFormat";

    static PyObject* _new_DisplayWireFormat(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatPixelEncoding>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatColorSpace>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatEotf>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatHdrMetadata>(args, 4);

                winrt::Windows::Devices::Display::Core::DisplayWireFormat instance{ param0, param1, param2, param3, param4 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DisplayWireFormat(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayWireFormat_CreateWithProperties(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::guid, winrt::Windows::Foundation::IInspectable>>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatPixelEncoding>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatColorSpace>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatEotf>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatHdrMetadata>(args, 5);

                return py::convert(winrt::Windows::Devices::Display::Core::DisplayWireFormat::CreateWithProperties(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_BitsPerChannel(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitsPerChannel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_ColorSpace(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorSpace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_Eotf(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Eotf());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_HdrMetadata(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HdrMetadata());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_PixelEncoding(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelEncoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayWireFormat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayWireFormat>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayWireFormat[] = {
        { "create_with_properties", (PyCFunction)DisplayWireFormat_CreateWithProperties, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_DisplayWireFormat, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DisplayWireFormat[] = {
        { const_cast<char*>("bits_per_channel"), (getter)DisplayWireFormat_get_BitsPerChannel, nullptr, nullptr, nullptr },
        { const_cast<char*>("color_space"), (getter)DisplayWireFormat_get_ColorSpace, nullptr, nullptr, nullptr },
        { const_cast<char*>("eotf"), (getter)DisplayWireFormat_get_Eotf, nullptr, nullptr, nullptr },
        { const_cast<char*>("hdr_metadata"), (getter)DisplayWireFormat_get_HdrMetadata, nullptr, nullptr, nullptr },
        { const_cast<char*>("pixel_encoding"), (getter)DisplayWireFormat_get_PixelEncoding, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)DisplayWireFormat_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayWireFormat[] = 
    {
        { Py_tp_new, _new_DisplayWireFormat },
        { Py_tp_dealloc, _dealloc_DisplayWireFormat },
        { Py_tp_methods, _methods_DisplayWireFormat },
        { Py_tp_getset, _getset_DisplayWireFormat },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayWireFormat =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayWireFormat",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayWireFormat
    };

    // ----- DisplayPresentationRate struct --------------------
    constexpr const char* const _type_name_DisplayPresentationRate = "DisplayPresentationRate";

    PyObject* _new_DisplayPresentationRate(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Devices::Display::Core::DisplayPresentationRate return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        PyObject* _VerticalSyncRate{};
        int32_t _VerticalSyncsPerPresentation{};

        static const char* kwlist[] = {"vertical_sync_rate", "vertical_syncs_per_presentation", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "Oi", const_cast<char**>(kwlist), &_VerticalSyncRate, &_VerticalSyncsPerPresentation))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Devices::Display::Core::DisplayPresentationRate return_value{ py::converter<winrt::Windows::Foundation::Numerics::Rational>::convert_to(_VerticalSyncRate), _VerticalSyncsPerPresentation };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_DisplayPresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate* self)
    {
    }

    static PyObject* DisplayPresentationRate_get_VerticalSyncRate(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VerticalSyncRate);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPresentationRate_set_VerticalSyncRate(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.VerticalSyncRate = py::converter<winrt::Windows::Foundation::Numerics::Rational>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPresentationRate_get_VerticalSyncsPerPresentation(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VerticalSyncsPerPresentation);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPresentationRate_set_VerticalSyncsPerPresentation(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.VerticalSyncsPerPresentation = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_DisplayPresentationRate[] = {
        { const_cast<char*>("vertical_sync_rate"), (getter)DisplayPresentationRate_get_VerticalSyncRate, (setter)DisplayPresentationRate_set_VerticalSyncRate, nullptr, nullptr },
        { const_cast<char*>("vertical_syncs_per_presentation"), (getter)DisplayPresentationRate_get_VerticalSyncsPerPresentation, (setter)DisplayPresentationRate_set_VerticalSyncsPerPresentation, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DisplayPresentationRate[] = 
    {
        { Py_tp_new, _new_DisplayPresentationRate },
        { Py_tp_dealloc, _dealloc_DisplayPresentationRate },
        { Py_tp_getset, _getset_DisplayPresentationRate },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayPresentationRate =
    {
        "_winrt_Windows_Devices_Display_Core.DisplayPresentationRate",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayPresentationRate
    };

    // ----- Windows.Devices.Display.Core Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayAdapter>::python_type = py::register_python_type(module, _type_name_DisplayAdapter, &_type_spec_DisplayAdapter, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayDevice>::python_type = py::register_python_type(module, _type_name_DisplayDevice, &_type_spec_DisplayDevice, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayFence>::python_type = py::register_python_type(module, _type_name_DisplayFence, &_type_spec_DisplayFence, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManager>::python_type = py::register_python_type(module, _type_name_DisplayManager, &_type_spec_DisplayManager, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs>::python_type = py::register_python_type(module, _type_name_DisplayManagerChangedEventArgs, &_type_spec_DisplayManagerChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs>::python_type = py::register_python_type(module, _type_name_DisplayManagerDisabledEventArgs, &_type_spec_DisplayManagerDisabledEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs>::python_type = py::register_python_type(module, _type_name_DisplayManagerEnabledEventArgs, &_type_spec_DisplayManagerEnabledEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs>::python_type = py::register_python_type(module, _type_name_DisplayManagerPathsFailedOrInvalidatedEventArgs, &_type_spec_DisplayManagerPathsFailedOrInvalidatedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerResultWithState>::python_type = py::register_python_type(module, _type_name_DisplayManagerResultWithState, &_type_spec_DisplayManagerResultWithState, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayModeInfo>::python_type = py::register_python_type(module, _type_name_DisplayModeInfo, &_type_spec_DisplayModeInfo, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayPath>::python_type = py::register_python_type(module, _type_name_DisplayPath, &_type_spec_DisplayPath, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription>::python_type = py::register_python_type(module, _type_name_DisplayPrimaryDescription, &_type_spec_DisplayPrimaryDescription, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayScanout>::python_type = py::register_python_type(module, _type_name_DisplayScanout, &_type_spec_DisplayScanout, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplaySource>::python_type = py::register_python_type(module, _type_name_DisplaySource, &_type_spec_DisplaySource, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayState>::python_type = py::register_python_type(module, _type_name_DisplayState, &_type_spec_DisplayState, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayStateOperationResult>::python_type = py::register_python_type(module, _type_name_DisplayStateOperationResult, &_type_spec_DisplayStateOperationResult, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplaySurface>::python_type = py::register_python_type(module, _type_name_DisplaySurface, &_type_spec_DisplaySurface, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayTarget>::python_type = py::register_python_type(module, _type_name_DisplayTarget, &_type_spec_DisplayTarget, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayTask>::python_type = py::register_python_type(module, _type_name_DisplayTask, &_type_spec_DisplayTask, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayTaskPool>::python_type = py::register_python_type(module, _type_name_DisplayTaskPool, &_type_spec_DisplayTaskPool, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayTaskResult>::python_type = py::register_python_type(module, _type_name_DisplayTaskResult, &_type_spec_DisplayTaskResult, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayView>::python_type = py::register_python_type(module, _type_name_DisplayView, &_type_spec_DisplayView, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayWireFormat>::python_type = py::register_python_type(module, _type_name_DisplayWireFormat, &_type_spec_DisplayWireFormat, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>::python_type = py::register_python_type(module, _type_name_DisplayPresentationRate, &_type_spec_DisplayPresentationRate, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Devices.Display.Core");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Devices_Display_Core",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Devices::Display::Core

PyMODINIT_FUNC
PyInit__winrt_Windows_Devices_Display_Core (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Devices::Display::Core::module_def);
}
