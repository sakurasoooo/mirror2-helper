// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Devices.Sensors.h"

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::Accelerometer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::AccelerometerDataThreshold>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::AccelerometerReading>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::AccelerometerShakenEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ActivitySensor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ActivitySensorReading>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangeReport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ActivitySensorTriggerDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::Altimeter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::AltimeterReading>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::Barometer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::BarometerDataThreshold>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::BarometerReading>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::BarometerReadingChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::Compass>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::CompassDataThreshold>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::CompassReading>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::CompassReadingChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::Gyrometer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::GyrometerDataThreshold>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::GyrometerReading>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::HingeAngleReading>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::HingeAngleSensor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::Inclinometer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::InclinometerDataThreshold>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::InclinometerReading>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::LightSensor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::LightSensorDataThreshold>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::LightSensorReading>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::Magnetometer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::MagnetometerDataThreshold>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::MagnetometerReading>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::OrientationSensor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::OrientationSensorReading>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::Pedometer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::PedometerDataThreshold>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::PedometerReading>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::PedometerReadingChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ProximitySensor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ProximitySensorDataThreshold>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ProximitySensorReading>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::SensorQuaternion>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::SensorRotationMatrix>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::SimpleOrientationSensor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sensors::ISensorDataThreshold>::python_type;

namespace py::cpp::Windows::Devices::Sensors
{
    // ----- Accelerometer class --------------------
    constexpr const char* const _type_name_Accelerometer = "Accelerometer";

    static PyObject* _new_Accelerometer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_Accelerometer);
        return nullptr;
    }

    static void _dealloc_Accelerometer(py::wrapper::Windows::Devices::Sensors::Accelerometer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Accelerometer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Accelerometer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Accelerometer_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Accelerometer_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Accelerometer::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::AccelerometerReadingType>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Accelerometer::GetDefault(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Accelerometer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::AccelerometerReadingType>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Accelerometer::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Accelerometer_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Accelerometer_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Accelerometer_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_get_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReadingTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Accelerometer_put_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Display::DisplayOrientations>(arg);

            self->obj.ReadingTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Accelerometer_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Accelerometer_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Accelerometer_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_get_ReadingType(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReadingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_get_ReportThreshold(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Accelerometer, winrt::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_add_Shaken(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Accelerometer, winrt::Windows::Devices::Sensors::AccelerometerShakenEventArgs>>(arg);

            return py::convert(self->obj.Shaken(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Accelerometer_remove_Shaken(py::wrapper::Windows::Devices::Sensors::Accelerometer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Shaken(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Accelerometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Accelerometer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Accelerometer[] = {
        { "from_id_async", (PyCFunction)Accelerometer_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading", (PyCFunction)Accelerometer_GetCurrentReading, METH_VARARGS, nullptr },
        { "get_default", (PyCFunction)Accelerometer_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)Accelerometer_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", (PyCFunction)Accelerometer_add_ReadingChanged, METH_O, nullptr },
        { "remove_reading_changed", (PyCFunction)Accelerometer_remove_ReadingChanged, METH_O, nullptr },
        { "add_shaken", (PyCFunction)Accelerometer_add_Shaken, METH_O, nullptr },
        { "remove_shaken", (PyCFunction)Accelerometer_remove_Shaken, METH_O, nullptr },
        { "_from", (PyCFunction)_from_Accelerometer, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_Accelerometer[] = {
        { const_cast<char*>("report_interval"), (getter)Accelerometer_get_ReportInterval, (setter)Accelerometer_put_ReportInterval, nullptr, nullptr },
        { const_cast<char*>("minimum_report_interval"), (getter)Accelerometer_get_MinimumReportInterval, nullptr, nullptr, nullptr },
        { const_cast<char*>("reading_transform"), (getter)Accelerometer_get_ReadingTransform, (setter)Accelerometer_put_ReadingTransform, nullptr, nullptr },
        { const_cast<char*>("report_latency"), (getter)Accelerometer_get_ReportLatency, (setter)Accelerometer_put_ReportLatency, nullptr, nullptr },
        { const_cast<char*>("max_batch_size"), (getter)Accelerometer_get_MaxBatchSize, nullptr, nullptr, nullptr },
        { const_cast<char*>("reading_type"), (getter)Accelerometer_get_ReadingType, nullptr, nullptr, nullptr },
        { const_cast<char*>("report_threshold"), (getter)Accelerometer_get_ReportThreshold, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)Accelerometer_get_DeviceId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Accelerometer[] = 
    {
        { Py_tp_new, _new_Accelerometer },
        { Py_tp_dealloc, _dealloc_Accelerometer },
        { Py_tp_methods, _methods_Accelerometer },
        { Py_tp_getset, _getset_Accelerometer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Accelerometer =
    {
        "_winrt_Windows_Devices_Sensors.Accelerometer",
        sizeof(py::wrapper::Windows::Devices::Sensors::Accelerometer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Accelerometer
    };

    // ----- AccelerometerDataThreshold class --------------------
    constexpr const char* const _type_name_AccelerometerDataThreshold = "AccelerometerDataThreshold";

    static PyObject* _new_AccelerometerDataThreshold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AccelerometerDataThreshold);
        return nullptr;
    }

    static void _dealloc_AccelerometerDataThreshold(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AccelerometerDataThreshold_get_ZAxisInGForce(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZAxisInGForce());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AccelerometerDataThreshold_put_ZAxisInGForce(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ZAxisInGForce(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AccelerometerDataThreshold_get_YAxisInGForce(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.YAxisInGForce());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AccelerometerDataThreshold_put_YAxisInGForce(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.YAxisInGForce(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AccelerometerDataThreshold_get_XAxisInGForce(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.XAxisInGForce());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AccelerometerDataThreshold_put_XAxisInGForce(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.XAxisInGForce(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AccelerometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::AccelerometerDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccelerometerDataThreshold[] = {
        { "_from", (PyCFunction)_from_AccelerometerDataThreshold, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AccelerometerDataThreshold[] = {
        { const_cast<char*>("z_axis_in_g_force"), (getter)AccelerometerDataThreshold_get_ZAxisInGForce, (setter)AccelerometerDataThreshold_put_ZAxisInGForce, nullptr, nullptr },
        { const_cast<char*>("y_axis_in_g_force"), (getter)AccelerometerDataThreshold_get_YAxisInGForce, (setter)AccelerometerDataThreshold_put_YAxisInGForce, nullptr, nullptr },
        { const_cast<char*>("x_axis_in_g_force"), (getter)AccelerometerDataThreshold_get_XAxisInGForce, (setter)AccelerometerDataThreshold_put_XAxisInGForce, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AccelerometerDataThreshold[] = 
    {
        { Py_tp_new, _new_AccelerometerDataThreshold },
        { Py_tp_dealloc, _dealloc_AccelerometerDataThreshold },
        { Py_tp_methods, _methods_AccelerometerDataThreshold },
        { Py_tp_getset, _getset_AccelerometerDataThreshold },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AccelerometerDataThreshold =
    {
        "_winrt_Windows_Devices_Sensors.AccelerometerDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::AccelerometerDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccelerometerDataThreshold
    };

    // ----- AccelerometerReading class --------------------
    constexpr const char* const _type_name_AccelerometerReading = "AccelerometerReading";

    static PyObject* _new_AccelerometerReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AccelerometerReading);
        return nullptr;
    }

    static void _dealloc_AccelerometerReading(py::wrapper::Windows::Devices::Sensors::AccelerometerReading* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AccelerometerReading_get_AccelerationX(py::wrapper::Windows::Devices::Sensors::AccelerometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccelerationX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccelerometerReading_get_AccelerationY(py::wrapper::Windows::Devices::Sensors::AccelerometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccelerationY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccelerometerReading_get_AccelerationZ(py::wrapper::Windows::Devices::Sensors::AccelerometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccelerationZ());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccelerometerReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::AccelerometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccelerometerReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::AccelerometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccelerometerReading_get_Properties(py::wrapper::Windows::Devices::Sensors::AccelerometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AccelerometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::AccelerometerReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccelerometerReading[] = {
        { "_from", (PyCFunction)_from_AccelerometerReading, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AccelerometerReading[] = {
        { const_cast<char*>("acceleration_x"), (getter)AccelerometerReading_get_AccelerationX, nullptr, nullptr, nullptr },
        { const_cast<char*>("acceleration_y"), (getter)AccelerometerReading_get_AccelerationY, nullptr, nullptr, nullptr },
        { const_cast<char*>("acceleration_z"), (getter)AccelerometerReading_get_AccelerationZ, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)AccelerometerReading_get_Timestamp, nullptr, nullptr, nullptr },
        { const_cast<char*>("performance_count"), (getter)AccelerometerReading_get_PerformanceCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)AccelerometerReading_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AccelerometerReading[] = 
    {
        { Py_tp_new, _new_AccelerometerReading },
        { Py_tp_dealloc, _dealloc_AccelerometerReading },
        { Py_tp_methods, _methods_AccelerometerReading },
        { Py_tp_getset, _getset_AccelerometerReading },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AccelerometerReading =
    {
        "_winrt_Windows_Devices_Sensors.AccelerometerReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::AccelerometerReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccelerometerReading
    };

    // ----- AccelerometerReadingChangedEventArgs class --------------------
    constexpr const char* const _type_name_AccelerometerReadingChangedEventArgs = "AccelerometerReadingChangedEventArgs";

    static PyObject* _new_AccelerometerReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AccelerometerReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_AccelerometerReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AccelerometerReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AccelerometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccelerometerReadingChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_AccelerometerReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AccelerometerReadingChangedEventArgs[] = {
        { const_cast<char*>("reading"), (getter)AccelerometerReadingChangedEventArgs_get_Reading, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AccelerometerReadingChangedEventArgs[] = 
    {
        { Py_tp_new, _new_AccelerometerReadingChangedEventArgs },
        { Py_tp_dealloc, _dealloc_AccelerometerReadingChangedEventArgs },
        { Py_tp_methods, _methods_AccelerometerReadingChangedEventArgs },
        { Py_tp_getset, _getset_AccelerometerReadingChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AccelerometerReadingChangedEventArgs =
    {
        "_winrt_Windows_Devices_Sensors.AccelerometerReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccelerometerReadingChangedEventArgs
    };

    // ----- AccelerometerShakenEventArgs class --------------------
    constexpr const char* const _type_name_AccelerometerShakenEventArgs = "AccelerometerShakenEventArgs";

    static PyObject* _new_AccelerometerShakenEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AccelerometerShakenEventArgs);
        return nullptr;
    }

    static void _dealloc_AccelerometerShakenEventArgs(py::wrapper::Windows::Devices::Sensors::AccelerometerShakenEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AccelerometerShakenEventArgs_get_Timestamp(py::wrapper::Windows::Devices::Sensors::AccelerometerShakenEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AccelerometerShakenEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::AccelerometerShakenEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccelerometerShakenEventArgs[] = {
        { "_from", (PyCFunction)_from_AccelerometerShakenEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AccelerometerShakenEventArgs[] = {
        { const_cast<char*>("timestamp"), (getter)AccelerometerShakenEventArgs_get_Timestamp, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AccelerometerShakenEventArgs[] = 
    {
        { Py_tp_new, _new_AccelerometerShakenEventArgs },
        { Py_tp_dealloc, _dealloc_AccelerometerShakenEventArgs },
        { Py_tp_methods, _methods_AccelerometerShakenEventArgs },
        { Py_tp_getset, _getset_AccelerometerShakenEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AccelerometerShakenEventArgs =
    {
        "_winrt_Windows_Devices_Sensors.AccelerometerShakenEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::AccelerometerShakenEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccelerometerShakenEventArgs
    };

    // ----- ActivitySensor class --------------------
    constexpr const char* const _type_name_ActivitySensor = "ActivitySensor";

    static PyObject* _new_ActivitySensor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ActivitySensor);
        return nullptr;
    }

    static void _dealloc_ActivitySensor(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ActivitySensor_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::ActivitySensor::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_GetCurrentReadingAsync(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReadingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::ActivitySensor::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::ActivitySensor::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_GetSystemHistoryAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::ActivitySensor::GetSystemHistoryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(winrt::Windows::Devices::Sensors::ActivitySensor::GetSystemHistoryAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_get_DeviceId(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_get_PowerInMilliwatts(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerInMilliwatts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_get_SubscribedActivities(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SubscribedActivities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_get_SupportedActivities(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedActivities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::ActivitySensor, winrt::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensor_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::ActivitySensor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ActivitySensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ActivitySensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivitySensor[] = {
        { "from_id_async", (PyCFunction)ActivitySensor_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading_async", (PyCFunction)ActivitySensor_GetCurrentReadingAsync, METH_VARARGS, nullptr },
        { "get_default_async", (PyCFunction)ActivitySensor_GetDefaultAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)ActivitySensor_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "get_system_history_async", (PyCFunction)ActivitySensor_GetSystemHistoryAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", (PyCFunction)ActivitySensor_add_ReadingChanged, METH_O, nullptr },
        { "remove_reading_changed", (PyCFunction)ActivitySensor_remove_ReadingChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ActivitySensor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ActivitySensor[] = {
        { const_cast<char*>("device_id"), (getter)ActivitySensor_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("minimum_report_interval"), (getter)ActivitySensor_get_MinimumReportInterval, nullptr, nullptr, nullptr },
        { const_cast<char*>("power_in_milliwatts"), (getter)ActivitySensor_get_PowerInMilliwatts, nullptr, nullptr, nullptr },
        { const_cast<char*>("subscribed_activities"), (getter)ActivitySensor_get_SubscribedActivities, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_activities"), (getter)ActivitySensor_get_SupportedActivities, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ActivitySensor[] = 
    {
        { Py_tp_new, _new_ActivitySensor },
        { Py_tp_dealloc, _dealloc_ActivitySensor },
        { Py_tp_methods, _methods_ActivitySensor },
        { Py_tp_getset, _getset_ActivitySensor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ActivitySensor =
    {
        "_winrt_Windows_Devices_Sensors.ActivitySensor",
        sizeof(py::wrapper::Windows::Devices::Sensors::ActivitySensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivitySensor
    };

    // ----- ActivitySensorReading class --------------------
    constexpr const char* const _type_name_ActivitySensorReading = "ActivitySensorReading";

    static PyObject* _new_ActivitySensorReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ActivitySensorReading);
        return nullptr;
    }

    static void _dealloc_ActivitySensorReading(py::wrapper::Windows::Devices::Sensors::ActivitySensorReading* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ActivitySensorReading_get_Activity(py::wrapper::Windows::Devices::Sensors::ActivitySensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Activity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensorReading_get_Confidence(py::wrapper::Windows::Devices::Sensors::ActivitySensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Confidence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensorReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::ActivitySensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ActivitySensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ActivitySensorReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivitySensorReading[] = {
        { "_from", (PyCFunction)_from_ActivitySensorReading, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ActivitySensorReading[] = {
        { const_cast<char*>("activity"), (getter)ActivitySensorReading_get_Activity, nullptr, nullptr, nullptr },
        { const_cast<char*>("confidence"), (getter)ActivitySensorReading_get_Confidence, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)ActivitySensorReading_get_Timestamp, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ActivitySensorReading[] = 
    {
        { Py_tp_new, _new_ActivitySensorReading },
        { Py_tp_dealloc, _dealloc_ActivitySensorReading },
        { Py_tp_methods, _methods_ActivitySensorReading },
        { Py_tp_getset, _getset_ActivitySensorReading },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ActivitySensorReading =
    {
        "_winrt_Windows_Devices_Sensors.ActivitySensorReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::ActivitySensorReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivitySensorReading
    };

    // ----- ActivitySensorReadingChangeReport class --------------------
    constexpr const char* const _type_name_ActivitySensorReadingChangeReport = "ActivitySensorReadingChangeReport";

    static PyObject* _new_ActivitySensorReadingChangeReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ActivitySensorReadingChangeReport);
        return nullptr;
    }

    static void _dealloc_ActivitySensorReadingChangeReport(py::wrapper::Windows::Devices::Sensors::ActivitySensorReadingChangeReport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ActivitySensorReadingChangeReport_get_Reading(py::wrapper::Windows::Devices::Sensors::ActivitySensorReadingChangeReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ActivitySensorReadingChangeReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangeReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivitySensorReadingChangeReport[] = {
        { "_from", (PyCFunction)_from_ActivitySensorReadingChangeReport, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ActivitySensorReadingChangeReport[] = {
        { const_cast<char*>("reading"), (getter)ActivitySensorReadingChangeReport_get_Reading, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ActivitySensorReadingChangeReport[] = 
    {
        { Py_tp_new, _new_ActivitySensorReadingChangeReport },
        { Py_tp_dealloc, _dealloc_ActivitySensorReadingChangeReport },
        { Py_tp_methods, _methods_ActivitySensorReadingChangeReport },
        { Py_tp_getset, _getset_ActivitySensorReadingChangeReport },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ActivitySensorReadingChangeReport =
    {
        "_winrt_Windows_Devices_Sensors.ActivitySensorReadingChangeReport",
        sizeof(py::wrapper::Windows::Devices::Sensors::ActivitySensorReadingChangeReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivitySensorReadingChangeReport
    };

    // ----- ActivitySensorReadingChangedEventArgs class --------------------
    constexpr const char* const _type_name_ActivitySensorReadingChangedEventArgs = "ActivitySensorReadingChangedEventArgs";

    static PyObject* _new_ActivitySensorReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ActivitySensorReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_ActivitySensorReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ActivitySensorReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ActivitySensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivitySensorReadingChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_ActivitySensorReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ActivitySensorReadingChangedEventArgs[] = {
        { const_cast<char*>("reading"), (getter)ActivitySensorReadingChangedEventArgs_get_Reading, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ActivitySensorReadingChangedEventArgs[] = 
    {
        { Py_tp_new, _new_ActivitySensorReadingChangedEventArgs },
        { Py_tp_dealloc, _dealloc_ActivitySensorReadingChangedEventArgs },
        { Py_tp_methods, _methods_ActivitySensorReadingChangedEventArgs },
        { Py_tp_getset, _getset_ActivitySensorReadingChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ActivitySensorReadingChangedEventArgs =
    {
        "_winrt_Windows_Devices_Sensors.ActivitySensorReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivitySensorReadingChangedEventArgs
    };

    // ----- ActivitySensorTriggerDetails class --------------------
    constexpr const char* const _type_name_ActivitySensorTriggerDetails = "ActivitySensorTriggerDetails";

    static PyObject* _new_ActivitySensorTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ActivitySensorTriggerDetails);
        return nullptr;
    }

    static void _dealloc_ActivitySensorTriggerDetails(py::wrapper::Windows::Devices::Sensors::ActivitySensorTriggerDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ActivitySensorTriggerDetails_ReadReports(py::wrapper::Windows::Devices::Sensors::ActivitySensorTriggerDetails* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadReports());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ActivitySensorTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ActivitySensorTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivitySensorTriggerDetails[] = {
        { "read_reports", (PyCFunction)ActivitySensorTriggerDetails_ReadReports, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ActivitySensorTriggerDetails, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ActivitySensorTriggerDetails[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ActivitySensorTriggerDetails[] = 
    {
        { Py_tp_new, _new_ActivitySensorTriggerDetails },
        { Py_tp_dealloc, _dealloc_ActivitySensorTriggerDetails },
        { Py_tp_methods, _methods_ActivitySensorTriggerDetails },
        { Py_tp_getset, _getset_ActivitySensorTriggerDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ActivitySensorTriggerDetails =
    {
        "_winrt_Windows_Devices_Sensors.ActivitySensorTriggerDetails",
        sizeof(py::wrapper::Windows::Devices::Sensors::ActivitySensorTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivitySensorTriggerDetails
    };

    // ----- Altimeter class --------------------
    constexpr const char* const _type_name_Altimeter = "Altimeter";

    static PyObject* _new_Altimeter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_Altimeter);
        return nullptr;
    }

    static void _dealloc_Altimeter(py::wrapper::Windows::Devices::Sensors::Altimeter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Altimeter_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::Altimeter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Altimeter_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Altimeter::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Altimeter_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Altimeter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Altimeter_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Altimeter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Altimeter_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Altimeter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Altimeter_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Altimeter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Altimeter_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::Altimeter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Altimeter_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::Altimeter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Altimeter_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::Altimeter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Altimeter_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Altimeter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Altimeter, winrt::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Altimeter_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Altimeter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Altimeter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Altimeter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Altimeter[] = {
        { "get_current_reading", (PyCFunction)Altimeter_GetCurrentReading, METH_VARARGS, nullptr },
        { "get_default", (PyCFunction)Altimeter_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", (PyCFunction)Altimeter_add_ReadingChanged, METH_O, nullptr },
        { "remove_reading_changed", (PyCFunction)Altimeter_remove_ReadingChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_Altimeter, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_Altimeter[] = {
        { const_cast<char*>("report_interval"), (getter)Altimeter_get_ReportInterval, (setter)Altimeter_put_ReportInterval, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)Altimeter_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("minimum_report_interval"), (getter)Altimeter_get_MinimumReportInterval, nullptr, nullptr, nullptr },
        { const_cast<char*>("report_latency"), (getter)Altimeter_get_ReportLatency, (setter)Altimeter_put_ReportLatency, nullptr, nullptr },
        { const_cast<char*>("max_batch_size"), (getter)Altimeter_get_MaxBatchSize, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Altimeter[] = 
    {
        { Py_tp_new, _new_Altimeter },
        { Py_tp_dealloc, _dealloc_Altimeter },
        { Py_tp_methods, _methods_Altimeter },
        { Py_tp_getset, _getset_Altimeter },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Altimeter =
    {
        "_winrt_Windows_Devices_Sensors.Altimeter",
        sizeof(py::wrapper::Windows::Devices::Sensors::Altimeter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Altimeter
    };

    // ----- AltimeterReading class --------------------
    constexpr const char* const _type_name_AltimeterReading = "AltimeterReading";

    static PyObject* _new_AltimeterReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AltimeterReading);
        return nullptr;
    }

    static void _dealloc_AltimeterReading(py::wrapper::Windows::Devices::Sensors::AltimeterReading* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AltimeterReading_get_AltitudeChangeInMeters(py::wrapper::Windows::Devices::Sensors::AltimeterReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AltitudeChangeInMeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AltimeterReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::AltimeterReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AltimeterReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::AltimeterReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AltimeterReading_get_Properties(py::wrapper::Windows::Devices::Sensors::AltimeterReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AltimeterReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::AltimeterReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AltimeterReading[] = {
        { "_from", (PyCFunction)_from_AltimeterReading, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AltimeterReading[] = {
        { const_cast<char*>("altitude_change_in_meters"), (getter)AltimeterReading_get_AltitudeChangeInMeters, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)AltimeterReading_get_Timestamp, nullptr, nullptr, nullptr },
        { const_cast<char*>("performance_count"), (getter)AltimeterReading_get_PerformanceCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)AltimeterReading_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AltimeterReading[] = 
    {
        { Py_tp_new, _new_AltimeterReading },
        { Py_tp_dealloc, _dealloc_AltimeterReading },
        { Py_tp_methods, _methods_AltimeterReading },
        { Py_tp_getset, _getset_AltimeterReading },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AltimeterReading =
    {
        "_winrt_Windows_Devices_Sensors.AltimeterReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::AltimeterReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AltimeterReading
    };

    // ----- AltimeterReadingChangedEventArgs class --------------------
    constexpr const char* const _type_name_AltimeterReadingChangedEventArgs = "AltimeterReadingChangedEventArgs";

    static PyObject* _new_AltimeterReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AltimeterReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_AltimeterReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AltimeterReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AltimeterReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AltimeterReadingChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_AltimeterReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AltimeterReadingChangedEventArgs[] = {
        { const_cast<char*>("reading"), (getter)AltimeterReadingChangedEventArgs_get_Reading, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AltimeterReadingChangedEventArgs[] = 
    {
        { Py_tp_new, _new_AltimeterReadingChangedEventArgs },
        { Py_tp_dealloc, _dealloc_AltimeterReadingChangedEventArgs },
        { Py_tp_methods, _methods_AltimeterReadingChangedEventArgs },
        { Py_tp_getset, _getset_AltimeterReadingChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AltimeterReadingChangedEventArgs =
    {
        "_winrt_Windows_Devices_Sensors.AltimeterReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AltimeterReadingChangedEventArgs
    };

    // ----- Barometer class --------------------
    constexpr const char* const _type_name_Barometer = "Barometer";

    static PyObject* _new_Barometer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_Barometer);
        return nullptr;
    }

    static void _dealloc_Barometer(py::wrapper::Windows::Devices::Sensors::Barometer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Barometer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Barometer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Barometer_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::Barometer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Barometer_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Barometer::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Barometer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Barometer::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Barometer_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Barometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Barometer_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Barometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Barometer_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Barometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Barometer_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Barometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Barometer_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::Barometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Barometer_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::Barometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Barometer_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::Barometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Barometer_get_ReportThreshold(py::wrapper::Windows::Devices::Sensors::Barometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Barometer_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Barometer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Barometer, winrt::Windows::Devices::Sensors::BarometerReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Barometer_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Barometer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Barometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Barometer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Barometer[] = {
        { "from_id_async", (PyCFunction)Barometer_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading", (PyCFunction)Barometer_GetCurrentReading, METH_VARARGS, nullptr },
        { "get_default", (PyCFunction)Barometer_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)Barometer_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", (PyCFunction)Barometer_add_ReadingChanged, METH_O, nullptr },
        { "remove_reading_changed", (PyCFunction)Barometer_remove_ReadingChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_Barometer, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_Barometer[] = {
        { const_cast<char*>("report_interval"), (getter)Barometer_get_ReportInterval, (setter)Barometer_put_ReportInterval, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)Barometer_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("minimum_report_interval"), (getter)Barometer_get_MinimumReportInterval, nullptr, nullptr, nullptr },
        { const_cast<char*>("report_latency"), (getter)Barometer_get_ReportLatency, (setter)Barometer_put_ReportLatency, nullptr, nullptr },
        { const_cast<char*>("max_batch_size"), (getter)Barometer_get_MaxBatchSize, nullptr, nullptr, nullptr },
        { const_cast<char*>("report_threshold"), (getter)Barometer_get_ReportThreshold, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Barometer[] = 
    {
        { Py_tp_new, _new_Barometer },
        { Py_tp_dealloc, _dealloc_Barometer },
        { Py_tp_methods, _methods_Barometer },
        { Py_tp_getset, _getset_Barometer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Barometer =
    {
        "_winrt_Windows_Devices_Sensors.Barometer",
        sizeof(py::wrapper::Windows::Devices::Sensors::Barometer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Barometer
    };

    // ----- BarometerDataThreshold class --------------------
    constexpr const char* const _type_name_BarometerDataThreshold = "BarometerDataThreshold";

    static PyObject* _new_BarometerDataThreshold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BarometerDataThreshold);
        return nullptr;
    }

    static void _dealloc_BarometerDataThreshold(py::wrapper::Windows::Devices::Sensors::BarometerDataThreshold* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BarometerDataThreshold_get_Hectopascals(py::wrapper::Windows::Devices::Sensors::BarometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Hectopascals());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarometerDataThreshold_put_Hectopascals(py::wrapper::Windows::Devices::Sensors::BarometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Hectopascals(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_BarometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::BarometerDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarometerDataThreshold[] = {
        { "_from", (PyCFunction)_from_BarometerDataThreshold, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BarometerDataThreshold[] = {
        { const_cast<char*>("hectopascals"), (getter)BarometerDataThreshold_get_Hectopascals, (setter)BarometerDataThreshold_put_Hectopascals, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BarometerDataThreshold[] = 
    {
        { Py_tp_new, _new_BarometerDataThreshold },
        { Py_tp_dealloc, _dealloc_BarometerDataThreshold },
        { Py_tp_methods, _methods_BarometerDataThreshold },
        { Py_tp_getset, _getset_BarometerDataThreshold },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BarometerDataThreshold =
    {
        "_winrt_Windows_Devices_Sensors.BarometerDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::BarometerDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarometerDataThreshold
    };

    // ----- BarometerReading class --------------------
    constexpr const char* const _type_name_BarometerReading = "BarometerReading";

    static PyObject* _new_BarometerReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BarometerReading);
        return nullptr;
    }

    static void _dealloc_BarometerReading(py::wrapper::Windows::Devices::Sensors::BarometerReading* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BarometerReading_get_StationPressureInHectopascals(py::wrapper::Windows::Devices::Sensors::BarometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StationPressureInHectopascals());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarometerReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::BarometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarometerReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::BarometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarometerReading_get_Properties(py::wrapper::Windows::Devices::Sensors::BarometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BarometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::BarometerReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarometerReading[] = {
        { "_from", (PyCFunction)_from_BarometerReading, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BarometerReading[] = {
        { const_cast<char*>("station_pressure_in_hectopascals"), (getter)BarometerReading_get_StationPressureInHectopascals, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)BarometerReading_get_Timestamp, nullptr, nullptr, nullptr },
        { const_cast<char*>("performance_count"), (getter)BarometerReading_get_PerformanceCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)BarometerReading_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BarometerReading[] = 
    {
        { Py_tp_new, _new_BarometerReading },
        { Py_tp_dealloc, _dealloc_BarometerReading },
        { Py_tp_methods, _methods_BarometerReading },
        { Py_tp_getset, _getset_BarometerReading },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BarometerReading =
    {
        "_winrt_Windows_Devices_Sensors.BarometerReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::BarometerReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarometerReading
    };

    // ----- BarometerReadingChangedEventArgs class --------------------
    constexpr const char* const _type_name_BarometerReadingChangedEventArgs = "BarometerReadingChangedEventArgs";

    static PyObject* _new_BarometerReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BarometerReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_BarometerReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::BarometerReadingChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BarometerReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::BarometerReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BarometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::BarometerReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarometerReadingChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_BarometerReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BarometerReadingChangedEventArgs[] = {
        { const_cast<char*>("reading"), (getter)BarometerReadingChangedEventArgs_get_Reading, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BarometerReadingChangedEventArgs[] = 
    {
        { Py_tp_new, _new_BarometerReadingChangedEventArgs },
        { Py_tp_dealloc, _dealloc_BarometerReadingChangedEventArgs },
        { Py_tp_methods, _methods_BarometerReadingChangedEventArgs },
        { Py_tp_getset, _getset_BarometerReadingChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BarometerReadingChangedEventArgs =
    {
        "_winrt_Windows_Devices_Sensors.BarometerReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::BarometerReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarometerReadingChangedEventArgs
    };

    // ----- Compass class --------------------
    constexpr const char* const _type_name_Compass = "Compass";

    static PyObject* _new_Compass(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_Compass);
        return nullptr;
    }

    static void _dealloc_Compass(py::wrapper::Windows::Devices::Sensors::Compass* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Compass_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Compass::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compass_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::Compass* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compass_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Compass::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compass_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Compass::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Compass_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Compass* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Compass_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Compass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Compass_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Compass* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Compass_get_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Compass* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReadingTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Compass_put_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Compass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Display::DisplayOrientations>(arg);

            self->obj.ReadingTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Compass_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::Compass* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Compass_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::Compass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Compass_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::Compass* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Compass_get_ReportThreshold(py::wrapper::Windows::Devices::Sensors::Compass* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Compass_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Compass* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Compass_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Compass* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Compass, winrt::Windows::Devices::Sensors::CompassReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Compass_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Compass* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Compass(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Compass>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Compass[] = {
        { "from_id_async", (PyCFunction)Compass_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading", (PyCFunction)Compass_GetCurrentReading, METH_VARARGS, nullptr },
        { "get_default", (PyCFunction)Compass_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)Compass_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", (PyCFunction)Compass_add_ReadingChanged, METH_O, nullptr },
        { "remove_reading_changed", (PyCFunction)Compass_remove_ReadingChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_Compass, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_Compass[] = {
        { const_cast<char*>("report_interval"), (getter)Compass_get_ReportInterval, (setter)Compass_put_ReportInterval, nullptr, nullptr },
        { const_cast<char*>("minimum_report_interval"), (getter)Compass_get_MinimumReportInterval, nullptr, nullptr, nullptr },
        { const_cast<char*>("reading_transform"), (getter)Compass_get_ReadingTransform, (setter)Compass_put_ReadingTransform, nullptr, nullptr },
        { const_cast<char*>("report_latency"), (getter)Compass_get_ReportLatency, (setter)Compass_put_ReportLatency, nullptr, nullptr },
        { const_cast<char*>("max_batch_size"), (getter)Compass_get_MaxBatchSize, nullptr, nullptr, nullptr },
        { const_cast<char*>("report_threshold"), (getter)Compass_get_ReportThreshold, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)Compass_get_DeviceId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Compass[] = 
    {
        { Py_tp_new, _new_Compass },
        { Py_tp_dealloc, _dealloc_Compass },
        { Py_tp_methods, _methods_Compass },
        { Py_tp_getset, _getset_Compass },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Compass =
    {
        "_winrt_Windows_Devices_Sensors.Compass",
        sizeof(py::wrapper::Windows::Devices::Sensors::Compass),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Compass
    };

    // ----- CompassDataThreshold class --------------------
    constexpr const char* const _type_name_CompassDataThreshold = "CompassDataThreshold";

    static PyObject* _new_CompassDataThreshold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CompassDataThreshold);
        return nullptr;
    }

    static void _dealloc_CompassDataThreshold(py::wrapper::Windows::Devices::Sensors::CompassDataThreshold* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CompassDataThreshold_get_Degrees(py::wrapper::Windows::Devices::Sensors::CompassDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Degrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompassDataThreshold_put_Degrees(py::wrapper::Windows::Devices::Sensors::CompassDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Degrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_CompassDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::CompassDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompassDataThreshold[] = {
        { "_from", (PyCFunction)_from_CompassDataThreshold, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CompassDataThreshold[] = {
        { const_cast<char*>("degrees"), (getter)CompassDataThreshold_get_Degrees, (setter)CompassDataThreshold_put_Degrees, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CompassDataThreshold[] = 
    {
        { Py_tp_new, _new_CompassDataThreshold },
        { Py_tp_dealloc, _dealloc_CompassDataThreshold },
        { Py_tp_methods, _methods_CompassDataThreshold },
        { Py_tp_getset, _getset_CompassDataThreshold },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CompassDataThreshold =
    {
        "_winrt_Windows_Devices_Sensors.CompassDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::CompassDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompassDataThreshold
    };

    // ----- CompassReading class --------------------
    constexpr const char* const _type_name_CompassReading = "CompassReading";

    static PyObject* _new_CompassReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CompassReading);
        return nullptr;
    }

    static void _dealloc_CompassReading(py::wrapper::Windows::Devices::Sensors::CompassReading* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CompassReading_get_HeadingMagneticNorth(py::wrapper::Windows::Devices::Sensors::CompassReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HeadingMagneticNorth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompassReading_get_HeadingTrueNorth(py::wrapper::Windows::Devices::Sensors::CompassReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HeadingTrueNorth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompassReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::CompassReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompassReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::CompassReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompassReading_get_Properties(py::wrapper::Windows::Devices::Sensors::CompassReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompassReading_get_HeadingAccuracy(py::wrapper::Windows::Devices::Sensors::CompassReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HeadingAccuracy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CompassReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::CompassReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompassReading[] = {
        { "_from", (PyCFunction)_from_CompassReading, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CompassReading[] = {
        { const_cast<char*>("heading_magnetic_north"), (getter)CompassReading_get_HeadingMagneticNorth, nullptr, nullptr, nullptr },
        { const_cast<char*>("heading_true_north"), (getter)CompassReading_get_HeadingTrueNorth, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)CompassReading_get_Timestamp, nullptr, nullptr, nullptr },
        { const_cast<char*>("performance_count"), (getter)CompassReading_get_PerformanceCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)CompassReading_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("heading_accuracy"), (getter)CompassReading_get_HeadingAccuracy, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CompassReading[] = 
    {
        { Py_tp_new, _new_CompassReading },
        { Py_tp_dealloc, _dealloc_CompassReading },
        { Py_tp_methods, _methods_CompassReading },
        { Py_tp_getset, _getset_CompassReading },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CompassReading =
    {
        "_winrt_Windows_Devices_Sensors.CompassReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::CompassReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompassReading
    };

    // ----- CompassReadingChangedEventArgs class --------------------
    constexpr const char* const _type_name_CompassReadingChangedEventArgs = "CompassReadingChangedEventArgs";

    static PyObject* _new_CompassReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CompassReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_CompassReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::CompassReadingChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CompassReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::CompassReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CompassReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::CompassReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompassReadingChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_CompassReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CompassReadingChangedEventArgs[] = {
        { const_cast<char*>("reading"), (getter)CompassReadingChangedEventArgs_get_Reading, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CompassReadingChangedEventArgs[] = 
    {
        { Py_tp_new, _new_CompassReadingChangedEventArgs },
        { Py_tp_dealloc, _dealloc_CompassReadingChangedEventArgs },
        { Py_tp_methods, _methods_CompassReadingChangedEventArgs },
        { Py_tp_getset, _getset_CompassReadingChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CompassReadingChangedEventArgs =
    {
        "_winrt_Windows_Devices_Sensors.CompassReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::CompassReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompassReadingChangedEventArgs
    };

    // ----- Gyrometer class --------------------
    constexpr const char* const _type_name_Gyrometer = "Gyrometer";

    static PyObject* _new_Gyrometer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_Gyrometer);
        return nullptr;
    }

    static void _dealloc_Gyrometer(py::wrapper::Windows::Devices::Sensors::Gyrometer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Gyrometer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Gyrometer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gyrometer_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gyrometer_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Gyrometer::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gyrometer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Gyrometer::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gyrometer_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Gyrometer_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Gyrometer_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gyrometer_get_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReadingTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Gyrometer_put_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Display::DisplayOrientations>(arg);

            self->obj.ReadingTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Gyrometer_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Gyrometer_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Gyrometer_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gyrometer_get_ReportThreshold(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gyrometer_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gyrometer_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Gyrometer, winrt::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gyrometer_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Gyrometer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Gyrometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Gyrometer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Gyrometer[] = {
        { "from_id_async", (PyCFunction)Gyrometer_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading", (PyCFunction)Gyrometer_GetCurrentReading, METH_VARARGS, nullptr },
        { "get_default", (PyCFunction)Gyrometer_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)Gyrometer_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", (PyCFunction)Gyrometer_add_ReadingChanged, METH_O, nullptr },
        { "remove_reading_changed", (PyCFunction)Gyrometer_remove_ReadingChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_Gyrometer, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_Gyrometer[] = {
        { const_cast<char*>("report_interval"), (getter)Gyrometer_get_ReportInterval, (setter)Gyrometer_put_ReportInterval, nullptr, nullptr },
        { const_cast<char*>("minimum_report_interval"), (getter)Gyrometer_get_MinimumReportInterval, nullptr, nullptr, nullptr },
        { const_cast<char*>("reading_transform"), (getter)Gyrometer_get_ReadingTransform, (setter)Gyrometer_put_ReadingTransform, nullptr, nullptr },
        { const_cast<char*>("report_latency"), (getter)Gyrometer_get_ReportLatency, (setter)Gyrometer_put_ReportLatency, nullptr, nullptr },
        { const_cast<char*>("max_batch_size"), (getter)Gyrometer_get_MaxBatchSize, nullptr, nullptr, nullptr },
        { const_cast<char*>("report_threshold"), (getter)Gyrometer_get_ReportThreshold, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)Gyrometer_get_DeviceId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Gyrometer[] = 
    {
        { Py_tp_new, _new_Gyrometer },
        { Py_tp_dealloc, _dealloc_Gyrometer },
        { Py_tp_methods, _methods_Gyrometer },
        { Py_tp_getset, _getset_Gyrometer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Gyrometer =
    {
        "_winrt_Windows_Devices_Sensors.Gyrometer",
        sizeof(py::wrapper::Windows::Devices::Sensors::Gyrometer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Gyrometer
    };

    // ----- GyrometerDataThreshold class --------------------
    constexpr const char* const _type_name_GyrometerDataThreshold = "GyrometerDataThreshold";

    static PyObject* _new_GyrometerDataThreshold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GyrometerDataThreshold);
        return nullptr;
    }

    static void _dealloc_GyrometerDataThreshold(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GyrometerDataThreshold_get_ZAxisInDegreesPerSecond(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZAxisInDegreesPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GyrometerDataThreshold_put_ZAxisInDegreesPerSecond(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ZAxisInDegreesPerSecond(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GyrometerDataThreshold_get_YAxisInDegreesPerSecond(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.YAxisInDegreesPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GyrometerDataThreshold_put_YAxisInDegreesPerSecond(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.YAxisInDegreesPerSecond(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GyrometerDataThreshold_get_XAxisInDegreesPerSecond(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.XAxisInDegreesPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GyrometerDataThreshold_put_XAxisInDegreesPerSecond(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.XAxisInDegreesPerSecond(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_GyrometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::GyrometerDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GyrometerDataThreshold[] = {
        { "_from", (PyCFunction)_from_GyrometerDataThreshold, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GyrometerDataThreshold[] = {
        { const_cast<char*>("z_axis_in_degrees_per_second"), (getter)GyrometerDataThreshold_get_ZAxisInDegreesPerSecond, (setter)GyrometerDataThreshold_put_ZAxisInDegreesPerSecond, nullptr, nullptr },
        { const_cast<char*>("y_axis_in_degrees_per_second"), (getter)GyrometerDataThreshold_get_YAxisInDegreesPerSecond, (setter)GyrometerDataThreshold_put_YAxisInDegreesPerSecond, nullptr, nullptr },
        { const_cast<char*>("x_axis_in_degrees_per_second"), (getter)GyrometerDataThreshold_get_XAxisInDegreesPerSecond, (setter)GyrometerDataThreshold_put_XAxisInDegreesPerSecond, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GyrometerDataThreshold[] = 
    {
        { Py_tp_new, _new_GyrometerDataThreshold },
        { Py_tp_dealloc, _dealloc_GyrometerDataThreshold },
        { Py_tp_methods, _methods_GyrometerDataThreshold },
        { Py_tp_getset, _getset_GyrometerDataThreshold },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GyrometerDataThreshold =
    {
        "_winrt_Windows_Devices_Sensors.GyrometerDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::GyrometerDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GyrometerDataThreshold
    };

    // ----- GyrometerReading class --------------------
    constexpr const char* const _type_name_GyrometerReading = "GyrometerReading";

    static PyObject* _new_GyrometerReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GyrometerReading);
        return nullptr;
    }

    static void _dealloc_GyrometerReading(py::wrapper::Windows::Devices::Sensors::GyrometerReading* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GyrometerReading_get_AngularVelocityX(py::wrapper::Windows::Devices::Sensors::GyrometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AngularVelocityX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GyrometerReading_get_AngularVelocityY(py::wrapper::Windows::Devices::Sensors::GyrometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AngularVelocityY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GyrometerReading_get_AngularVelocityZ(py::wrapper::Windows::Devices::Sensors::GyrometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AngularVelocityZ());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GyrometerReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::GyrometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GyrometerReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::GyrometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GyrometerReading_get_Properties(py::wrapper::Windows::Devices::Sensors::GyrometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GyrometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::GyrometerReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GyrometerReading[] = {
        { "_from", (PyCFunction)_from_GyrometerReading, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GyrometerReading[] = {
        { const_cast<char*>("angular_velocity_x"), (getter)GyrometerReading_get_AngularVelocityX, nullptr, nullptr, nullptr },
        { const_cast<char*>("angular_velocity_y"), (getter)GyrometerReading_get_AngularVelocityY, nullptr, nullptr, nullptr },
        { const_cast<char*>("angular_velocity_z"), (getter)GyrometerReading_get_AngularVelocityZ, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)GyrometerReading_get_Timestamp, nullptr, nullptr, nullptr },
        { const_cast<char*>("performance_count"), (getter)GyrometerReading_get_PerformanceCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)GyrometerReading_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GyrometerReading[] = 
    {
        { Py_tp_new, _new_GyrometerReading },
        { Py_tp_dealloc, _dealloc_GyrometerReading },
        { Py_tp_methods, _methods_GyrometerReading },
        { Py_tp_getset, _getset_GyrometerReading },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GyrometerReading =
    {
        "_winrt_Windows_Devices_Sensors.GyrometerReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::GyrometerReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GyrometerReading
    };

    // ----- GyrometerReadingChangedEventArgs class --------------------
    constexpr const char* const _type_name_GyrometerReadingChangedEventArgs = "GyrometerReadingChangedEventArgs";

    static PyObject* _new_GyrometerReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GyrometerReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_GyrometerReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GyrometerReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GyrometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GyrometerReadingChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_GyrometerReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GyrometerReadingChangedEventArgs[] = {
        { const_cast<char*>("reading"), (getter)GyrometerReadingChangedEventArgs_get_Reading, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GyrometerReadingChangedEventArgs[] = 
    {
        { Py_tp_new, _new_GyrometerReadingChangedEventArgs },
        { Py_tp_dealloc, _dealloc_GyrometerReadingChangedEventArgs },
        { Py_tp_methods, _methods_GyrometerReadingChangedEventArgs },
        { Py_tp_getset, _getset_GyrometerReadingChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GyrometerReadingChangedEventArgs =
    {
        "_winrt_Windows_Devices_Sensors.GyrometerReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GyrometerReadingChangedEventArgs
    };

    // ----- HingeAngleReading class --------------------
    constexpr const char* const _type_name_HingeAngleReading = "HingeAngleReading";

    static PyObject* _new_HingeAngleReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HingeAngleReading);
        return nullptr;
    }

    static void _dealloc_HingeAngleReading(py::wrapper::Windows::Devices::Sensors::HingeAngleReading* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HingeAngleReading_get_AngleInDegrees(py::wrapper::Windows::Devices::Sensors::HingeAngleReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AngleInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HingeAngleReading_get_Properties(py::wrapper::Windows::Devices::Sensors::HingeAngleReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HingeAngleReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::HingeAngleReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HingeAngleReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::HingeAngleReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HingeAngleReading[] = {
        { "_from", (PyCFunction)_from_HingeAngleReading, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HingeAngleReading[] = {
        { const_cast<char*>("angle_in_degrees"), (getter)HingeAngleReading_get_AngleInDegrees, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)HingeAngleReading_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)HingeAngleReading_get_Timestamp, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HingeAngleReading[] = 
    {
        { Py_tp_new, _new_HingeAngleReading },
        { Py_tp_dealloc, _dealloc_HingeAngleReading },
        { Py_tp_methods, _methods_HingeAngleReading },
        { Py_tp_getset, _getset_HingeAngleReading },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HingeAngleReading =
    {
        "_winrt_Windows_Devices_Sensors.HingeAngleReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::HingeAngleReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HingeAngleReading
    };

    // ----- HingeAngleSensor class --------------------
    constexpr const char* const _type_name_HingeAngleSensor = "HingeAngleSensor";

    static PyObject* _new_HingeAngleSensor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HingeAngleSensor);
        return nullptr;
    }

    static void _dealloc_HingeAngleSensor(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HingeAngleSensor_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::HingeAngleSensor::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_GetCurrentReadingAsync(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReadingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::HingeAngleSensor::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::HingeAngleSensor::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_GetRelatedToAdjacentPanelsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Devices::Sensors::HingeAngleSensor::GetRelatedToAdjacentPanelsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_get_ReportThresholdInDegrees(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportThresholdInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HingeAngleSensor_put_ReportThresholdInDegrees(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ReportThresholdInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HingeAngleSensor_get_DeviceId(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_get_MinReportThresholdInDegrees(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinReportThresholdInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::HingeAngleSensor, winrt::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HingeAngleSensor_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HingeAngleSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::HingeAngleSensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HingeAngleSensor[] = {
        { "from_id_async", (PyCFunction)HingeAngleSensor_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading_async", (PyCFunction)HingeAngleSensor_GetCurrentReadingAsync, METH_VARARGS, nullptr },
        { "get_default_async", (PyCFunction)HingeAngleSensor_GetDefaultAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)HingeAngleSensor_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "get_related_to_adjacent_panels_async", (PyCFunction)HingeAngleSensor_GetRelatedToAdjacentPanelsAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", (PyCFunction)HingeAngleSensor_add_ReadingChanged, METH_O, nullptr },
        { "remove_reading_changed", (PyCFunction)HingeAngleSensor_remove_ReadingChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_HingeAngleSensor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HingeAngleSensor[] = {
        { const_cast<char*>("report_threshold_in_degrees"), (getter)HingeAngleSensor_get_ReportThresholdInDegrees, (setter)HingeAngleSensor_put_ReportThresholdInDegrees, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)HingeAngleSensor_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("min_report_threshold_in_degrees"), (getter)HingeAngleSensor_get_MinReportThresholdInDegrees, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HingeAngleSensor[] = 
    {
        { Py_tp_new, _new_HingeAngleSensor },
        { Py_tp_dealloc, _dealloc_HingeAngleSensor },
        { Py_tp_methods, _methods_HingeAngleSensor },
        { Py_tp_getset, _getset_HingeAngleSensor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HingeAngleSensor =
    {
        "_winrt_Windows_Devices_Sensors.HingeAngleSensor",
        sizeof(py::wrapper::Windows::Devices::Sensors::HingeAngleSensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HingeAngleSensor
    };

    // ----- HingeAngleSensorReadingChangedEventArgs class --------------------
    constexpr const char* const _type_name_HingeAngleSensorReadingChangedEventArgs = "HingeAngleSensorReadingChangedEventArgs";

    static PyObject* _new_HingeAngleSensorReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HingeAngleSensorReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_HingeAngleSensorReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HingeAngleSensorReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HingeAngleSensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HingeAngleSensorReadingChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_HingeAngleSensorReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HingeAngleSensorReadingChangedEventArgs[] = {
        { const_cast<char*>("reading"), (getter)HingeAngleSensorReadingChangedEventArgs_get_Reading, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HingeAngleSensorReadingChangedEventArgs[] = 
    {
        { Py_tp_new, _new_HingeAngleSensorReadingChangedEventArgs },
        { Py_tp_dealloc, _dealloc_HingeAngleSensorReadingChangedEventArgs },
        { Py_tp_methods, _methods_HingeAngleSensorReadingChangedEventArgs },
        { Py_tp_getset, _getset_HingeAngleSensorReadingChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HingeAngleSensorReadingChangedEventArgs =
    {
        "_winrt_Windows_Devices_Sensors.HingeAngleSensorReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HingeAngleSensorReadingChangedEventArgs
    };

    // ----- Inclinometer class --------------------
    constexpr const char* const _type_name_Inclinometer = "Inclinometer";

    static PyObject* _new_Inclinometer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_Inclinometer);
        return nullptr;
    }

    static void _dealloc_Inclinometer(py::wrapper::Windows::Devices::Sensors::Inclinometer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Inclinometer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Inclinometer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Inclinometer_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Inclinometer_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Inclinometer::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorReadingType>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Inclinometer::GetDefault(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Inclinometer_GetDefaultForRelativeReadings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Inclinometer::GetDefaultForRelativeReadings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Inclinometer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorReadingType>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Inclinometer::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Inclinometer_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Inclinometer_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Inclinometer_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Inclinometer_get_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReadingTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Inclinometer_put_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Display::DisplayOrientations>(arg);

            self->obj.ReadingTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Inclinometer_get_ReadingType(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReadingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Inclinometer_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Inclinometer_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Inclinometer_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Inclinometer_get_ReportThreshold(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Inclinometer_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Inclinometer_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Inclinometer, winrt::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Inclinometer_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Inclinometer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Inclinometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Inclinometer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Inclinometer[] = {
        { "from_id_async", (PyCFunction)Inclinometer_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading", (PyCFunction)Inclinometer_GetCurrentReading, METH_VARARGS, nullptr },
        { "get_default", (PyCFunction)Inclinometer_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_for_relative_readings", (PyCFunction)Inclinometer_GetDefaultForRelativeReadings, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)Inclinometer_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", (PyCFunction)Inclinometer_add_ReadingChanged, METH_O, nullptr },
        { "remove_reading_changed", (PyCFunction)Inclinometer_remove_ReadingChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_Inclinometer, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_Inclinometer[] = {
        { const_cast<char*>("report_interval"), (getter)Inclinometer_get_ReportInterval, (setter)Inclinometer_put_ReportInterval, nullptr, nullptr },
        { const_cast<char*>("minimum_report_interval"), (getter)Inclinometer_get_MinimumReportInterval, nullptr, nullptr, nullptr },
        { const_cast<char*>("reading_transform"), (getter)Inclinometer_get_ReadingTransform, (setter)Inclinometer_put_ReadingTransform, nullptr, nullptr },
        { const_cast<char*>("reading_type"), (getter)Inclinometer_get_ReadingType, nullptr, nullptr, nullptr },
        { const_cast<char*>("report_latency"), (getter)Inclinometer_get_ReportLatency, (setter)Inclinometer_put_ReportLatency, nullptr, nullptr },
        { const_cast<char*>("max_batch_size"), (getter)Inclinometer_get_MaxBatchSize, nullptr, nullptr, nullptr },
        { const_cast<char*>("report_threshold"), (getter)Inclinometer_get_ReportThreshold, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)Inclinometer_get_DeviceId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Inclinometer[] = 
    {
        { Py_tp_new, _new_Inclinometer },
        { Py_tp_dealloc, _dealloc_Inclinometer },
        { Py_tp_methods, _methods_Inclinometer },
        { Py_tp_getset, _getset_Inclinometer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Inclinometer =
    {
        "_winrt_Windows_Devices_Sensors.Inclinometer",
        sizeof(py::wrapper::Windows::Devices::Sensors::Inclinometer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Inclinometer
    };

    // ----- InclinometerDataThreshold class --------------------
    constexpr const char* const _type_name_InclinometerDataThreshold = "InclinometerDataThreshold";

    static PyObject* _new_InclinometerDataThreshold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InclinometerDataThreshold);
        return nullptr;
    }

    static void _dealloc_InclinometerDataThreshold(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InclinometerDataThreshold_get_YawInDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.YawInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InclinometerDataThreshold_put_YawInDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.YawInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InclinometerDataThreshold_get_RollInDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RollInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InclinometerDataThreshold_put_RollInDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.RollInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InclinometerDataThreshold_get_PitchInDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PitchInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InclinometerDataThreshold_put_PitchInDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.PitchInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_InclinometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::InclinometerDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InclinometerDataThreshold[] = {
        { "_from", (PyCFunction)_from_InclinometerDataThreshold, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InclinometerDataThreshold[] = {
        { const_cast<char*>("yaw_in_degrees"), (getter)InclinometerDataThreshold_get_YawInDegrees, (setter)InclinometerDataThreshold_put_YawInDegrees, nullptr, nullptr },
        { const_cast<char*>("roll_in_degrees"), (getter)InclinometerDataThreshold_get_RollInDegrees, (setter)InclinometerDataThreshold_put_RollInDegrees, nullptr, nullptr },
        { const_cast<char*>("pitch_in_degrees"), (getter)InclinometerDataThreshold_get_PitchInDegrees, (setter)InclinometerDataThreshold_put_PitchInDegrees, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InclinometerDataThreshold[] = 
    {
        { Py_tp_new, _new_InclinometerDataThreshold },
        { Py_tp_dealloc, _dealloc_InclinometerDataThreshold },
        { Py_tp_methods, _methods_InclinometerDataThreshold },
        { Py_tp_getset, _getset_InclinometerDataThreshold },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InclinometerDataThreshold =
    {
        "_winrt_Windows_Devices_Sensors.InclinometerDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::InclinometerDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InclinometerDataThreshold
    };

    // ----- InclinometerReading class --------------------
    constexpr const char* const _type_name_InclinometerReading = "InclinometerReading";

    static PyObject* _new_InclinometerReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InclinometerReading);
        return nullptr;
    }

    static void _dealloc_InclinometerReading(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InclinometerReading_get_PitchDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PitchDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InclinometerReading_get_RollDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RollDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InclinometerReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InclinometerReading_get_YawDegrees(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.YawDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InclinometerReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InclinometerReading_get_Properties(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InclinometerReading_get_YawAccuracy(py::wrapper::Windows::Devices::Sensors::InclinometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.YawAccuracy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InclinometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::InclinometerReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InclinometerReading[] = {
        { "_from", (PyCFunction)_from_InclinometerReading, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InclinometerReading[] = {
        { const_cast<char*>("pitch_degrees"), (getter)InclinometerReading_get_PitchDegrees, nullptr, nullptr, nullptr },
        { const_cast<char*>("roll_degrees"), (getter)InclinometerReading_get_RollDegrees, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)InclinometerReading_get_Timestamp, nullptr, nullptr, nullptr },
        { const_cast<char*>("yaw_degrees"), (getter)InclinometerReading_get_YawDegrees, nullptr, nullptr, nullptr },
        { const_cast<char*>("performance_count"), (getter)InclinometerReading_get_PerformanceCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)InclinometerReading_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("yaw_accuracy"), (getter)InclinometerReading_get_YawAccuracy, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InclinometerReading[] = 
    {
        { Py_tp_new, _new_InclinometerReading },
        { Py_tp_dealloc, _dealloc_InclinometerReading },
        { Py_tp_methods, _methods_InclinometerReading },
        { Py_tp_getset, _getset_InclinometerReading },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InclinometerReading =
    {
        "_winrt_Windows_Devices_Sensors.InclinometerReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::InclinometerReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InclinometerReading
    };

    // ----- InclinometerReadingChangedEventArgs class --------------------
    constexpr const char* const _type_name_InclinometerReadingChangedEventArgs = "InclinometerReadingChangedEventArgs";

    static PyObject* _new_InclinometerReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InclinometerReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_InclinometerReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InclinometerReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InclinometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InclinometerReadingChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_InclinometerReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InclinometerReadingChangedEventArgs[] = {
        { const_cast<char*>("reading"), (getter)InclinometerReadingChangedEventArgs_get_Reading, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InclinometerReadingChangedEventArgs[] = 
    {
        { Py_tp_new, _new_InclinometerReadingChangedEventArgs },
        { Py_tp_dealloc, _dealloc_InclinometerReadingChangedEventArgs },
        { Py_tp_methods, _methods_InclinometerReadingChangedEventArgs },
        { Py_tp_getset, _getset_InclinometerReadingChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InclinometerReadingChangedEventArgs =
    {
        "_winrt_Windows_Devices_Sensors.InclinometerReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InclinometerReadingChangedEventArgs
    };

    // ----- LightSensor class --------------------
    constexpr const char* const _type_name_LightSensor = "LightSensor";

    static PyObject* _new_LightSensor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LightSensor);
        return nullptr;
    }

    static void _dealloc_LightSensor(py::wrapper::Windows::Devices::Sensors::LightSensor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LightSensor_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::LightSensor::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LightSensor_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::LightSensor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LightSensor_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::LightSensor::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LightSensor_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::LightSensor::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LightSensor_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::LightSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LightSensor_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::LightSensor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LightSensor_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::LightSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensor_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::LightSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LightSensor_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::LightSensor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LightSensor_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::LightSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensor_get_ReportThreshold(py::wrapper::Windows::Devices::Sensors::LightSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensor_get_DeviceId(py::wrapper::Windows::Devices::Sensors::LightSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensor_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::LightSensor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::LightSensor, winrt::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensor_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::LightSensor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LightSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::LightSensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LightSensor[] = {
        { "from_id_async", (PyCFunction)LightSensor_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading", (PyCFunction)LightSensor_GetCurrentReading, METH_VARARGS, nullptr },
        { "get_default", (PyCFunction)LightSensor_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)LightSensor_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", (PyCFunction)LightSensor_add_ReadingChanged, METH_O, nullptr },
        { "remove_reading_changed", (PyCFunction)LightSensor_remove_ReadingChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_LightSensor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LightSensor[] = {
        { const_cast<char*>("report_interval"), (getter)LightSensor_get_ReportInterval, (setter)LightSensor_put_ReportInterval, nullptr, nullptr },
        { const_cast<char*>("minimum_report_interval"), (getter)LightSensor_get_MinimumReportInterval, nullptr, nullptr, nullptr },
        { const_cast<char*>("report_latency"), (getter)LightSensor_get_ReportLatency, (setter)LightSensor_put_ReportLatency, nullptr, nullptr },
        { const_cast<char*>("max_batch_size"), (getter)LightSensor_get_MaxBatchSize, nullptr, nullptr, nullptr },
        { const_cast<char*>("report_threshold"), (getter)LightSensor_get_ReportThreshold, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)LightSensor_get_DeviceId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LightSensor[] = 
    {
        { Py_tp_new, _new_LightSensor },
        { Py_tp_dealloc, _dealloc_LightSensor },
        { Py_tp_methods, _methods_LightSensor },
        { Py_tp_getset, _getset_LightSensor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LightSensor =
    {
        "_winrt_Windows_Devices_Sensors.LightSensor",
        sizeof(py::wrapper::Windows::Devices::Sensors::LightSensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LightSensor
    };

    // ----- LightSensorDataThreshold class --------------------
    constexpr const char* const _type_name_LightSensorDataThreshold = "LightSensorDataThreshold";

    static PyObject* _new_LightSensorDataThreshold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LightSensorDataThreshold);
        return nullptr;
    }

    static void _dealloc_LightSensorDataThreshold(py::wrapper::Windows::Devices::Sensors::LightSensorDataThreshold* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LightSensorDataThreshold_get_LuxPercentage(py::wrapper::Windows::Devices::Sensors::LightSensorDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LuxPercentage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LightSensorDataThreshold_put_LuxPercentage(py::wrapper::Windows::Devices::Sensors::LightSensorDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.LuxPercentage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LightSensorDataThreshold_get_AbsoluteLux(py::wrapper::Windows::Devices::Sensors::LightSensorDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AbsoluteLux());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LightSensorDataThreshold_put_AbsoluteLux(py::wrapper::Windows::Devices::Sensors::LightSensorDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.AbsoluteLux(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_LightSensorDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::LightSensorDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LightSensorDataThreshold[] = {
        { "_from", (PyCFunction)_from_LightSensorDataThreshold, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LightSensorDataThreshold[] = {
        { const_cast<char*>("lux_percentage"), (getter)LightSensorDataThreshold_get_LuxPercentage, (setter)LightSensorDataThreshold_put_LuxPercentage, nullptr, nullptr },
        { const_cast<char*>("absolute_lux"), (getter)LightSensorDataThreshold_get_AbsoluteLux, (setter)LightSensorDataThreshold_put_AbsoluteLux, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LightSensorDataThreshold[] = 
    {
        { Py_tp_new, _new_LightSensorDataThreshold },
        { Py_tp_dealloc, _dealloc_LightSensorDataThreshold },
        { Py_tp_methods, _methods_LightSensorDataThreshold },
        { Py_tp_getset, _getset_LightSensorDataThreshold },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LightSensorDataThreshold =
    {
        "_winrt_Windows_Devices_Sensors.LightSensorDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::LightSensorDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LightSensorDataThreshold
    };

    // ----- LightSensorReading class --------------------
    constexpr const char* const _type_name_LightSensorReading = "LightSensorReading";

    static PyObject* _new_LightSensorReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LightSensorReading);
        return nullptr;
    }

    static void _dealloc_LightSensorReading(py::wrapper::Windows::Devices::Sensors::LightSensorReading* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LightSensorReading_get_IlluminanceInLux(py::wrapper::Windows::Devices::Sensors::LightSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IlluminanceInLux());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensorReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::LightSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensorReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::LightSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LightSensorReading_get_Properties(py::wrapper::Windows::Devices::Sensors::LightSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LightSensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::LightSensorReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LightSensorReading[] = {
        { "_from", (PyCFunction)_from_LightSensorReading, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LightSensorReading[] = {
        { const_cast<char*>("illuminance_in_lux"), (getter)LightSensorReading_get_IlluminanceInLux, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)LightSensorReading_get_Timestamp, nullptr, nullptr, nullptr },
        { const_cast<char*>("performance_count"), (getter)LightSensorReading_get_PerformanceCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)LightSensorReading_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LightSensorReading[] = 
    {
        { Py_tp_new, _new_LightSensorReading },
        { Py_tp_dealloc, _dealloc_LightSensorReading },
        { Py_tp_methods, _methods_LightSensorReading },
        { Py_tp_getset, _getset_LightSensorReading },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LightSensorReading =
    {
        "_winrt_Windows_Devices_Sensors.LightSensorReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::LightSensorReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LightSensorReading
    };

    // ----- LightSensorReadingChangedEventArgs class --------------------
    constexpr const char* const _type_name_LightSensorReadingChangedEventArgs = "LightSensorReadingChangedEventArgs";

    static PyObject* _new_LightSensorReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LightSensorReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_LightSensorReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LightSensorReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LightSensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LightSensorReadingChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_LightSensorReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LightSensorReadingChangedEventArgs[] = {
        { const_cast<char*>("reading"), (getter)LightSensorReadingChangedEventArgs_get_Reading, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LightSensorReadingChangedEventArgs[] = 
    {
        { Py_tp_new, _new_LightSensorReadingChangedEventArgs },
        { Py_tp_dealloc, _dealloc_LightSensorReadingChangedEventArgs },
        { Py_tp_methods, _methods_LightSensorReadingChangedEventArgs },
        { Py_tp_getset, _getset_LightSensorReadingChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LightSensorReadingChangedEventArgs =
    {
        "_winrt_Windows_Devices_Sensors.LightSensorReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LightSensorReadingChangedEventArgs
    };

    // ----- Magnetometer class --------------------
    constexpr const char* const _type_name_Magnetometer = "Magnetometer";

    static PyObject* _new_Magnetometer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_Magnetometer);
        return nullptr;
    }

    static void _dealloc_Magnetometer(py::wrapper::Windows::Devices::Sensors::Magnetometer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Magnetometer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Magnetometer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Magnetometer_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Magnetometer_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Magnetometer::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Magnetometer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Magnetometer::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Magnetometer_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Magnetometer_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Magnetometer_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Magnetometer_get_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReadingTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Magnetometer_put_ReadingTransform(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Display::DisplayOrientations>(arg);

            self->obj.ReadingTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Magnetometer_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Magnetometer_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Magnetometer_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Magnetometer_get_ReportThreshold(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Magnetometer_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Magnetometer_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Magnetometer, winrt::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Magnetometer_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Magnetometer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Magnetometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Magnetometer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Magnetometer[] = {
        { "from_id_async", (PyCFunction)Magnetometer_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading", (PyCFunction)Magnetometer_GetCurrentReading, METH_VARARGS, nullptr },
        { "get_default", (PyCFunction)Magnetometer_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)Magnetometer_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", (PyCFunction)Magnetometer_add_ReadingChanged, METH_O, nullptr },
        { "remove_reading_changed", (PyCFunction)Magnetometer_remove_ReadingChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_Magnetometer, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_Magnetometer[] = {
        { const_cast<char*>("report_interval"), (getter)Magnetometer_get_ReportInterval, (setter)Magnetometer_put_ReportInterval, nullptr, nullptr },
        { const_cast<char*>("minimum_report_interval"), (getter)Magnetometer_get_MinimumReportInterval, nullptr, nullptr, nullptr },
        { const_cast<char*>("reading_transform"), (getter)Magnetometer_get_ReadingTransform, (setter)Magnetometer_put_ReadingTransform, nullptr, nullptr },
        { const_cast<char*>("report_latency"), (getter)Magnetometer_get_ReportLatency, (setter)Magnetometer_put_ReportLatency, nullptr, nullptr },
        { const_cast<char*>("max_batch_size"), (getter)Magnetometer_get_MaxBatchSize, nullptr, nullptr, nullptr },
        { const_cast<char*>("report_threshold"), (getter)Magnetometer_get_ReportThreshold, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)Magnetometer_get_DeviceId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Magnetometer[] = 
    {
        { Py_tp_new, _new_Magnetometer },
        { Py_tp_dealloc, _dealloc_Magnetometer },
        { Py_tp_methods, _methods_Magnetometer },
        { Py_tp_getset, _getset_Magnetometer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Magnetometer =
    {
        "_winrt_Windows_Devices_Sensors.Magnetometer",
        sizeof(py::wrapper::Windows::Devices::Sensors::Magnetometer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Magnetometer
    };

    // ----- MagnetometerDataThreshold class --------------------
    constexpr const char* const _type_name_MagnetometerDataThreshold = "MagnetometerDataThreshold";

    static PyObject* _new_MagnetometerDataThreshold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagnetometerDataThreshold);
        return nullptr;
    }

    static void _dealloc_MagnetometerDataThreshold(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MagnetometerDataThreshold_get_ZAxisMicroteslas(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZAxisMicroteslas());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MagnetometerDataThreshold_put_ZAxisMicroteslas(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.ZAxisMicroteslas(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MagnetometerDataThreshold_get_YAxisMicroteslas(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.YAxisMicroteslas());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MagnetometerDataThreshold_put_YAxisMicroteslas(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.YAxisMicroteslas(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MagnetometerDataThreshold_get_XAxisMicroteslas(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.XAxisMicroteslas());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MagnetometerDataThreshold_put_XAxisMicroteslas(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.XAxisMicroteslas(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_MagnetometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::MagnetometerDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagnetometerDataThreshold[] = {
        { "_from", (PyCFunction)_from_MagnetometerDataThreshold, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MagnetometerDataThreshold[] = {
        { const_cast<char*>("z_axis_microteslas"), (getter)MagnetometerDataThreshold_get_ZAxisMicroteslas, (setter)MagnetometerDataThreshold_put_ZAxisMicroteslas, nullptr, nullptr },
        { const_cast<char*>("y_axis_microteslas"), (getter)MagnetometerDataThreshold_get_YAxisMicroteslas, (setter)MagnetometerDataThreshold_put_YAxisMicroteslas, nullptr, nullptr },
        { const_cast<char*>("x_axis_microteslas"), (getter)MagnetometerDataThreshold_get_XAxisMicroteslas, (setter)MagnetometerDataThreshold_put_XAxisMicroteslas, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MagnetometerDataThreshold[] = 
    {
        { Py_tp_new, _new_MagnetometerDataThreshold },
        { Py_tp_dealloc, _dealloc_MagnetometerDataThreshold },
        { Py_tp_methods, _methods_MagnetometerDataThreshold },
        { Py_tp_getset, _getset_MagnetometerDataThreshold },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MagnetometerDataThreshold =
    {
        "_winrt_Windows_Devices_Sensors.MagnetometerDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::MagnetometerDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagnetometerDataThreshold
    };

    // ----- MagnetometerReading class --------------------
    constexpr const char* const _type_name_MagnetometerReading = "MagnetometerReading";

    static PyObject* _new_MagnetometerReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagnetometerReading);
        return nullptr;
    }

    static void _dealloc_MagnetometerReading(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MagnetometerReading_get_DirectionalAccuracy(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DirectionalAccuracy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagnetometerReading_get_MagneticFieldX(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MagneticFieldX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagnetometerReading_get_MagneticFieldY(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MagneticFieldY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagnetometerReading_get_MagneticFieldZ(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MagneticFieldZ());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagnetometerReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagnetometerReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagnetometerReading_get_Properties(py::wrapper::Windows::Devices::Sensors::MagnetometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MagnetometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::MagnetometerReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagnetometerReading[] = {
        { "_from", (PyCFunction)_from_MagnetometerReading, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MagnetometerReading[] = {
        { const_cast<char*>("directional_accuracy"), (getter)MagnetometerReading_get_DirectionalAccuracy, nullptr, nullptr, nullptr },
        { const_cast<char*>("magnetic_field_x"), (getter)MagnetometerReading_get_MagneticFieldX, nullptr, nullptr, nullptr },
        { const_cast<char*>("magnetic_field_y"), (getter)MagnetometerReading_get_MagneticFieldY, nullptr, nullptr, nullptr },
        { const_cast<char*>("magnetic_field_z"), (getter)MagnetometerReading_get_MagneticFieldZ, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)MagnetometerReading_get_Timestamp, nullptr, nullptr, nullptr },
        { const_cast<char*>("performance_count"), (getter)MagnetometerReading_get_PerformanceCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)MagnetometerReading_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MagnetometerReading[] = 
    {
        { Py_tp_new, _new_MagnetometerReading },
        { Py_tp_dealloc, _dealloc_MagnetometerReading },
        { Py_tp_methods, _methods_MagnetometerReading },
        { Py_tp_getset, _getset_MagnetometerReading },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MagnetometerReading =
    {
        "_winrt_Windows_Devices_Sensors.MagnetometerReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::MagnetometerReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagnetometerReading
    };

    // ----- MagnetometerReadingChangedEventArgs class --------------------
    constexpr const char* const _type_name_MagnetometerReadingChangedEventArgs = "MagnetometerReadingChangedEventArgs";

    static PyObject* _new_MagnetometerReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagnetometerReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_MagnetometerReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MagnetometerReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MagnetometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagnetometerReadingChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_MagnetometerReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MagnetometerReadingChangedEventArgs[] = {
        { const_cast<char*>("reading"), (getter)MagnetometerReadingChangedEventArgs_get_Reading, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MagnetometerReadingChangedEventArgs[] = 
    {
        { Py_tp_new, _new_MagnetometerReadingChangedEventArgs },
        { Py_tp_dealloc, _dealloc_MagnetometerReadingChangedEventArgs },
        { Py_tp_methods, _methods_MagnetometerReadingChangedEventArgs },
        { Py_tp_getset, _getset_MagnetometerReadingChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MagnetometerReadingChangedEventArgs =
    {
        "_winrt_Windows_Devices_Sensors.MagnetometerReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagnetometerReadingChangedEventArgs
    };

    // ----- OrientationSensor class --------------------
    constexpr const char* const _type_name_OrientationSensor = "OrientationSensor";

    static PyObject* _new_OrientationSensor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_OrientationSensor);
        return nullptr;
    }

    static void _dealloc_OrientationSensor(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* OrientationSensor_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::OrientationSensor::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::OrientationSensor::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorReadingType>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::OrientationSensor::GetDefault(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorReadingType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Sensors::SensorOptimizationGoal>(args, 1);

                return py::convert(winrt::Windows::Devices::Sensors::OrientationSensor::GetDefault(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_GetDefaultForRelativeReadings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::OrientationSensor::GetDefaultForRelativeReadings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorReadingType>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::OrientationSensor::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorReadingType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Sensors::SensorOptimizationGoal>(args, 1);

                return py::convert(winrt::Windows::Devices::Sensors::OrientationSensor::GetDeviceSelector(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OrientationSensor_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OrientationSensor_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_get_ReadingTransform(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReadingTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OrientationSensor_put_ReadingTransform(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Display::DisplayOrientations>(arg);

            self->obj.ReadingTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OrientationSensor_get_ReadingType(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReadingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_get_ReportLatency(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OrientationSensor_put_ReportLatency(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportLatency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OrientationSensor_get_MaxBatchSize(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxBatchSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_get_DeviceId(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::OrientationSensor, winrt::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensor_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::OrientationSensor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_OrientationSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::OrientationSensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OrientationSensor[] = {
        { "from_id_async", (PyCFunction)OrientationSensor_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading", (PyCFunction)OrientationSensor_GetCurrentReading, METH_VARARGS, nullptr },
        { "get_default", (PyCFunction)OrientationSensor_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_for_relative_readings", (PyCFunction)OrientationSensor_GetDefaultForRelativeReadings, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)OrientationSensor_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", (PyCFunction)OrientationSensor_add_ReadingChanged, METH_O, nullptr },
        { "remove_reading_changed", (PyCFunction)OrientationSensor_remove_ReadingChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_OrientationSensor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_OrientationSensor[] = {
        { const_cast<char*>("report_interval"), (getter)OrientationSensor_get_ReportInterval, (setter)OrientationSensor_put_ReportInterval, nullptr, nullptr },
        { const_cast<char*>("minimum_report_interval"), (getter)OrientationSensor_get_MinimumReportInterval, nullptr, nullptr, nullptr },
        { const_cast<char*>("reading_transform"), (getter)OrientationSensor_get_ReadingTransform, (setter)OrientationSensor_put_ReadingTransform, nullptr, nullptr },
        { const_cast<char*>("reading_type"), (getter)OrientationSensor_get_ReadingType, nullptr, nullptr, nullptr },
        { const_cast<char*>("report_latency"), (getter)OrientationSensor_get_ReportLatency, (setter)OrientationSensor_put_ReportLatency, nullptr, nullptr },
        { const_cast<char*>("max_batch_size"), (getter)OrientationSensor_get_MaxBatchSize, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)OrientationSensor_get_DeviceId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_OrientationSensor[] = 
    {
        { Py_tp_new, _new_OrientationSensor },
        { Py_tp_dealloc, _dealloc_OrientationSensor },
        { Py_tp_methods, _methods_OrientationSensor },
        { Py_tp_getset, _getset_OrientationSensor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_OrientationSensor =
    {
        "_winrt_Windows_Devices_Sensors.OrientationSensor",
        sizeof(py::wrapper::Windows::Devices::Sensors::OrientationSensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OrientationSensor
    };

    // ----- OrientationSensorReading class --------------------
    constexpr const char* const _type_name_OrientationSensorReading = "OrientationSensorReading";

    static PyObject* _new_OrientationSensorReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_OrientationSensorReading);
        return nullptr;
    }

    static void _dealloc_OrientationSensorReading(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* OrientationSensorReading_get_Quaternion(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Quaternion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensorReading_get_RotationMatrix(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RotationMatrix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensorReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensorReading_get_PerformanceCount(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensorReading_get_Properties(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientationSensorReading_get_YawAccuracy(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.YawAccuracy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_OrientationSensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::OrientationSensorReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OrientationSensorReading[] = {
        { "_from", (PyCFunction)_from_OrientationSensorReading, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_OrientationSensorReading[] = {
        { const_cast<char*>("quaternion"), (getter)OrientationSensorReading_get_Quaternion, nullptr, nullptr, nullptr },
        { const_cast<char*>("rotation_matrix"), (getter)OrientationSensorReading_get_RotationMatrix, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)OrientationSensorReading_get_Timestamp, nullptr, nullptr, nullptr },
        { const_cast<char*>("performance_count"), (getter)OrientationSensorReading_get_PerformanceCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)OrientationSensorReading_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("yaw_accuracy"), (getter)OrientationSensorReading_get_YawAccuracy, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_OrientationSensorReading[] = 
    {
        { Py_tp_new, _new_OrientationSensorReading },
        { Py_tp_dealloc, _dealloc_OrientationSensorReading },
        { Py_tp_methods, _methods_OrientationSensorReading },
        { Py_tp_getset, _getset_OrientationSensorReading },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_OrientationSensorReading =
    {
        "_winrt_Windows_Devices_Sensors.OrientationSensorReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::OrientationSensorReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OrientationSensorReading
    };

    // ----- OrientationSensorReadingChangedEventArgs class --------------------
    constexpr const char* const _type_name_OrientationSensorReadingChangedEventArgs = "OrientationSensorReadingChangedEventArgs";

    static PyObject* _new_OrientationSensorReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_OrientationSensorReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_OrientationSensorReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* OrientationSensorReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_OrientationSensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OrientationSensorReadingChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_OrientationSensorReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_OrientationSensorReadingChangedEventArgs[] = {
        { const_cast<char*>("reading"), (getter)OrientationSensorReadingChangedEventArgs_get_Reading, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_OrientationSensorReadingChangedEventArgs[] = 
    {
        { Py_tp_new, _new_OrientationSensorReadingChangedEventArgs },
        { Py_tp_dealloc, _dealloc_OrientationSensorReadingChangedEventArgs },
        { Py_tp_methods, _methods_OrientationSensorReadingChangedEventArgs },
        { Py_tp_getset, _getset_OrientationSensorReadingChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_OrientationSensorReadingChangedEventArgs =
    {
        "_winrt_Windows_Devices_Sensors.OrientationSensorReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OrientationSensorReadingChangedEventArgs
    };

    // ----- Pedometer class --------------------
    constexpr const char* const _type_name_Pedometer = "Pedometer";

    static PyObject* _new_Pedometer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_Pedometer);
        return nullptr;
    }

    static void _dealloc_Pedometer(py::wrapper::Windows::Devices::Sensors::Pedometer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Pedometer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Pedometer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Pedometer_GetCurrentReadings(py::wrapper::Windows::Devices::Sensors::Pedometer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReadings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Pedometer_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Pedometer::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Pedometer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::Pedometer::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Pedometer_GetReadingsFromTriggerDetails(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Pedometer::GetReadingsFromTriggerDetails(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Pedometer_GetSystemHistoryAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::Pedometer::GetSystemHistoryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(winrt::Windows::Devices::Sensors::Pedometer::GetSystemHistoryAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Pedometer_get_ReportInterval(py::wrapper::Windows::Devices::Sensors::Pedometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Pedometer_put_ReportInterval(py::wrapper::Windows::Devices::Sensors::Pedometer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Pedometer_get_DeviceId(py::wrapper::Windows::Devices::Sensors::Pedometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Pedometer_get_MinimumReportInterval(py::wrapper::Windows::Devices::Sensors::Pedometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Pedometer_get_PowerInMilliwatts(py::wrapper::Windows::Devices::Sensors::Pedometer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerInMilliwatts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Pedometer_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Pedometer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::Pedometer, winrt::Windows::Devices::Sensors::PedometerReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Pedometer_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::Pedometer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Pedometer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::Pedometer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Pedometer[] = {
        { "from_id_async", (PyCFunction)Pedometer_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_readings", (PyCFunction)Pedometer_GetCurrentReadings, METH_VARARGS, nullptr },
        { "get_default_async", (PyCFunction)Pedometer_GetDefaultAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)Pedometer_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "get_readings_from_trigger_details", (PyCFunction)Pedometer_GetReadingsFromTriggerDetails, METH_VARARGS | METH_STATIC, nullptr },
        { "get_system_history_async", (PyCFunction)Pedometer_GetSystemHistoryAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", (PyCFunction)Pedometer_add_ReadingChanged, METH_O, nullptr },
        { "remove_reading_changed", (PyCFunction)Pedometer_remove_ReadingChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_Pedometer, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_Pedometer[] = {
        { const_cast<char*>("report_interval"), (getter)Pedometer_get_ReportInterval, (setter)Pedometer_put_ReportInterval, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)Pedometer_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("minimum_report_interval"), (getter)Pedometer_get_MinimumReportInterval, nullptr, nullptr, nullptr },
        { const_cast<char*>("power_in_milliwatts"), (getter)Pedometer_get_PowerInMilliwatts, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Pedometer[] = 
    {
        { Py_tp_new, _new_Pedometer },
        { Py_tp_dealloc, _dealloc_Pedometer },
        { Py_tp_methods, _methods_Pedometer },
        { Py_tp_getset, _getset_Pedometer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Pedometer =
    {
        "_winrt_Windows_Devices_Sensors.Pedometer",
        sizeof(py::wrapper::Windows::Devices::Sensors::Pedometer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Pedometer
    };

    // ----- PedometerDataThreshold class --------------------
    constexpr const char* const _type_name_PedometerDataThreshold = "PedometerDataThreshold";

    static PyObject* _new_PedometerDataThreshold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::Pedometer>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                winrt::Windows::Devices::Sensors::PedometerDataThreshold instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PedometerDataThreshold(py::wrapper::Windows::Devices::Sensors::PedometerDataThreshold* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_PedometerDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::PedometerDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PedometerDataThreshold[] = {
        { "_from", (PyCFunction)_from_PedometerDataThreshold, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PedometerDataThreshold[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PedometerDataThreshold[] = 
    {
        { Py_tp_new, _new_PedometerDataThreshold },
        { Py_tp_dealloc, _dealloc_PedometerDataThreshold },
        { Py_tp_methods, _methods_PedometerDataThreshold },
        { Py_tp_getset, _getset_PedometerDataThreshold },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PedometerDataThreshold =
    {
        "_winrt_Windows_Devices_Sensors.PedometerDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::PedometerDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PedometerDataThreshold
    };

    // ----- PedometerReading class --------------------
    constexpr const char* const _type_name_PedometerReading = "PedometerReading";

    static PyObject* _new_PedometerReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PedometerReading);
        return nullptr;
    }

    static void _dealloc_PedometerReading(py::wrapper::Windows::Devices::Sensors::PedometerReading* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PedometerReading_get_CumulativeSteps(py::wrapper::Windows::Devices::Sensors::PedometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CumulativeSteps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PedometerReading_get_CumulativeStepsDuration(py::wrapper::Windows::Devices::Sensors::PedometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CumulativeStepsDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PedometerReading_get_StepKind(py::wrapper::Windows::Devices::Sensors::PedometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StepKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PedometerReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::PedometerReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PedometerReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::PedometerReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PedometerReading[] = {
        { "_from", (PyCFunction)_from_PedometerReading, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PedometerReading[] = {
        { const_cast<char*>("cumulative_steps"), (getter)PedometerReading_get_CumulativeSteps, nullptr, nullptr, nullptr },
        { const_cast<char*>("cumulative_steps_duration"), (getter)PedometerReading_get_CumulativeStepsDuration, nullptr, nullptr, nullptr },
        { const_cast<char*>("step_kind"), (getter)PedometerReading_get_StepKind, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)PedometerReading_get_Timestamp, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PedometerReading[] = 
    {
        { Py_tp_new, _new_PedometerReading },
        { Py_tp_dealloc, _dealloc_PedometerReading },
        { Py_tp_methods, _methods_PedometerReading },
        { Py_tp_getset, _getset_PedometerReading },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PedometerReading =
    {
        "_winrt_Windows_Devices_Sensors.PedometerReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::PedometerReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PedometerReading
    };

    // ----- PedometerReadingChangedEventArgs class --------------------
    constexpr const char* const _type_name_PedometerReadingChangedEventArgs = "PedometerReadingChangedEventArgs";

    static PyObject* _new_PedometerReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PedometerReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_PedometerReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::PedometerReadingChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PedometerReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::PedometerReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PedometerReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::PedometerReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PedometerReadingChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_PedometerReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PedometerReadingChangedEventArgs[] = {
        { const_cast<char*>("reading"), (getter)PedometerReadingChangedEventArgs_get_Reading, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PedometerReadingChangedEventArgs[] = 
    {
        { Py_tp_new, _new_PedometerReadingChangedEventArgs },
        { Py_tp_dealloc, _dealloc_PedometerReadingChangedEventArgs },
        { Py_tp_methods, _methods_PedometerReadingChangedEventArgs },
        { Py_tp_getset, _getset_PedometerReadingChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PedometerReadingChangedEventArgs =
    {
        "_winrt_Windows_Devices_Sensors.PedometerReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::PedometerReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PedometerReadingChangedEventArgs
    };

    // ----- ProximitySensor class --------------------
    constexpr const char* const _type_name_ProximitySensor = "ProximitySensor";

    static PyObject* _new_ProximitySensor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProximitySensor);
        return nullptr;
    }

    static void _dealloc_ProximitySensor(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProximitySensor_CreateDisplayOnOffController(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateDisplayOnOffController());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::ProximitySensor::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_GetCurrentReading(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::ProximitySensor::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_GetReadingsFromTriggerDetails(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::ProximitySensor::GetReadingsFromTriggerDetails(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_get_DeviceId(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_get_MaxDistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxDistanceInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_get_MinDistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinDistanceInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_add_ReadingChanged(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::ProximitySensor, winrt::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs>>(arg);

            return py::convert(self->obj.ReadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProximitySensor_remove_ReadingChanged(py::wrapper::Windows::Devices::Sensors::ProximitySensor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProximitySensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ProximitySensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProximitySensor[] = {
        { "create_display_on_off_controller", (PyCFunction)ProximitySensor_CreateDisplayOnOffController, METH_VARARGS, nullptr },
        { "from_id", (PyCFunction)ProximitySensor_FromId, METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading", (PyCFunction)ProximitySensor_GetCurrentReading, METH_VARARGS, nullptr },
        { "get_device_selector", (PyCFunction)ProximitySensor_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "get_readings_from_trigger_details", (PyCFunction)ProximitySensor_GetReadingsFromTriggerDetails, METH_VARARGS | METH_STATIC, nullptr },
        { "add_reading_changed", (PyCFunction)ProximitySensor_add_ReadingChanged, METH_O, nullptr },
        { "remove_reading_changed", (PyCFunction)ProximitySensor_remove_ReadingChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ProximitySensor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ProximitySensor[] = {
        { const_cast<char*>("device_id"), (getter)ProximitySensor_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_distance_in_millimeters"), (getter)ProximitySensor_get_MaxDistanceInMillimeters, nullptr, nullptr, nullptr },
        { const_cast<char*>("min_distance_in_millimeters"), (getter)ProximitySensor_get_MinDistanceInMillimeters, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ProximitySensor[] = 
    {
        { Py_tp_new, _new_ProximitySensor },
        { Py_tp_dealloc, _dealloc_ProximitySensor },
        { Py_tp_methods, _methods_ProximitySensor },
        { Py_tp_getset, _getset_ProximitySensor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProximitySensor =
    {
        "_winrt_Windows_Devices_Sensors.ProximitySensor",
        sizeof(py::wrapper::Windows::Devices::Sensors::ProximitySensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProximitySensor
    };

    // ----- ProximitySensorDataThreshold class --------------------
    constexpr const char* const _type_name_ProximitySensorDataThreshold = "ProximitySensorDataThreshold";

    static PyObject* _new_ProximitySensorDataThreshold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::ProximitySensor>(args, 0);

                winrt::Windows::Devices::Sensors::ProximitySensorDataThreshold instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProximitySensorDataThreshold(py::wrapper::Windows::Devices::Sensors::ProximitySensorDataThreshold* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ProximitySensorDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ProximitySensorDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProximitySensorDataThreshold[] = {
        { "_from", (PyCFunction)_from_ProximitySensorDataThreshold, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ProximitySensorDataThreshold[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ProximitySensorDataThreshold[] = 
    {
        { Py_tp_new, _new_ProximitySensorDataThreshold },
        { Py_tp_dealloc, _dealloc_ProximitySensorDataThreshold },
        { Py_tp_methods, _methods_ProximitySensorDataThreshold },
        { Py_tp_getset, _getset_ProximitySensorDataThreshold },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProximitySensorDataThreshold =
    {
        "_winrt_Windows_Devices_Sensors.ProximitySensorDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::ProximitySensorDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProximitySensorDataThreshold
    };

    // ----- ProximitySensorDisplayOnOffController class --------------------
    constexpr const char* const _type_name_ProximitySensorDisplayOnOffController = "ProximitySensorDisplayOnOffController";

    static PyObject* _new_ProximitySensorDisplayOnOffController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProximitySensorDisplayOnOffController);
        return nullptr;
    }

    static void _dealloc_ProximitySensorDisplayOnOffController(py::wrapper::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProximitySensorDisplayOnOffController_Close(py::wrapper::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ProximitySensorDisplayOnOffController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ProximitySensorDisplayOnOffController(py::wrapper::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_ProximitySensorDisplayOnOffController(py::wrapper::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProximitySensorDisplayOnOffController[] = {
        { "close", (PyCFunction)ProximitySensorDisplayOnOffController_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ProximitySensorDisplayOnOffController, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_ProximitySensorDisplayOnOffController, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_ProximitySensorDisplayOnOffController, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ProximitySensorDisplayOnOffController[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ProximitySensorDisplayOnOffController[] = 
    {
        { Py_tp_new, _new_ProximitySensorDisplayOnOffController },
        { Py_tp_dealloc, _dealloc_ProximitySensorDisplayOnOffController },
        { Py_tp_methods, _methods_ProximitySensorDisplayOnOffController },
        { Py_tp_getset, _getset_ProximitySensorDisplayOnOffController },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProximitySensorDisplayOnOffController =
    {
        "_winrt_Windows_Devices_Sensors.ProximitySensorDisplayOnOffController",
        sizeof(py::wrapper::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProximitySensorDisplayOnOffController
    };

    // ----- ProximitySensorReading class --------------------
    constexpr const char* const _type_name_ProximitySensorReading = "ProximitySensorReading";

    static PyObject* _new_ProximitySensorReading(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProximitySensorReading);
        return nullptr;
    }

    static void _dealloc_ProximitySensorReading(py::wrapper::Windows::Devices::Sensors::ProximitySensorReading* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProximitySensorReading_get_DistanceInMillimeters(py::wrapper::Windows::Devices::Sensors::ProximitySensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DistanceInMillimeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProximitySensorReading_get_IsDetected(py::wrapper::Windows::Devices::Sensors::ProximitySensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDetected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProximitySensorReading_get_Timestamp(py::wrapper::Windows::Devices::Sensors::ProximitySensorReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProximitySensorReading(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ProximitySensorReading>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProximitySensorReading[] = {
        { "_from", (PyCFunction)_from_ProximitySensorReading, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ProximitySensorReading[] = {
        { const_cast<char*>("distance_in_millimeters"), (getter)ProximitySensorReading_get_DistanceInMillimeters, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_detected"), (getter)ProximitySensorReading_get_IsDetected, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)ProximitySensorReading_get_Timestamp, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ProximitySensorReading[] = 
    {
        { Py_tp_new, _new_ProximitySensorReading },
        { Py_tp_dealloc, _dealloc_ProximitySensorReading },
        { Py_tp_methods, _methods_ProximitySensorReading },
        { Py_tp_getset, _getset_ProximitySensorReading },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProximitySensorReading =
    {
        "_winrt_Windows_Devices_Sensors.ProximitySensorReading",
        sizeof(py::wrapper::Windows::Devices::Sensors::ProximitySensorReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProximitySensorReading
    };

    // ----- ProximitySensorReadingChangedEventArgs class --------------------
    constexpr const char* const _type_name_ProximitySensorReadingChangedEventArgs = "ProximitySensorReadingChangedEventArgs";

    static PyObject* _new_ProximitySensorReadingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProximitySensorReadingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_ProximitySensorReadingChangedEventArgs(py::wrapper::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProximitySensorReadingChangedEventArgs_get_Reading(py::wrapper::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProximitySensorReadingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProximitySensorReadingChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_ProximitySensorReadingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ProximitySensorReadingChangedEventArgs[] = {
        { const_cast<char*>("reading"), (getter)ProximitySensorReadingChangedEventArgs_get_Reading, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ProximitySensorReadingChangedEventArgs[] = 
    {
        { Py_tp_new, _new_ProximitySensorReadingChangedEventArgs },
        { Py_tp_dealloc, _dealloc_ProximitySensorReadingChangedEventArgs },
        { Py_tp_methods, _methods_ProximitySensorReadingChangedEventArgs },
        { Py_tp_getset, _getset_ProximitySensorReadingChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProximitySensorReadingChangedEventArgs =
    {
        "_winrt_Windows_Devices_Sensors.ProximitySensorReadingChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProximitySensorReadingChangedEventArgs
    };

    // ----- SensorDataThresholdTriggerDetails class --------------------
    constexpr const char* const _type_name_SensorDataThresholdTriggerDetails = "SensorDataThresholdTriggerDetails";

    static PyObject* _new_SensorDataThresholdTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SensorDataThresholdTriggerDetails);
        return nullptr;
    }

    static void _dealloc_SensorDataThresholdTriggerDetails(py::wrapper::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SensorDataThresholdTriggerDetails_get_DeviceId(py::wrapper::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorDataThresholdTriggerDetails_get_SensorType(py::wrapper::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SensorType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SensorDataThresholdTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SensorDataThresholdTriggerDetails[] = {
        { "_from", (PyCFunction)_from_SensorDataThresholdTriggerDetails, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SensorDataThresholdTriggerDetails[] = {
        { const_cast<char*>("device_id"), (getter)SensorDataThresholdTriggerDetails_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("sensor_type"), (getter)SensorDataThresholdTriggerDetails_get_SensorType, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SensorDataThresholdTriggerDetails[] = 
    {
        { Py_tp_new, _new_SensorDataThresholdTriggerDetails },
        { Py_tp_dealloc, _dealloc_SensorDataThresholdTriggerDetails },
        { Py_tp_methods, _methods_SensorDataThresholdTriggerDetails },
        { Py_tp_getset, _getset_SensorDataThresholdTriggerDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SensorDataThresholdTriggerDetails =
    {
        "_winrt_Windows_Devices_Sensors.SensorDataThresholdTriggerDetails",
        sizeof(py::wrapper::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SensorDataThresholdTriggerDetails
    };

    // ----- SensorQuaternion class --------------------
    constexpr const char* const _type_name_SensorQuaternion = "SensorQuaternion";

    static PyObject* _new_SensorQuaternion(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SensorQuaternion);
        return nullptr;
    }

    static void _dealloc_SensorQuaternion(py::wrapper::Windows::Devices::Sensors::SensorQuaternion* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SensorQuaternion_get_W(py::wrapper::Windows::Devices::Sensors::SensorQuaternion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.W());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorQuaternion_get_X(py::wrapper::Windows::Devices::Sensors::SensorQuaternion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorQuaternion_get_Y(py::wrapper::Windows::Devices::Sensors::SensorQuaternion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorQuaternion_get_Z(py::wrapper::Windows::Devices::Sensors::SensorQuaternion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Z());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SensorQuaternion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::SensorQuaternion>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SensorQuaternion[] = {
        { "_from", (PyCFunction)_from_SensorQuaternion, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SensorQuaternion[] = {
        { const_cast<char*>("w"), (getter)SensorQuaternion_get_W, nullptr, nullptr, nullptr },
        { const_cast<char*>("x"), (getter)SensorQuaternion_get_X, nullptr, nullptr, nullptr },
        { const_cast<char*>("y"), (getter)SensorQuaternion_get_Y, nullptr, nullptr, nullptr },
        { const_cast<char*>("z"), (getter)SensorQuaternion_get_Z, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SensorQuaternion[] = 
    {
        { Py_tp_new, _new_SensorQuaternion },
        { Py_tp_dealloc, _dealloc_SensorQuaternion },
        { Py_tp_methods, _methods_SensorQuaternion },
        { Py_tp_getset, _getset_SensorQuaternion },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SensorQuaternion =
    {
        "_winrt_Windows_Devices_Sensors.SensorQuaternion",
        sizeof(py::wrapper::Windows::Devices::Sensors::SensorQuaternion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SensorQuaternion
    };

    // ----- SensorRotationMatrix class --------------------
    constexpr const char* const _type_name_SensorRotationMatrix = "SensorRotationMatrix";

    static PyObject* _new_SensorRotationMatrix(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SensorRotationMatrix);
        return nullptr;
    }

    static void _dealloc_SensorRotationMatrix(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SensorRotationMatrix_get_M11(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.M11());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M12(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.M12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M13(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.M13());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M21(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.M21());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M22(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.M22());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M23(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.M23());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M31(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.M31());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M32(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.M32());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SensorRotationMatrix_get_M33(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.M33());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SensorRotationMatrix(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::SensorRotationMatrix>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SensorRotationMatrix[] = {
        { "_from", (PyCFunction)_from_SensorRotationMatrix, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SensorRotationMatrix[] = {
        { const_cast<char*>("m11"), (getter)SensorRotationMatrix_get_M11, nullptr, nullptr, nullptr },
        { const_cast<char*>("m12"), (getter)SensorRotationMatrix_get_M12, nullptr, nullptr, nullptr },
        { const_cast<char*>("m13"), (getter)SensorRotationMatrix_get_M13, nullptr, nullptr, nullptr },
        { const_cast<char*>("m21"), (getter)SensorRotationMatrix_get_M21, nullptr, nullptr, nullptr },
        { const_cast<char*>("m22"), (getter)SensorRotationMatrix_get_M22, nullptr, nullptr, nullptr },
        { const_cast<char*>("m23"), (getter)SensorRotationMatrix_get_M23, nullptr, nullptr, nullptr },
        { const_cast<char*>("m31"), (getter)SensorRotationMatrix_get_M31, nullptr, nullptr, nullptr },
        { const_cast<char*>("m32"), (getter)SensorRotationMatrix_get_M32, nullptr, nullptr, nullptr },
        { const_cast<char*>("m33"), (getter)SensorRotationMatrix_get_M33, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SensorRotationMatrix[] = 
    {
        { Py_tp_new, _new_SensorRotationMatrix },
        { Py_tp_dealloc, _dealloc_SensorRotationMatrix },
        { Py_tp_methods, _methods_SensorRotationMatrix },
        { Py_tp_getset, _getset_SensorRotationMatrix },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SensorRotationMatrix =
    {
        "_winrt_Windows_Devices_Sensors.SensorRotationMatrix",
        sizeof(py::wrapper::Windows::Devices::Sensors::SensorRotationMatrix),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SensorRotationMatrix
    };

    // ----- SimpleOrientationSensor class --------------------
    constexpr const char* const _type_name_SimpleOrientationSensor = "SimpleOrientationSensor";

    static PyObject* _new_SimpleOrientationSensor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SimpleOrientationSensor);
        return nullptr;
    }

    static void _dealloc_SimpleOrientationSensor(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SimpleOrientationSensor_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sensors::SimpleOrientationSensor::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SimpleOrientationSensor_GetCurrentOrientation(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentOrientation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SimpleOrientationSensor_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::SimpleOrientationSensor::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SimpleOrientationSensor_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sensors::SimpleOrientationSensor::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SimpleOrientationSensor_get_ReadingTransform(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReadingTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SimpleOrientationSensor_put_ReadingTransform(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Display::DisplayOrientations>(arg);

            self->obj.ReadingTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SimpleOrientationSensor_get_DeviceId(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SimpleOrientationSensor_add_OrientationChanged(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sensors::SimpleOrientationSensor, winrt::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs>>(arg);

            return py::convert(self->obj.OrientationChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SimpleOrientationSensor_remove_OrientationChanged(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OrientationChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SimpleOrientationSensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::SimpleOrientationSensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SimpleOrientationSensor[] = {
        { "from_id_async", (PyCFunction)SimpleOrientationSensor_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_orientation", (PyCFunction)SimpleOrientationSensor_GetCurrentOrientation, METH_VARARGS, nullptr },
        { "get_default", (PyCFunction)SimpleOrientationSensor_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)SimpleOrientationSensor_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "add_orientation_changed", (PyCFunction)SimpleOrientationSensor_add_OrientationChanged, METH_O, nullptr },
        { "remove_orientation_changed", (PyCFunction)SimpleOrientationSensor_remove_OrientationChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_SimpleOrientationSensor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SimpleOrientationSensor[] = {
        { const_cast<char*>("reading_transform"), (getter)SimpleOrientationSensor_get_ReadingTransform, (setter)SimpleOrientationSensor_put_ReadingTransform, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)SimpleOrientationSensor_get_DeviceId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SimpleOrientationSensor[] = 
    {
        { Py_tp_new, _new_SimpleOrientationSensor },
        { Py_tp_dealloc, _dealloc_SimpleOrientationSensor },
        { Py_tp_methods, _methods_SimpleOrientationSensor },
        { Py_tp_getset, _getset_SimpleOrientationSensor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SimpleOrientationSensor =
    {
        "_winrt_Windows_Devices_Sensors.SimpleOrientationSensor",
        sizeof(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SimpleOrientationSensor
    };

    // ----- SimpleOrientationSensorOrientationChangedEventArgs class --------------------
    constexpr const char* const _type_name_SimpleOrientationSensorOrientationChangedEventArgs = "SimpleOrientationSensorOrientationChangedEventArgs";

    static PyObject* _new_SimpleOrientationSensorOrientationChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SimpleOrientationSensorOrientationChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_SimpleOrientationSensorOrientationChangedEventArgs(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SimpleOrientationSensorOrientationChangedEventArgs_get_Orientation(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SimpleOrientationSensorOrientationChangedEventArgs_get_Timestamp(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SimpleOrientationSensorOrientationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SimpleOrientationSensorOrientationChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_SimpleOrientationSensorOrientationChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SimpleOrientationSensorOrientationChangedEventArgs[] = {
        { const_cast<char*>("orientation"), (getter)SimpleOrientationSensorOrientationChangedEventArgs_get_Orientation, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)SimpleOrientationSensorOrientationChangedEventArgs_get_Timestamp, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SimpleOrientationSensorOrientationChangedEventArgs[] = 
    {
        { Py_tp_new, _new_SimpleOrientationSensorOrientationChangedEventArgs },
        { Py_tp_dealloc, _dealloc_SimpleOrientationSensorOrientationChangedEventArgs },
        { Py_tp_methods, _methods_SimpleOrientationSensorOrientationChangedEventArgs },
        { Py_tp_getset, _getset_SimpleOrientationSensorOrientationChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SimpleOrientationSensorOrientationChangedEventArgs =
    {
        "_winrt_Windows_Devices_Sensors.SimpleOrientationSensorOrientationChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SimpleOrientationSensorOrientationChangedEventArgs
    };

    // ----- ISensorDataThreshold interface --------------------
    constexpr const char* const _type_name_ISensorDataThreshold = "ISensorDataThreshold";

    static PyObject* _new_ISensorDataThreshold(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ISensorDataThreshold);
        return nullptr;
    }

    static void _dealloc_ISensorDataThreshold(py::wrapper::Windows::Devices::Sensors::ISensorDataThreshold* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ISensorDataThreshold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sensors::ISensorDataThreshold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISensorDataThreshold[] = {
        { "_from", (PyCFunction)_from_ISensorDataThreshold, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ISensorDataThreshold[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ISensorDataThreshold[] = 
    {
        { Py_tp_new, _new_ISensorDataThreshold },
        { Py_tp_dealloc, _dealloc_ISensorDataThreshold },
        { Py_tp_methods, _methods_ISensorDataThreshold },
        { Py_tp_getset, _getset_ISensorDataThreshold },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ISensorDataThreshold =
    {
        "_winrt_Windows_Devices_Sensors.ISensorDataThreshold",
        sizeof(py::wrapper::Windows::Devices::Sensors::ISensorDataThreshold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISensorDataThreshold
    };

    // ----- Windows.Devices.Sensors Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Devices::Sensors::Accelerometer>::python_type = py::register_python_type(module, _type_name_Accelerometer, &_type_spec_Accelerometer, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::AccelerometerDataThreshold>::python_type = py::register_python_type(module, _type_name_AccelerometerDataThreshold, &_type_spec_AccelerometerDataThreshold, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::AccelerometerReading>::python_type = py::register_python_type(module, _type_name_AccelerometerReading, &_type_spec_AccelerometerReading, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::AccelerometerReadingChangedEventArgs>::python_type = py::register_python_type(module, _type_name_AccelerometerReadingChangedEventArgs, &_type_spec_AccelerometerReadingChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::AccelerometerShakenEventArgs>::python_type = py::register_python_type(module, _type_name_AccelerometerShakenEventArgs, &_type_spec_AccelerometerShakenEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::ActivitySensor>::python_type = py::register_python_type(module, _type_name_ActivitySensor, &_type_spec_ActivitySensor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::ActivitySensorReading>::python_type = py::register_python_type(module, _type_name_ActivitySensorReading, &_type_spec_ActivitySensorReading, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangeReport>::python_type = py::register_python_type(module, _type_name_ActivitySensorReadingChangeReport, &_type_spec_ActivitySensorReadingChangeReport, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::ActivitySensorReadingChangedEventArgs>::python_type = py::register_python_type(module, _type_name_ActivitySensorReadingChangedEventArgs, &_type_spec_ActivitySensorReadingChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::ActivitySensorTriggerDetails>::python_type = py::register_python_type(module, _type_name_ActivitySensorTriggerDetails, &_type_spec_ActivitySensorTriggerDetails, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::Altimeter>::python_type = py::register_python_type(module, _type_name_Altimeter, &_type_spec_Altimeter, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::AltimeterReading>::python_type = py::register_python_type(module, _type_name_AltimeterReading, &_type_spec_AltimeterReading, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::AltimeterReadingChangedEventArgs>::python_type = py::register_python_type(module, _type_name_AltimeterReadingChangedEventArgs, &_type_spec_AltimeterReadingChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::Barometer>::python_type = py::register_python_type(module, _type_name_Barometer, &_type_spec_Barometer, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::BarometerDataThreshold>::python_type = py::register_python_type(module, _type_name_BarometerDataThreshold, &_type_spec_BarometerDataThreshold, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::BarometerReading>::python_type = py::register_python_type(module, _type_name_BarometerReading, &_type_spec_BarometerReading, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::BarometerReadingChangedEventArgs>::python_type = py::register_python_type(module, _type_name_BarometerReadingChangedEventArgs, &_type_spec_BarometerReadingChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::Compass>::python_type = py::register_python_type(module, _type_name_Compass, &_type_spec_Compass, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::CompassDataThreshold>::python_type = py::register_python_type(module, _type_name_CompassDataThreshold, &_type_spec_CompassDataThreshold, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::CompassReading>::python_type = py::register_python_type(module, _type_name_CompassReading, &_type_spec_CompassReading, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::CompassReadingChangedEventArgs>::python_type = py::register_python_type(module, _type_name_CompassReadingChangedEventArgs, &_type_spec_CompassReadingChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::Gyrometer>::python_type = py::register_python_type(module, _type_name_Gyrometer, &_type_spec_Gyrometer, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::GyrometerDataThreshold>::python_type = py::register_python_type(module, _type_name_GyrometerDataThreshold, &_type_spec_GyrometerDataThreshold, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::GyrometerReading>::python_type = py::register_python_type(module, _type_name_GyrometerReading, &_type_spec_GyrometerReading, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::GyrometerReadingChangedEventArgs>::python_type = py::register_python_type(module, _type_name_GyrometerReadingChangedEventArgs, &_type_spec_GyrometerReadingChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::HingeAngleReading>::python_type = py::register_python_type(module, _type_name_HingeAngleReading, &_type_spec_HingeAngleReading, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::HingeAngleSensor>::python_type = py::register_python_type(module, _type_name_HingeAngleSensor, &_type_spec_HingeAngleSensor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::HingeAngleSensorReadingChangedEventArgs>::python_type = py::register_python_type(module, _type_name_HingeAngleSensorReadingChangedEventArgs, &_type_spec_HingeAngleSensorReadingChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::Inclinometer>::python_type = py::register_python_type(module, _type_name_Inclinometer, &_type_spec_Inclinometer, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::InclinometerDataThreshold>::python_type = py::register_python_type(module, _type_name_InclinometerDataThreshold, &_type_spec_InclinometerDataThreshold, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::InclinometerReading>::python_type = py::register_python_type(module, _type_name_InclinometerReading, &_type_spec_InclinometerReading, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::InclinometerReadingChangedEventArgs>::python_type = py::register_python_type(module, _type_name_InclinometerReadingChangedEventArgs, &_type_spec_InclinometerReadingChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::LightSensor>::python_type = py::register_python_type(module, _type_name_LightSensor, &_type_spec_LightSensor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::LightSensorDataThreshold>::python_type = py::register_python_type(module, _type_name_LightSensorDataThreshold, &_type_spec_LightSensorDataThreshold, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::LightSensorReading>::python_type = py::register_python_type(module, _type_name_LightSensorReading, &_type_spec_LightSensorReading, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::LightSensorReadingChangedEventArgs>::python_type = py::register_python_type(module, _type_name_LightSensorReadingChangedEventArgs, &_type_spec_LightSensorReadingChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::Magnetometer>::python_type = py::register_python_type(module, _type_name_Magnetometer, &_type_spec_Magnetometer, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::MagnetometerDataThreshold>::python_type = py::register_python_type(module, _type_name_MagnetometerDataThreshold, &_type_spec_MagnetometerDataThreshold, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::MagnetometerReading>::python_type = py::register_python_type(module, _type_name_MagnetometerReading, &_type_spec_MagnetometerReading, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::MagnetometerReadingChangedEventArgs>::python_type = py::register_python_type(module, _type_name_MagnetometerReadingChangedEventArgs, &_type_spec_MagnetometerReadingChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::OrientationSensor>::python_type = py::register_python_type(module, _type_name_OrientationSensor, &_type_spec_OrientationSensor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::OrientationSensorReading>::python_type = py::register_python_type(module, _type_name_OrientationSensorReading, &_type_spec_OrientationSensorReading, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::OrientationSensorReadingChangedEventArgs>::python_type = py::register_python_type(module, _type_name_OrientationSensorReadingChangedEventArgs, &_type_spec_OrientationSensorReadingChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::Pedometer>::python_type = py::register_python_type(module, _type_name_Pedometer, &_type_spec_Pedometer, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::PedometerDataThreshold>::python_type = py::register_python_type(module, _type_name_PedometerDataThreshold, &_type_spec_PedometerDataThreshold, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::PedometerReading>::python_type = py::register_python_type(module, _type_name_PedometerReading, &_type_spec_PedometerReading, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::PedometerReadingChangedEventArgs>::python_type = py::register_python_type(module, _type_name_PedometerReadingChangedEventArgs, &_type_spec_PedometerReadingChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::ProximitySensor>::python_type = py::register_python_type(module, _type_name_ProximitySensor, &_type_spec_ProximitySensor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::ProximitySensorDataThreshold>::python_type = py::register_python_type(module, _type_name_ProximitySensorDataThreshold, &_type_spec_ProximitySensorDataThreshold, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::ProximitySensorDisplayOnOffController>::python_type = py::register_python_type(module, _type_name_ProximitySensorDisplayOnOffController, &_type_spec_ProximitySensorDisplayOnOffController, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::ProximitySensorReading>::python_type = py::register_python_type(module, _type_name_ProximitySensorReading, &_type_spec_ProximitySensorReading, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::ProximitySensorReadingChangedEventArgs>::python_type = py::register_python_type(module, _type_name_ProximitySensorReadingChangedEventArgs, &_type_spec_ProximitySensorReadingChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::SensorDataThresholdTriggerDetails>::python_type = py::register_python_type(module, _type_name_SensorDataThresholdTriggerDetails, &_type_spec_SensorDataThresholdTriggerDetails, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::SensorQuaternion>::python_type = py::register_python_type(module, _type_name_SensorQuaternion, &_type_spec_SensorQuaternion, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::SensorRotationMatrix>::python_type = py::register_python_type(module, _type_name_SensorRotationMatrix, &_type_spec_SensorRotationMatrix, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::SimpleOrientationSensor>::python_type = py::register_python_type(module, _type_name_SimpleOrientationSensor, &_type_spec_SimpleOrientationSensor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::SimpleOrientationSensorOrientationChangedEventArgs>::python_type = py::register_python_type(module, _type_name_SimpleOrientationSensorOrientationChangedEventArgs, &_type_spec_SimpleOrientationSensorOrientationChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sensors::ISensorDataThreshold>::python_type = py::register_python_type(module, _type_name_ISensorDataThreshold, &_type_spec_ISensorDataThreshold, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Devices.Sensors");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Devices_Sensors",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Devices::Sensors

PyMODINIT_FUNC
PyInit__winrt_Windows_Devices_Sensors (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Devices::Sensors::module_def);
}
