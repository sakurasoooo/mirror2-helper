// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Devices.Gpio.h"

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Gpio::GpioChangeCounter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Gpio::GpioChangeReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Gpio::GpioController>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Gpio::GpioPin>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Gpio::GpioPinValueChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Gpio::GpioChangeCount>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Gpio::GpioChangeRecord>::python_type;

PyObject* py::converter<winrt::Windows::Devices::Gpio::GpioChangeCount>::convert(winrt::Windows::Devices::Gpio::GpioChangeCount instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Devices::Gpio::GpioChangeCount>());
}
winrt::Windows::Devices::Gpio::GpioChangeCount py::converter<winrt::Windows::Devices::Gpio::GpioChangeCount>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Devices::Gpio::GpioChangeCount>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Devices::Gpio::GpioChangeCount>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Devices::Gpio::GpioChangeCount return_value{};

    PyObject* py_Count = PyDict_GetItemString(obj, "count");
    if (!py_Count) { throw winrt::hresult_invalid_argument(); }
    return_value.Count = converter<uint64_t>::convert_to(py_Count);

    PyObject* py_RelativeTime = PyDict_GetItemString(obj, "relative_time");
    if (!py_RelativeTime) { throw winrt::hresult_invalid_argument(); }
    return_value.RelativeTime = converter<winrt::Windows::Foundation::TimeSpan>::convert_to(py_RelativeTime);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Devices::Gpio::GpioChangeRecord>::convert(winrt::Windows::Devices::Gpio::GpioChangeRecord instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Devices::Gpio::GpioChangeRecord>());
}
winrt::Windows::Devices::Gpio::GpioChangeRecord py::converter<winrt::Windows::Devices::Gpio::GpioChangeRecord>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Devices::Gpio::GpioChangeRecord>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Devices::Gpio::GpioChangeRecord>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Devices::Gpio::GpioChangeRecord return_value{};

    PyObject* py_RelativeTime = PyDict_GetItemString(obj, "relative_time");
    if (!py_RelativeTime) { throw winrt::hresult_invalid_argument(); }
    return_value.RelativeTime = converter<winrt::Windows::Foundation::TimeSpan>::convert_to(py_RelativeTime);

    PyObject* py_Edge = PyDict_GetItemString(obj, "edge");
    if (!py_Edge) { throw winrt::hresult_invalid_argument(); }
    return_value.Edge = converter<winrt::Windows::Devices::Gpio::GpioPinEdge>::convert_to(py_Edge);

    return return_value;
}

namespace py::cpp::Windows::Devices::Gpio
{
    // ----- GpioChangeCounter class --------------------
    constexpr const char* const _type_name_GpioChangeCounter = "GpioChangeCounter";

    static PyObject* _new_GpioChangeCounter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Gpio::GpioPin>(args, 0);

                winrt::Windows::Devices::Gpio::GpioChangeCounter instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GpioChangeCounter(py::wrapper::Windows::Devices::Gpio::GpioChangeCounter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GpioChangeCounter_Close(py::wrapper::Windows::Devices::Gpio::GpioChangeCounter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioChangeCounter_Read(py::wrapper::Windows::Devices::Gpio::GpioChangeCounter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Read());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioChangeCounter_Reset(py::wrapper::Windows::Devices::Gpio::GpioChangeCounter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Reset());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioChangeCounter_Start(py::wrapper::Windows::Devices::Gpio::GpioChangeCounter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioChangeCounter_Stop(py::wrapper::Windows::Devices::Gpio::GpioChangeCounter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioChangeCounter_get_Polarity(py::wrapper::Windows::Devices::Gpio::GpioChangeCounter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Polarity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GpioChangeCounter_put_Polarity(py::wrapper::Windows::Devices::Gpio::GpioChangeCounter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Gpio::GpioChangePolarity>(arg);

            self->obj.Polarity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GpioChangeCounter_get_IsStarted(py::wrapper::Windows::Devices::Gpio::GpioChangeCounter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStarted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GpioChangeCounter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Gpio::GpioChangeCounter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_GpioChangeCounter(py::wrapper::Windows::Devices::Gpio::GpioChangeCounter* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_GpioChangeCounter(py::wrapper::Windows::Devices::Gpio::GpioChangeCounter* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GpioChangeCounter[] = {
        { "close", (PyCFunction)GpioChangeCounter_Close, METH_VARARGS, nullptr },
        { "read", (PyCFunction)GpioChangeCounter_Read, METH_VARARGS, nullptr },
        { "reset", (PyCFunction)GpioChangeCounter_Reset, METH_VARARGS, nullptr },
        { "start", (PyCFunction)GpioChangeCounter_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)GpioChangeCounter_Stop, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_GpioChangeCounter, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_GpioChangeCounter, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_GpioChangeCounter, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GpioChangeCounter[] = {
        { const_cast<char*>("polarity"), (getter)GpioChangeCounter_get_Polarity, (setter)GpioChangeCounter_put_Polarity, nullptr, nullptr },
        { const_cast<char*>("is_started"), (getter)GpioChangeCounter_get_IsStarted, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GpioChangeCounter[] = 
    {
        { Py_tp_new, _new_GpioChangeCounter },
        { Py_tp_dealloc, _dealloc_GpioChangeCounter },
        { Py_tp_methods, _methods_GpioChangeCounter },
        { Py_tp_getset, _getset_GpioChangeCounter },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GpioChangeCounter =
    {
        "_winrt_Windows_Devices_Gpio.GpioChangeCounter",
        sizeof(py::wrapper::Windows::Devices::Gpio::GpioChangeCounter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GpioChangeCounter
    };

    // ----- GpioChangeReader class --------------------
    constexpr const char* const _type_name_GpioChangeReader = "GpioChangeReader";

    static PyObject* _new_GpioChangeReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Gpio::GpioPin>(args, 0);

                winrt::Windows::Devices::Gpio::GpioChangeReader instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Gpio::GpioPin>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                winrt::Windows::Devices::Gpio::GpioChangeReader instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GpioChangeReader(py::wrapper::Windows::Devices::Gpio::GpioChangeReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GpioChangeReader_Clear(py::wrapper::Windows::Devices::Gpio::GpioChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioChangeReader_Close(py::wrapper::Windows::Devices::Gpio::GpioChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioChangeReader_GetAllItems(py::wrapper::Windows::Devices::Gpio::GpioChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAllItems());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioChangeReader_GetNextItem(py::wrapper::Windows::Devices::Gpio::GpioChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetNextItem());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioChangeReader_PeekNextItem(py::wrapper::Windows::Devices::Gpio::GpioChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.PeekNextItem());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioChangeReader_Start(py::wrapper::Windows::Devices::Gpio::GpioChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioChangeReader_Stop(py::wrapper::Windows::Devices::Gpio::GpioChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioChangeReader_WaitForItemsAsync(py::wrapper::Windows::Devices::Gpio::GpioChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.WaitForItemsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioChangeReader_get_Polarity(py::wrapper::Windows::Devices::Gpio::GpioChangeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Polarity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GpioChangeReader_put_Polarity(py::wrapper::Windows::Devices::Gpio::GpioChangeReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Gpio::GpioChangePolarity>(arg);

            self->obj.Polarity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GpioChangeReader_get_Capacity(py::wrapper::Windows::Devices::Gpio::GpioChangeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GpioChangeReader_get_IsEmpty(py::wrapper::Windows::Devices::Gpio::GpioChangeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GpioChangeReader_get_IsOverflowed(py::wrapper::Windows::Devices::Gpio::GpioChangeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOverflowed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GpioChangeReader_get_IsStarted(py::wrapper::Windows::Devices::Gpio::GpioChangeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStarted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GpioChangeReader_get_Length(py::wrapper::Windows::Devices::Gpio::GpioChangeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GpioChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Gpio::GpioChangeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_GpioChangeReader(py::wrapper::Windows::Devices::Gpio::GpioChangeReader* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_GpioChangeReader(py::wrapper::Windows::Devices::Gpio::GpioChangeReader* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GpioChangeReader[] = {
        { "clear", (PyCFunction)GpioChangeReader_Clear, METH_VARARGS, nullptr },
        { "close", (PyCFunction)GpioChangeReader_Close, METH_VARARGS, nullptr },
        { "get_all_items", (PyCFunction)GpioChangeReader_GetAllItems, METH_VARARGS, nullptr },
        { "get_next_item", (PyCFunction)GpioChangeReader_GetNextItem, METH_VARARGS, nullptr },
        { "peek_next_item", (PyCFunction)GpioChangeReader_PeekNextItem, METH_VARARGS, nullptr },
        { "start", (PyCFunction)GpioChangeReader_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)GpioChangeReader_Stop, METH_VARARGS, nullptr },
        { "wait_for_items_async", (PyCFunction)GpioChangeReader_WaitForItemsAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_GpioChangeReader, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_GpioChangeReader, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_GpioChangeReader, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GpioChangeReader[] = {
        { const_cast<char*>("polarity"), (getter)GpioChangeReader_get_Polarity, (setter)GpioChangeReader_put_Polarity, nullptr, nullptr },
        { const_cast<char*>("capacity"), (getter)GpioChangeReader_get_Capacity, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_empty"), (getter)GpioChangeReader_get_IsEmpty, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_overflowed"), (getter)GpioChangeReader_get_IsOverflowed, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_started"), (getter)GpioChangeReader_get_IsStarted, nullptr, nullptr, nullptr },
        { const_cast<char*>("length"), (getter)GpioChangeReader_get_Length, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GpioChangeReader[] = 
    {
        { Py_tp_new, _new_GpioChangeReader },
        { Py_tp_dealloc, _dealloc_GpioChangeReader },
        { Py_tp_methods, _methods_GpioChangeReader },
        { Py_tp_getset, _getset_GpioChangeReader },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GpioChangeReader =
    {
        "_winrt_Windows_Devices_Gpio.GpioChangeReader",
        sizeof(py::wrapper::Windows::Devices::Gpio::GpioChangeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GpioChangeReader
    };

    // ----- GpioController class --------------------
    constexpr const char* const _type_name_GpioController = "GpioController";

    static PyObject* _new_GpioController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GpioController);
        return nullptr;
    }

    static void _dealloc_GpioController(py::wrapper::Windows::Devices::Gpio::GpioController* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GpioController_GetControllersAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Gpio::Provider::IGpioProvider>(args, 0);

                return py::convert(winrt::Windows::Devices::Gpio::GpioController::GetControllersAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioController_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Gpio::GpioController::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioController_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Gpio::GpioController::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioController_OpenPin(py::wrapper::Windows::Devices::Gpio::GpioController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.OpenPin(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Gpio::GpioSharingMode>(args, 1);

                return py::convert(self->obj.OpenPin(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioController_TryOpenPin(py::wrapper::Windows::Devices::Gpio::GpioController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Gpio::GpioSharingMode>(args, 1);
                winrt::Windows::Devices::Gpio::GpioPin param2 { nullptr };
                winrt::Windows::Devices::Gpio::GpioOpenStatus param3 {  };

                auto return_value = self->obj.TryOpenPin(param0, param1, param2, param3);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                py::pyobj_handle out3{ py::convert(param3) };
                if (!out3)
                {
                    return nullptr;
                }
                return PyTuple_Pack(3, out_return_value.get(), out2.get(), out3.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioController_get_PinCount(py::wrapper::Windows::Devices::Gpio::GpioController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PinCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GpioController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Gpio::GpioController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GpioController[] = {
        { "get_controllers_async", (PyCFunction)GpioController_GetControllersAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_default", (PyCFunction)GpioController_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_async", (PyCFunction)GpioController_GetDefaultAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "open_pin", (PyCFunction)GpioController_OpenPin, METH_VARARGS, nullptr },
        { "try_open_pin", (PyCFunction)GpioController_TryOpenPin, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_GpioController, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GpioController[] = {
        { const_cast<char*>("pin_count"), (getter)GpioController_get_PinCount, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GpioController[] = 
    {
        { Py_tp_new, _new_GpioController },
        { Py_tp_dealloc, _dealloc_GpioController },
        { Py_tp_methods, _methods_GpioController },
        { Py_tp_getset, _getset_GpioController },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GpioController =
    {
        "_winrt_Windows_Devices_Gpio.GpioController",
        sizeof(py::wrapper::Windows::Devices::Gpio::GpioController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GpioController
    };

    // ----- GpioPin class --------------------
    constexpr const char* const _type_name_GpioPin = "GpioPin";

    static PyObject* _new_GpioPin(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GpioPin);
        return nullptr;
    }

    static void _dealloc_GpioPin(py::wrapper::Windows::Devices::Gpio::GpioPin* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GpioPin_Close(py::wrapper::Windows::Devices::Gpio::GpioPin* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioPin_GetDriveMode(py::wrapper::Windows::Devices::Gpio::GpioPin* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDriveMode());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioPin_IsDriveModeSupported(py::wrapper::Windows::Devices::Gpio::GpioPin* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Gpio::GpioPinDriveMode>(args, 0);

                return py::convert(self->obj.IsDriveModeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioPin_Read(py::wrapper::Windows::Devices::Gpio::GpioPin* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Read());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioPin_SetDriveMode(py::wrapper::Windows::Devices::Gpio::GpioPin* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Gpio::GpioPinDriveMode>(args, 0);

                self->obj.SetDriveMode(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioPin_Write(py::wrapper::Windows::Devices::Gpio::GpioPin* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Gpio::GpioPinValue>(args, 0);

                self->obj.Write(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GpioPin_get_DebounceTimeout(py::wrapper::Windows::Devices::Gpio::GpioPin* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DebounceTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GpioPin_put_DebounceTimeout(py::wrapper::Windows::Devices::Gpio::GpioPin* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DebounceTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GpioPin_get_PinNumber(py::wrapper::Windows::Devices::Gpio::GpioPin* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PinNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GpioPin_get_SharingMode(py::wrapper::Windows::Devices::Gpio::GpioPin* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SharingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GpioPin_add_ValueChanged(py::wrapper::Windows::Devices::Gpio::GpioPin* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Gpio::GpioPin, winrt::Windows::Devices::Gpio::GpioPinValueChangedEventArgs>>(arg);

            return py::convert(self->obj.ValueChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GpioPin_remove_ValueChanged(py::wrapper::Windows::Devices::Gpio::GpioPin* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ValueChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GpioPin(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Gpio::GpioPin>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_GpioPin(py::wrapper::Windows::Devices::Gpio::GpioPin* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_GpioPin(py::wrapper::Windows::Devices::Gpio::GpioPin* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GpioPin[] = {
        { "close", (PyCFunction)GpioPin_Close, METH_VARARGS, nullptr },
        { "get_drive_mode", (PyCFunction)GpioPin_GetDriveMode, METH_VARARGS, nullptr },
        { "is_drive_mode_supported", (PyCFunction)GpioPin_IsDriveModeSupported, METH_VARARGS, nullptr },
        { "read", (PyCFunction)GpioPin_Read, METH_VARARGS, nullptr },
        { "set_drive_mode", (PyCFunction)GpioPin_SetDriveMode, METH_VARARGS, nullptr },
        { "write", (PyCFunction)GpioPin_Write, METH_VARARGS, nullptr },
        { "add_value_changed", (PyCFunction)GpioPin_add_ValueChanged, METH_O, nullptr },
        { "remove_value_changed", (PyCFunction)GpioPin_remove_ValueChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_GpioPin, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_GpioPin, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_GpioPin, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GpioPin[] = {
        { const_cast<char*>("debounce_timeout"), (getter)GpioPin_get_DebounceTimeout, (setter)GpioPin_put_DebounceTimeout, nullptr, nullptr },
        { const_cast<char*>("pin_number"), (getter)GpioPin_get_PinNumber, nullptr, nullptr, nullptr },
        { const_cast<char*>("sharing_mode"), (getter)GpioPin_get_SharingMode, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GpioPin[] = 
    {
        { Py_tp_new, _new_GpioPin },
        { Py_tp_dealloc, _dealloc_GpioPin },
        { Py_tp_methods, _methods_GpioPin },
        { Py_tp_getset, _getset_GpioPin },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GpioPin =
    {
        "_winrt_Windows_Devices_Gpio.GpioPin",
        sizeof(py::wrapper::Windows::Devices::Gpio::GpioPin),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GpioPin
    };

    // ----- GpioPinValueChangedEventArgs class --------------------
    constexpr const char* const _type_name_GpioPinValueChangedEventArgs = "GpioPinValueChangedEventArgs";

    static PyObject* _new_GpioPinValueChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GpioPinValueChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_GpioPinValueChangedEventArgs(py::wrapper::Windows::Devices::Gpio::GpioPinValueChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GpioPinValueChangedEventArgs_get_Edge(py::wrapper::Windows::Devices::Gpio::GpioPinValueChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Edge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GpioPinValueChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Gpio::GpioPinValueChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GpioPinValueChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_GpioPinValueChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GpioPinValueChangedEventArgs[] = {
        { const_cast<char*>("edge"), (getter)GpioPinValueChangedEventArgs_get_Edge, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GpioPinValueChangedEventArgs[] = 
    {
        { Py_tp_new, _new_GpioPinValueChangedEventArgs },
        { Py_tp_dealloc, _dealloc_GpioPinValueChangedEventArgs },
        { Py_tp_methods, _methods_GpioPinValueChangedEventArgs },
        { Py_tp_getset, _getset_GpioPinValueChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GpioPinValueChangedEventArgs =
    {
        "_winrt_Windows_Devices_Gpio.GpioPinValueChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Gpio::GpioPinValueChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GpioPinValueChangedEventArgs
    };

    // ----- GpioChangeCount struct --------------------
    constexpr const char* const _type_name_GpioChangeCount = "GpioChangeCount";

    PyObject* _new_GpioChangeCount(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Devices::Gpio::GpioChangeCount return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Devices::Gpio::GpioChangeCount>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint64_t _Count{};
        PyObject* _RelativeTime{};

        static const char* kwlist[] = {"count", "relative_time", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KO", const_cast<char**>(kwlist), &_Count, &_RelativeTime))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Devices::Gpio::GpioChangeCount return_value{ _Count, py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(_RelativeTime) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_GpioChangeCount(py::wrapper::Windows::Devices::Gpio::GpioChangeCount* self)
    {
    }

    static PyObject* GpioChangeCount_get_Count(py::wrapper::Windows::Devices::Gpio::GpioChangeCount* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Count);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GpioChangeCount_set_Count(py::wrapper::Windows::Devices::Gpio::GpioChangeCount* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Count = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GpioChangeCount_get_RelativeTime(py::wrapper::Windows::Devices::Gpio::GpioChangeCount* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelativeTime);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GpioChangeCount_set_RelativeTime(py::wrapper::Windows::Devices::Gpio::GpioChangeCount* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.RelativeTime = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GpioChangeCount[] = {
        { const_cast<char*>("count"), (getter)GpioChangeCount_get_Count, (setter)GpioChangeCount_set_Count, nullptr, nullptr },
        { const_cast<char*>("relative_time"), (getter)GpioChangeCount_get_RelativeTime, (setter)GpioChangeCount_set_RelativeTime, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GpioChangeCount[] = 
    {
        { Py_tp_new, _new_GpioChangeCount },
        { Py_tp_dealloc, _dealloc_GpioChangeCount },
        { Py_tp_getset, _getset_GpioChangeCount },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GpioChangeCount =
    {
        "_winrt_Windows_Devices_Gpio.GpioChangeCount",
        sizeof(py::wrapper::Windows::Devices::Gpio::GpioChangeCount),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GpioChangeCount
    };

    // ----- GpioChangeRecord struct --------------------
    constexpr const char* const _type_name_GpioChangeRecord = "GpioChangeRecord";

    PyObject* _new_GpioChangeRecord(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Devices::Gpio::GpioChangeRecord return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Devices::Gpio::GpioChangeRecord>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        PyObject* _RelativeTime{};
        int32_t _Edge{};

        static const char* kwlist[] = {"relative_time", "edge", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "Oi", const_cast<char**>(kwlist), &_RelativeTime, &_Edge))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Devices::Gpio::GpioChangeRecord return_value{ py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(_RelativeTime), static_cast<winrt::Windows::Devices::Gpio::GpioPinEdge>(_Edge) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_GpioChangeRecord(py::wrapper::Windows::Devices::Gpio::GpioChangeRecord* self)
    {
    }

    static PyObject* GpioChangeRecord_get_RelativeTime(py::wrapper::Windows::Devices::Gpio::GpioChangeRecord* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelativeTime);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GpioChangeRecord_set_RelativeTime(py::wrapper::Windows::Devices::Gpio::GpioChangeRecord* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.RelativeTime = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GpioChangeRecord_get_Edge(py::wrapper::Windows::Devices::Gpio::GpioChangeRecord* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Edge);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GpioChangeRecord_set_Edge(py::wrapper::Windows::Devices::Gpio::GpioChangeRecord* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Edge = py::converter<winrt::Windows::Devices::Gpio::GpioPinEdge>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GpioChangeRecord[] = {
        { const_cast<char*>("relative_time"), (getter)GpioChangeRecord_get_RelativeTime, (setter)GpioChangeRecord_set_RelativeTime, nullptr, nullptr },
        { const_cast<char*>("edge"), (getter)GpioChangeRecord_get_Edge, (setter)GpioChangeRecord_set_Edge, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GpioChangeRecord[] = 
    {
        { Py_tp_new, _new_GpioChangeRecord },
        { Py_tp_dealloc, _dealloc_GpioChangeRecord },
        { Py_tp_getset, _getset_GpioChangeRecord },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GpioChangeRecord =
    {
        "_winrt_Windows_Devices_Gpio.GpioChangeRecord",
        sizeof(py::wrapper::Windows::Devices::Gpio::GpioChangeRecord),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GpioChangeRecord
    };

    // ----- Windows.Devices.Gpio Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Devices::Gpio::GpioChangeCounter>::python_type = py::register_python_type(module, _type_name_GpioChangeCounter, &_type_spec_GpioChangeCounter, bases.get());
            py::winrt_type<winrt::Windows::Devices::Gpio::GpioChangeReader>::python_type = py::register_python_type(module, _type_name_GpioChangeReader, &_type_spec_GpioChangeReader, bases.get());
            py::winrt_type<winrt::Windows::Devices::Gpio::GpioController>::python_type = py::register_python_type(module, _type_name_GpioController, &_type_spec_GpioController, bases.get());
            py::winrt_type<winrt::Windows::Devices::Gpio::GpioPin>::python_type = py::register_python_type(module, _type_name_GpioPin, &_type_spec_GpioPin, bases.get());
            py::winrt_type<winrt::Windows::Devices::Gpio::GpioPinValueChangedEventArgs>::python_type = py::register_python_type(module, _type_name_GpioPinValueChangedEventArgs, &_type_spec_GpioPinValueChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Gpio::GpioChangeCount>::python_type = py::register_python_type(module, _type_name_GpioChangeCount, &_type_spec_GpioChangeCount, bases.get());
            py::winrt_type<winrt::Windows::Devices::Gpio::GpioChangeRecord>::python_type = py::register_python_type(module, _type_name_GpioChangeRecord, &_type_spec_GpioChangeRecord, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Devices.Gpio");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Devices_Gpio",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Devices::Gpio

PyMODINIT_FUNC
PyInit__winrt_Windows_Devices_Gpio (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Devices::Gpio::module_def);
}
