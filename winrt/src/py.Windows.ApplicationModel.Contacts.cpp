// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.ApplicationModel.Contacts.h"

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::AggregateContactManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::Contact>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactAddress>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactAnnotation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationList>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationStore>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactBatch>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactCardOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactChange>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactChangeReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactChangeTracker>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactChangedDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactDate>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactEmail>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactField>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactFieldFactory>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactGroup>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactInstantMessageField>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactJobInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactLaunchActionVerbs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactList>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactListSyncConstraints>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactListSyncManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactLocationField>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactManagerForUser>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactMatchReason>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactPanel>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactPhone>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactPicker>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactQueryTextSearch>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactSignificantOther>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactStore>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactStoreNotificationTriggerDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactWebsite>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::FullContactCardOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::KnownContactField>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::PinnedContactIdsQueryResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::PinnedContactManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::IContactField>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::IContactFieldFactory>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::IContactInstantMessageFieldFactory>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::IContactLocationFieldFactory>::python_type;

namespace py::cpp::Windows::ApplicationModel::Contacts
{
    // ----- AggregateContactManager class --------------------
    constexpr const char* const _type_name_AggregateContactManager = "AggregateContactManager";

    static PyObject* _new_AggregateContactManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AggregateContactManager);
        return nullptr;
    }

    static void _dealloc_AggregateContactManager(py::wrapper::Windows::ApplicationModel::Contacts::AggregateContactManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AggregateContactManager_FindRawContactsAsync(py::wrapper::Windows::ApplicationModel::Contacts::AggregateContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.FindRawContactsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AggregateContactManager_SetRemoteIdentificationInformationAsync(py::wrapper::Windows::ApplicationModel::Contacts::AggregateContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.SetRemoteIdentificationInformationAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AggregateContactManager_TryLinkContactsAsync(py::wrapper::Windows::ApplicationModel::Contacts::AggregateContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 1);

                return py::convert(self->obj.TryLinkContactsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AggregateContactManager_TrySetPreferredSourceForPictureAsync(py::wrapper::Windows::ApplicationModel::Contacts::AggregateContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 1);

                return py::convert(self->obj.TrySetPreferredSourceForPictureAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AggregateContactManager_UnlinkRawContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::AggregateContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.UnlinkRawContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_AggregateContactManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::AggregateContactManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AggregateContactManager[] = {
        { "find_raw_contacts_async", (PyCFunction)AggregateContactManager_FindRawContactsAsync, METH_VARARGS, nullptr },
        { "set_remote_identification_information_async", (PyCFunction)AggregateContactManager_SetRemoteIdentificationInformationAsync, METH_VARARGS, nullptr },
        { "try_link_contacts_async", (PyCFunction)AggregateContactManager_TryLinkContactsAsync, METH_VARARGS, nullptr },
        { "try_set_preferred_source_for_picture_async", (PyCFunction)AggregateContactManager_TrySetPreferredSourceForPictureAsync, METH_VARARGS, nullptr },
        { "unlink_raw_contact_async", (PyCFunction)AggregateContactManager_UnlinkRawContactAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AggregateContactManager, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AggregateContactManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_AggregateContactManager[] = 
    {
        { Py_tp_new, _new_AggregateContactManager },
        { Py_tp_dealloc, _dealloc_AggregateContactManager },
        { Py_tp_methods, _methods_AggregateContactManager },
        { Py_tp_getset, _getset_AggregateContactManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AggregateContactManager =
    {
        "_winrt_Windows_ApplicationModel_Contacts.AggregateContactManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::AggregateContactManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AggregateContactManager
    };

    // ----- Contact class --------------------
    constexpr const char* const _type_name_Contact = "Contact";

    static PyObject* _new_Contact(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::Contact instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Contact(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Contact_get_Thumbnail(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_Thumbnail(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Thumbnail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_Name(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_Name(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_Fields(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Fields());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_Id(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_Id(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_Notes(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Notes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_Notes(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Notes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_ConnectedServiceAccounts(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectedServiceAccounts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_Emails(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Emails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_Addresses(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Addresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_ImportantDates(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ImportantDates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_JobInfo(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.JobInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_DataSuppliers(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DataSuppliers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_Phones(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Phones());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_ProviderProperties(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_SignificantOthers(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignificantOthers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_Websites(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Websites());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_SourceDisplayPicture(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceDisplayPicture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_SourceDisplayPicture(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.SourceDisplayPicture(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_TextToneToken(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TextToneToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_TextToneToken(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TextToneToken(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_DisplayNameOverride(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayNameOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_DisplayNameOverride(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayNameOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_DisplayPictureUserUpdateTime(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayPictureUserUpdateTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_DisplayPictureUserUpdateTime(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.DisplayPictureUserUpdateTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_Nickname(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Nickname());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_Nickname(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Nickname(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_RemoteId(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_RemoteId(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_RingToneToken(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RingToneToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_RingToneToken(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RingToneToken(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_ContactListId(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactListId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_LargeDisplayPicture(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LargeDisplayPicture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_SmallDisplayPicture(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SmallDisplayPicture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_SortName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SortName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_AggregateId(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AggregateId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_FullName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FullName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_IsAggregate(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAggregate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_IsDisplayPictureManuallySet(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDisplayPictureManuallySet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_IsMe(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsMe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_YomiGivenName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.YomiGivenName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_YomiGivenName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.YomiGivenName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_HonorificNameSuffix(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HonorificNameSuffix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_HonorificNameSuffix(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HonorificNameSuffix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_YomiFamilyName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.YomiFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_YomiFamilyName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.YomiFamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_MiddleName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MiddleName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_MiddleName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MiddleName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_LastName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_LastName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.LastName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_HonorificNamePrefix(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HonorificNamePrefix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_HonorificNamePrefix(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HonorificNamePrefix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_FirstName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FirstName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_FirstName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FirstName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_DisplayName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_YomiDisplayName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.YomiDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Contact(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::Contact>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Contact[] = {
        { "_from", (PyCFunction)_from_Contact, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_Contact[] = {
        { const_cast<char*>("thumbnail"), (getter)Contact_get_Thumbnail, (setter)Contact_put_Thumbnail, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)Contact_get_Name, (setter)Contact_put_Name, nullptr, nullptr },
        { const_cast<char*>("fields"), (getter)Contact_get_Fields, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)Contact_get_Id, (setter)Contact_put_Id, nullptr, nullptr },
        { const_cast<char*>("notes"), (getter)Contact_get_Notes, (setter)Contact_put_Notes, nullptr, nullptr },
        { const_cast<char*>("connected_service_accounts"), (getter)Contact_get_ConnectedServiceAccounts, nullptr, nullptr, nullptr },
        { const_cast<char*>("emails"), (getter)Contact_get_Emails, nullptr, nullptr, nullptr },
        { const_cast<char*>("addresses"), (getter)Contact_get_Addresses, nullptr, nullptr, nullptr },
        { const_cast<char*>("important_dates"), (getter)Contact_get_ImportantDates, nullptr, nullptr, nullptr },
        { const_cast<char*>("job_info"), (getter)Contact_get_JobInfo, nullptr, nullptr, nullptr },
        { const_cast<char*>("data_suppliers"), (getter)Contact_get_DataSuppliers, nullptr, nullptr, nullptr },
        { const_cast<char*>("phones"), (getter)Contact_get_Phones, nullptr, nullptr, nullptr },
        { const_cast<char*>("provider_properties"), (getter)Contact_get_ProviderProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("significant_others"), (getter)Contact_get_SignificantOthers, nullptr, nullptr, nullptr },
        { const_cast<char*>("websites"), (getter)Contact_get_Websites, nullptr, nullptr, nullptr },
        { const_cast<char*>("source_display_picture"), (getter)Contact_get_SourceDisplayPicture, (setter)Contact_put_SourceDisplayPicture, nullptr, nullptr },
        { const_cast<char*>("text_tone_token"), (getter)Contact_get_TextToneToken, (setter)Contact_put_TextToneToken, nullptr, nullptr },
        { const_cast<char*>("display_name_override"), (getter)Contact_get_DisplayNameOverride, (setter)Contact_put_DisplayNameOverride, nullptr, nullptr },
        { const_cast<char*>("display_picture_user_update_time"), (getter)Contact_get_DisplayPictureUserUpdateTime, (setter)Contact_put_DisplayPictureUserUpdateTime, nullptr, nullptr },
        { const_cast<char*>("nickname"), (getter)Contact_get_Nickname, (setter)Contact_put_Nickname, nullptr, nullptr },
        { const_cast<char*>("remote_id"), (getter)Contact_get_RemoteId, (setter)Contact_put_RemoteId, nullptr, nullptr },
        { const_cast<char*>("ring_tone_token"), (getter)Contact_get_RingToneToken, (setter)Contact_put_RingToneToken, nullptr, nullptr },
        { const_cast<char*>("contact_list_id"), (getter)Contact_get_ContactListId, nullptr, nullptr, nullptr },
        { const_cast<char*>("large_display_picture"), (getter)Contact_get_LargeDisplayPicture, nullptr, nullptr, nullptr },
        { const_cast<char*>("small_display_picture"), (getter)Contact_get_SmallDisplayPicture, nullptr, nullptr, nullptr },
        { const_cast<char*>("sort_name"), (getter)Contact_get_SortName, nullptr, nullptr, nullptr },
        { const_cast<char*>("aggregate_id"), (getter)Contact_get_AggregateId, nullptr, nullptr, nullptr },
        { const_cast<char*>("full_name"), (getter)Contact_get_FullName, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_aggregate"), (getter)Contact_get_IsAggregate, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_display_picture_manually_set"), (getter)Contact_get_IsDisplayPictureManuallySet, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_me"), (getter)Contact_get_IsMe, nullptr, nullptr, nullptr },
        { const_cast<char*>("yomi_given_name"), (getter)Contact_get_YomiGivenName, (setter)Contact_put_YomiGivenName, nullptr, nullptr },
        { const_cast<char*>("honorific_name_suffix"), (getter)Contact_get_HonorificNameSuffix, (setter)Contact_put_HonorificNameSuffix, nullptr, nullptr },
        { const_cast<char*>("yomi_family_name"), (getter)Contact_get_YomiFamilyName, (setter)Contact_put_YomiFamilyName, nullptr, nullptr },
        { const_cast<char*>("middle_name"), (getter)Contact_get_MiddleName, (setter)Contact_put_MiddleName, nullptr, nullptr },
        { const_cast<char*>("last_name"), (getter)Contact_get_LastName, (setter)Contact_put_LastName, nullptr, nullptr },
        { const_cast<char*>("honorific_name_prefix"), (getter)Contact_get_HonorificNamePrefix, (setter)Contact_put_HonorificNamePrefix, nullptr, nullptr },
        { const_cast<char*>("first_name"), (getter)Contact_get_FirstName, (setter)Contact_put_FirstName, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)Contact_get_DisplayName, nullptr, nullptr, nullptr },
        { const_cast<char*>("yomi_display_name"), (getter)Contact_get_YomiDisplayName, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Contact[] = 
    {
        { Py_tp_new, _new_Contact },
        { Py_tp_dealloc, _dealloc_Contact },
        { Py_tp_methods, _methods_Contact },
        { Py_tp_getset, _getset_Contact },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Contact =
    {
        "_winrt_Windows_ApplicationModel_Contacts.Contact",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::Contact),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Contact
    };

    // ----- ContactAddress class --------------------
    constexpr const char* const _type_name_ContactAddress = "ContactAddress";

    static PyObject* _new_ContactAddress(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactAddress instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactAddress(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactAddress_get_StreetAddress(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StreetAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_StreetAddress(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.StreetAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_Region(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Region());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_Region(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Region(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_PostalCode(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PostalCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_PostalCode(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PostalCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_Locality(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Locality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_Locality(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Locality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAddressKind>(arg);

            self->obj.Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_Country(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Country());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_Country(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Country(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactAddress>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactAddress[] = {
        { "_from", (PyCFunction)_from_ContactAddress, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactAddress[] = {
        { const_cast<char*>("street_address"), (getter)ContactAddress_get_StreetAddress, (setter)ContactAddress_put_StreetAddress, nullptr, nullptr },
        { const_cast<char*>("region"), (getter)ContactAddress_get_Region, (setter)ContactAddress_put_Region, nullptr, nullptr },
        { const_cast<char*>("postal_code"), (getter)ContactAddress_get_PostalCode, (setter)ContactAddress_put_PostalCode, nullptr, nullptr },
        { const_cast<char*>("locality"), (getter)ContactAddress_get_Locality, (setter)ContactAddress_put_Locality, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)ContactAddress_get_Kind, (setter)ContactAddress_put_Kind, nullptr, nullptr },
        { const_cast<char*>("description"), (getter)ContactAddress_get_Description, (setter)ContactAddress_put_Description, nullptr, nullptr },
        { const_cast<char*>("country"), (getter)ContactAddress_get_Country, (setter)ContactAddress_put_Country, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactAddress[] = 
    {
        { Py_tp_new, _new_ContactAddress },
        { Py_tp_dealloc, _dealloc_ContactAddress },
        { Py_tp_methods, _methods_ContactAddress },
        { Py_tp_getset, _getset_ContactAddress },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactAddress =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactAddress",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactAddress
    };

    // ----- ContactAnnotation class --------------------
    constexpr const char* const _type_name_ContactAnnotation = "ContactAnnotation";

    static PyObject* _new_ContactAnnotation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactAnnotation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactAnnotation(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactAnnotation_get_SupportedOperations(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedOperations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAnnotation_put_SupportedOperations(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationOperations>(arg);

            self->obj.SupportedOperations(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAnnotation_get_RemoteId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAnnotation_put_RemoteId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAnnotation_get_ContactId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAnnotation_put_ContactId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContactId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAnnotation_get_AnnotationListId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AnnotationListId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactAnnotation_get_Id(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactAnnotation_get_IsDisabled(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDisabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactAnnotation_get_ProviderProperties(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactAnnotation_get_ContactListId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactListId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAnnotation_put_ContactListId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContactListId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactAnnotation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactAnnotation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactAnnotation[] = {
        { "_from", (PyCFunction)_from_ContactAnnotation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactAnnotation[] = {
        { const_cast<char*>("supported_operations"), (getter)ContactAnnotation_get_SupportedOperations, (setter)ContactAnnotation_put_SupportedOperations, nullptr, nullptr },
        { const_cast<char*>("remote_id"), (getter)ContactAnnotation_get_RemoteId, (setter)ContactAnnotation_put_RemoteId, nullptr, nullptr },
        { const_cast<char*>("contact_id"), (getter)ContactAnnotation_get_ContactId, (setter)ContactAnnotation_put_ContactId, nullptr, nullptr },
        { const_cast<char*>("annotation_list_id"), (getter)ContactAnnotation_get_AnnotationListId, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)ContactAnnotation_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_disabled"), (getter)ContactAnnotation_get_IsDisabled, nullptr, nullptr, nullptr },
        { const_cast<char*>("provider_properties"), (getter)ContactAnnotation_get_ProviderProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("contact_list_id"), (getter)ContactAnnotation_get_ContactListId, (setter)ContactAnnotation_put_ContactListId, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactAnnotation[] = 
    {
        { Py_tp_new, _new_ContactAnnotation },
        { Py_tp_dealloc, _dealloc_ContactAnnotation },
        { Py_tp_methods, _methods_ContactAnnotation },
        { Py_tp_getset, _getset_ContactAnnotation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactAnnotation =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactAnnotation",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactAnnotation
    };

    // ----- ContactAnnotationList class --------------------
    constexpr const char* const _type_name_ContactAnnotationList = "ContactAnnotationList";

    static PyObject* _new_ContactAnnotationList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactAnnotationList);
        return nullptr;
    }

    static void _dealloc_ContactAnnotationList(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactAnnotationList_DeleteAnnotationAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAnnotation>(args, 0);

                return py::convert(self->obj.DeleteAnnotationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_DeleteAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_FindAnnotationsAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindAnnotationsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_FindAnnotationsByRemoteIdAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindAnnotationsByRemoteIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_GetAnnotationAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAnnotationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_TrySaveAnnotationAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAnnotation>(args, 0);

                return py::convert(self->obj.TrySaveAnnotationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_get_Id(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_get_ProviderPackageFamilyName(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_get_UserDataAccountId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserDataAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactAnnotationList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactAnnotationList[] = {
        { "delete_annotation_async", (PyCFunction)ContactAnnotationList_DeleteAnnotationAsync, METH_VARARGS, nullptr },
        { "delete_async", (PyCFunction)ContactAnnotationList_DeleteAsync, METH_VARARGS, nullptr },
        { "find_annotations_async", (PyCFunction)ContactAnnotationList_FindAnnotationsAsync, METH_VARARGS, nullptr },
        { "find_annotations_by_remote_id_async", (PyCFunction)ContactAnnotationList_FindAnnotationsByRemoteIdAsync, METH_VARARGS, nullptr },
        { "get_annotation_async", (PyCFunction)ContactAnnotationList_GetAnnotationAsync, METH_VARARGS, nullptr },
        { "try_save_annotation_async", (PyCFunction)ContactAnnotationList_TrySaveAnnotationAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ContactAnnotationList, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactAnnotationList[] = {
        { const_cast<char*>("id"), (getter)ContactAnnotationList_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("provider_package_family_name"), (getter)ContactAnnotationList_get_ProviderPackageFamilyName, nullptr, nullptr, nullptr },
        { const_cast<char*>("user_data_account_id"), (getter)ContactAnnotationList_get_UserDataAccountId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactAnnotationList[] = 
    {
        { Py_tp_new, _new_ContactAnnotationList },
        { Py_tp_dealloc, _dealloc_ContactAnnotationList },
        { Py_tp_methods, _methods_ContactAnnotationList },
        { Py_tp_getset, _getset_ContactAnnotationList },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactAnnotationList =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactAnnotationList",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactAnnotationList
    };

    // ----- ContactAnnotationStore class --------------------
    constexpr const char* const _type_name_ContactAnnotationStore = "ContactAnnotationStore";

    static PyObject* _new_ContactAnnotationStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactAnnotationStore);
        return nullptr;
    }

    static void _dealloc_ContactAnnotationStore(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactAnnotationStore_CreateAnnotationListAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateAnnotationListAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateAnnotationListAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationStore_DisableAnnotationAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAnnotation>(args, 0);

                return py::convert(self->obj.DisableAnnotationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationStore_FindAnnotationListsAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindAnnotationListsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationStore_FindAnnotationsForContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.FindAnnotationsForContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationStore_FindAnnotationsForContactListAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindAnnotationsForContactListAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationStore_FindContactIdsByEmailAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindContactIdsByEmailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationStore_FindContactIdsByPhoneNumberAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindContactIdsByPhoneNumberAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationStore_GetAnnotationListAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAnnotationListAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ContactAnnotationStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactAnnotationStore[] = {
        { "create_annotation_list_async", (PyCFunction)ContactAnnotationStore_CreateAnnotationListAsync, METH_VARARGS, nullptr },
        { "disable_annotation_async", (PyCFunction)ContactAnnotationStore_DisableAnnotationAsync, METH_VARARGS, nullptr },
        { "find_annotation_lists_async", (PyCFunction)ContactAnnotationStore_FindAnnotationListsAsync, METH_VARARGS, nullptr },
        { "find_annotations_for_contact_async", (PyCFunction)ContactAnnotationStore_FindAnnotationsForContactAsync, METH_VARARGS, nullptr },
        { "find_annotations_for_contact_list_async", (PyCFunction)ContactAnnotationStore_FindAnnotationsForContactListAsync, METH_VARARGS, nullptr },
        { "find_contact_ids_by_email_async", (PyCFunction)ContactAnnotationStore_FindContactIdsByEmailAsync, METH_VARARGS, nullptr },
        { "find_contact_ids_by_phone_number_async", (PyCFunction)ContactAnnotationStore_FindContactIdsByPhoneNumberAsync, METH_VARARGS, nullptr },
        { "get_annotation_list_async", (PyCFunction)ContactAnnotationStore_GetAnnotationListAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ContactAnnotationStore, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactAnnotationStore[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactAnnotationStore[] = 
    {
        { Py_tp_new, _new_ContactAnnotationStore },
        { Py_tp_dealloc, _dealloc_ContactAnnotationStore },
        { Py_tp_methods, _methods_ContactAnnotationStore },
        { Py_tp_getset, _getset_ContactAnnotationStore },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactAnnotationStore =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactAnnotationStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactAnnotationStore
    };

    // ----- ContactBatch class --------------------
    constexpr const char* const _type_name_ContactBatch = "ContactBatch";

    static PyObject* _new_ContactBatch(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactBatch);
        return nullptr;
    }

    static void _dealloc_ContactBatch(py::wrapper::Windows::ApplicationModel::Contacts::ContactBatch* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactBatch_get_Contacts(py::wrapper::Windows::ApplicationModel::Contacts::ContactBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contacts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactBatch_get_Status(py::wrapper::Windows::ApplicationModel::Contacts::ContactBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactBatch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactBatch>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactBatch[] = {
        { "_from", (PyCFunction)_from_ContactBatch, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactBatch[] = {
        { const_cast<char*>("contacts"), (getter)ContactBatch_get_Contacts, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)ContactBatch_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactBatch[] = 
    {
        { Py_tp_new, _new_ContactBatch },
        { Py_tp_dealloc, _dealloc_ContactBatch },
        { Py_tp_methods, _methods_ContactBatch },
        { Py_tp_getset, _getset_ContactBatch },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactBatch =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactBatch",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactBatch),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactBatch
    };

    // ----- ContactCardDelayedDataLoader class --------------------
    constexpr const char* const _type_name_ContactCardDelayedDataLoader = "ContactCardDelayedDataLoader";

    static PyObject* _new_ContactCardDelayedDataLoader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactCardDelayedDataLoader);
        return nullptr;
    }

    static void _dealloc_ContactCardDelayedDataLoader(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactCardDelayedDataLoader_Close(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactCardDelayedDataLoader_SetData(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                self->obj.SetData(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ContactCardDelayedDataLoader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ContactCardDelayedDataLoader(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_ContactCardDelayedDataLoader(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactCardDelayedDataLoader[] = {
        { "close", (PyCFunction)ContactCardDelayedDataLoader_Close, METH_VARARGS, nullptr },
        { "set_data", (PyCFunction)ContactCardDelayedDataLoader_SetData, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ContactCardDelayedDataLoader, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_ContactCardDelayedDataLoader, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_ContactCardDelayedDataLoader, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactCardDelayedDataLoader[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactCardDelayedDataLoader[] = 
    {
        { Py_tp_new, _new_ContactCardDelayedDataLoader },
        { Py_tp_dealloc, _dealloc_ContactCardDelayedDataLoader },
        { Py_tp_methods, _methods_ContactCardDelayedDataLoader },
        { Py_tp_getset, _getset_ContactCardDelayedDataLoader },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactCardDelayedDataLoader =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactCardDelayedDataLoader",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactCardDelayedDataLoader
    };

    // ----- ContactCardOptions class --------------------
    constexpr const char* const _type_name_ContactCardOptions = "ContactCardOptions";

    static PyObject* _new_ContactCardOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactCardOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactCardOptions(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactCardOptions_get_InitialTabKind(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InitialTabKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactCardOptions_put_InitialTabKind(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactCardTabKind>(arg);

            self->obj.InitialTabKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactCardOptions_get_HeaderKind(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HeaderKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactCardOptions_put_HeaderKind(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactCardHeaderKind>(arg);

            self->obj.HeaderKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactCardOptions_get_ServerSearchContactListIds(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerSearchContactListIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactCardOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactCardOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactCardOptions[] = {
        { "_from", (PyCFunction)_from_ContactCardOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactCardOptions[] = {
        { const_cast<char*>("initial_tab_kind"), (getter)ContactCardOptions_get_InitialTabKind, (setter)ContactCardOptions_put_InitialTabKind, nullptr, nullptr },
        { const_cast<char*>("header_kind"), (getter)ContactCardOptions_get_HeaderKind, (setter)ContactCardOptions_put_HeaderKind, nullptr, nullptr },
        { const_cast<char*>("server_search_contact_list_ids"), (getter)ContactCardOptions_get_ServerSearchContactListIds, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactCardOptions[] = 
    {
        { Py_tp_new, _new_ContactCardOptions },
        { Py_tp_dealloc, _dealloc_ContactCardOptions },
        { Py_tp_methods, _methods_ContactCardOptions },
        { Py_tp_getset, _getset_ContactCardOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactCardOptions =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactCardOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactCardOptions
    };

    // ----- ContactChange class --------------------
    constexpr const char* const _type_name_ContactChange = "ContactChange";

    static PyObject* _new_ContactChange(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactChange);
        return nullptr;
    }

    static void _dealloc_ContactChange(py::wrapper::Windows::ApplicationModel::Contacts::ContactChange* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactChange_get_ChangeType(py::wrapper::Windows::ApplicationModel::Contacts::ContactChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactChange_get_Contact(py::wrapper::Windows::ApplicationModel::Contacts::ContactChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactChange[] = {
        { "_from", (PyCFunction)_from_ContactChange, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactChange[] = {
        { const_cast<char*>("change_type"), (getter)ContactChange_get_ChangeType, nullptr, nullptr, nullptr },
        { const_cast<char*>("contact"), (getter)ContactChange_get_Contact, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactChange[] = 
    {
        { Py_tp_new, _new_ContactChange },
        { Py_tp_dealloc, _dealloc_ContactChange },
        { Py_tp_methods, _methods_ContactChange },
        { Py_tp_getset, _getset_ContactChange },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactChange =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactChange",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactChange
    };

    // ----- ContactChangeReader class --------------------
    constexpr const char* const _type_name_ContactChangeReader = "ContactChangeReader";

    static PyObject* _new_ContactChangeReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactChangeReader);
        return nullptr;
    }

    static void _dealloc_ContactChangeReader(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactChangeReader_AcceptChanges(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.AcceptChanges();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactChangeReader_AcceptChangesThrough(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactChange>(args, 0);

                self->obj.AcceptChangesThrough(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactChangeReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ContactChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactChangeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactChangeReader[] = {
        { "accept_changes", (PyCFunction)ContactChangeReader_AcceptChanges, METH_VARARGS, nullptr },
        { "accept_changes_through", (PyCFunction)ContactChangeReader_AcceptChangesThrough, METH_VARARGS, nullptr },
        { "read_batch_async", (PyCFunction)ContactChangeReader_ReadBatchAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ContactChangeReader, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactChangeReader[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactChangeReader[] = 
    {
        { Py_tp_new, _new_ContactChangeReader },
        { Py_tp_dealloc, _dealloc_ContactChangeReader },
        { Py_tp_methods, _methods_ContactChangeReader },
        { Py_tp_getset, _getset_ContactChangeReader },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactChangeReader =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactChangeReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactChangeReader
    };

    // ----- ContactChangeTracker class --------------------
    constexpr const char* const _type_name_ContactChangeTracker = "ContactChangeTracker";

    static PyObject* _new_ContactChangeTracker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactChangeTracker);
        return nullptr;
    }

    static void _dealloc_ContactChangeTracker(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeTracker* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactChangeTracker_Enable(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Enable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactChangeTracker_GetChangeReader(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetChangeReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactChangeTracker_Reset(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactChangeTracker_get_IsTracking(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTracking());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactChangeTracker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactChangeTracker[] = {
        { "enable", (PyCFunction)ContactChangeTracker_Enable, METH_VARARGS, nullptr },
        { "get_change_reader", (PyCFunction)ContactChangeTracker_GetChangeReader, METH_VARARGS, nullptr },
        { "reset", (PyCFunction)ContactChangeTracker_Reset, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ContactChangeTracker, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactChangeTracker[] = {
        { const_cast<char*>("is_tracking"), (getter)ContactChangeTracker_get_IsTracking, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactChangeTracker[] = 
    {
        { Py_tp_new, _new_ContactChangeTracker },
        { Py_tp_dealloc, _dealloc_ContactChangeTracker },
        { Py_tp_methods, _methods_ContactChangeTracker },
        { Py_tp_getset, _getset_ContactChangeTracker },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactChangeTracker =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactChangeTracker",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeTracker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactChangeTracker
    };

    // ----- ContactChangedDeferral class --------------------
    constexpr const char* const _type_name_ContactChangedDeferral = "ContactChangedDeferral";

    static PyObject* _new_ContactChangedDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactChangedDeferral);
        return nullptr;
    }

    static void _dealloc_ContactChangedDeferral(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangedDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactChangedDeferral_Complete(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangedDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ContactChangedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactChangedDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactChangedDeferral[] = {
        { "complete", (PyCFunction)ContactChangedDeferral_Complete, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ContactChangedDeferral, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactChangedDeferral[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactChangedDeferral[] = 
    {
        { Py_tp_new, _new_ContactChangedDeferral },
        { Py_tp_dealloc, _dealloc_ContactChangedDeferral },
        { Py_tp_methods, _methods_ContactChangedDeferral },
        { Py_tp_getset, _getset_ContactChangedDeferral },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactChangedDeferral =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactChangedDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangedDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactChangedDeferral
    };

    // ----- ContactChangedEventArgs class --------------------
    constexpr const char* const _type_name_ContactChangedEventArgs = "ContactChangedEventArgs";

    static PyObject* _new_ContactChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_ContactChangedEventArgs(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactChangedEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ContactChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactChangedEventArgs[] = {
        { "get_deferral", (PyCFunction)ContactChangedEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ContactChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactChangedEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactChangedEventArgs[] = 
    {
        { Py_tp_new, _new_ContactChangedEventArgs },
        { Py_tp_dealloc, _dealloc_ContactChangedEventArgs },
        { Py_tp_methods, _methods_ContactChangedEventArgs },
        { Py_tp_getset, _getset_ContactChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactChangedEventArgs =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactChangedEventArgs
    };

    // ----- ContactConnectedServiceAccount class --------------------
    constexpr const char* const _type_name_ContactConnectedServiceAccount = "ContactConnectedServiceAccount";

    static PyObject* _new_ContactConnectedServiceAccount(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactConnectedServiceAccount(py::wrapper::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactConnectedServiceAccount_get_ServiceName(py::wrapper::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactConnectedServiceAccount_put_ServiceName(py::wrapper::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ServiceName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactConnectedServiceAccount_get_Id(py::wrapper::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactConnectedServiceAccount_put_Id(py::wrapper::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactConnectedServiceAccount(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactConnectedServiceAccount[] = {
        { "_from", (PyCFunction)_from_ContactConnectedServiceAccount, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactConnectedServiceAccount[] = {
        { const_cast<char*>("service_name"), (getter)ContactConnectedServiceAccount_get_ServiceName, (setter)ContactConnectedServiceAccount_put_ServiceName, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)ContactConnectedServiceAccount_get_Id, (setter)ContactConnectedServiceAccount_put_Id, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactConnectedServiceAccount[] = 
    {
        { Py_tp_new, _new_ContactConnectedServiceAccount },
        { Py_tp_dealloc, _dealloc_ContactConnectedServiceAccount },
        { Py_tp_methods, _methods_ContactConnectedServiceAccount },
        { Py_tp_getset, _getset_ContactConnectedServiceAccount },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactConnectedServiceAccount =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactConnectedServiceAccount",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactConnectedServiceAccount
    };

    // ----- ContactDate class --------------------
    constexpr const char* const _type_name_ContactDate = "ContactDate";

    static PyObject* _new_ContactDate(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactDate instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactDate(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactDate_get_Year(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Year());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactDate_put_Year(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.Year(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactDate_get_Month(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Month());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactDate_put_Month(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.Month(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactDate_get_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactDate_put_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactDateKind>(arg);

            self->obj.Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactDate_get_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactDate_put_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactDate_get_Day(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Day());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactDate_put_Day(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.Day(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactDate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactDate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactDate[] = {
        { "_from", (PyCFunction)_from_ContactDate, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactDate[] = {
        { const_cast<char*>("year"), (getter)ContactDate_get_Year, (setter)ContactDate_put_Year, nullptr, nullptr },
        { const_cast<char*>("month"), (getter)ContactDate_get_Month, (setter)ContactDate_put_Month, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)ContactDate_get_Kind, (setter)ContactDate_put_Kind, nullptr, nullptr },
        { const_cast<char*>("description"), (getter)ContactDate_get_Description, (setter)ContactDate_put_Description, nullptr, nullptr },
        { const_cast<char*>("day"), (getter)ContactDate_get_Day, (setter)ContactDate_put_Day, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactDate[] = 
    {
        { Py_tp_new, _new_ContactDate },
        { Py_tp_dealloc, _dealloc_ContactDate },
        { Py_tp_methods, _methods_ContactDate },
        { Py_tp_getset, _getset_ContactDate },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactDate =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactDate",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactDate
    };

    // ----- ContactEmail class --------------------
    constexpr const char* const _type_name_ContactEmail = "ContactEmail";

    static PyObject* _new_ContactEmail(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactEmail instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactEmail(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactEmail_get_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactEmail_put_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactEmailKind>(arg);

            self->obj.Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactEmail_get_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactEmail_put_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactEmail_get_Address(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactEmail_put_Address(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Address(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactEmail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactEmail>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactEmail[] = {
        { "_from", (PyCFunction)_from_ContactEmail, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactEmail[] = {
        { const_cast<char*>("kind"), (getter)ContactEmail_get_Kind, (setter)ContactEmail_put_Kind, nullptr, nullptr },
        { const_cast<char*>("description"), (getter)ContactEmail_get_Description, (setter)ContactEmail_put_Description, nullptr, nullptr },
        { const_cast<char*>("address"), (getter)ContactEmail_get_Address, (setter)ContactEmail_put_Address, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactEmail[] = 
    {
        { Py_tp_new, _new_ContactEmail },
        { Py_tp_dealloc, _dealloc_ContactEmail },
        { Py_tp_methods, _methods_ContactEmail },
        { Py_tp_getset, _getset_ContactEmail },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactEmail =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactEmail",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactEmail
    };

    // ----- ContactField class --------------------
    constexpr const char* const _type_name_ContactField = "ContactField";

    static PyObject* _new_ContactField(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 1);

                winrt::Windows::ApplicationModel::Contacts::ContactField instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 2);

                winrt::Windows::ApplicationModel::Contacts::ContactField instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 3);

                winrt::Windows::ApplicationModel::Contacts::ContactField instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactField(py::wrapper::Windows::ApplicationModel::Contacts::ContactField* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactField_get_Category(py::wrapper::Windows::ApplicationModel::Contacts::ContactField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Category());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactField_get_Name(py::wrapper::Windows::ApplicationModel::Contacts::ContactField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactField_get_Type(py::wrapper::Windows::ApplicationModel::Contacts::ContactField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactField_get_Value(py::wrapper::Windows::ApplicationModel::Contacts::ContactField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactField(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactField>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactField[] = {
        { "_from", (PyCFunction)_from_ContactField, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactField[] = {
        { const_cast<char*>("category"), (getter)ContactField_get_Category, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)ContactField_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)ContactField_get_Type, nullptr, nullptr, nullptr },
        { const_cast<char*>("value"), (getter)ContactField_get_Value, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactField[] = 
    {
        { Py_tp_new, _new_ContactField },
        { Py_tp_dealloc, _dealloc_ContactField },
        { Py_tp_methods, _methods_ContactField },
        { Py_tp_getset, _getset_ContactField },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactField =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactField",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactField),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactField
    };

    // ----- ContactFieldFactory class --------------------
    constexpr const char* const _type_name_ContactFieldFactory = "ContactFieldFactory";

    static PyObject* _new_ContactFieldFactory(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactFieldFactory instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactFieldFactory(py::wrapper::Windows::ApplicationModel::Contacts::ContactFieldFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactFieldFactory_CreateField(py::wrapper::Windows::ApplicationModel::Contacts::ContactFieldFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 1);

                return py::convert(self->obj.CreateField(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 2);

                return py::convert(self->obj.CreateField(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 3);

                return py::convert(self->obj.CreateField(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactFieldFactory_CreateInstantMessage(py::wrapper::Windows::ApplicationModel::Contacts::ContactFieldFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateInstantMessage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);

                return py::convert(self->obj.CreateInstantMessage(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 4);

                return py::convert(self->obj.CreateInstantMessage(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactFieldFactory_CreateLocation(py::wrapper::Windows::ApplicationModel::Contacts::ContactFieldFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateLocation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);

                return py::convert(self->obj.CreateLocation(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);

                return py::convert(self->obj.CreateLocation(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ContactFieldFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactFieldFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactFieldFactory[] = {
        { "create_field", (PyCFunction)ContactFieldFactory_CreateField, METH_VARARGS, nullptr },
        { "create_instant_message", (PyCFunction)ContactFieldFactory_CreateInstantMessage, METH_VARARGS, nullptr },
        { "create_location", (PyCFunction)ContactFieldFactory_CreateLocation, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ContactFieldFactory, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactFieldFactory[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactFieldFactory[] = 
    {
        { Py_tp_new, _new_ContactFieldFactory },
        { Py_tp_dealloc, _dealloc_ContactFieldFactory },
        { Py_tp_methods, _methods_ContactFieldFactory },
        { Py_tp_getset, _getset_ContactFieldFactory },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactFieldFactory =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactFieldFactory",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactFieldFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactFieldFactory
    };

    // ----- ContactGroup class --------------------
    constexpr const char* const _type_name_ContactGroup = "ContactGroup";

    static PyObject* _new_ContactGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactGroup);
        return nullptr;
    }

    static void _dealloc_ContactGroup(py::wrapper::Windows::ApplicationModel::Contacts::ContactGroup* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ContactGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactGroup[] = {
        { "_from", (PyCFunction)_from_ContactGroup, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactGroup[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactGroup[] = 
    {
        { Py_tp_new, _new_ContactGroup },
        { Py_tp_dealloc, _dealloc_ContactGroup },
        { Py_tp_methods, _methods_ContactGroup },
        { Py_tp_getset, _getset_ContactGroup },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactGroup =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactGroup",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactGroup
    };

    // ----- ContactInformation class --------------------
    constexpr const char* const _type_name_ContactInformation = "ContactInformation";

    static PyObject* _new_ContactInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactInformation);
        return nullptr;
    }

    static void _dealloc_ContactInformation(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactInformation_GetThumbnailAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetThumbnailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactInformation_QueryCustomFields(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.QueryCustomFields(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactInformation_get_CustomFields(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CustomFields());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInformation_get_Emails(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Emails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInformation_get_InstantMessages(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstantMessages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInformation_get_Locations(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Locations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInformation_get_Name(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInformation_get_PhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactInformation[] = {
        { "get_thumbnail_async", (PyCFunction)ContactInformation_GetThumbnailAsync, METH_VARARGS, nullptr },
        { "query_custom_fields", (PyCFunction)ContactInformation_QueryCustomFields, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ContactInformation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactInformation[] = {
        { const_cast<char*>("custom_fields"), (getter)ContactInformation_get_CustomFields, nullptr, nullptr, nullptr },
        { const_cast<char*>("emails"), (getter)ContactInformation_get_Emails, nullptr, nullptr, nullptr },
        { const_cast<char*>("instant_messages"), (getter)ContactInformation_get_InstantMessages, nullptr, nullptr, nullptr },
        { const_cast<char*>("locations"), (getter)ContactInformation_get_Locations, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)ContactInformation_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("phone_numbers"), (getter)ContactInformation_get_PhoneNumbers, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactInformation[] = 
    {
        { Py_tp_new, _new_ContactInformation },
        { Py_tp_dealloc, _dealloc_ContactInformation },
        { Py_tp_methods, _methods_ContactInformation },
        { Py_tp_getset, _getset_ContactInformation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactInformation =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactInformation",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactInformation
    };

    // ----- ContactInstantMessageField class --------------------
    constexpr const char* const _type_name_ContactInstantMessageField = "ContactInstantMessageField";

    static PyObject* _new_ContactInstantMessageField(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Contacts::ContactInstantMessageField instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);

                winrt::Windows::ApplicationModel::Contacts::ContactInstantMessageField instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 4);

                winrt::Windows::ApplicationModel::Contacts::ContactInstantMessageField instance{ param0, param1, param2, param3, param4 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactInstantMessageField(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactInstantMessageField_get_Category(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Category());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInstantMessageField_get_Name(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInstantMessageField_get_Type(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInstantMessageField_get_Value(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInstantMessageField_get_DisplayText(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInstantMessageField_get_LaunchUri(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LaunchUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInstantMessageField_get_Service(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Service());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInstantMessageField_get_UserName(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactInstantMessageField(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactInstantMessageField>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactInstantMessageField[] = {
        { "_from", (PyCFunction)_from_ContactInstantMessageField, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactInstantMessageField[] = {
        { const_cast<char*>("category"), (getter)ContactInstantMessageField_get_Category, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)ContactInstantMessageField_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)ContactInstantMessageField_get_Type, nullptr, nullptr, nullptr },
        { const_cast<char*>("value"), (getter)ContactInstantMessageField_get_Value, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_text"), (getter)ContactInstantMessageField_get_DisplayText, nullptr, nullptr, nullptr },
        { const_cast<char*>("launch_uri"), (getter)ContactInstantMessageField_get_LaunchUri, nullptr, nullptr, nullptr },
        { const_cast<char*>("service"), (getter)ContactInstantMessageField_get_Service, nullptr, nullptr, nullptr },
        { const_cast<char*>("user_name"), (getter)ContactInstantMessageField_get_UserName, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactInstantMessageField[] = 
    {
        { Py_tp_new, _new_ContactInstantMessageField },
        { Py_tp_dealloc, _dealloc_ContactInstantMessageField },
        { Py_tp_methods, _methods_ContactInstantMessageField },
        { Py_tp_getset, _getset_ContactInstantMessageField },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactInstantMessageField =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactInstantMessageField",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactInstantMessageField
    };

    // ----- ContactJobInfo class --------------------
    constexpr const char* const _type_name_ContactJobInfo = "ContactJobInfo";

    static PyObject* _new_ContactJobInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactJobInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactJobInfo(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactJobInfo_get_Title(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_Title(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactJobInfo_get_Office(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Office());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_Office(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Office(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactJobInfo_get_Manager(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Manager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_Manager(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Manager(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactJobInfo_get_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactJobInfo_get_Department(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Department());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_Department(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Department(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactJobInfo_get_CompanyYomiName(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CompanyYomiName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_CompanyYomiName(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CompanyYomiName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactJobInfo_get_CompanyName(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CompanyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_CompanyName(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CompanyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactJobInfo_get_CompanyAddress(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CompanyAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_CompanyAddress(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CompanyAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactJobInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactJobInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactJobInfo[] = {
        { "_from", (PyCFunction)_from_ContactJobInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactJobInfo[] = {
        { const_cast<char*>("title"), (getter)ContactJobInfo_get_Title, (setter)ContactJobInfo_put_Title, nullptr, nullptr },
        { const_cast<char*>("office"), (getter)ContactJobInfo_get_Office, (setter)ContactJobInfo_put_Office, nullptr, nullptr },
        { const_cast<char*>("manager"), (getter)ContactJobInfo_get_Manager, (setter)ContactJobInfo_put_Manager, nullptr, nullptr },
        { const_cast<char*>("description"), (getter)ContactJobInfo_get_Description, (setter)ContactJobInfo_put_Description, nullptr, nullptr },
        { const_cast<char*>("department"), (getter)ContactJobInfo_get_Department, (setter)ContactJobInfo_put_Department, nullptr, nullptr },
        { const_cast<char*>("company_yomi_name"), (getter)ContactJobInfo_get_CompanyYomiName, (setter)ContactJobInfo_put_CompanyYomiName, nullptr, nullptr },
        { const_cast<char*>("company_name"), (getter)ContactJobInfo_get_CompanyName, (setter)ContactJobInfo_put_CompanyName, nullptr, nullptr },
        { const_cast<char*>("company_address"), (getter)ContactJobInfo_get_CompanyAddress, (setter)ContactJobInfo_put_CompanyAddress, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactJobInfo[] = 
    {
        { Py_tp_new, _new_ContactJobInfo },
        { Py_tp_dealloc, _dealloc_ContactJobInfo },
        { Py_tp_methods, _methods_ContactJobInfo },
        { Py_tp_getset, _getset_ContactJobInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactJobInfo =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactJobInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactJobInfo
    };

    // ----- ContactLaunchActionVerbs class --------------------
    constexpr const char* const _type_name_ContactLaunchActionVerbs = "ContactLaunchActionVerbs";

    static PyObject* _new_ContactLaunchActionVerbs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactLaunchActionVerbs);
        return nullptr;
    }

    static PyObject* ContactLaunchActionVerbs_get_Call(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactLaunchActionVerbs::Call());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLaunchActionVerbs_get_Map(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactLaunchActionVerbs::Map());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLaunchActionVerbs_get_Message(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactLaunchActionVerbs::Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLaunchActionVerbs_get_Post(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactLaunchActionVerbs::Post());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLaunchActionVerbs_get_VideoCall(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactLaunchActionVerbs::VideoCall());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactLaunchActionVerbs[] = {
        { "get_call", (PyCFunction)ContactLaunchActionVerbs_get_Call, METH_NOARGS | METH_STATIC, nullptr },
        { "get_map", (PyCFunction)ContactLaunchActionVerbs_get_Map, METH_NOARGS | METH_STATIC, nullptr },
        { "get_message", (PyCFunction)ContactLaunchActionVerbs_get_Message, METH_NOARGS | METH_STATIC, nullptr },
        { "get_post", (PyCFunction)ContactLaunchActionVerbs_get_Post, METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_call", (PyCFunction)ContactLaunchActionVerbs_get_VideoCall, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactLaunchActionVerbs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactLaunchActionVerbs[] = 
    {
        { Py_tp_new, _new_ContactLaunchActionVerbs },
        { Py_tp_methods, _methods_ContactLaunchActionVerbs },
        { Py_tp_getset, _getset_ContactLaunchActionVerbs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactLaunchActionVerbs =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactLaunchActionVerbs",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactLaunchActionVerbs
    };

    // ----- ContactList class --------------------
    constexpr const char* const _type_name_ContactList = "ContactList";

    static PyObject* _new_ContactList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactList);
        return nullptr;
    }

    static void _dealloc_ContactList(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactList_DeleteAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_DeleteContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.DeleteContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_GetChangeTracker(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetChangeTracker(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_GetContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_GetContactFromRemoteIdAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetContactFromRemoteIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_GetContactReader(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetContactReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions>(args, 0);

                return py::convert(self->obj.GetContactReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_GetMeContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetMeContactAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_RegisterSyncManagerAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RegisterSyncManagerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_SaveAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.SaveAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_SaveContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.SaveContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_get_SupportsServerSearch(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportsServerSearch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactList_put_SupportsServerSearch(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SupportsServerSearch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactList_get_IsHidden(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHidden());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactList_put_IsHidden(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsHidden(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactList_get_OtherAppWriteAccess(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OtherAppWriteAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactList_put_OtherAppWriteAccess(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactListOtherAppWriteAccess>(arg);

            self->obj.OtherAppWriteAccess(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactList_get_DisplayName(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactList_put_DisplayName(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactList_get_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OtherAppReadAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactList_put_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactListOtherAppReadAccess>(arg);

            self->obj.OtherAppReadAccess(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactList_get_ChangeTracker(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeTracker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_get_SourceDisplayName(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_get_Id(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_get_SyncManager(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SyncManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_get_UserDataAccountId(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserDataAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_get_SyncConstraints(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SyncConstraints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_get_LimitedWriteOperations(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LimitedWriteOperations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_add_ContactChanged(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::ContactList, winrt::Windows::ApplicationModel::Contacts::ContactChangedEventArgs>>(arg);

            return py::convert(self->obj.ContactChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_remove_ContactChanged(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ContactChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactList[] = {
        { "delete_async", (PyCFunction)ContactList_DeleteAsync, METH_VARARGS, nullptr },
        { "delete_contact_async", (PyCFunction)ContactList_DeleteContactAsync, METH_VARARGS, nullptr },
        { "get_change_tracker", (PyCFunction)ContactList_GetChangeTracker, METH_VARARGS, nullptr },
        { "get_contact_async", (PyCFunction)ContactList_GetContactAsync, METH_VARARGS, nullptr },
        { "get_contact_from_remote_id_async", (PyCFunction)ContactList_GetContactFromRemoteIdAsync, METH_VARARGS, nullptr },
        { "get_contact_reader", (PyCFunction)ContactList_GetContactReader, METH_VARARGS, nullptr },
        { "get_me_contact_async", (PyCFunction)ContactList_GetMeContactAsync, METH_VARARGS, nullptr },
        { "register_sync_manager_async", (PyCFunction)ContactList_RegisterSyncManagerAsync, METH_VARARGS, nullptr },
        { "save_async", (PyCFunction)ContactList_SaveAsync, METH_VARARGS, nullptr },
        { "save_contact_async", (PyCFunction)ContactList_SaveContactAsync, METH_VARARGS, nullptr },
        { "add_contact_changed", (PyCFunction)ContactList_add_ContactChanged, METH_O, nullptr },
        { "remove_contact_changed", (PyCFunction)ContactList_remove_ContactChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ContactList, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactList[] = {
        { const_cast<char*>("supports_server_search"), (getter)ContactList_get_SupportsServerSearch, (setter)ContactList_put_SupportsServerSearch, nullptr, nullptr },
        { const_cast<char*>("is_hidden"), (getter)ContactList_get_IsHidden, (setter)ContactList_put_IsHidden, nullptr, nullptr },
        { const_cast<char*>("other_app_write_access"), (getter)ContactList_get_OtherAppWriteAccess, (setter)ContactList_put_OtherAppWriteAccess, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)ContactList_get_DisplayName, (setter)ContactList_put_DisplayName, nullptr, nullptr },
        { const_cast<char*>("other_app_read_access"), (getter)ContactList_get_OtherAppReadAccess, (setter)ContactList_put_OtherAppReadAccess, nullptr, nullptr },
        { const_cast<char*>("change_tracker"), (getter)ContactList_get_ChangeTracker, nullptr, nullptr, nullptr },
        { const_cast<char*>("source_display_name"), (getter)ContactList_get_SourceDisplayName, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)ContactList_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("sync_manager"), (getter)ContactList_get_SyncManager, nullptr, nullptr, nullptr },
        { const_cast<char*>("user_data_account_id"), (getter)ContactList_get_UserDataAccountId, nullptr, nullptr, nullptr },
        { const_cast<char*>("sync_constraints"), (getter)ContactList_get_SyncConstraints, nullptr, nullptr, nullptr },
        { const_cast<char*>("limited_write_operations"), (getter)ContactList_get_LimitedWriteOperations, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactList[] = 
    {
        { Py_tp_new, _new_ContactList },
        { Py_tp_dealloc, _dealloc_ContactList },
        { Py_tp_methods, _methods_ContactList },
        { Py_tp_getset, _getset_ContactList },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactList =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactList",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactList
    };

    // ----- ContactListLimitedWriteOperations class --------------------
    constexpr const char* const _type_name_ContactListLimitedWriteOperations = "ContactListLimitedWriteOperations";

    static PyObject* _new_ContactListLimitedWriteOperations(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactListLimitedWriteOperations);
        return nullptr;
    }

    static void _dealloc_ContactListLimitedWriteOperations(py::wrapper::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactListLimitedWriteOperations_TryCreateOrUpdateContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.TryCreateOrUpdateContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListLimitedWriteOperations_TryDeleteContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryDeleteContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ContactListLimitedWriteOperations(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListLimitedWriteOperations[] = {
        { "try_create_or_update_contact_async", (PyCFunction)ContactListLimitedWriteOperations_TryCreateOrUpdateContactAsync, METH_VARARGS, nullptr },
        { "try_delete_contact_async", (PyCFunction)ContactListLimitedWriteOperations_TryDeleteContactAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ContactListLimitedWriteOperations, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactListLimitedWriteOperations[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactListLimitedWriteOperations[] = 
    {
        { Py_tp_new, _new_ContactListLimitedWriteOperations },
        { Py_tp_dealloc, _dealloc_ContactListLimitedWriteOperations },
        { Py_tp_methods, _methods_ContactListLimitedWriteOperations },
        { Py_tp_getset, _getset_ContactListLimitedWriteOperations },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactListLimitedWriteOperations =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactListLimitedWriteOperations",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListLimitedWriteOperations
    };

    // ----- ContactListSyncConstraints class --------------------
    constexpr const char* const _type_name_ContactListSyncConstraints = "ContactListSyncConstraints";

    static PyObject* _new_ContactListSyncConstraints(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactListSyncConstraints);
        return nullptr;
    }

    static void _dealloc_ContactListSyncConstraints(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactListSyncConstraints_get_CanSyncDescriptions(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanSyncDescriptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_CanSyncDescriptions(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanSyncDescriptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxCompanyPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxCompanyPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxCompanyPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxCompanyPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxChildRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxChildRelationships());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxChildRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxChildRelationships(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxBusinessFaxPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxBusinessFaxPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxBusinessFaxPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxBusinessFaxPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxBirthdayDates(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxBirthdayDates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxBirthdayDates(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxBirthdayDates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxAssistantPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxAssistantPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxAssistantPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxAssistantPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxOtherAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxOtherAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxOtherAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxOtherAddresses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxAnniversaryDates(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxAnniversaryDates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxAnniversaryDates(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxAnniversaryDates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxHomeAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxHomeAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxHomeAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxHomeAddresses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxOtherDates(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxOtherDates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxOtherDates(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxOtherDates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxMobilePhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxMobilePhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxMobilePhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxMobilePhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxJobInfo(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxJobInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxJobInfo(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxJobInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxHomePhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxHomePhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxHomePhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxHomePhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxHomeFaxPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxHomeFaxPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxHomeFaxPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxHomeFaxPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxOtherEmailAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxOtherEmailAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxOtherEmailAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxOtherEmailAddresses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxPersonalEmailAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPersonalEmailAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxPersonalEmailAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxPersonalEmailAddresses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxPartnerRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPartnerRelationships());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxPartnerRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxPartnerRelationships(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxParentRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxParentRelationships());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxParentRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxParentRelationships(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxPagerPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPagerPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxPagerPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxPagerPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxOtherRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxOtherRelationships());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxOtherRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxOtherRelationships(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxOtherPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxOtherPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxOtherPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxOtherPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxRadioPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxRadioPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxRadioPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxRadioPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxWorkPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxWorkPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxWorkPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxWorkPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxWorkEmailAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxWorkEmailAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxWorkEmailAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxWorkEmailAddresses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxWorkAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxWorkAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxWorkAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxWorkAddresses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxWebsites(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxWebsites());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxWebsites(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxWebsites(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxSpouseRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxSpouseRelationships());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxSpouseRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxSpouseRelationships(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxSiblingRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxSiblingRelationships());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxSiblingRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxSiblingRelationships(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactListSyncConstraints(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactListSyncConstraints>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListSyncConstraints[] = {
        { "_from", (PyCFunction)_from_ContactListSyncConstraints, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactListSyncConstraints[] = {
        { const_cast<char*>("can_sync_descriptions"), (getter)ContactListSyncConstraints_get_CanSyncDescriptions, (setter)ContactListSyncConstraints_put_CanSyncDescriptions, nullptr, nullptr },
        { const_cast<char*>("max_company_phone_numbers"), (getter)ContactListSyncConstraints_get_MaxCompanyPhoneNumbers, (setter)ContactListSyncConstraints_put_MaxCompanyPhoneNumbers, nullptr, nullptr },
        { const_cast<char*>("max_child_relationships"), (getter)ContactListSyncConstraints_get_MaxChildRelationships, (setter)ContactListSyncConstraints_put_MaxChildRelationships, nullptr, nullptr },
        { const_cast<char*>("max_business_fax_phone_numbers"), (getter)ContactListSyncConstraints_get_MaxBusinessFaxPhoneNumbers, (setter)ContactListSyncConstraints_put_MaxBusinessFaxPhoneNumbers, nullptr, nullptr },
        { const_cast<char*>("max_birthday_dates"), (getter)ContactListSyncConstraints_get_MaxBirthdayDates, (setter)ContactListSyncConstraints_put_MaxBirthdayDates, nullptr, nullptr },
        { const_cast<char*>("max_assistant_phone_numbers"), (getter)ContactListSyncConstraints_get_MaxAssistantPhoneNumbers, (setter)ContactListSyncConstraints_put_MaxAssistantPhoneNumbers, nullptr, nullptr },
        { const_cast<char*>("max_other_addresses"), (getter)ContactListSyncConstraints_get_MaxOtherAddresses, (setter)ContactListSyncConstraints_put_MaxOtherAddresses, nullptr, nullptr },
        { const_cast<char*>("max_anniversary_dates"), (getter)ContactListSyncConstraints_get_MaxAnniversaryDates, (setter)ContactListSyncConstraints_put_MaxAnniversaryDates, nullptr, nullptr },
        { const_cast<char*>("max_home_addresses"), (getter)ContactListSyncConstraints_get_MaxHomeAddresses, (setter)ContactListSyncConstraints_put_MaxHomeAddresses, nullptr, nullptr },
        { const_cast<char*>("max_other_dates"), (getter)ContactListSyncConstraints_get_MaxOtherDates, (setter)ContactListSyncConstraints_put_MaxOtherDates, nullptr, nullptr },
        { const_cast<char*>("max_mobile_phone_numbers"), (getter)ContactListSyncConstraints_get_MaxMobilePhoneNumbers, (setter)ContactListSyncConstraints_put_MaxMobilePhoneNumbers, nullptr, nullptr },
        { const_cast<char*>("max_job_info"), (getter)ContactListSyncConstraints_get_MaxJobInfo, (setter)ContactListSyncConstraints_put_MaxJobInfo, nullptr, nullptr },
        { const_cast<char*>("max_home_phone_numbers"), (getter)ContactListSyncConstraints_get_MaxHomePhoneNumbers, (setter)ContactListSyncConstraints_put_MaxHomePhoneNumbers, nullptr, nullptr },
        { const_cast<char*>("max_home_fax_phone_numbers"), (getter)ContactListSyncConstraints_get_MaxHomeFaxPhoneNumbers, (setter)ContactListSyncConstraints_put_MaxHomeFaxPhoneNumbers, nullptr, nullptr },
        { const_cast<char*>("max_other_email_addresses"), (getter)ContactListSyncConstraints_get_MaxOtherEmailAddresses, (setter)ContactListSyncConstraints_put_MaxOtherEmailAddresses, nullptr, nullptr },
        { const_cast<char*>("max_personal_email_addresses"), (getter)ContactListSyncConstraints_get_MaxPersonalEmailAddresses, (setter)ContactListSyncConstraints_put_MaxPersonalEmailAddresses, nullptr, nullptr },
        { const_cast<char*>("max_partner_relationships"), (getter)ContactListSyncConstraints_get_MaxPartnerRelationships, (setter)ContactListSyncConstraints_put_MaxPartnerRelationships, nullptr, nullptr },
        { const_cast<char*>("max_parent_relationships"), (getter)ContactListSyncConstraints_get_MaxParentRelationships, (setter)ContactListSyncConstraints_put_MaxParentRelationships, nullptr, nullptr },
        { const_cast<char*>("max_pager_phone_numbers"), (getter)ContactListSyncConstraints_get_MaxPagerPhoneNumbers, (setter)ContactListSyncConstraints_put_MaxPagerPhoneNumbers, nullptr, nullptr },
        { const_cast<char*>("max_other_relationships"), (getter)ContactListSyncConstraints_get_MaxOtherRelationships, (setter)ContactListSyncConstraints_put_MaxOtherRelationships, nullptr, nullptr },
        { const_cast<char*>("max_other_phone_numbers"), (getter)ContactListSyncConstraints_get_MaxOtherPhoneNumbers, (setter)ContactListSyncConstraints_put_MaxOtherPhoneNumbers, nullptr, nullptr },
        { const_cast<char*>("max_radio_phone_numbers"), (getter)ContactListSyncConstraints_get_MaxRadioPhoneNumbers, (setter)ContactListSyncConstraints_put_MaxRadioPhoneNumbers, nullptr, nullptr },
        { const_cast<char*>("max_work_phone_numbers"), (getter)ContactListSyncConstraints_get_MaxWorkPhoneNumbers, (setter)ContactListSyncConstraints_put_MaxWorkPhoneNumbers, nullptr, nullptr },
        { const_cast<char*>("max_work_email_addresses"), (getter)ContactListSyncConstraints_get_MaxWorkEmailAddresses, (setter)ContactListSyncConstraints_put_MaxWorkEmailAddresses, nullptr, nullptr },
        { const_cast<char*>("max_work_addresses"), (getter)ContactListSyncConstraints_get_MaxWorkAddresses, (setter)ContactListSyncConstraints_put_MaxWorkAddresses, nullptr, nullptr },
        { const_cast<char*>("max_websites"), (getter)ContactListSyncConstraints_get_MaxWebsites, (setter)ContactListSyncConstraints_put_MaxWebsites, nullptr, nullptr },
        { const_cast<char*>("max_spouse_relationships"), (getter)ContactListSyncConstraints_get_MaxSpouseRelationships, (setter)ContactListSyncConstraints_put_MaxSpouseRelationships, nullptr, nullptr },
        { const_cast<char*>("max_sibling_relationships"), (getter)ContactListSyncConstraints_get_MaxSiblingRelationships, (setter)ContactListSyncConstraints_put_MaxSiblingRelationships, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactListSyncConstraints[] = 
    {
        { Py_tp_new, _new_ContactListSyncConstraints },
        { Py_tp_dealloc, _dealloc_ContactListSyncConstraints },
        { Py_tp_methods, _methods_ContactListSyncConstraints },
        { Py_tp_getset, _getset_ContactListSyncConstraints },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactListSyncConstraints =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactListSyncConstraints",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListSyncConstraints
    };

    // ----- ContactListSyncManager class --------------------
    constexpr const char* const _type_name_ContactListSyncManager = "ContactListSyncManager";

    static PyObject* _new_ContactListSyncManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactListSyncManager);
        return nullptr;
    }

    static void _dealloc_ContactListSyncManager(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactListSyncManager_SyncAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.SyncAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListSyncManager_get_Status(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncManager_put_Status(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactListSyncStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncManager_get_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastSuccessfulSyncTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncManager_put_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.LastSuccessfulSyncTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncManager_get_LastAttemptedSyncTime(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastAttemptedSyncTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncManager_put_LastAttemptedSyncTime(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.LastAttemptedSyncTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncManager_add_SyncStatusChanged(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::ContactListSyncManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SyncStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactListSyncManager_remove_SyncStatusChanged(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SyncStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactListSyncManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactListSyncManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListSyncManager[] = {
        { "sync_async", (PyCFunction)ContactListSyncManager_SyncAsync, METH_VARARGS, nullptr },
        { "add_sync_status_changed", (PyCFunction)ContactListSyncManager_add_SyncStatusChanged, METH_O, nullptr },
        { "remove_sync_status_changed", (PyCFunction)ContactListSyncManager_remove_SyncStatusChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ContactListSyncManager, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactListSyncManager[] = {
        { const_cast<char*>("status"), (getter)ContactListSyncManager_get_Status, (setter)ContactListSyncManager_put_Status, nullptr, nullptr },
        { const_cast<char*>("last_successful_sync_time"), (getter)ContactListSyncManager_get_LastSuccessfulSyncTime, (setter)ContactListSyncManager_put_LastSuccessfulSyncTime, nullptr, nullptr },
        { const_cast<char*>("last_attempted_sync_time"), (getter)ContactListSyncManager_get_LastAttemptedSyncTime, (setter)ContactListSyncManager_put_LastAttemptedSyncTime, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactListSyncManager[] = 
    {
        { Py_tp_new, _new_ContactListSyncManager },
        { Py_tp_dealloc, _dealloc_ContactListSyncManager },
        { Py_tp_methods, _methods_ContactListSyncManager },
        { Py_tp_getset, _getset_ContactListSyncManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactListSyncManager =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactListSyncManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListSyncManager
    };

    // ----- ContactLocationField class --------------------
    constexpr const char* const _type_name_ContactLocationField = "ContactLocationField";

    static PyObject* _new_ContactLocationField(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Contacts::ContactLocationField instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);

                winrt::Windows::ApplicationModel::Contacts::ContactLocationField instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);

                winrt::Windows::ApplicationModel::Contacts::ContactLocationField instance{ param0, param1, param2, param3, param4, param5, param6 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactLocationField(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactLocationField_get_Category(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Category());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_Name(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_Type(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_Value(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_City(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.City());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_Country(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Country());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_PostalCode(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PostalCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_Region(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Region());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_Street(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Street());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_UnstructuredAddress(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UnstructuredAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactLocationField(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactLocationField>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactLocationField[] = {
        { "_from", (PyCFunction)_from_ContactLocationField, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactLocationField[] = {
        { const_cast<char*>("category"), (getter)ContactLocationField_get_Category, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)ContactLocationField_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)ContactLocationField_get_Type, nullptr, nullptr, nullptr },
        { const_cast<char*>("value"), (getter)ContactLocationField_get_Value, nullptr, nullptr, nullptr },
        { const_cast<char*>("city"), (getter)ContactLocationField_get_City, nullptr, nullptr, nullptr },
        { const_cast<char*>("country"), (getter)ContactLocationField_get_Country, nullptr, nullptr, nullptr },
        { const_cast<char*>("postal_code"), (getter)ContactLocationField_get_PostalCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("region"), (getter)ContactLocationField_get_Region, nullptr, nullptr, nullptr },
        { const_cast<char*>("street"), (getter)ContactLocationField_get_Street, nullptr, nullptr, nullptr },
        { const_cast<char*>("unstructured_address"), (getter)ContactLocationField_get_UnstructuredAddress, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactLocationField[] = 
    {
        { Py_tp_new, _new_ContactLocationField },
        { Py_tp_dealloc, _dealloc_ContactLocationField },
        { Py_tp_methods, _methods_ContactLocationField },
        { Py_tp_getset, _getset_ContactLocationField },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactLocationField =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactLocationField",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactLocationField
    };

    // ----- ContactManager class --------------------
    constexpr const char* const _type_name_ContactManager = "ContactManager";

    static PyObject* _new_ContactManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactManager);
        return nullptr;
    }

    static PyObject* ContactManager_ConvertContactToVCardAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::ConvertContactToVCardAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::ConvertContactToVCardAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_ConvertVCardToContactAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::ConvertVCardToContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_IsShowContactCardSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::IsShowContactCardSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_IsShowDelayLoadedContactCardSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::IsShowDelayLoadedContactCardSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_IsShowFullContactCardSupportedAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::IsShowFullContactCardSupportedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_RequestAnnotationStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationStoreAccessType>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::RequestAnnotationStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::RequestStoreAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactStoreAccessType>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_ShowContactCard(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                winrt::Windows::ApplicationModel::Contacts::ContactManager::ShowContactCard(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);

                winrt::Windows::ApplicationModel::Contacts::ContactManager::ShowContactCard(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactCardOptions>(args, 3);

                winrt::Windows::ApplicationModel::Contacts::ContactManager::ShowContactCard(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_ShowDelayLoadedContactCard(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::ShowDelayLoadedContactCard(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactCardOptions>(args, 3);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::ShowDelayLoadedContactCard(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_ShowFullContactCard(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::FullContactCardOptions>(args, 1);

                winrt::Windows::ApplicationModel::Contacts::ContactManager::ShowFullContactCard(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_get_SystemSortOrder(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::SystemSortOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactManager_put_SystemSortOrder(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactNameOrder>(arg);

            winrt::Windows::ApplicationModel::Contacts::ContactManager::SystemSortOrder(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactManager_get_SystemDisplayNameOrder(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::SystemDisplayNameOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactManager_put_SystemDisplayNameOrder(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactNameOrder>(arg);

            winrt::Windows::ApplicationModel::Contacts::ContactManager::SystemDisplayNameOrder(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactManager_get_IncludeMiddleNameInSystemDisplayAndSort(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::IncludeMiddleNameInSystemDisplayAndSort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactManager_put_IncludeMiddleNameInSystemDisplayAndSort(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        try
        {
            auto param0 = py::convert_to<bool>(arg);

            winrt::Windows::ApplicationModel::Contacts::ContactManager::IncludeMiddleNameInSystemDisplayAndSort(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactManager[] = {
        { "convert_contact_to_v_card_async", (PyCFunction)ContactManager_ConvertContactToVCardAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "convert_v_card_to_contact_async", (PyCFunction)ContactManager_ConvertVCardToContactAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", (PyCFunction)ContactManager_GetForUser, METH_VARARGS | METH_STATIC, nullptr },
        { "is_show_contact_card_supported", (PyCFunction)ContactManager_IsShowContactCardSupported, METH_VARARGS | METH_STATIC, nullptr },
        { "is_show_delay_loaded_contact_card_supported", (PyCFunction)ContactManager_IsShowDelayLoadedContactCardSupported, METH_VARARGS | METH_STATIC, nullptr },
        { "is_show_full_contact_card_supported_async", (PyCFunction)ContactManager_IsShowFullContactCardSupportedAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "request_annotation_store_async", (PyCFunction)ContactManager_RequestAnnotationStoreAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "request_store_async", (PyCFunction)ContactManager_RequestStoreAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "show_contact_card", (PyCFunction)ContactManager_ShowContactCard, METH_VARARGS | METH_STATIC, nullptr },
        { "show_delay_loaded_contact_card", (PyCFunction)ContactManager_ShowDelayLoadedContactCard, METH_VARARGS | METH_STATIC, nullptr },
        { "show_full_contact_card", (PyCFunction)ContactManager_ShowFullContactCard, METH_VARARGS | METH_STATIC, nullptr },
        { "get_system_sort_order", (PyCFunction)ContactManager_get_SystemSortOrder, METH_NOARGS | METH_STATIC, nullptr },
        { "put_system_sort_order", (PyCFunction)ContactManager_put_SystemSortOrder, METH_O | METH_STATIC, nullptr },
        { "get_system_display_name_order", (PyCFunction)ContactManager_get_SystemDisplayNameOrder, METH_NOARGS | METH_STATIC, nullptr },
        { "put_system_display_name_order", (PyCFunction)ContactManager_put_SystemDisplayNameOrder, METH_O | METH_STATIC, nullptr },
        { "get_include_middle_name_in_system_display_and_sort", (PyCFunction)ContactManager_get_IncludeMiddleNameInSystemDisplayAndSort, METH_NOARGS | METH_STATIC, nullptr },
        { "put_include_middle_name_in_system_display_and_sort", (PyCFunction)ContactManager_put_IncludeMiddleNameInSystemDisplayAndSort, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactManager[] = 
    {
        { Py_tp_new, _new_ContactManager },
        { Py_tp_methods, _methods_ContactManager },
        { Py_tp_getset, _getset_ContactManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactManager =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactManager
    };

    // ----- ContactManagerForUser class --------------------
    constexpr const char* const _type_name_ContactManagerForUser = "ContactManagerForUser";

    static PyObject* _new_ContactManagerForUser(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactManagerForUser);
        return nullptr;
    }

    static void _dealloc_ContactManagerForUser(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactManagerForUser_ConvertContactToVCardAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.ConvertContactToVCardAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.ConvertContactToVCardAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManagerForUser_ConvertVCardToContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                return py::convert(self->obj.ConvertVCardToContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManagerForUser_RequestAnnotationStoreAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationStoreAccessType>(args, 0);

                return py::convert(self->obj.RequestAnnotationStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManagerForUser_RequestStoreAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactStoreAccessType>(args, 0);

                return py::convert(self->obj.RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManagerForUser_ShowFullContactCard(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::FullContactCardOptions>(args, 1);

                self->obj.ShowFullContactCard(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManagerForUser_get_SystemSortOrder(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemSortOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactManagerForUser_put_SystemSortOrder(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactNameOrder>(arg);

            self->obj.SystemSortOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactManagerForUser_get_SystemDisplayNameOrder(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemDisplayNameOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactManagerForUser_put_SystemDisplayNameOrder(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactNameOrder>(arg);

            self->obj.SystemDisplayNameOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactManagerForUser_get_User(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactManagerForUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactManagerForUser[] = {
        { "convert_contact_to_v_card_async", (PyCFunction)ContactManagerForUser_ConvertContactToVCardAsync, METH_VARARGS, nullptr },
        { "convert_v_card_to_contact_async", (PyCFunction)ContactManagerForUser_ConvertVCardToContactAsync, METH_VARARGS, nullptr },
        { "request_annotation_store_async", (PyCFunction)ContactManagerForUser_RequestAnnotationStoreAsync, METH_VARARGS, nullptr },
        { "request_store_async", (PyCFunction)ContactManagerForUser_RequestStoreAsync, METH_VARARGS, nullptr },
        { "show_full_contact_card", (PyCFunction)ContactManagerForUser_ShowFullContactCard, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ContactManagerForUser, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactManagerForUser[] = {
        { const_cast<char*>("system_sort_order"), (getter)ContactManagerForUser_get_SystemSortOrder, (setter)ContactManagerForUser_put_SystemSortOrder, nullptr, nullptr },
        { const_cast<char*>("system_display_name_order"), (getter)ContactManagerForUser_get_SystemDisplayNameOrder, (setter)ContactManagerForUser_put_SystemDisplayNameOrder, nullptr, nullptr },
        { const_cast<char*>("user"), (getter)ContactManagerForUser_get_User, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactManagerForUser[] = 
    {
        { Py_tp_new, _new_ContactManagerForUser },
        { Py_tp_dealloc, _dealloc_ContactManagerForUser },
        { Py_tp_methods, _methods_ContactManagerForUser },
        { Py_tp_getset, _getset_ContactManagerForUser },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactManagerForUser =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactManagerForUser",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactManagerForUser
    };

    // ----- ContactMatchReason class --------------------
    constexpr const char* const _type_name_ContactMatchReason = "ContactMatchReason";

    static PyObject* _new_ContactMatchReason(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactMatchReason);
        return nullptr;
    }

    static void _dealloc_ContactMatchReason(py::wrapper::Windows::ApplicationModel::Contacts::ContactMatchReason* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactMatchReason_get_Field(py::wrapper::Windows::ApplicationModel::Contacts::ContactMatchReason* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Field());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMatchReason_get_Segments(py::wrapper::Windows::ApplicationModel::Contacts::ContactMatchReason* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Segments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMatchReason_get_Text(py::wrapper::Windows::ApplicationModel::Contacts::ContactMatchReason* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactMatchReason(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactMatchReason>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactMatchReason[] = {
        { "_from", (PyCFunction)_from_ContactMatchReason, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactMatchReason[] = {
        { const_cast<char*>("field"), (getter)ContactMatchReason_get_Field, nullptr, nullptr, nullptr },
        { const_cast<char*>("segments"), (getter)ContactMatchReason_get_Segments, nullptr, nullptr, nullptr },
        { const_cast<char*>("text"), (getter)ContactMatchReason_get_Text, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactMatchReason[] = 
    {
        { Py_tp_new, _new_ContactMatchReason },
        { Py_tp_dealloc, _dealloc_ContactMatchReason },
        { Py_tp_methods, _methods_ContactMatchReason },
        { Py_tp_getset, _getset_ContactMatchReason },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactMatchReason =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactMatchReason",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactMatchReason),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactMatchReason
    };

    // ----- ContactPanel class --------------------
    constexpr const char* const _type_name_ContactPanel = "ContactPanel";

    static PyObject* _new_ContactPanel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactPanel);
        return nullptr;
    }

    static void _dealloc_ContactPanel(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactPanel_ClosePanel(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ClosePanel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactPanel_get_HeaderColor(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HeaderColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactPanel_put_HeaderColor(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.HeaderColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactPanel_add_Closing(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::ContactPanel, winrt::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs>>(arg);

            return py::convert(self->obj.Closing(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanel_remove_Closing(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closing(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanel_add_LaunchFullAppRequested(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::ContactPanel, winrt::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs>>(arg);

            return py::convert(self->obj.LaunchFullAppRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanel_remove_LaunchFullAppRequested(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LaunchFullAppRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPanel[] = {
        { "close_panel", (PyCFunction)ContactPanel_ClosePanel, METH_VARARGS, nullptr },
        { "add_closing", (PyCFunction)ContactPanel_add_Closing, METH_O, nullptr },
        { "remove_closing", (PyCFunction)ContactPanel_remove_Closing, METH_O, nullptr },
        { "add_launch_full_app_requested", (PyCFunction)ContactPanel_add_LaunchFullAppRequested, METH_O, nullptr },
        { "remove_launch_full_app_requested", (PyCFunction)ContactPanel_remove_LaunchFullAppRequested, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ContactPanel, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactPanel[] = {
        { const_cast<char*>("header_color"), (getter)ContactPanel_get_HeaderColor, (setter)ContactPanel_put_HeaderColor, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactPanel[] = 
    {
        { Py_tp_new, _new_ContactPanel },
        { Py_tp_dealloc, _dealloc_ContactPanel },
        { Py_tp_methods, _methods_ContactPanel },
        { Py_tp_getset, _getset_ContactPanel },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactPanel =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactPanel",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPanel
    };

    // ----- ContactPanelClosingEventArgs class --------------------
    constexpr const char* const _type_name_ContactPanelClosingEventArgs = "ContactPanelClosingEventArgs";

    static PyObject* _new_ContactPanelClosingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactPanelClosingEventArgs);
        return nullptr;
    }

    static void _dealloc_ContactPanelClosingEventArgs(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactPanelClosingEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ContactPanelClosingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPanelClosingEventArgs[] = {
        { "get_deferral", (PyCFunction)ContactPanelClosingEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ContactPanelClosingEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactPanelClosingEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactPanelClosingEventArgs[] = 
    {
        { Py_tp_new, _new_ContactPanelClosingEventArgs },
        { Py_tp_dealloc, _dealloc_ContactPanelClosingEventArgs },
        { Py_tp_methods, _methods_ContactPanelClosingEventArgs },
        { Py_tp_getset, _getset_ContactPanelClosingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactPanelClosingEventArgs =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactPanelClosingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPanelClosingEventArgs
    };

    // ----- ContactPanelLaunchFullAppRequestedEventArgs class --------------------
    constexpr const char* const _type_name_ContactPanelLaunchFullAppRequestedEventArgs = "ContactPanelLaunchFullAppRequestedEventArgs";

    static PyObject* _new_ContactPanelLaunchFullAppRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactPanelLaunchFullAppRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_ContactPanelLaunchFullAppRequestedEventArgs(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactPanelLaunchFullAppRequestedEventArgs_get_Handled(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactPanelLaunchFullAppRequestedEventArgs_put_Handled(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactPanelLaunchFullAppRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPanelLaunchFullAppRequestedEventArgs[] = {
        { "_from", (PyCFunction)_from_ContactPanelLaunchFullAppRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactPanelLaunchFullAppRequestedEventArgs[] = {
        { const_cast<char*>("handled"), (getter)ContactPanelLaunchFullAppRequestedEventArgs_get_Handled, (setter)ContactPanelLaunchFullAppRequestedEventArgs_put_Handled, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactPanelLaunchFullAppRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_ContactPanelLaunchFullAppRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_ContactPanelLaunchFullAppRequestedEventArgs },
        { Py_tp_methods, _methods_ContactPanelLaunchFullAppRequestedEventArgs },
        { Py_tp_getset, _getset_ContactPanelLaunchFullAppRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactPanelLaunchFullAppRequestedEventArgs =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactPanelLaunchFullAppRequestedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPanelLaunchFullAppRequestedEventArgs
    };

    // ----- ContactPhone class --------------------
    constexpr const char* const _type_name_ContactPhone = "ContactPhone";

    static PyObject* _new_ContactPhone(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactPhone instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactPhone(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactPhone_get_Number(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Number());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactPhone_put_Number(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Number(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactPhone_get_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactPhone_put_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactPhoneKind>(arg);

            self->obj.Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactPhone_get_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactPhone_put_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactPhone(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactPhone>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPhone[] = {
        { "_from", (PyCFunction)_from_ContactPhone, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactPhone[] = {
        { const_cast<char*>("number"), (getter)ContactPhone_get_Number, (setter)ContactPhone_put_Number, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)ContactPhone_get_Kind, (setter)ContactPhone_put_Kind, nullptr, nullptr },
        { const_cast<char*>("description"), (getter)ContactPhone_get_Description, (setter)ContactPhone_put_Description, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactPhone[] = 
    {
        { Py_tp_new, _new_ContactPhone },
        { Py_tp_dealloc, _dealloc_ContactPhone },
        { Py_tp_methods, _methods_ContactPhone },
        { Py_tp_getset, _getset_ContactPhone },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactPhone =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactPhone",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPhone
    };

    // ----- ContactPicker class --------------------
    constexpr const char* const _type_name_ContactPicker = "ContactPicker";

    static PyObject* _new_ContactPicker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactPicker instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactPicker(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactPicker_CreateForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactPicker::CreateForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactPicker_IsSupportedAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactPicker::IsSupportedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactPicker_PickContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.PickContactAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactPicker_PickContactsAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.PickContactsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactPicker_PickMultipleContactsAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.PickMultipleContactsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactPicker_PickSingleContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.PickSingleContactAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactPicker_get_SelectionMode(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SelectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactPicker_put_SelectionMode(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactSelectionMode>(arg);

            self->obj.SelectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactPicker_get_CommitButtonText(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CommitButtonText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactPicker_put_CommitButtonText(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CommitButtonText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactPicker_get_DesiredFields(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredFields());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPicker_get_DesiredFieldsWithContactFieldType(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredFieldsWithContactFieldType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPicker_get_User(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactPicker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactPicker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPicker[] = {
        { "create_for_user", (PyCFunction)ContactPicker_CreateForUser, METH_VARARGS | METH_STATIC, nullptr },
        { "is_supported_async", (PyCFunction)ContactPicker_IsSupportedAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "pick_contact_async", (PyCFunction)ContactPicker_PickContactAsync, METH_VARARGS, nullptr },
        { "pick_contacts_async", (PyCFunction)ContactPicker_PickContactsAsync, METH_VARARGS, nullptr },
        { "pick_multiple_contacts_async", (PyCFunction)ContactPicker_PickMultipleContactsAsync, METH_VARARGS, nullptr },
        { "pick_single_contact_async", (PyCFunction)ContactPicker_PickSingleContactAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ContactPicker, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactPicker[] = {
        { const_cast<char*>("selection_mode"), (getter)ContactPicker_get_SelectionMode, (setter)ContactPicker_put_SelectionMode, nullptr, nullptr },
        { const_cast<char*>("commit_button_text"), (getter)ContactPicker_get_CommitButtonText, (setter)ContactPicker_put_CommitButtonText, nullptr, nullptr },
        { const_cast<char*>("desired_fields"), (getter)ContactPicker_get_DesiredFields, nullptr, nullptr, nullptr },
        { const_cast<char*>("desired_fields_with_contact_field_type"), (getter)ContactPicker_get_DesiredFieldsWithContactFieldType, nullptr, nullptr, nullptr },
        { const_cast<char*>("user"), (getter)ContactPicker_get_User, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactPicker[] = 
    {
        { Py_tp_new, _new_ContactPicker },
        { Py_tp_dealloc, _dealloc_ContactPicker },
        { Py_tp_methods, _methods_ContactPicker },
        { Py_tp_getset, _getset_ContactPicker },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactPicker =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactPicker",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPicker
    };

    // ----- ContactQueryOptions class --------------------
    constexpr const char* const _type_name_ContactQueryOptions = "ContactQueryOptions";

    static PyObject* _new_ContactQueryOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactQuerySearchFields>(args, 1);

                winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactQueryOptions(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactQueryOptions_get_IncludeContactsFromHiddenLists(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IncludeContactsFromHiddenLists());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactQueryOptions_put_IncludeContactsFromHiddenLists(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeContactsFromHiddenLists(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactQueryOptions_get_DesiredOperations(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredOperations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactQueryOptions_put_DesiredOperations(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationOperations>(arg);

            self->obj.DesiredOperations(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactQueryOptions_get_DesiredFields(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredFields());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactQueryOptions_put_DesiredFields(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactQueryDesiredFields>(arg);

            self->obj.DesiredFields(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactQueryOptions_get_AnnotationListIds(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AnnotationListIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactQueryOptions_get_ContactListIds(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactListIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactQueryOptions_get_TextSearch(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TextSearch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactQueryOptions[] = {
        { "_from", (PyCFunction)_from_ContactQueryOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactQueryOptions[] = {
        { const_cast<char*>("include_contacts_from_hidden_lists"), (getter)ContactQueryOptions_get_IncludeContactsFromHiddenLists, (setter)ContactQueryOptions_put_IncludeContactsFromHiddenLists, nullptr, nullptr },
        { const_cast<char*>("desired_operations"), (getter)ContactQueryOptions_get_DesiredOperations, (setter)ContactQueryOptions_put_DesiredOperations, nullptr, nullptr },
        { const_cast<char*>("desired_fields"), (getter)ContactQueryOptions_get_DesiredFields, (setter)ContactQueryOptions_put_DesiredFields, nullptr, nullptr },
        { const_cast<char*>("annotation_list_ids"), (getter)ContactQueryOptions_get_AnnotationListIds, nullptr, nullptr, nullptr },
        { const_cast<char*>("contact_list_ids"), (getter)ContactQueryOptions_get_ContactListIds, nullptr, nullptr, nullptr },
        { const_cast<char*>("text_search"), (getter)ContactQueryOptions_get_TextSearch, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactQueryOptions[] = 
    {
        { Py_tp_new, _new_ContactQueryOptions },
        { Py_tp_dealloc, _dealloc_ContactQueryOptions },
        { Py_tp_methods, _methods_ContactQueryOptions },
        { Py_tp_getset, _getset_ContactQueryOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactQueryOptions =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactQueryOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactQueryOptions
    };

    // ----- ContactQueryTextSearch class --------------------
    constexpr const char* const _type_name_ContactQueryTextSearch = "ContactQueryTextSearch";

    static PyObject* _new_ContactQueryTextSearch(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactQueryTextSearch);
        return nullptr;
    }

    static void _dealloc_ContactQueryTextSearch(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactQueryTextSearch_get_Text(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactQueryTextSearch_put_Text(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactQueryTextSearch_get_SearchScope(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SearchScope());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactQueryTextSearch_put_SearchScope(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactQuerySearchScope>(arg);

            self->obj.SearchScope(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactQueryTextSearch_get_Fields(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Fields());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactQueryTextSearch_put_Fields(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactQuerySearchFields>(arg);

            self->obj.Fields(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactQueryTextSearch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactQueryTextSearch>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactQueryTextSearch[] = {
        { "_from", (PyCFunction)_from_ContactQueryTextSearch, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactQueryTextSearch[] = {
        { const_cast<char*>("text"), (getter)ContactQueryTextSearch_get_Text, (setter)ContactQueryTextSearch_put_Text, nullptr, nullptr },
        { const_cast<char*>("search_scope"), (getter)ContactQueryTextSearch_get_SearchScope, (setter)ContactQueryTextSearch_put_SearchScope, nullptr, nullptr },
        { const_cast<char*>("fields"), (getter)ContactQueryTextSearch_get_Fields, (setter)ContactQueryTextSearch_put_Fields, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactQueryTextSearch[] = 
    {
        { Py_tp_new, _new_ContactQueryTextSearch },
        { Py_tp_dealloc, _dealloc_ContactQueryTextSearch },
        { Py_tp_methods, _methods_ContactQueryTextSearch },
        { Py_tp_getset, _getset_ContactQueryTextSearch },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactQueryTextSearch =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactQueryTextSearch",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactQueryTextSearch
    };

    // ----- ContactReader class --------------------
    constexpr const char* const _type_name_ContactReader = "ContactReader";

    static PyObject* _new_ContactReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactReader);
        return nullptr;
    }

    static void _dealloc_ContactReader(py::wrapper::Windows::ApplicationModel::Contacts::ContactReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactReader_GetMatchingPropertiesWithMatchReason(py::wrapper::Windows::ApplicationModel::Contacts::ContactReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.GetMatchingPropertiesWithMatchReason(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ContactReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactReader[] = {
        { "get_matching_properties_with_match_reason", (PyCFunction)ContactReader_GetMatchingPropertiesWithMatchReason, METH_VARARGS, nullptr },
        { "read_batch_async", (PyCFunction)ContactReader_ReadBatchAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ContactReader, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactReader[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactReader[] = 
    {
        { Py_tp_new, _new_ContactReader },
        { Py_tp_dealloc, _dealloc_ContactReader },
        { Py_tp_methods, _methods_ContactReader },
        { Py_tp_getset, _getset_ContactReader },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactReader =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactReader
    };

    // ----- ContactSignificantOther class --------------------
    constexpr const char* const _type_name_ContactSignificantOther = "ContactSignificantOther";

    static PyObject* _new_ContactSignificantOther(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactSignificantOther instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactSignificantOther(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactSignificantOther_get_Name(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactSignificantOther_put_Name(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactSignificantOther_get_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactSignificantOther_put_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactSignificantOther_get_Relationship(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Relationship());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactSignificantOther_put_Relationship(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactRelationship>(arg);

            self->obj.Relationship(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactSignificantOther(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactSignificantOther>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactSignificantOther[] = {
        { "_from", (PyCFunction)_from_ContactSignificantOther, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactSignificantOther[] = {
        { const_cast<char*>("name"), (getter)ContactSignificantOther_get_Name, (setter)ContactSignificantOther_put_Name, nullptr, nullptr },
        { const_cast<char*>("description"), (getter)ContactSignificantOther_get_Description, (setter)ContactSignificantOther_put_Description, nullptr, nullptr },
        { const_cast<char*>("relationship"), (getter)ContactSignificantOther_get_Relationship, (setter)ContactSignificantOther_put_Relationship, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactSignificantOther[] = 
    {
        { Py_tp_new, _new_ContactSignificantOther },
        { Py_tp_dealloc, _dealloc_ContactSignificantOther },
        { Py_tp_methods, _methods_ContactSignificantOther },
        { Py_tp_getset, _getset_ContactSignificantOther },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactSignificantOther =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactSignificantOther",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactSignificantOther
    };

    // ----- ContactStore class --------------------
    constexpr const char* const _type_name_ContactStore = "ContactStore";

    static PyObject* _new_ContactStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactStore);
        return nullptr;
    }

    static void _dealloc_ContactStore(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactStore_CreateContactListAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateContactListAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CreateContactListAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_FindContactListsAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindContactListsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_FindContactsAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindContactsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindContactsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_GetChangeTracker(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetChangeTracker(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_GetContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_GetContactListAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetContactListAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_GetContactReader(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetContactReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions>(args, 0);

                return py::convert(self->obj.GetContactReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_GetMeContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetMeContactAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_get_AggregateContactManager(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AggregateContactManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactStore_get_ChangeTracker(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeTracker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactStore_add_ContactChanged(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::ContactStore, winrt::Windows::ApplicationModel::Contacts::ContactChangedEventArgs>>(arg);

            return py::convert(self->obj.ContactChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactStore_remove_ContactChanged(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ContactChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactStore[] = {
        { "create_contact_list_async", (PyCFunction)ContactStore_CreateContactListAsync, METH_VARARGS, nullptr },
        { "find_contact_lists_async", (PyCFunction)ContactStore_FindContactListsAsync, METH_VARARGS, nullptr },
        { "find_contacts_async", (PyCFunction)ContactStore_FindContactsAsync, METH_VARARGS, nullptr },
        { "get_change_tracker", (PyCFunction)ContactStore_GetChangeTracker, METH_VARARGS, nullptr },
        { "get_contact_async", (PyCFunction)ContactStore_GetContactAsync, METH_VARARGS, nullptr },
        { "get_contact_list_async", (PyCFunction)ContactStore_GetContactListAsync, METH_VARARGS, nullptr },
        { "get_contact_reader", (PyCFunction)ContactStore_GetContactReader, METH_VARARGS, nullptr },
        { "get_me_contact_async", (PyCFunction)ContactStore_GetMeContactAsync, METH_VARARGS, nullptr },
        { "add_contact_changed", (PyCFunction)ContactStore_add_ContactChanged, METH_O, nullptr },
        { "remove_contact_changed", (PyCFunction)ContactStore_remove_ContactChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ContactStore, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactStore[] = {
        { const_cast<char*>("aggregate_contact_manager"), (getter)ContactStore_get_AggregateContactManager, nullptr, nullptr, nullptr },
        { const_cast<char*>("change_tracker"), (getter)ContactStore_get_ChangeTracker, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactStore[] = 
    {
        { Py_tp_new, _new_ContactStore },
        { Py_tp_dealloc, _dealloc_ContactStore },
        { Py_tp_methods, _methods_ContactStore },
        { Py_tp_getset, _getset_ContactStore },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactStore =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactStore
    };

    // ----- ContactStoreNotificationTriggerDetails class --------------------
    constexpr const char* const _type_name_ContactStoreNotificationTriggerDetails = "ContactStoreNotificationTriggerDetails";

    static PyObject* _new_ContactStoreNotificationTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactStoreNotificationTriggerDetails);
        return nullptr;
    }

    static void _dealloc_ContactStoreNotificationTriggerDetails(py::wrapper::Windows::ApplicationModel::Contacts::ContactStoreNotificationTriggerDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ContactStoreNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactStoreNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactStoreNotificationTriggerDetails[] = {
        { "_from", (PyCFunction)_from_ContactStoreNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactStoreNotificationTriggerDetails[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactStoreNotificationTriggerDetails[] = 
    {
        { Py_tp_new, _new_ContactStoreNotificationTriggerDetails },
        { Py_tp_dealloc, _dealloc_ContactStoreNotificationTriggerDetails },
        { Py_tp_methods, _methods_ContactStoreNotificationTriggerDetails },
        { Py_tp_getset, _getset_ContactStoreNotificationTriggerDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactStoreNotificationTriggerDetails =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactStoreNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactStoreNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactStoreNotificationTriggerDetails
    };

    // ----- ContactWebsite class --------------------
    constexpr const char* const _type_name_ContactWebsite = "ContactWebsite";

    static PyObject* _new_ContactWebsite(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactWebsite instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactWebsite(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactWebsite_get_Uri(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactWebsite_put_Uri(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactWebsite_get_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactWebsite_put_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactWebsite_get_RawValue(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactWebsite_put_RawValue(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RawValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactWebsite(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactWebsite>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactWebsite[] = {
        { "_from", (PyCFunction)_from_ContactWebsite, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactWebsite[] = {
        { const_cast<char*>("uri"), (getter)ContactWebsite_get_Uri, (setter)ContactWebsite_put_Uri, nullptr, nullptr },
        { const_cast<char*>("description"), (getter)ContactWebsite_get_Description, (setter)ContactWebsite_put_Description, nullptr, nullptr },
        { const_cast<char*>("raw_value"), (getter)ContactWebsite_get_RawValue, (setter)ContactWebsite_put_RawValue, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactWebsite[] = 
    {
        { Py_tp_new, _new_ContactWebsite },
        { Py_tp_dealloc, _dealloc_ContactWebsite },
        { Py_tp_methods, _methods_ContactWebsite },
        { Py_tp_getset, _getset_ContactWebsite },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactWebsite =
    {
        "_winrt_Windows_ApplicationModel_Contacts.ContactWebsite",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactWebsite
    };

    // ----- FullContactCardOptions class --------------------
    constexpr const char* const _type_name_FullContactCardOptions = "FullContactCardOptions";

    static PyObject* _new_FullContactCardOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::FullContactCardOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FullContactCardOptions(py::wrapper::Windows::ApplicationModel::Contacts::FullContactCardOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FullContactCardOptions_get_DesiredRemainingView(py::wrapper::Windows::ApplicationModel::Contacts::FullContactCardOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredRemainingView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FullContactCardOptions_put_DesiredRemainingView(py::wrapper::Windows::ApplicationModel::Contacts::FullContactCardOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(arg);

            self->obj.DesiredRemainingView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_FullContactCardOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::FullContactCardOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FullContactCardOptions[] = {
        { "_from", (PyCFunction)_from_FullContactCardOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FullContactCardOptions[] = {
        { const_cast<char*>("desired_remaining_view"), (getter)FullContactCardOptions_get_DesiredRemainingView, (setter)FullContactCardOptions_put_DesiredRemainingView, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FullContactCardOptions[] = 
    {
        { Py_tp_new, _new_FullContactCardOptions },
        { Py_tp_dealloc, _dealloc_FullContactCardOptions },
        { Py_tp_methods, _methods_FullContactCardOptions },
        { Py_tp_getset, _getset_FullContactCardOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FullContactCardOptions =
    {
        "_winrt_Windows_ApplicationModel_Contacts.FullContactCardOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::FullContactCardOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FullContactCardOptions
    };

    // ----- KnownContactField class --------------------
    constexpr const char* const _type_name_KnownContactField = "KnownContactField";

    static PyObject* _new_KnownContactField(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KnownContactField);
        return nullptr;
    }

    static PyObject* KnownContactField_ConvertNameToType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::KnownContactField::ConvertNameToType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownContactField_ConvertTypeToName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::KnownContactField::ConvertTypeToName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownContactField_get_Email(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::KnownContactField::Email());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactField_get_InstantMessage(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::KnownContactField::InstantMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactField_get_Location(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::KnownContactField::Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactField_get_PhoneNumber(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::KnownContactField::PhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownContactField[] = {
        { "convert_name_to_type", (PyCFunction)KnownContactField_ConvertNameToType, METH_VARARGS | METH_STATIC, nullptr },
        { "convert_type_to_name", (PyCFunction)KnownContactField_ConvertTypeToName, METH_VARARGS | METH_STATIC, nullptr },
        { "get_email", (PyCFunction)KnownContactField_get_Email, METH_NOARGS | METH_STATIC, nullptr },
        { "get_instant_message", (PyCFunction)KnownContactField_get_InstantMessage, METH_NOARGS | METH_STATIC, nullptr },
        { "get_location", (PyCFunction)KnownContactField_get_Location, METH_NOARGS | METH_STATIC, nullptr },
        { "get_phone_number", (PyCFunction)KnownContactField_get_PhoneNumber, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_KnownContactField[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_KnownContactField[] = 
    {
        { Py_tp_new, _new_KnownContactField },
        { Py_tp_methods, _methods_KnownContactField },
        { Py_tp_getset, _getset_KnownContactField },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_KnownContactField =
    {
        "_winrt_Windows_ApplicationModel_Contacts.KnownContactField",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownContactField
    };

    // ----- PinnedContactIdsQueryResult class --------------------
    constexpr const char* const _type_name_PinnedContactIdsQueryResult = "PinnedContactIdsQueryResult";

    static PyObject* _new_PinnedContactIdsQueryResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PinnedContactIdsQueryResult);
        return nullptr;
    }

    static void _dealloc_PinnedContactIdsQueryResult(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactIdsQueryResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PinnedContactIdsQueryResult_get_ContactIds(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactIdsQueryResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PinnedContactIdsQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::PinnedContactIdsQueryResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PinnedContactIdsQueryResult[] = {
        { "_from", (PyCFunction)_from_PinnedContactIdsQueryResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PinnedContactIdsQueryResult[] = {
        { const_cast<char*>("contact_ids"), (getter)PinnedContactIdsQueryResult_get_ContactIds, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PinnedContactIdsQueryResult[] = 
    {
        { Py_tp_new, _new_PinnedContactIdsQueryResult },
        { Py_tp_dealloc, _dealloc_PinnedContactIdsQueryResult },
        { Py_tp_methods, _methods_PinnedContactIdsQueryResult },
        { Py_tp_getset, _getset_PinnedContactIdsQueryResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PinnedContactIdsQueryResult =
    {
        "_winrt_Windows_ApplicationModel_Contacts.PinnedContactIdsQueryResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactIdsQueryResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PinnedContactIdsQueryResult
    };

    // ----- PinnedContactManager class --------------------
    constexpr const char* const _type_name_PinnedContactManager = "PinnedContactManager";

    static PyObject* _new_PinnedContactManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PinnedContactManager);
        return nullptr;
    }

    static void _dealloc_PinnedContactManager(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PinnedContactManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Contacts::PinnedContactManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::PinnedContactManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_GetPinnedContactIdsAsync(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPinnedContactIdsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_IsContactPinned(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::PinnedContactSurface>(args, 1);

                return py::convert(self->obj.IsContactPinned(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_IsPinSurfaceSupported(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::PinnedContactSurface>(args, 0);

                return py::convert(self->obj.IsPinSurfaceSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Contacts::PinnedContactManager::IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_RequestPinContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::PinnedContactSurface>(args, 1);

                return py::convert(self->obj.RequestPinContactAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_RequestPinContactsAsync(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Contacts::Contact>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::PinnedContactSurface>(args, 1);

                return py::convert(self->obj.RequestPinContactsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_RequestUnpinContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::PinnedContactSurface>(args, 1);

                return py::convert(self->obj.RequestUnpinContactAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_SignalContactActivity(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                self->obj.SignalContactActivity(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_get_User(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PinnedContactManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::PinnedContactManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PinnedContactManager[] = {
        { "get_default", (PyCFunction)PinnedContactManager_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", (PyCFunction)PinnedContactManager_GetForUser, METH_VARARGS | METH_STATIC, nullptr },
        { "get_pinned_contact_ids_async", (PyCFunction)PinnedContactManager_GetPinnedContactIdsAsync, METH_VARARGS, nullptr },
        { "is_contact_pinned", (PyCFunction)PinnedContactManager_IsContactPinned, METH_VARARGS, nullptr },
        { "is_pin_surface_supported", (PyCFunction)PinnedContactManager_IsPinSurfaceSupported, METH_VARARGS, nullptr },
        { "is_supported", (PyCFunction)PinnedContactManager_IsSupported, METH_VARARGS | METH_STATIC, nullptr },
        { "request_pin_contact_async", (PyCFunction)PinnedContactManager_RequestPinContactAsync, METH_VARARGS, nullptr },
        { "request_pin_contacts_async", (PyCFunction)PinnedContactManager_RequestPinContactsAsync, METH_VARARGS, nullptr },
        { "request_unpin_contact_async", (PyCFunction)PinnedContactManager_RequestUnpinContactAsync, METH_VARARGS, nullptr },
        { "signal_contact_activity", (PyCFunction)PinnedContactManager_SignalContactActivity, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PinnedContactManager, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PinnedContactManager[] = {
        { const_cast<char*>("user"), (getter)PinnedContactManager_get_User, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PinnedContactManager[] = 
    {
        { Py_tp_new, _new_PinnedContactManager },
        { Py_tp_dealloc, _dealloc_PinnedContactManager },
        { Py_tp_methods, _methods_PinnedContactManager },
        { Py_tp_getset, _getset_PinnedContactManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PinnedContactManager =
    {
        "_winrt_Windows_ApplicationModel_Contacts.PinnedContactManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PinnedContactManager
    };

    // ----- IContactField interface --------------------
    constexpr const char* const _type_name_IContactField = "IContactField";

    static PyObject* _new_IContactField(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IContactField);
        return nullptr;
    }

    static void _dealloc_IContactField(py::wrapper::Windows::ApplicationModel::Contacts::IContactField* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IContactField_get_Category(py::wrapper::Windows::ApplicationModel::Contacts::IContactField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Category());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactField_get_Name(py::wrapper::Windows::ApplicationModel::Contacts::IContactField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactField_get_Type(py::wrapper::Windows::ApplicationModel::Contacts::IContactField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactField_get_Value(py::wrapper::Windows::ApplicationModel::Contacts::IContactField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IContactField(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::IContactField>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactField[] = {
        { "_from", (PyCFunction)_from_IContactField, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IContactField[] = {
        { const_cast<char*>("category"), (getter)IContactField_get_Category, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)IContactField_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)IContactField_get_Type, nullptr, nullptr, nullptr },
        { const_cast<char*>("value"), (getter)IContactField_get_Value, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IContactField[] = 
    {
        { Py_tp_new, _new_IContactField },
        { Py_tp_dealloc, _dealloc_IContactField },
        { Py_tp_methods, _methods_IContactField },
        { Py_tp_getset, _getset_IContactField },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IContactField =
    {
        "_winrt_Windows_ApplicationModel_Contacts.IContactField",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::IContactField),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactField
    };

    // ----- IContactFieldFactory interface --------------------
    constexpr const char* const _type_name_IContactFieldFactory = "IContactFieldFactory";

    static PyObject* _new_IContactFieldFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IContactFieldFactory);
        return nullptr;
    }

    static void _dealloc_IContactFieldFactory(py::wrapper::Windows::ApplicationModel::Contacts::IContactFieldFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IContactFieldFactory_CreateField(py::wrapper::Windows::ApplicationModel::Contacts::IContactFieldFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 1);

                return py::convert(self->obj.CreateField(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 2);

                return py::convert(self->obj.CreateField(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 3);

                return py::convert(self->obj.CreateField(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IContactFieldFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::IContactFieldFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactFieldFactory[] = {
        { "create_field", (PyCFunction)IContactFieldFactory_CreateField, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IContactFieldFactory, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IContactFieldFactory[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IContactFieldFactory[] = 
    {
        { Py_tp_new, _new_IContactFieldFactory },
        { Py_tp_dealloc, _dealloc_IContactFieldFactory },
        { Py_tp_methods, _methods_IContactFieldFactory },
        { Py_tp_getset, _getset_IContactFieldFactory },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IContactFieldFactory =
    {
        "_winrt_Windows_ApplicationModel_Contacts.IContactFieldFactory",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::IContactFieldFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactFieldFactory
    };

    // ----- IContactInstantMessageFieldFactory interface --------------------
    constexpr const char* const _type_name_IContactInstantMessageFieldFactory = "IContactInstantMessageFieldFactory";

    static PyObject* _new_IContactInstantMessageFieldFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IContactInstantMessageFieldFactory);
        return nullptr;
    }

    static void _dealloc_IContactInstantMessageFieldFactory(py::wrapper::Windows::ApplicationModel::Contacts::IContactInstantMessageFieldFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IContactInstantMessageFieldFactory_CreateInstantMessage(py::wrapper::Windows::ApplicationModel::Contacts::IContactInstantMessageFieldFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateInstantMessage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);

                return py::convert(self->obj.CreateInstantMessage(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 4);

                return py::convert(self->obj.CreateInstantMessage(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IContactInstantMessageFieldFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::IContactInstantMessageFieldFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactInstantMessageFieldFactory[] = {
        { "create_instant_message", (PyCFunction)IContactInstantMessageFieldFactory_CreateInstantMessage, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IContactInstantMessageFieldFactory, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IContactInstantMessageFieldFactory[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IContactInstantMessageFieldFactory[] = 
    {
        { Py_tp_new, _new_IContactInstantMessageFieldFactory },
        { Py_tp_dealloc, _dealloc_IContactInstantMessageFieldFactory },
        { Py_tp_methods, _methods_IContactInstantMessageFieldFactory },
        { Py_tp_getset, _getset_IContactInstantMessageFieldFactory },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IContactInstantMessageFieldFactory =
    {
        "_winrt_Windows_ApplicationModel_Contacts.IContactInstantMessageFieldFactory",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::IContactInstantMessageFieldFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactInstantMessageFieldFactory
    };

    // ----- IContactLocationFieldFactory interface --------------------
    constexpr const char* const _type_name_IContactLocationFieldFactory = "IContactLocationFieldFactory";

    static PyObject* _new_IContactLocationFieldFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IContactLocationFieldFactory);
        return nullptr;
    }

    static void _dealloc_IContactLocationFieldFactory(py::wrapper::Windows::ApplicationModel::Contacts::IContactLocationFieldFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IContactLocationFieldFactory_CreateLocation(py::wrapper::Windows::ApplicationModel::Contacts::IContactLocationFieldFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateLocation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);

                return py::convert(self->obj.CreateLocation(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);

                return py::convert(self->obj.CreateLocation(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IContactLocationFieldFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::IContactLocationFieldFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactLocationFieldFactory[] = {
        { "create_location", (PyCFunction)IContactLocationFieldFactory_CreateLocation, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IContactLocationFieldFactory, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IContactLocationFieldFactory[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IContactLocationFieldFactory[] = 
    {
        { Py_tp_new, _new_IContactLocationFieldFactory },
        { Py_tp_dealloc, _dealloc_IContactLocationFieldFactory },
        { Py_tp_methods, _methods_IContactLocationFieldFactory },
        { Py_tp_getset, _getset_IContactLocationFieldFactory },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IContactLocationFieldFactory =
    {
        "_winrt_Windows_ApplicationModel_Contacts.IContactLocationFieldFactory",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::IContactLocationFieldFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactLocationFieldFactory
    };

    // ----- Windows.ApplicationModel.Contacts Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::AggregateContactManager>::python_type = py::register_python_type(module, _type_name_AggregateContactManager, &_type_spec_AggregateContactManager, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::Contact>::python_type = py::register_python_type(module, _type_name_Contact, &_type_spec_Contact, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactAddress>::python_type = py::register_python_type(module, _type_name_ContactAddress, &_type_spec_ContactAddress, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactAnnotation>::python_type = py::register_python_type(module, _type_name_ContactAnnotation, &_type_spec_ContactAnnotation, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationList>::python_type = py::register_python_type(module, _type_name_ContactAnnotationList, &_type_spec_ContactAnnotationList, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationStore>::python_type = py::register_python_type(module, _type_name_ContactAnnotationStore, &_type_spec_ContactAnnotationStore, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactBatch>::python_type = py::register_python_type(module, _type_name_ContactBatch, &_type_spec_ContactBatch, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader>::python_type = py::register_python_type(module, _type_name_ContactCardDelayedDataLoader, &_type_spec_ContactCardDelayedDataLoader, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactCardOptions>::python_type = py::register_python_type(module, _type_name_ContactCardOptions, &_type_spec_ContactCardOptions, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactChange>::python_type = py::register_python_type(module, _type_name_ContactChange, &_type_spec_ContactChange, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactChangeReader>::python_type = py::register_python_type(module, _type_name_ContactChangeReader, &_type_spec_ContactChangeReader, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactChangeTracker>::python_type = py::register_python_type(module, _type_name_ContactChangeTracker, &_type_spec_ContactChangeTracker, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactChangedDeferral>::python_type = py::register_python_type(module, _type_name_ContactChangedDeferral, &_type_spec_ContactChangedDeferral, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactChangedEventArgs>::python_type = py::register_python_type(module, _type_name_ContactChangedEventArgs, &_type_spec_ContactChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount>::python_type = py::register_python_type(module, _type_name_ContactConnectedServiceAccount, &_type_spec_ContactConnectedServiceAccount, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactDate>::python_type = py::register_python_type(module, _type_name_ContactDate, &_type_spec_ContactDate, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactEmail>::python_type = py::register_python_type(module, _type_name_ContactEmail, &_type_spec_ContactEmail, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactField>::python_type = py::register_python_type(module, _type_name_ContactField, &_type_spec_ContactField, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactFieldFactory>::python_type = py::register_python_type(module, _type_name_ContactFieldFactory, &_type_spec_ContactFieldFactory, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactGroup>::python_type = py::register_python_type(module, _type_name_ContactGroup, &_type_spec_ContactGroup, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactInformation>::python_type = py::register_python_type(module, _type_name_ContactInformation, &_type_spec_ContactInformation, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactInstantMessageField>::python_type = py::register_python_type(module, _type_name_ContactInstantMessageField, &_type_spec_ContactInstantMessageField, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactJobInfo>::python_type = py::register_python_type(module, _type_name_ContactJobInfo, &_type_spec_ContactJobInfo, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactLaunchActionVerbs>::python_type = py::register_python_type(module, _type_name_ContactLaunchActionVerbs, &_type_spec_ContactLaunchActionVerbs, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactList>::python_type = py::register_python_type(module, _type_name_ContactList, &_type_spec_ContactList, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations>::python_type = py::register_python_type(module, _type_name_ContactListLimitedWriteOperations, &_type_spec_ContactListLimitedWriteOperations, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactListSyncConstraints>::python_type = py::register_python_type(module, _type_name_ContactListSyncConstraints, &_type_spec_ContactListSyncConstraints, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactListSyncManager>::python_type = py::register_python_type(module, _type_name_ContactListSyncManager, &_type_spec_ContactListSyncManager, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactLocationField>::python_type = py::register_python_type(module, _type_name_ContactLocationField, &_type_spec_ContactLocationField, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactManager>::python_type = py::register_python_type(module, _type_name_ContactManager, &_type_spec_ContactManager, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactManagerForUser>::python_type = py::register_python_type(module, _type_name_ContactManagerForUser, &_type_spec_ContactManagerForUser, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactMatchReason>::python_type = py::register_python_type(module, _type_name_ContactMatchReason, &_type_spec_ContactMatchReason, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactPanel>::python_type = py::register_python_type(module, _type_name_ContactPanel, &_type_spec_ContactPanel, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs>::python_type = py::register_python_type(module, _type_name_ContactPanelClosingEventArgs, &_type_spec_ContactPanelClosingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_ContactPanelLaunchFullAppRequestedEventArgs, &_type_spec_ContactPanelLaunchFullAppRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactPhone>::python_type = py::register_python_type(module, _type_name_ContactPhone, &_type_spec_ContactPhone, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactPicker>::python_type = py::register_python_type(module, _type_name_ContactPicker, &_type_spec_ContactPicker, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions>::python_type = py::register_python_type(module, _type_name_ContactQueryOptions, &_type_spec_ContactQueryOptions, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactQueryTextSearch>::python_type = py::register_python_type(module, _type_name_ContactQueryTextSearch, &_type_spec_ContactQueryTextSearch, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactReader>::python_type = py::register_python_type(module, _type_name_ContactReader, &_type_spec_ContactReader, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactSignificantOther>::python_type = py::register_python_type(module, _type_name_ContactSignificantOther, &_type_spec_ContactSignificantOther, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactStore>::python_type = py::register_python_type(module, _type_name_ContactStore, &_type_spec_ContactStore, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactStoreNotificationTriggerDetails>::python_type = py::register_python_type(module, _type_name_ContactStoreNotificationTriggerDetails, &_type_spec_ContactStoreNotificationTriggerDetails, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactWebsite>::python_type = py::register_python_type(module, _type_name_ContactWebsite, &_type_spec_ContactWebsite, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::FullContactCardOptions>::python_type = py::register_python_type(module, _type_name_FullContactCardOptions, &_type_spec_FullContactCardOptions, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::KnownContactField>::python_type = py::register_python_type(module, _type_name_KnownContactField, &_type_spec_KnownContactField, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::PinnedContactIdsQueryResult>::python_type = py::register_python_type(module, _type_name_PinnedContactIdsQueryResult, &_type_spec_PinnedContactIdsQueryResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::PinnedContactManager>::python_type = py::register_python_type(module, _type_name_PinnedContactManager, &_type_spec_PinnedContactManager, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::IContactField>::python_type = py::register_python_type(module, _type_name_IContactField, &_type_spec_IContactField, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::IContactFieldFactory>::python_type = py::register_python_type(module, _type_name_IContactFieldFactory, &_type_spec_IContactFieldFactory, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::IContactInstantMessageFieldFactory>::python_type = py::register_python_type(module, _type_name_IContactInstantMessageFieldFactory, &_type_spec_IContactInstantMessageFieldFactory, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::IContactLocationFieldFactory>::python_type = py::register_python_type(module, _type_name_IContactLocationFieldFactory, &_type_spec_IContactLocationFieldFactory, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.Contacts");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_ApplicationModel_Contacts",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::ApplicationModel::Contacts

PyMODINIT_FUNC
PyInit__winrt_Windows_ApplicationModel_Contacts (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::ApplicationModel::Contacts::module_def);
}
