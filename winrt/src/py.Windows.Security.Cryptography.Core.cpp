// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Security.Cryptography.Core.h"

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::CryptographicEngine>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::CryptographicHash>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::CryptographicKey>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::EccCurveNames>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::HashAlgorithmProvider>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::MacAlgorithmProvider>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::PersistedKeyProvider>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider>::python_type;

namespace py::cpp::Windows::Security::Cryptography::Core
{
    // ----- AsymmetricAlgorithmNames class --------------------
    constexpr const char* const _type_name_AsymmetricAlgorithmNames = "AsymmetricAlgorithmNames";

    static PyObject* _new_AsymmetricAlgorithmNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AsymmetricAlgorithmNames);
        return nullptr;
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaP521Sha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaP521Sha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_DsaSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::DsaSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_DsaSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::DsaSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaP256Sha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaP256Sha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaP384Sha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaP384Sha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPkcs1Sha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaOaepSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaOaepSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaOaepSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaOaepSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaOaepSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaOaepSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaOaepSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaOaepSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaPkcs1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaPkcs1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPkcs1Sha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPkcs1Sha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPkcs1Sha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPssSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPssSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPssSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPssSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPssSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPssSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPssSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPssSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AsymmetricAlgorithmNames[] = {
        { "get_ecdsa_p521_sha512", (PyCFunction)AsymmetricAlgorithmNames_get_EcdsaP521Sha512, METH_NOARGS | METH_STATIC, nullptr },
        { "get_dsa_sha1", (PyCFunction)AsymmetricAlgorithmNames_get_DsaSha1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_dsa_sha256", (PyCFunction)AsymmetricAlgorithmNames_get_DsaSha256, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdsa_p256_sha256", (PyCFunction)AsymmetricAlgorithmNames_get_EcdsaP256Sha256, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdsa_p384_sha384", (PyCFunction)AsymmetricAlgorithmNames_get_EcdsaP384Sha384, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_sign_pkcs1_sha256", (PyCFunction)AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha256, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_oaep_sha1", (PyCFunction)AsymmetricAlgorithmNames_get_RsaOaepSha1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_oaep_sha256", (PyCFunction)AsymmetricAlgorithmNames_get_RsaOaepSha256, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_oaep_sha384", (PyCFunction)AsymmetricAlgorithmNames_get_RsaOaepSha384, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_oaep_sha512", (PyCFunction)AsymmetricAlgorithmNames_get_RsaOaepSha512, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_pkcs1", (PyCFunction)AsymmetricAlgorithmNames_get_RsaPkcs1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_sign_pkcs1_sha1", (PyCFunction)AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_sign_pkcs1_sha384", (PyCFunction)AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha384, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_sign_pkcs1_sha512", (PyCFunction)AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha512, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_sign_pss_sha1", (PyCFunction)AsymmetricAlgorithmNames_get_RsaSignPssSha1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_sign_pss_sha256", (PyCFunction)AsymmetricAlgorithmNames_get_RsaSignPssSha256, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_sign_pss_sha384", (PyCFunction)AsymmetricAlgorithmNames_get_RsaSignPssSha384, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_sign_pss_sha512", (PyCFunction)AsymmetricAlgorithmNames_get_RsaSignPssSha512, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdsa_sha384", (PyCFunction)AsymmetricAlgorithmNames_get_EcdsaSha384, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdsa_sha512", (PyCFunction)AsymmetricAlgorithmNames_get_EcdsaSha512, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdsa_sha256", (PyCFunction)AsymmetricAlgorithmNames_get_EcdsaSha256, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AsymmetricAlgorithmNames[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_AsymmetricAlgorithmNames[] = 
    {
        { Py_tp_new, _new_AsymmetricAlgorithmNames },
        { Py_tp_methods, _methods_AsymmetricAlgorithmNames },
        { Py_tp_getset, _getset_AsymmetricAlgorithmNames },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AsymmetricAlgorithmNames =
    {
        "_winrt_Windows_Security_Cryptography_Core.AsymmetricAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AsymmetricAlgorithmNames
    };

    // ----- AsymmetricKeyAlgorithmProvider class --------------------
    constexpr const char* const _type_name_AsymmetricKeyAlgorithmProvider = "AsymmetricKeyAlgorithmProvider";

    static PyObject* _new_AsymmetricKeyAlgorithmProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AsymmetricKeyAlgorithmProvider);
        return nullptr;
    }

    static void _dealloc_AsymmetricKeyAlgorithmProvider(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_CreateKeyPair(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.CreateKeyPair(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_CreateKeyPairWithCurveName(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateKeyPairWithCurveName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_CreateKeyPairWithCurveParameters(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(self->obj.CreateKeyPairWithCurveParameters(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_ImportKeyPair(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.ImportKeyPair(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPrivateKeyBlobType>(args, 1);

                return py::convert(self->obj.ImportKeyPair(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_ImportPublicKey(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.ImportPublicKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPublicKeyBlobType>(args, 1);

                return py::convert(self->obj.ImportPublicKey(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_OpenAlgorithm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider::OpenAlgorithm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_get_AlgorithmName(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AsymmetricKeyAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AsymmetricKeyAlgorithmProvider[] = {
        { "create_key_pair", (PyCFunction)AsymmetricKeyAlgorithmProvider_CreateKeyPair, METH_VARARGS, nullptr },
        { "create_key_pair_with_curve_name", (PyCFunction)AsymmetricKeyAlgorithmProvider_CreateKeyPairWithCurveName, METH_VARARGS, nullptr },
        { "create_key_pair_with_curve_parameters", (PyCFunction)AsymmetricKeyAlgorithmProvider_CreateKeyPairWithCurveParameters, METH_VARARGS, nullptr },
        { "import_key_pair", (PyCFunction)AsymmetricKeyAlgorithmProvider_ImportKeyPair, METH_VARARGS, nullptr },
        { "import_public_key", (PyCFunction)AsymmetricKeyAlgorithmProvider_ImportPublicKey, METH_VARARGS, nullptr },
        { "open_algorithm", (PyCFunction)AsymmetricKeyAlgorithmProvider_OpenAlgorithm, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_AsymmetricKeyAlgorithmProvider, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AsymmetricKeyAlgorithmProvider[] = {
        { const_cast<char*>("algorithm_name"), (getter)AsymmetricKeyAlgorithmProvider_get_AlgorithmName, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AsymmetricKeyAlgorithmProvider[] = 
    {
        { Py_tp_new, _new_AsymmetricKeyAlgorithmProvider },
        { Py_tp_dealloc, _dealloc_AsymmetricKeyAlgorithmProvider },
        { Py_tp_methods, _methods_AsymmetricKeyAlgorithmProvider },
        { Py_tp_getset, _getset_AsymmetricKeyAlgorithmProvider },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AsymmetricKeyAlgorithmProvider =
    {
        "_winrt_Windows_Security_Cryptography_Core.AsymmetricKeyAlgorithmProvider",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AsymmetricKeyAlgorithmProvider
    };

    // ----- CryptographicEngine class --------------------
    constexpr const char* const _type_name_CryptographicEngine = "CryptographicEngine";

    static PyObject* _new_CryptographicEngine(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CryptographicEngine);
        return nullptr;
    }

    static PyObject* CryptographicEngine_Decrypt(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::Decrypt(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_DecryptAndAuthenticate(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 4);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::DecryptAndAuthenticate(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_DecryptAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::DecryptAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_DeriveKeyMaterial(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::DeriveKeyMaterial(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_Encrypt(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::Encrypt(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_EncryptAndAuthenticate(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 3);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::EncryptAndAuthenticate(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_Sign(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::Sign(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_SignAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::SignAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_SignHashedData(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::SignHashedData(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_SignHashedDataAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::SignHashedDataAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_VerifySignature(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::VerifySignature(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_VerifySignatureWithHashInput(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::VerifySignatureWithHashInput(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_CryptographicEngine[] = {
        { "decrypt", (PyCFunction)CryptographicEngine_Decrypt, METH_VARARGS | METH_STATIC, nullptr },
        { "decrypt_and_authenticate", (PyCFunction)CryptographicEngine_DecryptAndAuthenticate, METH_VARARGS | METH_STATIC, nullptr },
        { "decrypt_async", (PyCFunction)CryptographicEngine_DecryptAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "derive_key_material", (PyCFunction)CryptographicEngine_DeriveKeyMaterial, METH_VARARGS | METH_STATIC, nullptr },
        { "encrypt", (PyCFunction)CryptographicEngine_Encrypt, METH_VARARGS | METH_STATIC, nullptr },
        { "encrypt_and_authenticate", (PyCFunction)CryptographicEngine_EncryptAndAuthenticate, METH_VARARGS | METH_STATIC, nullptr },
        { "sign", (PyCFunction)CryptographicEngine_Sign, METH_VARARGS | METH_STATIC, nullptr },
        { "sign_async", (PyCFunction)CryptographicEngine_SignAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "sign_hashed_data", (PyCFunction)CryptographicEngine_SignHashedData, METH_VARARGS | METH_STATIC, nullptr },
        { "sign_hashed_data_async", (PyCFunction)CryptographicEngine_SignHashedDataAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "verify_signature", (PyCFunction)CryptographicEngine_VerifySignature, METH_VARARGS | METH_STATIC, nullptr },
        { "verify_signature_with_hash_input", (PyCFunction)CryptographicEngine_VerifySignatureWithHashInput, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CryptographicEngine[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_CryptographicEngine[] = 
    {
        { Py_tp_new, _new_CryptographicEngine },
        { Py_tp_methods, _methods_CryptographicEngine },
        { Py_tp_getset, _getset_CryptographicEngine },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CryptographicEngine =
    {
        "_winrt_Windows_Security_Cryptography_Core.CryptographicEngine",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CryptographicEngine
    };

    // ----- CryptographicHash class --------------------
    constexpr const char* const _type_name_CryptographicHash = "CryptographicHash";

    static PyObject* _new_CryptographicHash(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CryptographicHash);
        return nullptr;
    }

    static void _dealloc_CryptographicHash(py::wrapper::Windows::Security::Cryptography::Core::CryptographicHash* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CryptographicHash_Append(py::wrapper::Windows::Security::Cryptography::Core::CryptographicHash* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicHash_GetValueAndReset(py::wrapper::Windows::Security::Cryptography::Core::CryptographicHash* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetValueAndReset());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_CryptographicHash(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::CryptographicHash>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CryptographicHash[] = {
        { "append", (PyCFunction)CryptographicHash_Append, METH_VARARGS, nullptr },
        { "get_value_and_reset", (PyCFunction)CryptographicHash_GetValueAndReset, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_CryptographicHash, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CryptographicHash[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_CryptographicHash[] = 
    {
        { Py_tp_new, _new_CryptographicHash },
        { Py_tp_dealloc, _dealloc_CryptographicHash },
        { Py_tp_methods, _methods_CryptographicHash },
        { Py_tp_getset, _getset_CryptographicHash },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CryptographicHash =
    {
        "_winrt_Windows_Security_Cryptography_Core.CryptographicHash",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::CryptographicHash),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CryptographicHash
    };

    // ----- CryptographicKey class --------------------
    constexpr const char* const _type_name_CryptographicKey = "CryptographicKey";

    static PyObject* _new_CryptographicKey(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CryptographicKey);
        return nullptr;
    }

    static void _dealloc_CryptographicKey(py::wrapper::Windows::Security::Cryptography::Core::CryptographicKey* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CryptographicKey_Export(py::wrapper::Windows::Security::Cryptography::Core::CryptographicKey* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Export());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPrivateKeyBlobType>(args, 0);

                return py::convert(self->obj.Export(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicKey_ExportPublicKey(py::wrapper::Windows::Security::Cryptography::Core::CryptographicKey* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ExportPublicKey());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPublicKeyBlobType>(args, 0);

                return py::convert(self->obj.ExportPublicKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicKey_get_KeySize(py::wrapper::Windows::Security::Cryptography::Core::CryptographicKey* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeySize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CryptographicKey(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::CryptographicKey>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CryptographicKey[] = {
        { "export", (PyCFunction)CryptographicKey_Export, METH_VARARGS, nullptr },
        { "export_public_key", (PyCFunction)CryptographicKey_ExportPublicKey, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_CryptographicKey, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CryptographicKey[] = {
        { const_cast<char*>("key_size"), (getter)CryptographicKey_get_KeySize, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CryptographicKey[] = 
    {
        { Py_tp_new, _new_CryptographicKey },
        { Py_tp_dealloc, _dealloc_CryptographicKey },
        { Py_tp_methods, _methods_CryptographicKey },
        { Py_tp_getset, _getset_CryptographicKey },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CryptographicKey =
    {
        "_winrt_Windows_Security_Cryptography_Core.CryptographicKey",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::CryptographicKey),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CryptographicKey
    };

    // ----- EccCurveNames class --------------------
    constexpr const char* const _type_name_EccCurveNames = "EccCurveNames";

    static PyObject* _new_EccCurveNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EccCurveNames);
        return nullptr;
    }

    static PyObject* EccCurveNames_get_AllEccCurveNames(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::AllEccCurveNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP160r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP160r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP160t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP160t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP192r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP192r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP192t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP192t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP224r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP224r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP224t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP224t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP256r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP256r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP256t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP256t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP320r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP320r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP320t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP320t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP384r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP384r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP384t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP384t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP512r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP512r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP512t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP512t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_Curve25519(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::Curve25519());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_Ec192wapi(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::Ec192wapi());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NistP192(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NistP192());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NistP224(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NistP224());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NistP256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NistP256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NistP384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NistP384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NistP521(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NistP521());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NumsP256t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NumsP256t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NumsP384t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NumsP384t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NumsP512t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NumsP512t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP160k1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP160k1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP160r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP160r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP160r2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP160r2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP192k1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP192k1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP192r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP192r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP224k1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP224k1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP224r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP224r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP256k1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP256k1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP256r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP256r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP384r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP384r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP521r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP521r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_Wtls12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::Wtls12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_Wtls7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::Wtls7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_Wtls9(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::Wtls9());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P192v1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P192v1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P192v2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P192v2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P192v3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P192v3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P239v1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P239v1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P239v2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P239v2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P239v3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P239v3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P256v1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P256v1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EccCurveNames[] = {
        { "get_all_ecc_curve_names", (PyCFunction)EccCurveNames_get_AllEccCurveNames, METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p160r1", (PyCFunction)EccCurveNames_get_BrainpoolP160r1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p160t1", (PyCFunction)EccCurveNames_get_BrainpoolP160t1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p192r1", (PyCFunction)EccCurveNames_get_BrainpoolP192r1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p192t1", (PyCFunction)EccCurveNames_get_BrainpoolP192t1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p224r1", (PyCFunction)EccCurveNames_get_BrainpoolP224r1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p224t1", (PyCFunction)EccCurveNames_get_BrainpoolP224t1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p256r1", (PyCFunction)EccCurveNames_get_BrainpoolP256r1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p256t1", (PyCFunction)EccCurveNames_get_BrainpoolP256t1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p320r1", (PyCFunction)EccCurveNames_get_BrainpoolP320r1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p320t1", (PyCFunction)EccCurveNames_get_BrainpoolP320t1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p384r1", (PyCFunction)EccCurveNames_get_BrainpoolP384r1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p384t1", (PyCFunction)EccCurveNames_get_BrainpoolP384t1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p512r1", (PyCFunction)EccCurveNames_get_BrainpoolP512r1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p512t1", (PyCFunction)EccCurveNames_get_BrainpoolP512t1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_curve25519", (PyCFunction)EccCurveNames_get_Curve25519, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ec192wapi", (PyCFunction)EccCurveNames_get_Ec192wapi, METH_NOARGS | METH_STATIC, nullptr },
        { "get_nist_p192", (PyCFunction)EccCurveNames_get_NistP192, METH_NOARGS | METH_STATIC, nullptr },
        { "get_nist_p224", (PyCFunction)EccCurveNames_get_NistP224, METH_NOARGS | METH_STATIC, nullptr },
        { "get_nist_p256", (PyCFunction)EccCurveNames_get_NistP256, METH_NOARGS | METH_STATIC, nullptr },
        { "get_nist_p384", (PyCFunction)EccCurveNames_get_NistP384, METH_NOARGS | METH_STATIC, nullptr },
        { "get_nist_p521", (PyCFunction)EccCurveNames_get_NistP521, METH_NOARGS | METH_STATIC, nullptr },
        { "get_nums_p256t1", (PyCFunction)EccCurveNames_get_NumsP256t1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_nums_p384t1", (PyCFunction)EccCurveNames_get_NumsP384t1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_nums_p512t1", (PyCFunction)EccCurveNames_get_NumsP512t1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p160k1", (PyCFunction)EccCurveNames_get_SecP160k1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p160r1", (PyCFunction)EccCurveNames_get_SecP160r1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p160r2", (PyCFunction)EccCurveNames_get_SecP160r2, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p192k1", (PyCFunction)EccCurveNames_get_SecP192k1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p192r1", (PyCFunction)EccCurveNames_get_SecP192r1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p224k1", (PyCFunction)EccCurveNames_get_SecP224k1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p224r1", (PyCFunction)EccCurveNames_get_SecP224r1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p256k1", (PyCFunction)EccCurveNames_get_SecP256k1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p256r1", (PyCFunction)EccCurveNames_get_SecP256r1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p384r1", (PyCFunction)EccCurveNames_get_SecP384r1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p521r1", (PyCFunction)EccCurveNames_get_SecP521r1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_wtls12", (PyCFunction)EccCurveNames_get_Wtls12, METH_NOARGS | METH_STATIC, nullptr },
        { "get_wtls7", (PyCFunction)EccCurveNames_get_Wtls7, METH_NOARGS | METH_STATIC, nullptr },
        { "get_wtls9", (PyCFunction)EccCurveNames_get_Wtls9, METH_NOARGS | METH_STATIC, nullptr },
        { "get_x962_p192v1", (PyCFunction)EccCurveNames_get_X962P192v1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_x962_p192v2", (PyCFunction)EccCurveNames_get_X962P192v2, METH_NOARGS | METH_STATIC, nullptr },
        { "get_x962_p192v3", (PyCFunction)EccCurveNames_get_X962P192v3, METH_NOARGS | METH_STATIC, nullptr },
        { "get_x962_p239v1", (PyCFunction)EccCurveNames_get_X962P239v1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_x962_p239v2", (PyCFunction)EccCurveNames_get_X962P239v2, METH_NOARGS | METH_STATIC, nullptr },
        { "get_x962_p239v3", (PyCFunction)EccCurveNames_get_X962P239v3, METH_NOARGS | METH_STATIC, nullptr },
        { "get_x962_p256v1", (PyCFunction)EccCurveNames_get_X962P256v1, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EccCurveNames[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_EccCurveNames[] = 
    {
        { Py_tp_new, _new_EccCurveNames },
        { Py_tp_methods, _methods_EccCurveNames },
        { Py_tp_getset, _getset_EccCurveNames },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EccCurveNames =
    {
        "_winrt_Windows_Security_Cryptography_Core.EccCurveNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EccCurveNames
    };

    // ----- EncryptedAndAuthenticatedData class --------------------
    constexpr const char* const _type_name_EncryptedAndAuthenticatedData = "EncryptedAndAuthenticatedData";

    static PyObject* _new_EncryptedAndAuthenticatedData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EncryptedAndAuthenticatedData);
        return nullptr;
    }

    static void _dealloc_EncryptedAndAuthenticatedData(py::wrapper::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EncryptedAndAuthenticatedData_get_AuthenticationTag(py::wrapper::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AuthenticationTag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EncryptedAndAuthenticatedData_get_EncryptedData(py::wrapper::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncryptedData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EncryptedAndAuthenticatedData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EncryptedAndAuthenticatedData[] = {
        { "_from", (PyCFunction)_from_EncryptedAndAuthenticatedData, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EncryptedAndAuthenticatedData[] = {
        { const_cast<char*>("authentication_tag"), (getter)EncryptedAndAuthenticatedData_get_AuthenticationTag, nullptr, nullptr, nullptr },
        { const_cast<char*>("encrypted_data"), (getter)EncryptedAndAuthenticatedData_get_EncryptedData, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EncryptedAndAuthenticatedData[] = 
    {
        { Py_tp_new, _new_EncryptedAndAuthenticatedData },
        { Py_tp_dealloc, _dealloc_EncryptedAndAuthenticatedData },
        { Py_tp_methods, _methods_EncryptedAndAuthenticatedData },
        { Py_tp_getset, _getset_EncryptedAndAuthenticatedData },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EncryptedAndAuthenticatedData =
    {
        "_winrt_Windows_Security_Cryptography_Core.EncryptedAndAuthenticatedData",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EncryptedAndAuthenticatedData
    };

    // ----- HashAlgorithmNames class --------------------
    constexpr const char* const _type_name_HashAlgorithmNames = "HashAlgorithmNames";

    static PyObject* _new_HashAlgorithmNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HashAlgorithmNames);
        return nullptr;
    }

    static PyObject* HashAlgorithmNames_get_Md5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames::Md5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmNames_get_Sha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames::Sha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmNames_get_Sha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames::Sha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmNames_get_Sha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames::Sha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmNames_get_Sha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames::Sha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HashAlgorithmNames[] = {
        { "get_md5", (PyCFunction)HashAlgorithmNames_get_Md5, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sha1", (PyCFunction)HashAlgorithmNames_get_Sha1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sha256", (PyCFunction)HashAlgorithmNames_get_Sha256, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sha384", (PyCFunction)HashAlgorithmNames_get_Sha384, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sha512", (PyCFunction)HashAlgorithmNames_get_Sha512, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HashAlgorithmNames[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_HashAlgorithmNames[] = 
    {
        { Py_tp_new, _new_HashAlgorithmNames },
        { Py_tp_methods, _methods_HashAlgorithmNames },
        { Py_tp_getset, _getset_HashAlgorithmNames },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HashAlgorithmNames =
    {
        "_winrt_Windows_Security_Cryptography_Core.HashAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HashAlgorithmNames
    };

    // ----- HashAlgorithmProvider class --------------------
    constexpr const char* const _type_name_HashAlgorithmProvider = "HashAlgorithmProvider";

    static PyObject* _new_HashAlgorithmProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HashAlgorithmProvider);
        return nullptr;
    }

    static void _dealloc_HashAlgorithmProvider(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HashAlgorithmProvider_CreateHash(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateHash());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmProvider_HashData(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.HashData(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmProvider_OpenAlgorithm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmProvider::OpenAlgorithm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmProvider_get_AlgorithmName(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmProvider_get_HashLength(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HashLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HashAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::HashAlgorithmProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HashAlgorithmProvider[] = {
        { "create_hash", (PyCFunction)HashAlgorithmProvider_CreateHash, METH_VARARGS, nullptr },
        { "hash_data", (PyCFunction)HashAlgorithmProvider_HashData, METH_VARARGS, nullptr },
        { "open_algorithm", (PyCFunction)HashAlgorithmProvider_OpenAlgorithm, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_HashAlgorithmProvider, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HashAlgorithmProvider[] = {
        { const_cast<char*>("algorithm_name"), (getter)HashAlgorithmProvider_get_AlgorithmName, nullptr, nullptr, nullptr },
        { const_cast<char*>("hash_length"), (getter)HashAlgorithmProvider_get_HashLength, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HashAlgorithmProvider[] = 
    {
        { Py_tp_new, _new_HashAlgorithmProvider },
        { Py_tp_dealloc, _dealloc_HashAlgorithmProvider },
        { Py_tp_methods, _methods_HashAlgorithmProvider },
        { Py_tp_getset, _getset_HashAlgorithmProvider },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HashAlgorithmProvider =
    {
        "_winrt_Windows_Security_Cryptography_Core.HashAlgorithmProvider",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HashAlgorithmProvider
    };

    // ----- KeyDerivationAlgorithmNames class --------------------
    constexpr const char* const _type_name_KeyDerivationAlgorithmNames = "KeyDerivationAlgorithmNames";

    static PyObject* _new_KeyDerivationAlgorithmNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KeyDerivationAlgorithmNames);
        return nullptr;
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Pbkdf2Sha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Pbkdf2Sha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Pbkdf2Md5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Pbkdf2Md5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Pbkdf2Sha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Pbkdf2Sha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp800108CtrHmacSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Pbkdf2Sha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Pbkdf2Sha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Pbkdf2Sha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Pbkdf2Sha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp800108CtrHmacMd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp800108CtrHmacMd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp800108CtrHmacSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp800108CtrHmacSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp800108CtrHmacSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp80056aConcatMd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp80056aConcatMd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp80056aConcatSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp80056aConcatSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp80056aConcatSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp80056aConcatSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp80056aConcatSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp80056aConcatSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp80056aConcatSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp80056aConcatSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_CapiKdfSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::CapiKdfSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_CapiKdfSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::CapiKdfSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_CapiKdfSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::CapiKdfSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_CapiKdfSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::CapiKdfSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_CapiKdfMd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::CapiKdfMd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyDerivationAlgorithmNames[] = {
        { "get_pbkdf2_sha256", (PyCFunction)KeyDerivationAlgorithmNames_get_Pbkdf2Sha256, METH_NOARGS | METH_STATIC, nullptr },
        { "get_pbkdf2_md5", (PyCFunction)KeyDerivationAlgorithmNames_get_Pbkdf2Md5, METH_NOARGS | METH_STATIC, nullptr },
        { "get_pbkdf2_sha1", (PyCFunction)KeyDerivationAlgorithmNames_get_Pbkdf2Sha1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sp800108_ctr_hmac_sha512", (PyCFunction)KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha512, METH_NOARGS | METH_STATIC, nullptr },
        { "get_pbkdf2_sha384", (PyCFunction)KeyDerivationAlgorithmNames_get_Pbkdf2Sha384, METH_NOARGS | METH_STATIC, nullptr },
        { "get_pbkdf2_sha512", (PyCFunction)KeyDerivationAlgorithmNames_get_Pbkdf2Sha512, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sp800108_ctr_hmac_md5", (PyCFunction)KeyDerivationAlgorithmNames_get_Sp800108CtrHmacMd5, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sp800108_ctr_hmac_sha1", (PyCFunction)KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sp800108_ctr_hmac_sha256", (PyCFunction)KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha256, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sp800108_ctr_hmac_sha384", (PyCFunction)KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha384, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sp80056a_concat_md5", (PyCFunction)KeyDerivationAlgorithmNames_get_Sp80056aConcatMd5, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sp80056a_concat_sha1", (PyCFunction)KeyDerivationAlgorithmNames_get_Sp80056aConcatSha1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sp80056a_concat_sha256", (PyCFunction)KeyDerivationAlgorithmNames_get_Sp80056aConcatSha256, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sp80056a_concat_sha384", (PyCFunction)KeyDerivationAlgorithmNames_get_Sp80056aConcatSha384, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sp80056a_concat_sha512", (PyCFunction)KeyDerivationAlgorithmNames_get_Sp80056aConcatSha512, METH_NOARGS | METH_STATIC, nullptr },
        { "get_capi_kdf_sha1", (PyCFunction)KeyDerivationAlgorithmNames_get_CapiKdfSha1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_capi_kdf_sha256", (PyCFunction)KeyDerivationAlgorithmNames_get_CapiKdfSha256, METH_NOARGS | METH_STATIC, nullptr },
        { "get_capi_kdf_sha384", (PyCFunction)KeyDerivationAlgorithmNames_get_CapiKdfSha384, METH_NOARGS | METH_STATIC, nullptr },
        { "get_capi_kdf_sha512", (PyCFunction)KeyDerivationAlgorithmNames_get_CapiKdfSha512, METH_NOARGS | METH_STATIC, nullptr },
        { "get_capi_kdf_md5", (PyCFunction)KeyDerivationAlgorithmNames_get_CapiKdfMd5, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_KeyDerivationAlgorithmNames[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_KeyDerivationAlgorithmNames[] = 
    {
        { Py_tp_new, _new_KeyDerivationAlgorithmNames },
        { Py_tp_methods, _methods_KeyDerivationAlgorithmNames },
        { Py_tp_getset, _getset_KeyDerivationAlgorithmNames },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_KeyDerivationAlgorithmNames =
    {
        "_winrt_Windows_Security_Cryptography_Core.KeyDerivationAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyDerivationAlgorithmNames
    };

    // ----- KeyDerivationAlgorithmProvider class --------------------
    constexpr const char* const _type_name_KeyDerivationAlgorithmProvider = "KeyDerivationAlgorithmProvider";

    static PyObject* _new_KeyDerivationAlgorithmProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KeyDerivationAlgorithmProvider);
        return nullptr;
    }

    static void _dealloc_KeyDerivationAlgorithmProvider(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* KeyDerivationAlgorithmProvider_CreateKey(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.CreateKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmProvider_OpenAlgorithm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider::OpenAlgorithm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmProvider_get_AlgorithmName(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_KeyDerivationAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyDerivationAlgorithmProvider[] = {
        { "create_key", (PyCFunction)KeyDerivationAlgorithmProvider_CreateKey, METH_VARARGS, nullptr },
        { "open_algorithm", (PyCFunction)KeyDerivationAlgorithmProvider_OpenAlgorithm, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_KeyDerivationAlgorithmProvider, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_KeyDerivationAlgorithmProvider[] = {
        { const_cast<char*>("algorithm_name"), (getter)KeyDerivationAlgorithmProvider_get_AlgorithmName, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_KeyDerivationAlgorithmProvider[] = 
    {
        { Py_tp_new, _new_KeyDerivationAlgorithmProvider },
        { Py_tp_dealloc, _dealloc_KeyDerivationAlgorithmProvider },
        { Py_tp_methods, _methods_KeyDerivationAlgorithmProvider },
        { Py_tp_getset, _getset_KeyDerivationAlgorithmProvider },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_KeyDerivationAlgorithmProvider =
    {
        "_winrt_Windows_Security_Cryptography_Core.KeyDerivationAlgorithmProvider",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyDerivationAlgorithmProvider
    };

    // ----- KeyDerivationParameters class --------------------
    constexpr const char* const _type_name_KeyDerivationParameters = "KeyDerivationParameters";

    static PyObject* _new_KeyDerivationParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KeyDerivationParameters);
        return nullptr;
    }

    static void _dealloc_KeyDerivationParameters(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* KeyDerivationParameters_BuildForCapi1Kdf(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::Capi1KdfTargetAlgorithm>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters::BuildForCapi1Kdf(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationParameters_BuildForPbkdf2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters::BuildForPbkdf2(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationParameters_BuildForSP800108(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters::BuildForSP800108(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationParameters_BuildForSP80056a(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 4);

                return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters::BuildForSP80056a(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationParameters_get_KdfGenericBinary(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KdfGenericBinary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyDerivationParameters_put_KdfGenericBinary(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.KdfGenericBinary(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyDerivationParameters_get_IterationCount(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IterationCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationParameters_get_Capi1KdfTargetAlgorithm(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capi1KdfTargetAlgorithm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyDerivationParameters_put_Capi1KdfTargetAlgorithm(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::Capi1KdfTargetAlgorithm>(arg);

            self->obj.Capi1KdfTargetAlgorithm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_KeyDerivationParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyDerivationParameters[] = {
        { "build_for_capi1_kdf", (PyCFunction)KeyDerivationParameters_BuildForCapi1Kdf, METH_VARARGS | METH_STATIC, nullptr },
        { "build_for_pbkdf2", (PyCFunction)KeyDerivationParameters_BuildForPbkdf2, METH_VARARGS | METH_STATIC, nullptr },
        { "build_for_s_p800108", (PyCFunction)KeyDerivationParameters_BuildForSP800108, METH_VARARGS | METH_STATIC, nullptr },
        { "build_for_s_p80056a", (PyCFunction)KeyDerivationParameters_BuildForSP80056a, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_KeyDerivationParameters, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_KeyDerivationParameters[] = {
        { const_cast<char*>("kdf_generic_binary"), (getter)KeyDerivationParameters_get_KdfGenericBinary, (setter)KeyDerivationParameters_put_KdfGenericBinary, nullptr, nullptr },
        { const_cast<char*>("iteration_count"), (getter)KeyDerivationParameters_get_IterationCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("capi1_kdf_target_algorithm"), (getter)KeyDerivationParameters_get_Capi1KdfTargetAlgorithm, (setter)KeyDerivationParameters_put_Capi1KdfTargetAlgorithm, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_KeyDerivationParameters[] = 
    {
        { Py_tp_new, _new_KeyDerivationParameters },
        { Py_tp_dealloc, _dealloc_KeyDerivationParameters },
        { Py_tp_methods, _methods_KeyDerivationParameters },
        { Py_tp_getset, _getset_KeyDerivationParameters },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_KeyDerivationParameters =
    {
        "_winrt_Windows_Security_Cryptography_Core.KeyDerivationParameters",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyDerivationParameters
    };

    // ----- MacAlgorithmNames class --------------------
    constexpr const char* const _type_name_MacAlgorithmNames = "MacAlgorithmNames";

    static PyObject* _new_MacAlgorithmNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MacAlgorithmNames);
        return nullptr;
    }

    static PyObject* MacAlgorithmNames_get_AesCmac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::AesCmac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmNames_get_HmacMd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::HmacMd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmNames_get_HmacSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::HmacSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmNames_get_HmacSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::HmacSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmNames_get_HmacSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::HmacSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmNames_get_HmacSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::HmacSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MacAlgorithmNames[] = {
        { "get_aes_cmac", (PyCFunction)MacAlgorithmNames_get_AesCmac, METH_NOARGS | METH_STATIC, nullptr },
        { "get_hmac_md5", (PyCFunction)MacAlgorithmNames_get_HmacMd5, METH_NOARGS | METH_STATIC, nullptr },
        { "get_hmac_sha1", (PyCFunction)MacAlgorithmNames_get_HmacSha1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_hmac_sha256", (PyCFunction)MacAlgorithmNames_get_HmacSha256, METH_NOARGS | METH_STATIC, nullptr },
        { "get_hmac_sha384", (PyCFunction)MacAlgorithmNames_get_HmacSha384, METH_NOARGS | METH_STATIC, nullptr },
        { "get_hmac_sha512", (PyCFunction)MacAlgorithmNames_get_HmacSha512, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MacAlgorithmNames[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_MacAlgorithmNames[] = 
    {
        { Py_tp_new, _new_MacAlgorithmNames },
        { Py_tp_methods, _methods_MacAlgorithmNames },
        { Py_tp_getset, _getset_MacAlgorithmNames },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MacAlgorithmNames =
    {
        "_winrt_Windows_Security_Cryptography_Core.MacAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MacAlgorithmNames
    };

    // ----- MacAlgorithmProvider class --------------------
    constexpr const char* const _type_name_MacAlgorithmProvider = "MacAlgorithmProvider";

    static PyObject* _new_MacAlgorithmProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MacAlgorithmProvider);
        return nullptr;
    }

    static void _dealloc_MacAlgorithmProvider(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MacAlgorithmProvider_CreateHash(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.CreateHash(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmProvider_CreateKey(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.CreateKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmProvider_OpenAlgorithm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmProvider::OpenAlgorithm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmProvider_get_AlgorithmName(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmProvider_get_MacLength(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MacLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MacAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::MacAlgorithmProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MacAlgorithmProvider[] = {
        { "create_hash", (PyCFunction)MacAlgorithmProvider_CreateHash, METH_VARARGS, nullptr },
        { "create_key", (PyCFunction)MacAlgorithmProvider_CreateKey, METH_VARARGS, nullptr },
        { "open_algorithm", (PyCFunction)MacAlgorithmProvider_OpenAlgorithm, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_MacAlgorithmProvider, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MacAlgorithmProvider[] = {
        { const_cast<char*>("algorithm_name"), (getter)MacAlgorithmProvider_get_AlgorithmName, nullptr, nullptr, nullptr },
        { const_cast<char*>("mac_length"), (getter)MacAlgorithmProvider_get_MacLength, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MacAlgorithmProvider[] = 
    {
        { Py_tp_new, _new_MacAlgorithmProvider },
        { Py_tp_dealloc, _dealloc_MacAlgorithmProvider },
        { Py_tp_methods, _methods_MacAlgorithmProvider },
        { Py_tp_getset, _getset_MacAlgorithmProvider },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MacAlgorithmProvider =
    {
        "_winrt_Windows_Security_Cryptography_Core.MacAlgorithmProvider",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MacAlgorithmProvider
    };

    // ----- PersistedKeyProvider class --------------------
    constexpr const char* const _type_name_PersistedKeyProvider = "PersistedKeyProvider";

    static PyObject* _new_PersistedKeyProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PersistedKeyProvider);
        return nullptr;
    }

    static PyObject* PersistedKeyProvider_OpenKeyPairFromCertificateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPadding>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::PersistedKeyProvider::OpenKeyPairFromCertificateAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PersistedKeyProvider_OpenPublicKeyFromCertificate(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPadding>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::PersistedKeyProvider::OpenPublicKeyFromCertificate(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PersistedKeyProvider[] = {
        { "open_key_pair_from_certificate_async", (PyCFunction)PersistedKeyProvider_OpenKeyPairFromCertificateAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "open_public_key_from_certificate", (PyCFunction)PersistedKeyProvider_OpenPublicKeyFromCertificate, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PersistedKeyProvider[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PersistedKeyProvider[] = 
    {
        { Py_tp_new, _new_PersistedKeyProvider },
        { Py_tp_methods, _methods_PersistedKeyProvider },
        { Py_tp_getset, _getset_PersistedKeyProvider },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PersistedKeyProvider =
    {
        "_winrt_Windows_Security_Cryptography_Core.PersistedKeyProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PersistedKeyProvider
    };

    // ----- SymmetricAlgorithmNames class --------------------
    constexpr const char* const _type_name_SymmetricAlgorithmNames = "SymmetricAlgorithmNames";

    static PyObject* _new_SymmetricAlgorithmNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SymmetricAlgorithmNames);
        return nullptr;
    }

    static PyObject* SymmetricAlgorithmNames_get_AesCbc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesCbc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_AesCbcPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesCbcPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_AesCcm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesCcm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_AesEcb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesEcb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_AesEcbPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesEcbPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_AesGcm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesGcm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_DesCbc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::DesCbc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_DesCbcPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::DesCbcPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_DesEcb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::DesEcb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_DesEcbPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::DesEcbPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_Rc2Cbc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::Rc2Cbc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_Rc2CbcPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::Rc2CbcPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_Rc2Ecb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::Rc2Ecb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_Rc2EcbPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::Rc2EcbPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_Rc4(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::Rc4());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_TripleDesCbc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::TripleDesCbc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_TripleDesCbcPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::TripleDesCbcPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_TripleDesEcb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::TripleDesEcb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_TripleDesEcbPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::TripleDesEcbPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SymmetricAlgorithmNames[] = {
        { "get_aes_cbc", (PyCFunction)SymmetricAlgorithmNames_get_AesCbc, METH_NOARGS | METH_STATIC, nullptr },
        { "get_aes_cbc_pkcs7", (PyCFunction)SymmetricAlgorithmNames_get_AesCbcPkcs7, METH_NOARGS | METH_STATIC, nullptr },
        { "get_aes_ccm", (PyCFunction)SymmetricAlgorithmNames_get_AesCcm, METH_NOARGS | METH_STATIC, nullptr },
        { "get_aes_ecb", (PyCFunction)SymmetricAlgorithmNames_get_AesEcb, METH_NOARGS | METH_STATIC, nullptr },
        { "get_aes_ecb_pkcs7", (PyCFunction)SymmetricAlgorithmNames_get_AesEcbPkcs7, METH_NOARGS | METH_STATIC, nullptr },
        { "get_aes_gcm", (PyCFunction)SymmetricAlgorithmNames_get_AesGcm, METH_NOARGS | METH_STATIC, nullptr },
        { "get_des_cbc", (PyCFunction)SymmetricAlgorithmNames_get_DesCbc, METH_NOARGS | METH_STATIC, nullptr },
        { "get_des_cbc_pkcs7", (PyCFunction)SymmetricAlgorithmNames_get_DesCbcPkcs7, METH_NOARGS | METH_STATIC, nullptr },
        { "get_des_ecb", (PyCFunction)SymmetricAlgorithmNames_get_DesEcb, METH_NOARGS | METH_STATIC, nullptr },
        { "get_des_ecb_pkcs7", (PyCFunction)SymmetricAlgorithmNames_get_DesEcbPkcs7, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rc2_cbc", (PyCFunction)SymmetricAlgorithmNames_get_Rc2Cbc, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rc2_cbc_pkcs7", (PyCFunction)SymmetricAlgorithmNames_get_Rc2CbcPkcs7, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rc2_ecb", (PyCFunction)SymmetricAlgorithmNames_get_Rc2Ecb, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rc2_ecb_pkcs7", (PyCFunction)SymmetricAlgorithmNames_get_Rc2EcbPkcs7, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rc4", (PyCFunction)SymmetricAlgorithmNames_get_Rc4, METH_NOARGS | METH_STATIC, nullptr },
        { "get_triple_des_cbc", (PyCFunction)SymmetricAlgorithmNames_get_TripleDesCbc, METH_NOARGS | METH_STATIC, nullptr },
        { "get_triple_des_cbc_pkcs7", (PyCFunction)SymmetricAlgorithmNames_get_TripleDesCbcPkcs7, METH_NOARGS | METH_STATIC, nullptr },
        { "get_triple_des_ecb", (PyCFunction)SymmetricAlgorithmNames_get_TripleDesEcb, METH_NOARGS | METH_STATIC, nullptr },
        { "get_triple_des_ecb_pkcs7", (PyCFunction)SymmetricAlgorithmNames_get_TripleDesEcbPkcs7, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SymmetricAlgorithmNames[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_SymmetricAlgorithmNames[] = 
    {
        { Py_tp_new, _new_SymmetricAlgorithmNames },
        { Py_tp_methods, _methods_SymmetricAlgorithmNames },
        { Py_tp_getset, _getset_SymmetricAlgorithmNames },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SymmetricAlgorithmNames =
    {
        "_winrt_Windows_Security_Cryptography_Core.SymmetricAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SymmetricAlgorithmNames
    };

    // ----- SymmetricKeyAlgorithmProvider class --------------------
    constexpr const char* const _type_name_SymmetricKeyAlgorithmProvider = "SymmetricKeyAlgorithmProvider";

    static PyObject* _new_SymmetricKeyAlgorithmProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SymmetricKeyAlgorithmProvider);
        return nullptr;
    }

    static void _dealloc_SymmetricKeyAlgorithmProvider(py::wrapper::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SymmetricKeyAlgorithmProvider_CreateSymmetricKey(py::wrapper::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.CreateSymmetricKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SymmetricKeyAlgorithmProvider_OpenAlgorithm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider::OpenAlgorithm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SymmetricKeyAlgorithmProvider_get_AlgorithmName(py::wrapper::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricKeyAlgorithmProvider_get_BlockLength(py::wrapper::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BlockLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SymmetricKeyAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SymmetricKeyAlgorithmProvider[] = {
        { "create_symmetric_key", (PyCFunction)SymmetricKeyAlgorithmProvider_CreateSymmetricKey, METH_VARARGS, nullptr },
        { "open_algorithm", (PyCFunction)SymmetricKeyAlgorithmProvider_OpenAlgorithm, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_SymmetricKeyAlgorithmProvider, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SymmetricKeyAlgorithmProvider[] = {
        { const_cast<char*>("algorithm_name"), (getter)SymmetricKeyAlgorithmProvider_get_AlgorithmName, nullptr, nullptr, nullptr },
        { const_cast<char*>("block_length"), (getter)SymmetricKeyAlgorithmProvider_get_BlockLength, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SymmetricKeyAlgorithmProvider[] = 
    {
        { Py_tp_new, _new_SymmetricKeyAlgorithmProvider },
        { Py_tp_dealloc, _dealloc_SymmetricKeyAlgorithmProvider },
        { Py_tp_methods, _methods_SymmetricKeyAlgorithmProvider },
        { Py_tp_getset, _getset_SymmetricKeyAlgorithmProvider },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SymmetricKeyAlgorithmProvider =
    {
        "_winrt_Windows_Security_Cryptography_Core.SymmetricKeyAlgorithmProvider",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SymmetricKeyAlgorithmProvider
    };

    // ----- Windows.Security.Cryptography.Core Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames>::python_type = py::register_python_type(module, _type_name_AsymmetricAlgorithmNames, &_type_spec_AsymmetricAlgorithmNames, nullptr);
            py::winrt_type<winrt::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider>::python_type = py::register_python_type(module, _type_name_AsymmetricKeyAlgorithmProvider, &_type_spec_AsymmetricKeyAlgorithmProvider, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Core::CryptographicEngine>::python_type = py::register_python_type(module, _type_name_CryptographicEngine, &_type_spec_CryptographicEngine, nullptr);
            py::winrt_type<winrt::Windows::Security::Cryptography::Core::CryptographicHash>::python_type = py::register_python_type(module, _type_name_CryptographicHash, &_type_spec_CryptographicHash, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Core::CryptographicKey>::python_type = py::register_python_type(module, _type_name_CryptographicKey, &_type_spec_CryptographicKey, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Core::EccCurveNames>::python_type = py::register_python_type(module, _type_name_EccCurveNames, &_type_spec_EccCurveNames, nullptr);
            py::winrt_type<winrt::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData>::python_type = py::register_python_type(module, _type_name_EncryptedAndAuthenticatedData, &_type_spec_EncryptedAndAuthenticatedData, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames>::python_type = py::register_python_type(module, _type_name_HashAlgorithmNames, &_type_spec_HashAlgorithmNames, nullptr);
            py::winrt_type<winrt::Windows::Security::Cryptography::Core::HashAlgorithmProvider>::python_type = py::register_python_type(module, _type_name_HashAlgorithmProvider, &_type_spec_HashAlgorithmProvider, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames>::python_type = py::register_python_type(module, _type_name_KeyDerivationAlgorithmNames, &_type_spec_KeyDerivationAlgorithmNames, nullptr);
            py::winrt_type<winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider>::python_type = py::register_python_type(module, _type_name_KeyDerivationAlgorithmProvider, &_type_spec_KeyDerivationAlgorithmProvider, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters>::python_type = py::register_python_type(module, _type_name_KeyDerivationParameters, &_type_spec_KeyDerivationParameters, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames>::python_type = py::register_python_type(module, _type_name_MacAlgorithmNames, &_type_spec_MacAlgorithmNames, nullptr);
            py::winrt_type<winrt::Windows::Security::Cryptography::Core::MacAlgorithmProvider>::python_type = py::register_python_type(module, _type_name_MacAlgorithmProvider, &_type_spec_MacAlgorithmProvider, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Core::PersistedKeyProvider>::python_type = py::register_python_type(module, _type_name_PersistedKeyProvider, &_type_spec_PersistedKeyProvider, nullptr);
            py::winrt_type<winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames>::python_type = py::register_python_type(module, _type_name_SymmetricAlgorithmNames, &_type_spec_SymmetricAlgorithmNames, nullptr);
            py::winrt_type<winrt::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider>::python_type = py::register_python_type(module, _type_name_SymmetricKeyAlgorithmProvider, &_type_spec_SymmetricKeyAlgorithmProvider, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Security.Cryptography.Core");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Security_Cryptography_Core",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Security::Cryptography::Core

PyMODINIT_FUNC
PyInit__winrt_Windows_Security_Cryptography_Core (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Security::Cryptography::Core::module_def);
}
