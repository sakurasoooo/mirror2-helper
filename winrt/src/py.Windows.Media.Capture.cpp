// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Media.Capture.h"

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AdvancedCapturedPhoto>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AdvancedPhotoCapture>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppCapture>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::CameraCaptureUI>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::CapturedFrame>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::CapturedFrameControlValues>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::CapturedPhoto>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::LowLagMediaRecording>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::LowLagPhotoCapture>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::LowLagPhotoSequenceCapture>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCapture>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureFailedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureInitializationSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCapturePauseResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureRelativePanelWatcher>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureStopResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureVideoProfile>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::PhotoCapturedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::VideoStreamConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::WhiteBalanceGain>::python_type;

PyObject* py::converter<winrt::Windows::Media::Capture::WhiteBalanceGain>::convert(winrt::Windows::Media::Capture::WhiteBalanceGain instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Media::Capture::WhiteBalanceGain>());
}
winrt::Windows::Media::Capture::WhiteBalanceGain py::converter<winrt::Windows::Media::Capture::WhiteBalanceGain>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Media::Capture::WhiteBalanceGain>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Media::Capture::WhiteBalanceGain>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Media::Capture::WhiteBalanceGain return_value{};

    PyObject* py_R = PyDict_GetItemString(obj, "r");
    if (!py_R) { throw winrt::hresult_invalid_argument(); }
    return_value.R = converter<double>::convert_to(py_R);

    PyObject* py_G = PyDict_GetItemString(obj, "g");
    if (!py_G) { throw winrt::hresult_invalid_argument(); }
    return_value.G = converter<double>::convert_to(py_G);

    PyObject* py_B = PyDict_GetItemString(obj, "b");
    if (!py_B) { throw winrt::hresult_invalid_argument(); }
    return_value.B = converter<double>::convert_to(py_B);

    return return_value;
}

namespace py::cpp::Windows::Media::Capture
{
    // ----- AdvancedCapturedPhoto class --------------------
    constexpr const char* const _type_name_AdvancedCapturedPhoto = "AdvancedCapturedPhoto";

    static PyObject* _new_AdvancedCapturedPhoto(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AdvancedCapturedPhoto);
        return nullptr;
    }

    static void _dealloc_AdvancedCapturedPhoto(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdvancedCapturedPhoto_get_Context(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Context());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedCapturedPhoto_get_Frame(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedCapturedPhoto_get_Mode(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedCapturedPhoto_get_FrameBoundsRelativeToReferencePhoto(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameBoundsRelativeToReferencePhoto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AdvancedCapturedPhoto(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AdvancedCapturedPhoto>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdvancedCapturedPhoto[] = {
        { "_from", (PyCFunction)_from_AdvancedCapturedPhoto, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AdvancedCapturedPhoto[] = {
        { const_cast<char*>("context"), (getter)AdvancedCapturedPhoto_get_Context, nullptr, nullptr, nullptr },
        { const_cast<char*>("frame"), (getter)AdvancedCapturedPhoto_get_Frame, nullptr, nullptr, nullptr },
        { const_cast<char*>("mode"), (getter)AdvancedCapturedPhoto_get_Mode, nullptr, nullptr, nullptr },
        { const_cast<char*>("frame_bounds_relative_to_reference_photo"), (getter)AdvancedCapturedPhoto_get_FrameBoundsRelativeToReferencePhoto, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AdvancedCapturedPhoto[] = 
    {
        { Py_tp_new, _new_AdvancedCapturedPhoto },
        { Py_tp_dealloc, _dealloc_AdvancedCapturedPhoto },
        { Py_tp_methods, _methods_AdvancedCapturedPhoto },
        { Py_tp_getset, _getset_AdvancedCapturedPhoto },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AdvancedCapturedPhoto =
    {
        "_winrt_Windows_Media_Capture.AdvancedCapturedPhoto",
        sizeof(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdvancedCapturedPhoto
    };

    // ----- AdvancedPhotoCapture class --------------------
    constexpr const char* const _type_name_AdvancedPhotoCapture = "AdvancedPhotoCapture";

    static PyObject* _new_AdvancedPhotoCapture(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AdvancedPhotoCapture);
        return nullptr;
    }

    static void _dealloc_AdvancedPhotoCapture(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdvancedPhotoCapture_CaptureAsync(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CaptureAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.CaptureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoCapture_FinishAsync(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FinishAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoCapture_add_AllPhotosCaptured(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AdvancedPhotoCapture, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AllPhotosCaptured(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoCapture_remove_AllPhotosCaptured(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AllPhotosCaptured(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoCapture_add_OptionalReferencePhotoCaptured(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AdvancedPhotoCapture, winrt::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs>>(arg);

            return py::convert(self->obj.OptionalReferencePhotoCaptured(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoCapture_remove_OptionalReferencePhotoCaptured(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OptionalReferencePhotoCaptured(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AdvancedPhotoCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AdvancedPhotoCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdvancedPhotoCapture[] = {
        { "capture_async", (PyCFunction)AdvancedPhotoCapture_CaptureAsync, METH_VARARGS, nullptr },
        { "finish_async", (PyCFunction)AdvancedPhotoCapture_FinishAsync, METH_VARARGS, nullptr },
        { "add_all_photos_captured", (PyCFunction)AdvancedPhotoCapture_add_AllPhotosCaptured, METH_O, nullptr },
        { "remove_all_photos_captured", (PyCFunction)AdvancedPhotoCapture_remove_AllPhotosCaptured, METH_O, nullptr },
        { "add_optional_reference_photo_captured", (PyCFunction)AdvancedPhotoCapture_add_OptionalReferencePhotoCaptured, METH_O, nullptr },
        { "remove_optional_reference_photo_captured", (PyCFunction)AdvancedPhotoCapture_remove_OptionalReferencePhotoCaptured, METH_O, nullptr },
        { "_from", (PyCFunction)_from_AdvancedPhotoCapture, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AdvancedPhotoCapture[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_AdvancedPhotoCapture[] = 
    {
        { Py_tp_new, _new_AdvancedPhotoCapture },
        { Py_tp_dealloc, _dealloc_AdvancedPhotoCapture },
        { Py_tp_methods, _methods_AdvancedPhotoCapture },
        { Py_tp_getset, _getset_AdvancedPhotoCapture },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AdvancedPhotoCapture =
    {
        "_winrt_Windows_Media_Capture.AdvancedPhotoCapture",
        sizeof(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdvancedPhotoCapture
    };

    // ----- AppCapture class --------------------
    constexpr const char* const _type_name_AppCapture = "AppCapture";

    static PyObject* _new_AppCapture(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppCapture);
        return nullptr;
    }

    static void _dealloc_AppCapture(py::wrapper::Windows::Media::Capture::AppCapture* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppCapture_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::Capture::AppCapture::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCapture_SetAllowedAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(winrt::Windows::Media::Capture::AppCapture::SetAllowedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCapture_get_IsCapturingAudio(py::wrapper::Windows::Media::Capture::AppCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCapturingAudio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCapture_get_IsCapturingVideo(py::wrapper::Windows::Media::Capture::AppCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCapturingVideo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCapture_add_CapturingChanged(py::wrapper::Windows::Media::Capture::AppCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppCapture, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CapturingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCapture_remove_CapturingChanged(py::wrapper::Windows::Media::Capture::AppCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CapturingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCapture[] = {
        { "get_for_current_view", (PyCFunction)AppCapture_GetForCurrentView, METH_VARARGS | METH_STATIC, nullptr },
        { "set_allowed_async", (PyCFunction)AppCapture_SetAllowedAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "add_capturing_changed", (PyCFunction)AppCapture_add_CapturingChanged, METH_O, nullptr },
        { "remove_capturing_changed", (PyCFunction)AppCapture_remove_CapturingChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_AppCapture, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppCapture[] = {
        { const_cast<char*>("is_capturing_audio"), (getter)AppCapture_get_IsCapturingAudio, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_capturing_video"), (getter)AppCapture_get_IsCapturingVideo, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AppCapture[] = 
    {
        { Py_tp_new, _new_AppCapture },
        { Py_tp_dealloc, _dealloc_AppCapture },
        { Py_tp_methods, _methods_AppCapture },
        { Py_tp_getset, _getset_AppCapture },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppCapture =
    {
        "_winrt_Windows_Media_Capture.AppCapture",
        sizeof(py::wrapper::Windows::Media::Capture::AppCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCapture
    };

    // ----- CameraCaptureUI class --------------------
    constexpr const char* const _type_name_CameraCaptureUI = "CameraCaptureUI";

    static PyObject* _new_CameraCaptureUI(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Capture::CameraCaptureUI instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CameraCaptureUI(py::wrapper::Windows::Media::Capture::CameraCaptureUI* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CameraCaptureUI_CaptureFileAsync(py::wrapper::Windows::Media::Capture::CameraCaptureUI* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::CameraCaptureUIMode>(args, 0);

                return py::convert(self->obj.CaptureFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraCaptureUI_get_PhotoSettings(py::wrapper::Windows::Media::Capture::CameraCaptureUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhotoSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraCaptureUI_get_VideoSettings(py::wrapper::Windows::Media::Capture::CameraCaptureUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CameraCaptureUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CameraCaptureUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraCaptureUI[] = {
        { "capture_file_async", (PyCFunction)CameraCaptureUI_CaptureFileAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_CameraCaptureUI, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CameraCaptureUI[] = {
        { const_cast<char*>("photo_settings"), (getter)CameraCaptureUI_get_PhotoSettings, nullptr, nullptr, nullptr },
        { const_cast<char*>("video_settings"), (getter)CameraCaptureUI_get_VideoSettings, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CameraCaptureUI[] = 
    {
        { Py_tp_new, _new_CameraCaptureUI },
        { Py_tp_dealloc, _dealloc_CameraCaptureUI },
        { Py_tp_methods, _methods_CameraCaptureUI },
        { Py_tp_getset, _getset_CameraCaptureUI },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CameraCaptureUI =
    {
        "_winrt_Windows_Media_Capture.CameraCaptureUI",
        sizeof(py::wrapper::Windows::Media::Capture::CameraCaptureUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraCaptureUI
    };

    // ----- CameraCaptureUIPhotoCaptureSettings class --------------------
    constexpr const char* const _type_name_CameraCaptureUIPhotoCaptureSettings = "CameraCaptureUIPhotoCaptureSettings";

    static PyObject* _new_CameraCaptureUIPhotoCaptureSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CameraCaptureUIPhotoCaptureSettings);
        return nullptr;
    }

    static void _dealloc_CameraCaptureUIPhotoCaptureSettings(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CameraCaptureUIPhotoCaptureSettings_get_MaxResolution(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIPhotoCaptureSettings_put_MaxResolution(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::CameraCaptureUIMaxPhotoResolution>(arg);

            self->obj.MaxResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIPhotoCaptureSettings_get_Format(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIPhotoCaptureSettings_put_Format(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::CameraCaptureUIPhotoFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIPhotoCaptureSettings_get_CroppedSizeInPixels(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CroppedSizeInPixels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIPhotoCaptureSettings_put_CroppedSizeInPixels(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.CroppedSizeInPixels(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIPhotoCaptureSettings_get_CroppedAspectRatio(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CroppedAspectRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIPhotoCaptureSettings_put_CroppedAspectRatio(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.CroppedAspectRatio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIPhotoCaptureSettings_get_AllowCropping(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowCropping());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIPhotoCaptureSettings_put_AllowCropping(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowCropping(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_CameraCaptureUIPhotoCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraCaptureUIPhotoCaptureSettings[] = {
        { "_from", (PyCFunction)_from_CameraCaptureUIPhotoCaptureSettings, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CameraCaptureUIPhotoCaptureSettings[] = {
        { const_cast<char*>("max_resolution"), (getter)CameraCaptureUIPhotoCaptureSettings_get_MaxResolution, (setter)CameraCaptureUIPhotoCaptureSettings_put_MaxResolution, nullptr, nullptr },
        { const_cast<char*>("format"), (getter)CameraCaptureUIPhotoCaptureSettings_get_Format, (setter)CameraCaptureUIPhotoCaptureSettings_put_Format, nullptr, nullptr },
        { const_cast<char*>("cropped_size_in_pixels"), (getter)CameraCaptureUIPhotoCaptureSettings_get_CroppedSizeInPixels, (setter)CameraCaptureUIPhotoCaptureSettings_put_CroppedSizeInPixels, nullptr, nullptr },
        { const_cast<char*>("cropped_aspect_ratio"), (getter)CameraCaptureUIPhotoCaptureSettings_get_CroppedAspectRatio, (setter)CameraCaptureUIPhotoCaptureSettings_put_CroppedAspectRatio, nullptr, nullptr },
        { const_cast<char*>("allow_cropping"), (getter)CameraCaptureUIPhotoCaptureSettings_get_AllowCropping, (setter)CameraCaptureUIPhotoCaptureSettings_put_AllowCropping, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CameraCaptureUIPhotoCaptureSettings[] = 
    {
        { Py_tp_new, _new_CameraCaptureUIPhotoCaptureSettings },
        { Py_tp_dealloc, _dealloc_CameraCaptureUIPhotoCaptureSettings },
        { Py_tp_methods, _methods_CameraCaptureUIPhotoCaptureSettings },
        { Py_tp_getset, _getset_CameraCaptureUIPhotoCaptureSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CameraCaptureUIPhotoCaptureSettings =
    {
        "_winrt_Windows_Media_Capture.CameraCaptureUIPhotoCaptureSettings",
        sizeof(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraCaptureUIPhotoCaptureSettings
    };

    // ----- CameraCaptureUIVideoCaptureSettings class --------------------
    constexpr const char* const _type_name_CameraCaptureUIVideoCaptureSettings = "CameraCaptureUIVideoCaptureSettings";

    static PyObject* _new_CameraCaptureUIVideoCaptureSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CameraCaptureUIVideoCaptureSettings);
        return nullptr;
    }

    static void _dealloc_CameraCaptureUIVideoCaptureSettings(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CameraCaptureUIVideoCaptureSettings_get_MaxResolution(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIVideoCaptureSettings_put_MaxResolution(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::CameraCaptureUIMaxVideoResolution>(arg);

            self->obj.MaxResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIVideoCaptureSettings_get_MaxDurationInSeconds(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxDurationInSeconds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIVideoCaptureSettings_put_MaxDurationInSeconds(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.MaxDurationInSeconds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIVideoCaptureSettings_get_Format(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIVideoCaptureSettings_put_Format(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::CameraCaptureUIVideoFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIVideoCaptureSettings_get_AllowTrimming(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowTrimming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIVideoCaptureSettings_put_AllowTrimming(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowTrimming(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_CameraCaptureUIVideoCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraCaptureUIVideoCaptureSettings[] = {
        { "_from", (PyCFunction)_from_CameraCaptureUIVideoCaptureSettings, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CameraCaptureUIVideoCaptureSettings[] = {
        { const_cast<char*>("max_resolution"), (getter)CameraCaptureUIVideoCaptureSettings_get_MaxResolution, (setter)CameraCaptureUIVideoCaptureSettings_put_MaxResolution, nullptr, nullptr },
        { const_cast<char*>("max_duration_in_seconds"), (getter)CameraCaptureUIVideoCaptureSettings_get_MaxDurationInSeconds, (setter)CameraCaptureUIVideoCaptureSettings_put_MaxDurationInSeconds, nullptr, nullptr },
        { const_cast<char*>("format"), (getter)CameraCaptureUIVideoCaptureSettings_get_Format, (setter)CameraCaptureUIVideoCaptureSettings_put_Format, nullptr, nullptr },
        { const_cast<char*>("allow_trimming"), (getter)CameraCaptureUIVideoCaptureSettings_get_AllowTrimming, (setter)CameraCaptureUIVideoCaptureSettings_put_AllowTrimming, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CameraCaptureUIVideoCaptureSettings[] = 
    {
        { Py_tp_new, _new_CameraCaptureUIVideoCaptureSettings },
        { Py_tp_dealloc, _dealloc_CameraCaptureUIVideoCaptureSettings },
        { Py_tp_methods, _methods_CameraCaptureUIVideoCaptureSettings },
        { Py_tp_getset, _getset_CameraCaptureUIVideoCaptureSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CameraCaptureUIVideoCaptureSettings =
    {
        "_winrt_Windows_Media_Capture.CameraCaptureUIVideoCaptureSettings",
        sizeof(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraCaptureUIVideoCaptureSettings
    };

    // ----- CapturedFrame class --------------------
    constexpr const char* const _type_name_CapturedFrame = "CapturedFrame";

    static PyObject* _new_CapturedFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CapturedFrame);
        return nullptr;
    }

    static void _dealloc_CapturedFrame(py::wrapper::Windows::Media::Capture::CapturedFrame* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CapturedFrame_CloneStream(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CloneStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_Close(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_FlushAsync(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_GetInputStreamAt(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetInputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_GetOutputStreamAt(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetOutputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_ReadAsync(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_Seek(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_WriteAsync(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_Height(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_Width(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_BitmapProperties(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_ControlValues(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ControlValues());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_SoftwareBitmap(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SoftwareBitmap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_ContentType(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_Size(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CapturedFrame_put_Size(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CapturedFrame_get_CanRead(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_CanWrite(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_Position(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CapturedFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CapturedFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_CapturedFrame(py::wrapper::Windows::Media::Capture::CapturedFrame* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_CapturedFrame(py::wrapper::Windows::Media::Capture::CapturedFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CapturedFrame[] = {
        { "clone_stream", (PyCFunction)CapturedFrame_CloneStream, METH_VARARGS, nullptr },
        { "close", (PyCFunction)CapturedFrame_Close, METH_VARARGS, nullptr },
        { "flush_async", (PyCFunction)CapturedFrame_FlushAsync, METH_VARARGS, nullptr },
        { "get_input_stream_at", (PyCFunction)CapturedFrame_GetInputStreamAt, METH_VARARGS, nullptr },
        { "get_output_stream_at", (PyCFunction)CapturedFrame_GetOutputStreamAt, METH_VARARGS, nullptr },
        { "read_async", (PyCFunction)CapturedFrame_ReadAsync, METH_VARARGS, nullptr },
        { "seek", (PyCFunction)CapturedFrame_Seek, METH_VARARGS, nullptr },
        { "write_async", (PyCFunction)CapturedFrame_WriteAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_CapturedFrame, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_CapturedFrame, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_CapturedFrame, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CapturedFrame[] = {
        { const_cast<char*>("height"), (getter)CapturedFrame_get_Height, nullptr, nullptr, nullptr },
        { const_cast<char*>("width"), (getter)CapturedFrame_get_Width, nullptr, nullptr, nullptr },
        { const_cast<char*>("bitmap_properties"), (getter)CapturedFrame_get_BitmapProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("control_values"), (getter)CapturedFrame_get_ControlValues, nullptr, nullptr, nullptr },
        { const_cast<char*>("software_bitmap"), (getter)CapturedFrame_get_SoftwareBitmap, nullptr, nullptr, nullptr },
        { const_cast<char*>("content_type"), (getter)CapturedFrame_get_ContentType, nullptr, nullptr, nullptr },
        { const_cast<char*>("size"), (getter)CapturedFrame_get_Size, (setter)CapturedFrame_put_Size, nullptr, nullptr },
        { const_cast<char*>("can_read"), (getter)CapturedFrame_get_CanRead, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_write"), (getter)CapturedFrame_get_CanWrite, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)CapturedFrame_get_Position, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CapturedFrame[] = 
    {
        { Py_tp_new, _new_CapturedFrame },
        { Py_tp_dealloc, _dealloc_CapturedFrame },
        { Py_tp_methods, _methods_CapturedFrame },
        { Py_tp_getset, _getset_CapturedFrame },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CapturedFrame =
    {
        "_winrt_Windows_Media_Capture.CapturedFrame",
        sizeof(py::wrapper::Windows::Media::Capture::CapturedFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CapturedFrame
    };

    // ----- CapturedFrameControlValues class --------------------
    constexpr const char* const _type_name_CapturedFrameControlValues = "CapturedFrameControlValues";

    static PyObject* _new_CapturedFrameControlValues(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CapturedFrameControlValues);
        return nullptr;
    }

    static void _dealloc_CapturedFrameControlValues(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CapturedFrameControlValues_get_Exposure(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Exposure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_ExposureCompensation(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExposureCompensation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_FlashPowerPercent(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FlashPowerPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_Flashed(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Flashed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_Focus(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Focus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_IsoSpeed(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsoSpeed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_SceneMode(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SceneMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_WhiteBalance(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WhiteBalance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_ZoomFactor(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZoomFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_FocusState(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FocusState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_IsoAnalogGain(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsoAnalogGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_IsoDigitalGain(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsoDigitalGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_SensorFrameRate(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SensorFrameRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_WhiteBalanceGain(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WhiteBalanceGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CapturedFrameControlValues(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CapturedFrameControlValues>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CapturedFrameControlValues[] = {
        { "_from", (PyCFunction)_from_CapturedFrameControlValues, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CapturedFrameControlValues[] = {
        { const_cast<char*>("exposure"), (getter)CapturedFrameControlValues_get_Exposure, nullptr, nullptr, nullptr },
        { const_cast<char*>("exposure_compensation"), (getter)CapturedFrameControlValues_get_ExposureCompensation, nullptr, nullptr, nullptr },
        { const_cast<char*>("flash_power_percent"), (getter)CapturedFrameControlValues_get_FlashPowerPercent, nullptr, nullptr, nullptr },
        { const_cast<char*>("flashed"), (getter)CapturedFrameControlValues_get_Flashed, nullptr, nullptr, nullptr },
        { const_cast<char*>("focus"), (getter)CapturedFrameControlValues_get_Focus, nullptr, nullptr, nullptr },
        { const_cast<char*>("iso_speed"), (getter)CapturedFrameControlValues_get_IsoSpeed, nullptr, nullptr, nullptr },
        { const_cast<char*>("scene_mode"), (getter)CapturedFrameControlValues_get_SceneMode, nullptr, nullptr, nullptr },
        { const_cast<char*>("white_balance"), (getter)CapturedFrameControlValues_get_WhiteBalance, nullptr, nullptr, nullptr },
        { const_cast<char*>("zoom_factor"), (getter)CapturedFrameControlValues_get_ZoomFactor, nullptr, nullptr, nullptr },
        { const_cast<char*>("focus_state"), (getter)CapturedFrameControlValues_get_FocusState, nullptr, nullptr, nullptr },
        { const_cast<char*>("iso_analog_gain"), (getter)CapturedFrameControlValues_get_IsoAnalogGain, nullptr, nullptr, nullptr },
        { const_cast<char*>("iso_digital_gain"), (getter)CapturedFrameControlValues_get_IsoDigitalGain, nullptr, nullptr, nullptr },
        { const_cast<char*>("sensor_frame_rate"), (getter)CapturedFrameControlValues_get_SensorFrameRate, nullptr, nullptr, nullptr },
        { const_cast<char*>("white_balance_gain"), (getter)CapturedFrameControlValues_get_WhiteBalanceGain, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CapturedFrameControlValues[] = 
    {
        { Py_tp_new, _new_CapturedFrameControlValues },
        { Py_tp_dealloc, _dealloc_CapturedFrameControlValues },
        { Py_tp_methods, _methods_CapturedFrameControlValues },
        { Py_tp_getset, _getset_CapturedFrameControlValues },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CapturedFrameControlValues =
    {
        "_winrt_Windows_Media_Capture.CapturedFrameControlValues",
        sizeof(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CapturedFrameControlValues
    };

    // ----- CapturedPhoto class --------------------
    constexpr const char* const _type_name_CapturedPhoto = "CapturedPhoto";

    static PyObject* _new_CapturedPhoto(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CapturedPhoto);
        return nullptr;
    }

    static void _dealloc_CapturedPhoto(py::wrapper::Windows::Media::Capture::CapturedPhoto* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CapturedPhoto_get_Frame(py::wrapper::Windows::Media::Capture::CapturedPhoto* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedPhoto_get_Thumbnail(py::wrapper::Windows::Media::Capture::CapturedPhoto* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CapturedPhoto(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CapturedPhoto>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CapturedPhoto[] = {
        { "_from", (PyCFunction)_from_CapturedPhoto, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CapturedPhoto[] = {
        { const_cast<char*>("frame"), (getter)CapturedPhoto_get_Frame, nullptr, nullptr, nullptr },
        { const_cast<char*>("thumbnail"), (getter)CapturedPhoto_get_Thumbnail, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CapturedPhoto[] = 
    {
        { Py_tp_new, _new_CapturedPhoto },
        { Py_tp_dealloc, _dealloc_CapturedPhoto },
        { Py_tp_methods, _methods_CapturedPhoto },
        { Py_tp_getset, _getset_CapturedPhoto },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CapturedPhoto =
    {
        "_winrt_Windows_Media_Capture.CapturedPhoto",
        sizeof(py::wrapper::Windows::Media::Capture::CapturedPhoto),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CapturedPhoto
    };

    // ----- LowLagMediaRecording class --------------------
    constexpr const char* const _type_name_LowLagMediaRecording = "LowLagMediaRecording";

    static PyObject* _new_LowLagMediaRecording(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LowLagMediaRecording);
        return nullptr;
    }

    static void _dealloc_LowLagMediaRecording(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LowLagMediaRecording_FinishAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FinishAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_PauseAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::MediaCapturePauseBehavior>(args, 0);

                return py::convert(self->obj.PauseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_PauseWithResultAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::MediaCapturePauseBehavior>(args, 0);

                return py::convert(self->obj.PauseWithResultAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_ResumeAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ResumeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_StartAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_StopAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StopAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_StopWithResultAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StopWithResultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_LowLagMediaRecording(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::LowLagMediaRecording>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLagMediaRecording[] = {
        { "finish_async", (PyCFunction)LowLagMediaRecording_FinishAsync, METH_VARARGS, nullptr },
        { "pause_async", (PyCFunction)LowLagMediaRecording_PauseAsync, METH_VARARGS, nullptr },
        { "pause_with_result_async", (PyCFunction)LowLagMediaRecording_PauseWithResultAsync, METH_VARARGS, nullptr },
        { "resume_async", (PyCFunction)LowLagMediaRecording_ResumeAsync, METH_VARARGS, nullptr },
        { "start_async", (PyCFunction)LowLagMediaRecording_StartAsync, METH_VARARGS, nullptr },
        { "stop_async", (PyCFunction)LowLagMediaRecording_StopAsync, METH_VARARGS, nullptr },
        { "stop_with_result_async", (PyCFunction)LowLagMediaRecording_StopWithResultAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_LowLagMediaRecording, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LowLagMediaRecording[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_LowLagMediaRecording[] = 
    {
        { Py_tp_new, _new_LowLagMediaRecording },
        { Py_tp_dealloc, _dealloc_LowLagMediaRecording },
        { Py_tp_methods, _methods_LowLagMediaRecording },
        { Py_tp_getset, _getset_LowLagMediaRecording },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LowLagMediaRecording =
    {
        "_winrt_Windows_Media_Capture.LowLagMediaRecording",
        sizeof(py::wrapper::Windows::Media::Capture::LowLagMediaRecording),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLagMediaRecording
    };

    // ----- LowLagPhotoCapture class --------------------
    constexpr const char* const _type_name_LowLagPhotoCapture = "LowLagPhotoCapture";

    static PyObject* _new_LowLagPhotoCapture(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LowLagPhotoCapture);
        return nullptr;
    }

    static void _dealloc_LowLagPhotoCapture(py::wrapper::Windows::Media::Capture::LowLagPhotoCapture* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LowLagPhotoCapture_CaptureAsync(py::wrapper::Windows::Media::Capture::LowLagPhotoCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CaptureAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoCapture_FinishAsync(py::wrapper::Windows::Media::Capture::LowLagPhotoCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FinishAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_LowLagPhotoCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::LowLagPhotoCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLagPhotoCapture[] = {
        { "capture_async", (PyCFunction)LowLagPhotoCapture_CaptureAsync, METH_VARARGS, nullptr },
        { "finish_async", (PyCFunction)LowLagPhotoCapture_FinishAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_LowLagPhotoCapture, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LowLagPhotoCapture[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_LowLagPhotoCapture[] = 
    {
        { Py_tp_new, _new_LowLagPhotoCapture },
        { Py_tp_dealloc, _dealloc_LowLagPhotoCapture },
        { Py_tp_methods, _methods_LowLagPhotoCapture },
        { Py_tp_getset, _getset_LowLagPhotoCapture },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LowLagPhotoCapture =
    {
        "_winrt_Windows_Media_Capture.LowLagPhotoCapture",
        sizeof(py::wrapper::Windows::Media::Capture::LowLagPhotoCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLagPhotoCapture
    };

    // ----- LowLagPhotoSequenceCapture class --------------------
    constexpr const char* const _type_name_LowLagPhotoSequenceCapture = "LowLagPhotoSequenceCapture";

    static PyObject* _new_LowLagPhotoSequenceCapture(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LowLagPhotoSequenceCapture);
        return nullptr;
    }

    static void _dealloc_LowLagPhotoSequenceCapture(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LowLagPhotoSequenceCapture_FinishAsync(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FinishAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceCapture_StartAsync(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceCapture_StopAsync(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StopAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceCapture_add_PhotoCaptured(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::LowLagPhotoSequenceCapture, winrt::Windows::Media::Capture::PhotoCapturedEventArgs>>(arg);

            return py::convert(self->obj.PhotoCaptured(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceCapture_remove_PhotoCaptured(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PhotoCaptured(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LowLagPhotoSequenceCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::LowLagPhotoSequenceCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLagPhotoSequenceCapture[] = {
        { "finish_async", (PyCFunction)LowLagPhotoSequenceCapture_FinishAsync, METH_VARARGS, nullptr },
        { "start_async", (PyCFunction)LowLagPhotoSequenceCapture_StartAsync, METH_VARARGS, nullptr },
        { "stop_async", (PyCFunction)LowLagPhotoSequenceCapture_StopAsync, METH_VARARGS, nullptr },
        { "add_photo_captured", (PyCFunction)LowLagPhotoSequenceCapture_add_PhotoCaptured, METH_O, nullptr },
        { "remove_photo_captured", (PyCFunction)LowLagPhotoSequenceCapture_remove_PhotoCaptured, METH_O, nullptr },
        { "_from", (PyCFunction)_from_LowLagPhotoSequenceCapture, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LowLagPhotoSequenceCapture[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_LowLagPhotoSequenceCapture[] = 
    {
        { Py_tp_new, _new_LowLagPhotoSequenceCapture },
        { Py_tp_dealloc, _dealloc_LowLagPhotoSequenceCapture },
        { Py_tp_methods, _methods_LowLagPhotoSequenceCapture },
        { Py_tp_getset, _getset_LowLagPhotoSequenceCapture },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LowLagPhotoSequenceCapture =
    {
        "_winrt_Windows_Media_Capture.LowLagPhotoSequenceCapture",
        sizeof(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLagPhotoSequenceCapture
    };

    // ----- MediaCapture class --------------------
    constexpr const char* const _type_name_MediaCapture = "MediaCapture";

    static PyObject* _new_MediaCapture(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Capture::MediaCapture instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaCapture(py::wrapper::Windows::Media::Capture::MediaCapture* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCapture_AddAudioEffectAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                return py::convert(self->obj.AddAudioEffectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_AddEffectAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                return py::convert(self->obj.AddEffectAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_AddVideoEffectAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IVideoEffectDefinition>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 1);

                return py::convert(self->obj.AddVideoEffectAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_CapturePhotoToStorageFileAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);

                return py::convert(self->obj.CapturePhotoToStorageFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_CapturePhotoToStreamAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(self->obj.CapturePhotoToStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_ClearEffectsAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.ClearEffectsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_Close(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_CreateFrameReaderAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::Frames::MediaFrameSource>(args, 0);

                return py::convert(self->obj.CreateFrameReaderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::Frames::MediaFrameSource>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CreateFrameReaderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::Frames::MediaFrameSource>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapSize>(args, 2);

                return py::convert(self->obj.CreateFrameReaderAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_CreateMultiSourceFrameReaderAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Capture::Frames::MediaFrameSource>>(args, 0);

                return py::convert(self->obj.CreateMultiSourceFrameReaderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_CreateRelativePanelWatcher(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::StreamingCaptureMode>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::WindowManagement::DisplayRegion>(args, 1);

                return py::convert(self->obj.CreateRelativePanelWatcher(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_FindAllVideoProfiles(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Capture::MediaCapture::FindAllVideoProfiles(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_FindConcurrentProfiles(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Capture::MediaCapture::FindConcurrentProfiles(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_FindKnownVideoProfiles(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Capture::KnownVideoProfile>(args, 1);

                return py::convert(winrt::Windows::Media::Capture::MediaCapture::FindKnownVideoProfiles(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_GetEncoderProperty(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                return py::convert(self->obj.GetEncoderProperty(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_GetPreviewFrameAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPreviewFrameAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::VideoFrame>(args, 0);

                return py::convert(self->obj.GetPreviewFrameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_GetPreviewMirroring(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPreviewMirroring());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_GetPreviewRotation(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPreviewRotation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_GetRecordRotation(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRecordRotation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_InitializeAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.InitializeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureInitializationSettings>(args, 0);

                return py::convert(self->obj.InitializeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_IsVideoProfileSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Capture::MediaCapture::IsVideoProfileSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PauseRecordAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::MediaCapturePauseBehavior>(args, 0);

                return py::convert(self->obj.PauseRecordAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PauseRecordWithResultAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::MediaCapturePauseBehavior>(args, 0);

                return py::convert(self->obj.PauseRecordWithResultAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareAdvancedPhotoCaptureAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);

                return py::convert(self->obj.PrepareAdvancedPhotoCaptureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareLowLagPhotoCaptureAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);

                return py::convert(self->obj.PrepareLowLagPhotoCaptureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareLowLagPhotoSequenceCaptureAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);

                return py::convert(self->obj.PrepareLowLagPhotoSequenceCaptureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareLowLagRecordToCustomSinkAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::IMediaExtension>(args, 1);

                return py::convert(self->obj.PrepareLowLagRecordToCustomSinkAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                return py::convert(self->obj.PrepareLowLagRecordToCustomSinkAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareLowLagRecordToStorageFileAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);

                return py::convert(self->obj.PrepareLowLagRecordToStorageFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareLowLagRecordToStreamAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(self->obj.PrepareLowLagRecordToStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareVariablePhotoSequenceCaptureAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);

                return py::convert(self->obj.PrepareVariablePhotoSequenceCaptureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_RemoveEffectAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::IMediaExtension>(args, 0);

                return py::convert(self->obj.RemoveEffectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_ResumeRecordAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ResumeRecordAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_SetEncoderProperty(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                self->obj.SetEncoderProperty(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_SetEncodingPropertiesAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaPropertySet>(args, 2);

                return py::convert(self->obj.SetEncodingPropertiesAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_SetPreviewMirroring(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.SetPreviewMirroring(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_SetPreviewRotation(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::VideoRotation>(args, 0);

                self->obj.SetPreviewRotation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_SetRecordRotation(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::VideoRotation>(args, 0);

                self->obj.SetRecordRotation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StartPreviewAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartPreviewAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StartPreviewToCustomSinkAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::IMediaExtension>(args, 1);

                return py::convert(self->obj.StartPreviewToCustomSinkAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                return py::convert(self->obj.StartPreviewToCustomSinkAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StartRecordToCustomSinkAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::IMediaExtension>(args, 1);

                return py::convert(self->obj.StartRecordToCustomSinkAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                return py::convert(self->obj.StartRecordToCustomSinkAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StartRecordToStorageFileAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);

                return py::convert(self->obj.StartRecordToStorageFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StartRecordToStreamAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(self->obj.StartRecordToStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StopPreviewAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StopPreviewAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StopRecordAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StopRecordAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StopRecordWithResultAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StopRecordWithResultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_AudioDeviceController(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioDeviceController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_MediaCaptureSettings(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaCaptureSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_VideoDeviceController(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoDeviceController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_CameraStreamState(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CameraStreamState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_ThermalStatus(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ThermalStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_FrameSources(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameSources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_Failed(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureFailedEventHandler>(arg);

            return py::convert(self->obj.Failed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_Failed(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Failed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_RecordLimitationExceeded(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::RecordLimitationExceededEventHandler>(arg);

            return py::convert(self->obj.RecordLimitationExceeded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_RecordLimitationExceeded(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RecordLimitationExceeded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_FocusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCapture, winrt::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs>>(arg);

            return py::convert(self->obj.FocusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_FocusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FocusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_PhotoConfirmationCaptured(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCapture, winrt::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs>>(arg);

            return py::convert(self->obj.PhotoConfirmationCaptured(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_PhotoConfirmationCaptured(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PhotoConfirmationCaptured(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_CameraStreamStateChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCapture, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CameraStreamStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_CameraStreamStateChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CameraStreamStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_ThermalStatusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCapture, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ThermalStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_ThermalStatusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ThermalStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_CaptureDeviceExclusiveControlStatusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCapture, winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs>>(arg);

            return py::convert(self->obj.CaptureDeviceExclusiveControlStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_CaptureDeviceExclusiveControlStatusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CaptureDeviceExclusiveControlStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaCapture(py::wrapper::Windows::Media::Capture::MediaCapture* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_MediaCapture(py::wrapper::Windows::Media::Capture::MediaCapture* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCapture[] = {
        { "add_audio_effect_async", (PyCFunction)MediaCapture_AddAudioEffectAsync, METH_VARARGS, nullptr },
        { "add_effect_async", (PyCFunction)MediaCapture_AddEffectAsync, METH_VARARGS, nullptr },
        { "add_video_effect_async", (PyCFunction)MediaCapture_AddVideoEffectAsync, METH_VARARGS, nullptr },
        { "capture_photo_to_storage_file_async", (PyCFunction)MediaCapture_CapturePhotoToStorageFileAsync, METH_VARARGS, nullptr },
        { "capture_photo_to_stream_async", (PyCFunction)MediaCapture_CapturePhotoToStreamAsync, METH_VARARGS, nullptr },
        { "clear_effects_async", (PyCFunction)MediaCapture_ClearEffectsAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)MediaCapture_Close, METH_VARARGS, nullptr },
        { "create_frame_reader_async", (PyCFunction)MediaCapture_CreateFrameReaderAsync, METH_VARARGS, nullptr },
        { "create_multi_source_frame_reader_async", (PyCFunction)MediaCapture_CreateMultiSourceFrameReaderAsync, METH_VARARGS, nullptr },
        { "create_relative_panel_watcher", (PyCFunction)MediaCapture_CreateRelativePanelWatcher, METH_VARARGS, nullptr },
        { "find_all_video_profiles", (PyCFunction)MediaCapture_FindAllVideoProfiles, METH_VARARGS | METH_STATIC, nullptr },
        { "find_concurrent_profiles", (PyCFunction)MediaCapture_FindConcurrentProfiles, METH_VARARGS | METH_STATIC, nullptr },
        { "find_known_video_profiles", (PyCFunction)MediaCapture_FindKnownVideoProfiles, METH_VARARGS | METH_STATIC, nullptr },
        { "get_encoder_property", (PyCFunction)MediaCapture_GetEncoderProperty, METH_VARARGS, nullptr },
        { "get_preview_frame_async", (PyCFunction)MediaCapture_GetPreviewFrameAsync, METH_VARARGS, nullptr },
        { "get_preview_mirroring", (PyCFunction)MediaCapture_GetPreviewMirroring, METH_VARARGS, nullptr },
        { "get_preview_rotation", (PyCFunction)MediaCapture_GetPreviewRotation, METH_VARARGS, nullptr },
        { "get_record_rotation", (PyCFunction)MediaCapture_GetRecordRotation, METH_VARARGS, nullptr },
        { "initialize_async", (PyCFunction)MediaCapture_InitializeAsync, METH_VARARGS, nullptr },
        { "is_video_profile_supported", (PyCFunction)MediaCapture_IsVideoProfileSupported, METH_VARARGS | METH_STATIC, nullptr },
        { "pause_record_async", (PyCFunction)MediaCapture_PauseRecordAsync, METH_VARARGS, nullptr },
        { "pause_record_with_result_async", (PyCFunction)MediaCapture_PauseRecordWithResultAsync, METH_VARARGS, nullptr },
        { "prepare_advanced_photo_capture_async", (PyCFunction)MediaCapture_PrepareAdvancedPhotoCaptureAsync, METH_VARARGS, nullptr },
        { "prepare_low_lag_photo_capture_async", (PyCFunction)MediaCapture_PrepareLowLagPhotoCaptureAsync, METH_VARARGS, nullptr },
        { "prepare_low_lag_photo_sequence_capture_async", (PyCFunction)MediaCapture_PrepareLowLagPhotoSequenceCaptureAsync, METH_VARARGS, nullptr },
        { "prepare_low_lag_record_to_custom_sink_async", (PyCFunction)MediaCapture_PrepareLowLagRecordToCustomSinkAsync, METH_VARARGS, nullptr },
        { "prepare_low_lag_record_to_storage_file_async", (PyCFunction)MediaCapture_PrepareLowLagRecordToStorageFileAsync, METH_VARARGS, nullptr },
        { "prepare_low_lag_record_to_stream_async", (PyCFunction)MediaCapture_PrepareLowLagRecordToStreamAsync, METH_VARARGS, nullptr },
        { "prepare_variable_photo_sequence_capture_async", (PyCFunction)MediaCapture_PrepareVariablePhotoSequenceCaptureAsync, METH_VARARGS, nullptr },
        { "remove_effect_async", (PyCFunction)MediaCapture_RemoveEffectAsync, METH_VARARGS, nullptr },
        { "resume_record_async", (PyCFunction)MediaCapture_ResumeRecordAsync, METH_VARARGS, nullptr },
        { "set_encoder_property", (PyCFunction)MediaCapture_SetEncoderProperty, METH_VARARGS, nullptr },
        { "set_encoding_properties_async", (PyCFunction)MediaCapture_SetEncodingPropertiesAsync, METH_VARARGS, nullptr },
        { "set_preview_mirroring", (PyCFunction)MediaCapture_SetPreviewMirroring, METH_VARARGS, nullptr },
        { "set_preview_rotation", (PyCFunction)MediaCapture_SetPreviewRotation, METH_VARARGS, nullptr },
        { "set_record_rotation", (PyCFunction)MediaCapture_SetRecordRotation, METH_VARARGS, nullptr },
        { "start_preview_async", (PyCFunction)MediaCapture_StartPreviewAsync, METH_VARARGS, nullptr },
        { "start_preview_to_custom_sink_async", (PyCFunction)MediaCapture_StartPreviewToCustomSinkAsync, METH_VARARGS, nullptr },
        { "start_record_to_custom_sink_async", (PyCFunction)MediaCapture_StartRecordToCustomSinkAsync, METH_VARARGS, nullptr },
        { "start_record_to_storage_file_async", (PyCFunction)MediaCapture_StartRecordToStorageFileAsync, METH_VARARGS, nullptr },
        { "start_record_to_stream_async", (PyCFunction)MediaCapture_StartRecordToStreamAsync, METH_VARARGS, nullptr },
        { "stop_preview_async", (PyCFunction)MediaCapture_StopPreviewAsync, METH_VARARGS, nullptr },
        { "stop_record_async", (PyCFunction)MediaCapture_StopRecordAsync, METH_VARARGS, nullptr },
        { "stop_record_with_result_async", (PyCFunction)MediaCapture_StopRecordWithResultAsync, METH_VARARGS, nullptr },
        { "add_failed", (PyCFunction)MediaCapture_add_Failed, METH_O, nullptr },
        { "remove_failed", (PyCFunction)MediaCapture_remove_Failed, METH_O, nullptr },
        { "add_record_limitation_exceeded", (PyCFunction)MediaCapture_add_RecordLimitationExceeded, METH_O, nullptr },
        { "remove_record_limitation_exceeded", (PyCFunction)MediaCapture_remove_RecordLimitationExceeded, METH_O, nullptr },
        { "add_focus_changed", (PyCFunction)MediaCapture_add_FocusChanged, METH_O, nullptr },
        { "remove_focus_changed", (PyCFunction)MediaCapture_remove_FocusChanged, METH_O, nullptr },
        { "add_photo_confirmation_captured", (PyCFunction)MediaCapture_add_PhotoConfirmationCaptured, METH_O, nullptr },
        { "remove_photo_confirmation_captured", (PyCFunction)MediaCapture_remove_PhotoConfirmationCaptured, METH_O, nullptr },
        { "add_camera_stream_state_changed", (PyCFunction)MediaCapture_add_CameraStreamStateChanged, METH_O, nullptr },
        { "remove_camera_stream_state_changed", (PyCFunction)MediaCapture_remove_CameraStreamStateChanged, METH_O, nullptr },
        { "add_thermal_status_changed", (PyCFunction)MediaCapture_add_ThermalStatusChanged, METH_O, nullptr },
        { "remove_thermal_status_changed", (PyCFunction)MediaCapture_remove_ThermalStatusChanged, METH_O, nullptr },
        { "add_capture_device_exclusive_control_status_changed", (PyCFunction)MediaCapture_add_CaptureDeviceExclusiveControlStatusChanged, METH_O, nullptr },
        { "remove_capture_device_exclusive_control_status_changed", (PyCFunction)MediaCapture_remove_CaptureDeviceExclusiveControlStatusChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MediaCapture, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_MediaCapture, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_MediaCapture, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaCapture[] = {
        { const_cast<char*>("audio_device_controller"), (getter)MediaCapture_get_AudioDeviceController, nullptr, nullptr, nullptr },
        { const_cast<char*>("media_capture_settings"), (getter)MediaCapture_get_MediaCaptureSettings, nullptr, nullptr, nullptr },
        { const_cast<char*>("video_device_controller"), (getter)MediaCapture_get_VideoDeviceController, nullptr, nullptr, nullptr },
        { const_cast<char*>("camera_stream_state"), (getter)MediaCapture_get_CameraStreamState, nullptr, nullptr, nullptr },
        { const_cast<char*>("thermal_status"), (getter)MediaCapture_get_ThermalStatus, nullptr, nullptr, nullptr },
        { const_cast<char*>("frame_sources"), (getter)MediaCapture_get_FrameSources, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaCapture[] = 
    {
        { Py_tp_new, _new_MediaCapture },
        { Py_tp_dealloc, _dealloc_MediaCapture },
        { Py_tp_methods, _methods_MediaCapture },
        { Py_tp_getset, _getset_MediaCapture },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaCapture =
    {
        "_winrt_Windows_Media_Capture.MediaCapture",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCapture
    };

    // ----- MediaCaptureDeviceExclusiveControlStatusChangedEventArgs class --------------------
    constexpr const char* const _type_name_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs = "MediaCaptureDeviceExclusiveControlStatusChangedEventArgs";

    static PyObject* _new_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs(py::wrapper::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCaptureDeviceExclusiveControlStatusChangedEventArgs_get_DeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureDeviceExclusiveControlStatusChangedEventArgs_get_Status(py::wrapper::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs[] = {
        { const_cast<char*>("device_id"), (getter)MediaCaptureDeviceExclusiveControlStatusChangedEventArgs_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)MediaCaptureDeviceExclusiveControlStatusChangedEventArgs_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs },
        { Py_tp_methods, _methods_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs },
        { Py_tp_getset, _getset_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs =
    {
        "_winrt_Windows_Media_Capture.MediaCaptureDeviceExclusiveControlStatusChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs
    };

    // ----- MediaCaptureFailedEventArgs class --------------------
    constexpr const char* const _type_name_MediaCaptureFailedEventArgs = "MediaCaptureFailedEventArgs";

    static PyObject* _new_MediaCaptureFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaCaptureFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaCaptureFailedEventArgs(py::wrapper::Windows::Media::Capture::MediaCaptureFailedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCaptureFailedEventArgs_get_Code(py::wrapper::Windows::Media::Capture::MediaCaptureFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Code());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureFailedEventArgs_get_Message(py::wrapper::Windows::Media::Capture::MediaCaptureFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCaptureFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureFailedEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaCaptureFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaCaptureFailedEventArgs[] = {
        { const_cast<char*>("code"), (getter)MediaCaptureFailedEventArgs_get_Code, nullptr, nullptr, nullptr },
        { const_cast<char*>("message"), (getter)MediaCaptureFailedEventArgs_get_Message, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaCaptureFailedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaCaptureFailedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaCaptureFailedEventArgs },
        { Py_tp_methods, _methods_MediaCaptureFailedEventArgs },
        { Py_tp_getset, _getset_MediaCaptureFailedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaCaptureFailedEventArgs =
    {
        "_winrt_Windows_Media_Capture.MediaCaptureFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureFailedEventArgs
    };

    // ----- MediaCaptureFocusChangedEventArgs class --------------------
    constexpr const char* const _type_name_MediaCaptureFocusChangedEventArgs = "MediaCaptureFocusChangedEventArgs";

    static PyObject* _new_MediaCaptureFocusChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaCaptureFocusChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaCaptureFocusChangedEventArgs(py::wrapper::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCaptureFocusChangedEventArgs_get_FocusState(py::wrapper::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FocusState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCaptureFocusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureFocusChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_MediaCaptureFocusChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaCaptureFocusChangedEventArgs[] = {
        { const_cast<char*>("focus_state"), (getter)MediaCaptureFocusChangedEventArgs_get_FocusState, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaCaptureFocusChangedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaCaptureFocusChangedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaCaptureFocusChangedEventArgs },
        { Py_tp_methods, _methods_MediaCaptureFocusChangedEventArgs },
        { Py_tp_getset, _getset_MediaCaptureFocusChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaCaptureFocusChangedEventArgs =
    {
        "_winrt_Windows_Media_Capture.MediaCaptureFocusChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureFocusChangedEventArgs
    };

    // ----- MediaCaptureInitializationSettings class --------------------
    constexpr const char* const _type_name_MediaCaptureInitializationSettings = "MediaCaptureInitializationSettings";

    static PyObject* _new_MediaCaptureInitializationSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Capture::MediaCaptureInitializationSettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaCaptureInitializationSettings(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCaptureInitializationSettings_get_VideoDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_VideoDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.VideoDeviceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_StreamingCaptureMode(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StreamingCaptureMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_StreamingCaptureMode(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::StreamingCaptureMode>(arg);

            self->obj.StreamingCaptureMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_PhotoCaptureSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhotoCaptureSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_PhotoCaptureSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::PhotoCaptureSource>(arg);

            self->obj.PhotoCaptureSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_AudioDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_AudioDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AudioDeviceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_MediaCategory(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_MediaCategory(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(arg);

            self->obj.MediaCategory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_AudioProcessing(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_AudioProcessing(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::AudioProcessing>(arg);

            self->obj.AudioProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_VideoSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_VideoSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaSource>(arg);

            self->obj.VideoSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_AudioSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_AudioSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaSource>(arg);

            self->obj.AudioSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_VideoProfile(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_VideoProfile(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureVideoProfile>(arg);

            self->obj.VideoProfile(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_RecordMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RecordMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_RecordMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>(arg);

            self->obj.RecordMediaDescription(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_PreviewMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviewMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_PreviewMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>(arg);

            self->obj.PreviewMediaDescription(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_PhotoMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhotoMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_PhotoMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>(arg);

            self->obj.PhotoMediaDescription(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_SourceGroup(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_SourceGroup(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::Frames::MediaFrameSourceGroup>(arg);

            self->obj.SourceGroup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_SharingMode(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SharingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_SharingMode(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureSharingMode>(arg);

            self->obj.SharingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_MemoryPreference(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MemoryPreference());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_MemoryPreference(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureMemoryPreference>(arg);

            self->obj.MemoryPreference(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_AlwaysPlaySystemShutterSound(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlwaysPlaySystemShutterSound());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_AlwaysPlaySystemShutterSound(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AlwaysPlaySystemShutterSound(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_DeviceUriPasswordCredential(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceUriPasswordCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_DeviceUriPasswordCredential(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.DeviceUriPasswordCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_DeviceUri(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_DeviceUri(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.DeviceUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_MediaCaptureInitializationSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureInitializationSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureInitializationSettings[] = {
        { "_from", (PyCFunction)_from_MediaCaptureInitializationSettings, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaCaptureInitializationSettings[] = {
        { const_cast<char*>("video_device_id"), (getter)MediaCaptureInitializationSettings_get_VideoDeviceId, (setter)MediaCaptureInitializationSettings_put_VideoDeviceId, nullptr, nullptr },
        { const_cast<char*>("streaming_capture_mode"), (getter)MediaCaptureInitializationSettings_get_StreamingCaptureMode, (setter)MediaCaptureInitializationSettings_put_StreamingCaptureMode, nullptr, nullptr },
        { const_cast<char*>("photo_capture_source"), (getter)MediaCaptureInitializationSettings_get_PhotoCaptureSource, (setter)MediaCaptureInitializationSettings_put_PhotoCaptureSource, nullptr, nullptr },
        { const_cast<char*>("audio_device_id"), (getter)MediaCaptureInitializationSettings_get_AudioDeviceId, (setter)MediaCaptureInitializationSettings_put_AudioDeviceId, nullptr, nullptr },
        { const_cast<char*>("media_category"), (getter)MediaCaptureInitializationSettings_get_MediaCategory, (setter)MediaCaptureInitializationSettings_put_MediaCategory, nullptr, nullptr },
        { const_cast<char*>("audio_processing"), (getter)MediaCaptureInitializationSettings_get_AudioProcessing, (setter)MediaCaptureInitializationSettings_put_AudioProcessing, nullptr, nullptr },
        { const_cast<char*>("video_source"), (getter)MediaCaptureInitializationSettings_get_VideoSource, (setter)MediaCaptureInitializationSettings_put_VideoSource, nullptr, nullptr },
        { const_cast<char*>("audio_source"), (getter)MediaCaptureInitializationSettings_get_AudioSource, (setter)MediaCaptureInitializationSettings_put_AudioSource, nullptr, nullptr },
        { const_cast<char*>("video_profile"), (getter)MediaCaptureInitializationSettings_get_VideoProfile, (setter)MediaCaptureInitializationSettings_put_VideoProfile, nullptr, nullptr },
        { const_cast<char*>("record_media_description"), (getter)MediaCaptureInitializationSettings_get_RecordMediaDescription, (setter)MediaCaptureInitializationSettings_put_RecordMediaDescription, nullptr, nullptr },
        { const_cast<char*>("preview_media_description"), (getter)MediaCaptureInitializationSettings_get_PreviewMediaDescription, (setter)MediaCaptureInitializationSettings_put_PreviewMediaDescription, nullptr, nullptr },
        { const_cast<char*>("photo_media_description"), (getter)MediaCaptureInitializationSettings_get_PhotoMediaDescription, (setter)MediaCaptureInitializationSettings_put_PhotoMediaDescription, nullptr, nullptr },
        { const_cast<char*>("source_group"), (getter)MediaCaptureInitializationSettings_get_SourceGroup, (setter)MediaCaptureInitializationSettings_put_SourceGroup, nullptr, nullptr },
        { const_cast<char*>("sharing_mode"), (getter)MediaCaptureInitializationSettings_get_SharingMode, (setter)MediaCaptureInitializationSettings_put_SharingMode, nullptr, nullptr },
        { const_cast<char*>("memory_preference"), (getter)MediaCaptureInitializationSettings_get_MemoryPreference, (setter)MediaCaptureInitializationSettings_put_MemoryPreference, nullptr, nullptr },
        { const_cast<char*>("always_play_system_shutter_sound"), (getter)MediaCaptureInitializationSettings_get_AlwaysPlaySystemShutterSound, (setter)MediaCaptureInitializationSettings_put_AlwaysPlaySystemShutterSound, nullptr, nullptr },
        { const_cast<char*>("device_uri_password_credential"), (getter)MediaCaptureInitializationSettings_get_DeviceUriPasswordCredential, (setter)MediaCaptureInitializationSettings_put_DeviceUriPasswordCredential, nullptr, nullptr },
        { const_cast<char*>("device_uri"), (getter)MediaCaptureInitializationSettings_get_DeviceUri, (setter)MediaCaptureInitializationSettings_put_DeviceUri, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaCaptureInitializationSettings[] = 
    {
        { Py_tp_new, _new_MediaCaptureInitializationSettings },
        { Py_tp_dealloc, _dealloc_MediaCaptureInitializationSettings },
        { Py_tp_methods, _methods_MediaCaptureInitializationSettings },
        { Py_tp_getset, _getset_MediaCaptureInitializationSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaCaptureInitializationSettings =
    {
        "_winrt_Windows_Media_Capture.MediaCaptureInitializationSettings",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureInitializationSettings
    };

    // ----- MediaCapturePauseResult class --------------------
    constexpr const char* const _type_name_MediaCapturePauseResult = "MediaCapturePauseResult";

    static PyObject* _new_MediaCapturePauseResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaCapturePauseResult);
        return nullptr;
    }

    static void _dealloc_MediaCapturePauseResult(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCapturePauseResult_Close(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapturePauseResult_get_LastFrame(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapturePauseResult_get_RecordDuration(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RecordDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCapturePauseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCapturePauseResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaCapturePauseResult(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_MediaCapturePauseResult(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCapturePauseResult[] = {
        { "close", (PyCFunction)MediaCapturePauseResult_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaCapturePauseResult, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_MediaCapturePauseResult, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_MediaCapturePauseResult, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaCapturePauseResult[] = {
        { const_cast<char*>("last_frame"), (getter)MediaCapturePauseResult_get_LastFrame, nullptr, nullptr, nullptr },
        { const_cast<char*>("record_duration"), (getter)MediaCapturePauseResult_get_RecordDuration, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaCapturePauseResult[] = 
    {
        { Py_tp_new, _new_MediaCapturePauseResult },
        { Py_tp_dealloc, _dealloc_MediaCapturePauseResult },
        { Py_tp_methods, _methods_MediaCapturePauseResult },
        { Py_tp_getset, _getset_MediaCapturePauseResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaCapturePauseResult =
    {
        "_winrt_Windows_Media_Capture.MediaCapturePauseResult",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCapturePauseResult
    };

    // ----- MediaCaptureRelativePanelWatcher class --------------------
    constexpr const char* const _type_name_MediaCaptureRelativePanelWatcher = "MediaCaptureRelativePanelWatcher";

    static PyObject* _new_MediaCaptureRelativePanelWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaCaptureRelativePanelWatcher);
        return nullptr;
    }

    static void _dealloc_MediaCaptureRelativePanelWatcher(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCaptureRelativePanelWatcher_Close(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCaptureRelativePanelWatcher_Start(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCaptureRelativePanelWatcher_Stop(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCaptureRelativePanelWatcher_get_RelativePanel(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelativePanel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureRelativePanelWatcher_add_Changed(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCaptureRelativePanelWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Changed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureRelativePanelWatcher_remove_Changed(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Changed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCaptureRelativePanelWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureRelativePanelWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaCaptureRelativePanelWatcher(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_MediaCaptureRelativePanelWatcher(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureRelativePanelWatcher[] = {
        { "close", (PyCFunction)MediaCaptureRelativePanelWatcher_Close, METH_VARARGS, nullptr },
        { "start", (PyCFunction)MediaCaptureRelativePanelWatcher_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)MediaCaptureRelativePanelWatcher_Stop, METH_VARARGS, nullptr },
        { "add_changed", (PyCFunction)MediaCaptureRelativePanelWatcher_add_Changed, METH_O, nullptr },
        { "remove_changed", (PyCFunction)MediaCaptureRelativePanelWatcher_remove_Changed, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MediaCaptureRelativePanelWatcher, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_MediaCaptureRelativePanelWatcher, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_MediaCaptureRelativePanelWatcher, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaCaptureRelativePanelWatcher[] = {
        { const_cast<char*>("relative_panel"), (getter)MediaCaptureRelativePanelWatcher_get_RelativePanel, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaCaptureRelativePanelWatcher[] = 
    {
        { Py_tp_new, _new_MediaCaptureRelativePanelWatcher },
        { Py_tp_dealloc, _dealloc_MediaCaptureRelativePanelWatcher },
        { Py_tp_methods, _methods_MediaCaptureRelativePanelWatcher },
        { Py_tp_getset, _getset_MediaCaptureRelativePanelWatcher },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaCaptureRelativePanelWatcher =
    {
        "_winrt_Windows_Media_Capture.MediaCaptureRelativePanelWatcher",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureRelativePanelWatcher
    };

    // ----- MediaCaptureSettings class --------------------
    constexpr const char* const _type_name_MediaCaptureSettings = "MediaCaptureSettings";

    static PyObject* _new_MediaCaptureSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaCaptureSettings);
        return nullptr;
    }

    static void _dealloc_MediaCaptureSettings(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCaptureSettings_get_AudioDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_PhotoCaptureSource(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhotoCaptureSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_StreamingCaptureMode(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StreamingCaptureMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_VideoDeviceCharacteristic(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoDeviceCharacteristic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_VideoDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_AudioProcessing(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_CameraSoundRequiredForRegion(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CameraSoundRequiredForRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_ConcurrentRecordAndPhotoSequenceSupported(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConcurrentRecordAndPhotoSequenceSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_ConcurrentRecordAndPhotoSupported(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConcurrentRecordAndPhotoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_Horizontal35mmEquivalentFocalLength(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Horizontal35mmEquivalentFocalLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_MediaCategory(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_PitchOffsetDegrees(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PitchOffsetDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_Vertical35mmEquivalentFocalLength(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Vertical35mmEquivalentFocalLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_Direct3D11Device(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Direct3D11Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureSettings[] = {
        { "_from", (PyCFunction)_from_MediaCaptureSettings, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaCaptureSettings[] = {
        { const_cast<char*>("audio_device_id"), (getter)MediaCaptureSettings_get_AudioDeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("photo_capture_source"), (getter)MediaCaptureSettings_get_PhotoCaptureSource, nullptr, nullptr, nullptr },
        { const_cast<char*>("streaming_capture_mode"), (getter)MediaCaptureSettings_get_StreamingCaptureMode, nullptr, nullptr, nullptr },
        { const_cast<char*>("video_device_characteristic"), (getter)MediaCaptureSettings_get_VideoDeviceCharacteristic, nullptr, nullptr, nullptr },
        { const_cast<char*>("video_device_id"), (getter)MediaCaptureSettings_get_VideoDeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("audio_processing"), (getter)MediaCaptureSettings_get_AudioProcessing, nullptr, nullptr, nullptr },
        { const_cast<char*>("camera_sound_required_for_region"), (getter)MediaCaptureSettings_get_CameraSoundRequiredForRegion, nullptr, nullptr, nullptr },
        { const_cast<char*>("concurrent_record_and_photo_sequence_supported"), (getter)MediaCaptureSettings_get_ConcurrentRecordAndPhotoSequenceSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("concurrent_record_and_photo_supported"), (getter)MediaCaptureSettings_get_ConcurrentRecordAndPhotoSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("horizontal35mm_equivalent_focal_length"), (getter)MediaCaptureSettings_get_Horizontal35mmEquivalentFocalLength, nullptr, nullptr, nullptr },
        { const_cast<char*>("media_category"), (getter)MediaCaptureSettings_get_MediaCategory, nullptr, nullptr, nullptr },
        { const_cast<char*>("pitch_offset_degrees"), (getter)MediaCaptureSettings_get_PitchOffsetDegrees, nullptr, nullptr, nullptr },
        { const_cast<char*>("vertical35mm_equivalent_focal_length"), (getter)MediaCaptureSettings_get_Vertical35mmEquivalentFocalLength, nullptr, nullptr, nullptr },
        { const_cast<char*>("direct3_d11_device"), (getter)MediaCaptureSettings_get_Direct3D11Device, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaCaptureSettings[] = 
    {
        { Py_tp_new, _new_MediaCaptureSettings },
        { Py_tp_dealloc, _dealloc_MediaCaptureSettings },
        { Py_tp_methods, _methods_MediaCaptureSettings },
        { Py_tp_getset, _getset_MediaCaptureSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaCaptureSettings =
    {
        "_winrt_Windows_Media_Capture.MediaCaptureSettings",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureSettings
    };

    // ----- MediaCaptureStopResult class --------------------
    constexpr const char* const _type_name_MediaCaptureStopResult = "MediaCaptureStopResult";

    static PyObject* _new_MediaCaptureStopResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaCaptureStopResult);
        return nullptr;
    }

    static void _dealloc_MediaCaptureStopResult(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCaptureStopResult_Close(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCaptureStopResult_get_LastFrame(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureStopResult_get_RecordDuration(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RecordDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCaptureStopResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureStopResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaCaptureStopResult(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_MediaCaptureStopResult(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureStopResult[] = {
        { "close", (PyCFunction)MediaCaptureStopResult_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaCaptureStopResult, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_MediaCaptureStopResult, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_MediaCaptureStopResult, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaCaptureStopResult[] = {
        { const_cast<char*>("last_frame"), (getter)MediaCaptureStopResult_get_LastFrame, nullptr, nullptr, nullptr },
        { const_cast<char*>("record_duration"), (getter)MediaCaptureStopResult_get_RecordDuration, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaCaptureStopResult[] = 
    {
        { Py_tp_new, _new_MediaCaptureStopResult },
        { Py_tp_dealloc, _dealloc_MediaCaptureStopResult },
        { Py_tp_methods, _methods_MediaCaptureStopResult },
        { Py_tp_getset, _getset_MediaCaptureStopResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaCaptureStopResult =
    {
        "_winrt_Windows_Media_Capture.MediaCaptureStopResult",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureStopResult
    };

    // ----- MediaCaptureVideoProfile class --------------------
    constexpr const char* const _type_name_MediaCaptureVideoProfile = "MediaCaptureVideoProfile";

    static PyObject* _new_MediaCaptureVideoProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaCaptureVideoProfile);
        return nullptr;
    }

    static void _dealloc_MediaCaptureVideoProfile(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCaptureVideoProfile_GetConcurrency(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConcurrency());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_Id(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_SupportedPhotoMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedPhotoMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_SupportedPreviewMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedPreviewMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_SupportedRecordMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedRecordMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_VideoDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_FrameSourceInfos(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameSourceInfos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_Properties(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCaptureVideoProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureVideoProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureVideoProfile[] = {
        { "get_concurrency", (PyCFunction)MediaCaptureVideoProfile_GetConcurrency, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaCaptureVideoProfile, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaCaptureVideoProfile[] = {
        { const_cast<char*>("id"), (getter)MediaCaptureVideoProfile_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_photo_media_description"), (getter)MediaCaptureVideoProfile_get_SupportedPhotoMediaDescription, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_preview_media_description"), (getter)MediaCaptureVideoProfile_get_SupportedPreviewMediaDescription, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_record_media_description"), (getter)MediaCaptureVideoProfile_get_SupportedRecordMediaDescription, nullptr, nullptr, nullptr },
        { const_cast<char*>("video_device_id"), (getter)MediaCaptureVideoProfile_get_VideoDeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("frame_source_infos"), (getter)MediaCaptureVideoProfile_get_FrameSourceInfos, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)MediaCaptureVideoProfile_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaCaptureVideoProfile[] = 
    {
        { Py_tp_new, _new_MediaCaptureVideoProfile },
        { Py_tp_dealloc, _dealloc_MediaCaptureVideoProfile },
        { Py_tp_methods, _methods_MediaCaptureVideoProfile },
        { Py_tp_getset, _getset_MediaCaptureVideoProfile },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaCaptureVideoProfile =
    {
        "_winrt_Windows_Media_Capture.MediaCaptureVideoProfile",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureVideoProfile
    };

    // ----- MediaCaptureVideoProfileMediaDescription class --------------------
    constexpr const char* const _type_name_MediaCaptureVideoProfileMediaDescription = "MediaCaptureVideoProfileMediaDescription";

    static PyObject* _new_MediaCaptureVideoProfileMediaDescription(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaCaptureVideoProfileMediaDescription);
        return nullptr;
    }

    static void _dealloc_MediaCaptureVideoProfileMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_FrameRate(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_Height(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_IsHdrVideoSupported(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHdrVideoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_IsVariablePhotoSequenceSupported(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVariablePhotoSequenceSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_Width(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_Properties(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_Subtype(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCaptureVideoProfileMediaDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureVideoProfileMediaDescription[] = {
        { "_from", (PyCFunction)_from_MediaCaptureVideoProfileMediaDescription, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaCaptureVideoProfileMediaDescription[] = {
        { const_cast<char*>("frame_rate"), (getter)MediaCaptureVideoProfileMediaDescription_get_FrameRate, nullptr, nullptr, nullptr },
        { const_cast<char*>("height"), (getter)MediaCaptureVideoProfileMediaDescription_get_Height, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_hdr_video_supported"), (getter)MediaCaptureVideoProfileMediaDescription_get_IsHdrVideoSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_variable_photo_sequence_supported"), (getter)MediaCaptureVideoProfileMediaDescription_get_IsVariablePhotoSequenceSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("width"), (getter)MediaCaptureVideoProfileMediaDescription_get_Width, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)MediaCaptureVideoProfileMediaDescription_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("subtype"), (getter)MediaCaptureVideoProfileMediaDescription_get_Subtype, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaCaptureVideoProfileMediaDescription[] = 
    {
        { Py_tp_new, _new_MediaCaptureVideoProfileMediaDescription },
        { Py_tp_dealloc, _dealloc_MediaCaptureVideoProfileMediaDescription },
        { Py_tp_methods, _methods_MediaCaptureVideoProfileMediaDescription },
        { Py_tp_getset, _getset_MediaCaptureVideoProfileMediaDescription },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaCaptureVideoProfileMediaDescription =
    {
        "_winrt_Windows_Media_Capture.MediaCaptureVideoProfileMediaDescription",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureVideoProfileMediaDescription
    };

    // ----- OptionalReferencePhotoCapturedEventArgs class --------------------
    constexpr const char* const _type_name_OptionalReferencePhotoCapturedEventArgs = "OptionalReferencePhotoCapturedEventArgs";

    static PyObject* _new_OptionalReferencePhotoCapturedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_OptionalReferencePhotoCapturedEventArgs);
        return nullptr;
    }

    static void _dealloc_OptionalReferencePhotoCapturedEventArgs(py::wrapper::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* OptionalReferencePhotoCapturedEventArgs_get_Context(py::wrapper::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Context());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OptionalReferencePhotoCapturedEventArgs_get_Frame(py::wrapper::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_OptionalReferencePhotoCapturedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OptionalReferencePhotoCapturedEventArgs[] = {
        { "_from", (PyCFunction)_from_OptionalReferencePhotoCapturedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_OptionalReferencePhotoCapturedEventArgs[] = {
        { const_cast<char*>("context"), (getter)OptionalReferencePhotoCapturedEventArgs_get_Context, nullptr, nullptr, nullptr },
        { const_cast<char*>("frame"), (getter)OptionalReferencePhotoCapturedEventArgs_get_Frame, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_OptionalReferencePhotoCapturedEventArgs[] = 
    {
        { Py_tp_new, _new_OptionalReferencePhotoCapturedEventArgs },
        { Py_tp_dealloc, _dealloc_OptionalReferencePhotoCapturedEventArgs },
        { Py_tp_methods, _methods_OptionalReferencePhotoCapturedEventArgs },
        { Py_tp_getset, _getset_OptionalReferencePhotoCapturedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_OptionalReferencePhotoCapturedEventArgs =
    {
        "_winrt_Windows_Media_Capture.OptionalReferencePhotoCapturedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OptionalReferencePhotoCapturedEventArgs
    };

    // ----- PhotoCapturedEventArgs class --------------------
    constexpr const char* const _type_name_PhotoCapturedEventArgs = "PhotoCapturedEventArgs";

    static PyObject* _new_PhotoCapturedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhotoCapturedEventArgs);
        return nullptr;
    }

    static void _dealloc_PhotoCapturedEventArgs(py::wrapper::Windows::Media::Capture::PhotoCapturedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhotoCapturedEventArgs_get_CaptureTimeOffset(py::wrapper::Windows::Media::Capture::PhotoCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CaptureTimeOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoCapturedEventArgs_get_Frame(py::wrapper::Windows::Media::Capture::PhotoCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoCapturedEventArgs_get_Thumbnail(py::wrapper::Windows::Media::Capture::PhotoCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhotoCapturedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::PhotoCapturedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoCapturedEventArgs[] = {
        { "_from", (PyCFunction)_from_PhotoCapturedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhotoCapturedEventArgs[] = {
        { const_cast<char*>("capture_time_offset"), (getter)PhotoCapturedEventArgs_get_CaptureTimeOffset, nullptr, nullptr, nullptr },
        { const_cast<char*>("frame"), (getter)PhotoCapturedEventArgs_get_Frame, nullptr, nullptr, nullptr },
        { const_cast<char*>("thumbnail"), (getter)PhotoCapturedEventArgs_get_Thumbnail, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PhotoCapturedEventArgs[] = 
    {
        { Py_tp_new, _new_PhotoCapturedEventArgs },
        { Py_tp_dealloc, _dealloc_PhotoCapturedEventArgs },
        { Py_tp_methods, _methods_PhotoCapturedEventArgs },
        { Py_tp_getset, _getset_PhotoCapturedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhotoCapturedEventArgs =
    {
        "_winrt_Windows_Media_Capture.PhotoCapturedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::PhotoCapturedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoCapturedEventArgs
    };

    // ----- PhotoConfirmationCapturedEventArgs class --------------------
    constexpr const char* const _type_name_PhotoConfirmationCapturedEventArgs = "PhotoConfirmationCapturedEventArgs";

    static PyObject* _new_PhotoConfirmationCapturedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhotoConfirmationCapturedEventArgs);
        return nullptr;
    }

    static void _dealloc_PhotoConfirmationCapturedEventArgs(py::wrapper::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhotoConfirmationCapturedEventArgs_get_CaptureTimeOffset(py::wrapper::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CaptureTimeOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoConfirmationCapturedEventArgs_get_Frame(py::wrapper::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhotoConfirmationCapturedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoConfirmationCapturedEventArgs[] = {
        { "_from", (PyCFunction)_from_PhotoConfirmationCapturedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhotoConfirmationCapturedEventArgs[] = {
        { const_cast<char*>("capture_time_offset"), (getter)PhotoConfirmationCapturedEventArgs_get_CaptureTimeOffset, nullptr, nullptr, nullptr },
        { const_cast<char*>("frame"), (getter)PhotoConfirmationCapturedEventArgs_get_Frame, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PhotoConfirmationCapturedEventArgs[] = 
    {
        { Py_tp_new, _new_PhotoConfirmationCapturedEventArgs },
        { Py_tp_dealloc, _dealloc_PhotoConfirmationCapturedEventArgs },
        { Py_tp_methods, _methods_PhotoConfirmationCapturedEventArgs },
        { Py_tp_getset, _getset_PhotoConfirmationCapturedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhotoConfirmationCapturedEventArgs =
    {
        "_winrt_Windows_Media_Capture.PhotoConfirmationCapturedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoConfirmationCapturedEventArgs
    };

    // ----- VideoStreamConfiguration class --------------------
    constexpr const char* const _type_name_VideoStreamConfiguration = "VideoStreamConfiguration";

    static PyObject* _new_VideoStreamConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VideoStreamConfiguration);
        return nullptr;
    }

    static void _dealloc_VideoStreamConfiguration(py::wrapper::Windows::Media::Capture::VideoStreamConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoStreamConfiguration_get_InputProperties(py::wrapper::Windows::Media::Capture::VideoStreamConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoStreamConfiguration_get_OutputProperties(py::wrapper::Windows::Media::Capture::VideoStreamConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoStreamConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::VideoStreamConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStreamConfiguration[] = {
        { "_from", (PyCFunction)_from_VideoStreamConfiguration, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VideoStreamConfiguration[] = {
        { const_cast<char*>("input_properties"), (getter)VideoStreamConfiguration_get_InputProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("output_properties"), (getter)VideoStreamConfiguration_get_OutputProperties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VideoStreamConfiguration[] = 
    {
        { Py_tp_new, _new_VideoStreamConfiguration },
        { Py_tp_dealloc, _dealloc_VideoStreamConfiguration },
        { Py_tp_methods, _methods_VideoStreamConfiguration },
        { Py_tp_getset, _getset_VideoStreamConfiguration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoStreamConfiguration =
    {
        "_winrt_Windows_Media_Capture.VideoStreamConfiguration",
        sizeof(py::wrapper::Windows::Media::Capture::VideoStreamConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStreamConfiguration
    };

    // ----- WhiteBalanceGain struct --------------------
    constexpr const char* const _type_name_WhiteBalanceGain = "WhiteBalanceGain";

    PyObject* _new_WhiteBalanceGain(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Capture::WhiteBalanceGain return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Media::Capture::WhiteBalanceGain>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        double _R{};
        double _G{};
        double _B{};

        static const char* kwlist[] = {"r", "g", "b", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddd", const_cast<char**>(kwlist), &_R, &_G, &_B))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Capture::WhiteBalanceGain return_value{ _R, _G, _B };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_WhiteBalanceGain(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self)
    {
    }

    static PyObject* WhiteBalanceGain_get_R(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.R);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WhiteBalanceGain_set_R(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.R = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WhiteBalanceGain_get_G(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.G);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WhiteBalanceGain_set_G(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.G = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WhiteBalanceGain_get_B(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.B);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WhiteBalanceGain_set_B(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.B = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_WhiteBalanceGain[] = {
        { const_cast<char*>("r"), (getter)WhiteBalanceGain_get_R, (setter)WhiteBalanceGain_set_R, nullptr, nullptr },
        { const_cast<char*>("g"), (getter)WhiteBalanceGain_get_G, (setter)WhiteBalanceGain_set_G, nullptr, nullptr },
        { const_cast<char*>("b"), (getter)WhiteBalanceGain_get_B, (setter)WhiteBalanceGain_set_B, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_WhiteBalanceGain[] = 
    {
        { Py_tp_new, _new_WhiteBalanceGain },
        { Py_tp_dealloc, _dealloc_WhiteBalanceGain },
        { Py_tp_getset, _getset_WhiteBalanceGain },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_WhiteBalanceGain =
    {
        "_winrt_Windows_Media_Capture.WhiteBalanceGain",
        sizeof(py::wrapper::Windows::Media::Capture::WhiteBalanceGain),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WhiteBalanceGain
    };

    // ----- Windows.Media.Capture Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Media::Capture::AdvancedCapturedPhoto>::python_type = py::register_python_type(module, _type_name_AdvancedCapturedPhoto, &_type_spec_AdvancedCapturedPhoto, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::AdvancedPhotoCapture>::python_type = py::register_python_type(module, _type_name_AdvancedPhotoCapture, &_type_spec_AdvancedPhotoCapture, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::AppCapture>::python_type = py::register_python_type(module, _type_name_AppCapture, &_type_spec_AppCapture, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::CameraCaptureUI>::python_type = py::register_python_type(module, _type_name_CameraCaptureUI, &_type_spec_CameraCaptureUI, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings>::python_type = py::register_python_type(module, _type_name_CameraCaptureUIPhotoCaptureSettings, &_type_spec_CameraCaptureUIPhotoCaptureSettings, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings>::python_type = py::register_python_type(module, _type_name_CameraCaptureUIVideoCaptureSettings, &_type_spec_CameraCaptureUIVideoCaptureSettings, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::CapturedFrame>::python_type = py::register_python_type(module, _type_name_CapturedFrame, &_type_spec_CapturedFrame, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::CapturedFrameControlValues>::python_type = py::register_python_type(module, _type_name_CapturedFrameControlValues, &_type_spec_CapturedFrameControlValues, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::CapturedPhoto>::python_type = py::register_python_type(module, _type_name_CapturedPhoto, &_type_spec_CapturedPhoto, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::LowLagMediaRecording>::python_type = py::register_python_type(module, _type_name_LowLagMediaRecording, &_type_spec_LowLagMediaRecording, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::LowLagPhotoCapture>::python_type = py::register_python_type(module, _type_name_LowLagPhotoCapture, &_type_spec_LowLagPhotoCapture, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::LowLagPhotoSequenceCapture>::python_type = py::register_python_type(module, _type_name_LowLagPhotoSequenceCapture, &_type_spec_LowLagPhotoSequenceCapture, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCapture>::python_type = py::register_python_type(module, _type_name_MediaCapture, &_type_spec_MediaCapture, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs, &_type_spec_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureFailedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaCaptureFailedEventArgs, &_type_spec_MediaCaptureFailedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaCaptureFocusChangedEventArgs, &_type_spec_MediaCaptureFocusChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureInitializationSettings>::python_type = py::register_python_type(module, _type_name_MediaCaptureInitializationSettings, &_type_spec_MediaCaptureInitializationSettings, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCapturePauseResult>::python_type = py::register_python_type(module, _type_name_MediaCapturePauseResult, &_type_spec_MediaCapturePauseResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureRelativePanelWatcher>::python_type = py::register_python_type(module, _type_name_MediaCaptureRelativePanelWatcher, &_type_spec_MediaCaptureRelativePanelWatcher, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureSettings>::python_type = py::register_python_type(module, _type_name_MediaCaptureSettings, &_type_spec_MediaCaptureSettings, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureStopResult>::python_type = py::register_python_type(module, _type_name_MediaCaptureStopResult, &_type_spec_MediaCaptureStopResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureVideoProfile>::python_type = py::register_python_type(module, _type_name_MediaCaptureVideoProfile, &_type_spec_MediaCaptureVideoProfile, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>::python_type = py::register_python_type(module, _type_name_MediaCaptureVideoProfileMediaDescription, &_type_spec_MediaCaptureVideoProfileMediaDescription, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs>::python_type = py::register_python_type(module, _type_name_OptionalReferencePhotoCapturedEventArgs, &_type_spec_OptionalReferencePhotoCapturedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::PhotoCapturedEventArgs>::python_type = py::register_python_type(module, _type_name_PhotoCapturedEventArgs, &_type_spec_PhotoCapturedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs>::python_type = py::register_python_type(module, _type_name_PhotoConfirmationCapturedEventArgs, &_type_spec_PhotoConfirmationCapturedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::VideoStreamConfiguration>::python_type = py::register_python_type(module, _type_name_VideoStreamConfiguration, &_type_spec_VideoStreamConfiguration, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::WhiteBalanceGain>::python_type = py::register_python_type(module, _type_name_WhiteBalanceGain, &_type_spec_WhiteBalanceGain, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Media.Capture");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Media_Capture",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Media::Capture

PyMODINIT_FUNC
PyInit__winrt_Windows_Media_Capture (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Media::Capture::module_def);
}
