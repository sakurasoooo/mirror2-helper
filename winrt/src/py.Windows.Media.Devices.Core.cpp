// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Media.Devices.Core.h"

PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::CameraIntrinsics>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameControlCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameController>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameExposureCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameExposureCompensationControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameExposureControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameFlashCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameFlashControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameFocusCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameFocusControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameIsoSpeedControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::VariablePhotoSequenceController>::python_type;

namespace py::cpp::Windows::Media::Devices::Core
{
    // ----- CameraIntrinsics class --------------------
    constexpr const char* const _type_name_CameraIntrinsics = "CameraIntrinsics";

    static PyObject* _new_CameraIntrinsics(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 3);
                auto param4 = py::convert_to<uint32_t>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);

                winrt::Windows::Media::Devices::Core::CameraIntrinsics instance{ param0, param1, param2, param3, param4, param5 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CameraIntrinsics(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CameraIntrinsics_DistortPoint(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.DistortPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_DistortPoints(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Point>>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Foundation::Point>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Foundation::Point> param1 ( param1_count, py::empty_instance<winrt::Windows::Foundation::Point>::get() );

                self->obj.DistortPoints(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_ProjectManyOntoFrame(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Numerics::float3>>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Foundation::Point>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Foundation::Point> param1 ( param1_count, py::empty_instance<winrt::Windows::Foundation::Point>::get() );

                self->obj.ProjectManyOntoFrame(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_ProjectOntoFrame(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);

                return py::convert(self->obj.ProjectOntoFrame(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_UndistortPoint(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.UndistortPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_UndistortPoints(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Point>>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Foundation::Point>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Foundation::Point> param1 ( param1_count, py::empty_instance<winrt::Windows::Foundation::Point>::get() );

                self->obj.UndistortPoints(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_UnprojectAtUnitDepth(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.UnprojectAtUnitDepth(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_UnprojectPixelsAtUnitDepth(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Point>>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Foundation::Numerics::float2>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Foundation::Numerics::float2> param1 ( param1_count, py::empty_instance<winrt::Windows::Foundation::Numerics::float2>::get() );

                self->obj.UnprojectPixelsAtUnitDepth(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_FocalLength(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FocalLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_ImageHeight(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ImageHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_ImageWidth(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ImageWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_PrincipalPoint(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrincipalPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_RadialDistortion(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RadialDistortion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_TangentialDistortion(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TangentialDistortion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_UndistortedProjectionTransform(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UndistortedProjectionTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CameraIntrinsics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::CameraIntrinsics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraIntrinsics[] = {
        { "distort_point", (PyCFunction)CameraIntrinsics_DistortPoint, METH_VARARGS, nullptr },
        { "distort_points", (PyCFunction)CameraIntrinsics_DistortPoints, METH_VARARGS, nullptr },
        { "project_many_onto_frame", (PyCFunction)CameraIntrinsics_ProjectManyOntoFrame, METH_VARARGS, nullptr },
        { "project_onto_frame", (PyCFunction)CameraIntrinsics_ProjectOntoFrame, METH_VARARGS, nullptr },
        { "undistort_point", (PyCFunction)CameraIntrinsics_UndistortPoint, METH_VARARGS, nullptr },
        { "undistort_points", (PyCFunction)CameraIntrinsics_UndistortPoints, METH_VARARGS, nullptr },
        { "unproject_at_unit_depth", (PyCFunction)CameraIntrinsics_UnprojectAtUnitDepth, METH_VARARGS, nullptr },
        { "unproject_pixels_at_unit_depth", (PyCFunction)CameraIntrinsics_UnprojectPixelsAtUnitDepth, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_CameraIntrinsics, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CameraIntrinsics[] = {
        { const_cast<char*>("focal_length"), (getter)CameraIntrinsics_get_FocalLength, nullptr, nullptr, nullptr },
        { const_cast<char*>("image_height"), (getter)CameraIntrinsics_get_ImageHeight, nullptr, nullptr, nullptr },
        { const_cast<char*>("image_width"), (getter)CameraIntrinsics_get_ImageWidth, nullptr, nullptr, nullptr },
        { const_cast<char*>("principal_point"), (getter)CameraIntrinsics_get_PrincipalPoint, nullptr, nullptr, nullptr },
        { const_cast<char*>("radial_distortion"), (getter)CameraIntrinsics_get_RadialDistortion, nullptr, nullptr, nullptr },
        { const_cast<char*>("tangential_distortion"), (getter)CameraIntrinsics_get_TangentialDistortion, nullptr, nullptr, nullptr },
        { const_cast<char*>("undistorted_projection_transform"), (getter)CameraIntrinsics_get_UndistortedProjectionTransform, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CameraIntrinsics[] = 
    {
        { Py_tp_new, _new_CameraIntrinsics },
        { Py_tp_dealloc, _dealloc_CameraIntrinsics },
        { Py_tp_methods, _methods_CameraIntrinsics },
        { Py_tp_getset, _getset_CameraIntrinsics },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CameraIntrinsics =
    {
        "_winrt_Windows_Media_Devices_Core.CameraIntrinsics",
        sizeof(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraIntrinsics
    };

    // ----- DepthCorrelatedCoordinateMapper class --------------------
    constexpr const char* const _type_name_DepthCorrelatedCoordinateMapper = "DepthCorrelatedCoordinateMapper";

    static PyObject* _new_DepthCorrelatedCoordinateMapper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DepthCorrelatedCoordinateMapper);
        return nullptr;
    }

    static void _dealloc_DepthCorrelatedCoordinateMapper(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DepthCorrelatedCoordinateMapper_Close(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DepthCorrelatedCoordinateMapper_MapPoint(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Devices::Core::CameraIntrinsics>(args, 2);

                return py::convert(self->obj.MapPoint(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DepthCorrelatedCoordinateMapper_MapPoints(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Point>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Devices::Core::CameraIntrinsics>(args, 2);
                auto param3_count = py::convert_to<winrt::com_array<winrt::Windows::Foundation::Point>::size_type>(args, 3);
                winrt::com_array<winrt::Windows::Foundation::Point> param3 ( param3_count, py::empty_instance<winrt::Windows::Foundation::Point>::get() );

                self->obj.MapPoints(param0, param1, param2, param3);

                py::pyobj_handle out3{ py::convert(param3) };
                if (!out3)
                {
                    return nullptr;
                }
                return out3.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DepthCorrelatedCoordinateMapper_UnprojectPoint(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 1);

                return py::convert(self->obj.UnprojectPoint(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DepthCorrelatedCoordinateMapper_UnprojectPoints(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Point>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 1);
                auto param2_count = py::convert_to<winrt::com_array<winrt::Windows::Foundation::Numerics::float3>::size_type>(args, 2);
                winrt::com_array<winrt::Windows::Foundation::Numerics::float3> param2 ( param2_count, py::empty_instance<winrt::Windows::Foundation::Numerics::float3>::get() );

                self->obj.UnprojectPoints(param0, param1, param2);

                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return out2.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_DepthCorrelatedCoordinateMapper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_DepthCorrelatedCoordinateMapper(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_DepthCorrelatedCoordinateMapper(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DepthCorrelatedCoordinateMapper[] = {
        { "close", (PyCFunction)DepthCorrelatedCoordinateMapper_Close, METH_VARARGS, nullptr },
        { "map_point", (PyCFunction)DepthCorrelatedCoordinateMapper_MapPoint, METH_VARARGS, nullptr },
        { "map_points", (PyCFunction)DepthCorrelatedCoordinateMapper_MapPoints, METH_VARARGS, nullptr },
        { "unproject_point", (PyCFunction)DepthCorrelatedCoordinateMapper_UnprojectPoint, METH_VARARGS, nullptr },
        { "unproject_points", (PyCFunction)DepthCorrelatedCoordinateMapper_UnprojectPoints, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DepthCorrelatedCoordinateMapper, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_DepthCorrelatedCoordinateMapper, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_DepthCorrelatedCoordinateMapper, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DepthCorrelatedCoordinateMapper[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_DepthCorrelatedCoordinateMapper[] = 
    {
        { Py_tp_new, _new_DepthCorrelatedCoordinateMapper },
        { Py_tp_dealloc, _dealloc_DepthCorrelatedCoordinateMapper },
        { Py_tp_methods, _methods_DepthCorrelatedCoordinateMapper },
        { Py_tp_getset, _getset_DepthCorrelatedCoordinateMapper },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DepthCorrelatedCoordinateMapper =
    {
        "_winrt_Windows_Media_Devices_Core.DepthCorrelatedCoordinateMapper",
        sizeof(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DepthCorrelatedCoordinateMapper
    };

    // ----- FrameControlCapabilities class --------------------
    constexpr const char* const _type_name_FrameControlCapabilities = "FrameControlCapabilities";

    static PyObject* _new_FrameControlCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameControlCapabilities);
        return nullptr;
    }

    static void _dealloc_FrameControlCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameControlCapabilities_get_Exposure(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Exposure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameControlCapabilities_get_ExposureCompensation(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExposureCompensation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameControlCapabilities_get_Focus(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Focus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameControlCapabilities_get_IsoSpeed(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsoSpeed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameControlCapabilities_get_PhotoConfirmationSupported(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhotoConfirmationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameControlCapabilities_get_Flash(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Flash());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FrameControlCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameControlCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameControlCapabilities[] = {
        { "_from", (PyCFunction)_from_FrameControlCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FrameControlCapabilities[] = {
        { const_cast<char*>("exposure"), (getter)FrameControlCapabilities_get_Exposure, nullptr, nullptr, nullptr },
        { const_cast<char*>("exposure_compensation"), (getter)FrameControlCapabilities_get_ExposureCompensation, nullptr, nullptr, nullptr },
        { const_cast<char*>("focus"), (getter)FrameControlCapabilities_get_Focus, nullptr, nullptr, nullptr },
        { const_cast<char*>("iso_speed"), (getter)FrameControlCapabilities_get_IsoSpeed, nullptr, nullptr, nullptr },
        { const_cast<char*>("photo_confirmation_supported"), (getter)FrameControlCapabilities_get_PhotoConfirmationSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("flash"), (getter)FrameControlCapabilities_get_Flash, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FrameControlCapabilities[] = 
    {
        { Py_tp_new, _new_FrameControlCapabilities },
        { Py_tp_dealloc, _dealloc_FrameControlCapabilities },
        { Py_tp_methods, _methods_FrameControlCapabilities },
        { Py_tp_getset, _getset_FrameControlCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameControlCapabilities =
    {
        "_winrt_Windows_Media_Devices_Core.FrameControlCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameControlCapabilities
    };

    // ----- FrameController class --------------------
    constexpr const char* const _type_name_FrameController = "FrameController";

    static PyObject* _new_FrameController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Devices::Core::FrameController instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FrameController(py::wrapper::Windows::Media::Devices::Core::FrameController* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameController_get_PhotoConfirmationEnabled(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhotoConfirmationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameController_put_PhotoConfirmationEnabled(py::wrapper::Windows::Media::Devices::Core::FrameController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.PhotoConfirmationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameController_get_ExposureCompensationControl(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExposureCompensationControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameController_get_ExposureControl(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExposureControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameController_get_FocusControl(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FocusControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameController_get_IsoSpeedControl(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsoSpeedControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameController_get_FlashControl(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FlashControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FrameController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameController[] = {
        { "_from", (PyCFunction)_from_FrameController, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FrameController[] = {
        { const_cast<char*>("photo_confirmation_enabled"), (getter)FrameController_get_PhotoConfirmationEnabled, (setter)FrameController_put_PhotoConfirmationEnabled, nullptr, nullptr },
        { const_cast<char*>("exposure_compensation_control"), (getter)FrameController_get_ExposureCompensationControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("exposure_control"), (getter)FrameController_get_ExposureControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("focus_control"), (getter)FrameController_get_FocusControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("iso_speed_control"), (getter)FrameController_get_IsoSpeedControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("flash_control"), (getter)FrameController_get_FlashControl, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FrameController[] = 
    {
        { Py_tp_new, _new_FrameController },
        { Py_tp_dealloc, _dealloc_FrameController },
        { Py_tp_methods, _methods_FrameController },
        { Py_tp_getset, _getset_FrameController },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameController =
    {
        "_winrt_Windows_Media_Devices_Core.FrameController",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameController
    };

    // ----- FrameExposureCapabilities class --------------------
    constexpr const char* const _type_name_FrameExposureCapabilities = "FrameExposureCapabilities";

    static PyObject* _new_FrameExposureCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameExposureCapabilities);
        return nullptr;
    }

    static void _dealloc_FrameExposureCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameExposureCapabilities_get_Max(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCapabilities_get_Min(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCapabilities_get_Step(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FrameExposureCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameExposureCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameExposureCapabilities[] = {
        { "_from", (PyCFunction)_from_FrameExposureCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FrameExposureCapabilities[] = {
        { const_cast<char*>("max"), (getter)FrameExposureCapabilities_get_Max, nullptr, nullptr, nullptr },
        { const_cast<char*>("min"), (getter)FrameExposureCapabilities_get_Min, nullptr, nullptr, nullptr },
        { const_cast<char*>("step"), (getter)FrameExposureCapabilities_get_Step, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)FrameExposureCapabilities_get_Supported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FrameExposureCapabilities[] = 
    {
        { Py_tp_new, _new_FrameExposureCapabilities },
        { Py_tp_dealloc, _dealloc_FrameExposureCapabilities },
        { Py_tp_methods, _methods_FrameExposureCapabilities },
        { Py_tp_getset, _getset_FrameExposureCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameExposureCapabilities =
    {
        "_winrt_Windows_Media_Devices_Core.FrameExposureCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameExposureCapabilities
    };

    // ----- FrameExposureCompensationCapabilities class --------------------
    constexpr const char* const _type_name_FrameExposureCompensationCapabilities = "FrameExposureCompensationCapabilities";

    static PyObject* _new_FrameExposureCompensationCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameExposureCompensationCapabilities);
        return nullptr;
    }

    static void _dealloc_FrameExposureCompensationCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameExposureCompensationCapabilities_get_Max(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCompensationCapabilities_get_Min(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCompensationCapabilities_get_Step(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCompensationCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FrameExposureCompensationCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameExposureCompensationCapabilities[] = {
        { "_from", (PyCFunction)_from_FrameExposureCompensationCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FrameExposureCompensationCapabilities[] = {
        { const_cast<char*>("max"), (getter)FrameExposureCompensationCapabilities_get_Max, nullptr, nullptr, nullptr },
        { const_cast<char*>("min"), (getter)FrameExposureCompensationCapabilities_get_Min, nullptr, nullptr, nullptr },
        { const_cast<char*>("step"), (getter)FrameExposureCompensationCapabilities_get_Step, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)FrameExposureCompensationCapabilities_get_Supported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FrameExposureCompensationCapabilities[] = 
    {
        { Py_tp_new, _new_FrameExposureCompensationCapabilities },
        { Py_tp_dealloc, _dealloc_FrameExposureCompensationCapabilities },
        { Py_tp_methods, _methods_FrameExposureCompensationCapabilities },
        { Py_tp_getset, _getset_FrameExposureCompensationCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameExposureCompensationCapabilities =
    {
        "_winrt_Windows_Media_Devices_Core.FrameExposureCompensationCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameExposureCompensationCapabilities
    };

    // ----- FrameExposureCompensationControl class --------------------
    constexpr const char* const _type_name_FrameExposureCompensationControl = "FrameExposureCompensationControl";

    static PyObject* _new_FrameExposureCompensationControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameExposureCompensationControl);
        return nullptr;
    }

    static void _dealloc_FrameExposureCompensationControl(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameExposureCompensationControl_get_Value(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameExposureCompensationControl_put_Value(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<float>>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_FrameExposureCompensationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameExposureCompensationControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameExposureCompensationControl[] = {
        { "_from", (PyCFunction)_from_FrameExposureCompensationControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FrameExposureCompensationControl[] = {
        { const_cast<char*>("value"), (getter)FrameExposureCompensationControl_get_Value, (setter)FrameExposureCompensationControl_put_Value, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FrameExposureCompensationControl[] = 
    {
        { Py_tp_new, _new_FrameExposureCompensationControl },
        { Py_tp_dealloc, _dealloc_FrameExposureCompensationControl },
        { Py_tp_methods, _methods_FrameExposureCompensationControl },
        { Py_tp_getset, _getset_FrameExposureCompensationControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameExposureCompensationControl =
    {
        "_winrt_Windows_Media_Devices_Core.FrameExposureCompensationControl",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameExposureCompensationControl
    };

    // ----- FrameExposureControl class --------------------
    constexpr const char* const _type_name_FrameExposureControl = "FrameExposureControl";

    static PyObject* _new_FrameExposureControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameExposureControl);
        return nullptr;
    }

    static void _dealloc_FrameExposureControl(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameExposureControl_get_Value(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameExposureControl_put_Value(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameExposureControl_get_Auto(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Auto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameExposureControl_put_Auto(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Auto(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_FrameExposureControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameExposureControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameExposureControl[] = {
        { "_from", (PyCFunction)_from_FrameExposureControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FrameExposureControl[] = {
        { const_cast<char*>("value"), (getter)FrameExposureControl_get_Value, (setter)FrameExposureControl_put_Value, nullptr, nullptr },
        { const_cast<char*>("auto"), (getter)FrameExposureControl_get_Auto, (setter)FrameExposureControl_put_Auto, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FrameExposureControl[] = 
    {
        { Py_tp_new, _new_FrameExposureControl },
        { Py_tp_dealloc, _dealloc_FrameExposureControl },
        { Py_tp_methods, _methods_FrameExposureControl },
        { Py_tp_getset, _getset_FrameExposureControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameExposureControl =
    {
        "_winrt_Windows_Media_Devices_Core.FrameExposureControl",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameExposureControl
    };

    // ----- FrameFlashCapabilities class --------------------
    constexpr const char* const _type_name_FrameFlashCapabilities = "FrameFlashCapabilities";

    static PyObject* _new_FrameFlashCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameFlashCapabilities);
        return nullptr;
    }

    static void _dealloc_FrameFlashCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameFlashCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameFlashCapabilities_get_PowerSupported(py::wrapper::Windows::Media::Devices::Core::FrameFlashCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameFlashCapabilities_get_RedEyeReductionSupported(py::wrapper::Windows::Media::Devices::Core::FrameFlashCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RedEyeReductionSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameFlashCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::Core::FrameFlashCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FrameFlashCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameFlashCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameFlashCapabilities[] = {
        { "_from", (PyCFunction)_from_FrameFlashCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FrameFlashCapabilities[] = {
        { const_cast<char*>("power_supported"), (getter)FrameFlashCapabilities_get_PowerSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("red_eye_reduction_supported"), (getter)FrameFlashCapabilities_get_RedEyeReductionSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)FrameFlashCapabilities_get_Supported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FrameFlashCapabilities[] = 
    {
        { Py_tp_new, _new_FrameFlashCapabilities },
        { Py_tp_dealloc, _dealloc_FrameFlashCapabilities },
        { Py_tp_methods, _methods_FrameFlashCapabilities },
        { Py_tp_getset, _getset_FrameFlashCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameFlashCapabilities =
    {
        "_winrt_Windows_Media_Devices_Core.FrameFlashCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameFlashCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameFlashCapabilities
    };

    // ----- FrameFlashControl class --------------------
    constexpr const char* const _type_name_FrameFlashControl = "FrameFlashControl";

    static PyObject* _new_FrameFlashControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameFlashControl);
        return nullptr;
    }

    static void _dealloc_FrameFlashControl(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameFlashControl_get_RedEyeReduction(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RedEyeReduction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameFlashControl_put_RedEyeReduction(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RedEyeReduction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameFlashControl_get_PowerPercent(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameFlashControl_put_PowerPercent(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.PowerPercent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameFlashControl_get_Mode(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameFlashControl_put_Mode(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::Core::FrameFlashMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameFlashControl_get_Auto(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Auto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameFlashControl_put_Auto(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Auto(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_FrameFlashControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameFlashControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameFlashControl[] = {
        { "_from", (PyCFunction)_from_FrameFlashControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FrameFlashControl[] = {
        { const_cast<char*>("red_eye_reduction"), (getter)FrameFlashControl_get_RedEyeReduction, (setter)FrameFlashControl_put_RedEyeReduction, nullptr, nullptr },
        { const_cast<char*>("power_percent"), (getter)FrameFlashControl_get_PowerPercent, (setter)FrameFlashControl_put_PowerPercent, nullptr, nullptr },
        { const_cast<char*>("mode"), (getter)FrameFlashControl_get_Mode, (setter)FrameFlashControl_put_Mode, nullptr, nullptr },
        { const_cast<char*>("auto"), (getter)FrameFlashControl_get_Auto, (setter)FrameFlashControl_put_Auto, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FrameFlashControl[] = 
    {
        { Py_tp_new, _new_FrameFlashControl },
        { Py_tp_dealloc, _dealloc_FrameFlashControl },
        { Py_tp_methods, _methods_FrameFlashControl },
        { Py_tp_getset, _getset_FrameFlashControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameFlashControl =
    {
        "_winrt_Windows_Media_Devices_Core.FrameFlashControl",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameFlashControl
    };

    // ----- FrameFocusCapabilities class --------------------
    constexpr const char* const _type_name_FrameFocusCapabilities = "FrameFocusCapabilities";

    static PyObject* _new_FrameFocusCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameFocusCapabilities);
        return nullptr;
    }

    static void _dealloc_FrameFocusCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameFocusCapabilities_get_Max(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameFocusCapabilities_get_Min(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameFocusCapabilities_get_Step(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameFocusCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FrameFocusCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameFocusCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameFocusCapabilities[] = {
        { "_from", (PyCFunction)_from_FrameFocusCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FrameFocusCapabilities[] = {
        { const_cast<char*>("max"), (getter)FrameFocusCapabilities_get_Max, nullptr, nullptr, nullptr },
        { const_cast<char*>("min"), (getter)FrameFocusCapabilities_get_Min, nullptr, nullptr, nullptr },
        { const_cast<char*>("step"), (getter)FrameFocusCapabilities_get_Step, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)FrameFocusCapabilities_get_Supported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FrameFocusCapabilities[] = 
    {
        { Py_tp_new, _new_FrameFocusCapabilities },
        { Py_tp_dealloc, _dealloc_FrameFocusCapabilities },
        { Py_tp_methods, _methods_FrameFocusCapabilities },
        { Py_tp_getset, _getset_FrameFocusCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameFocusCapabilities =
    {
        "_winrt_Windows_Media_Devices_Core.FrameFocusCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameFocusCapabilities
    };

    // ----- FrameFocusControl class --------------------
    constexpr const char* const _type_name_FrameFocusControl = "FrameFocusControl";

    static PyObject* _new_FrameFocusControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameFocusControl);
        return nullptr;
    }

    static void _dealloc_FrameFocusControl(py::wrapper::Windows::Media::Devices::Core::FrameFocusControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameFocusControl_get_Value(py::wrapper::Windows::Media::Devices::Core::FrameFocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameFocusControl_put_Value(py::wrapper::Windows::Media::Devices::Core::FrameFocusControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_FrameFocusControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameFocusControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameFocusControl[] = {
        { "_from", (PyCFunction)_from_FrameFocusControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FrameFocusControl[] = {
        { const_cast<char*>("value"), (getter)FrameFocusControl_get_Value, (setter)FrameFocusControl_put_Value, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FrameFocusControl[] = 
    {
        { Py_tp_new, _new_FrameFocusControl },
        { Py_tp_dealloc, _dealloc_FrameFocusControl },
        { Py_tp_methods, _methods_FrameFocusControl },
        { Py_tp_getset, _getset_FrameFocusControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameFocusControl =
    {
        "_winrt_Windows_Media_Devices_Core.FrameFocusControl",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameFocusControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameFocusControl
    };

    // ----- FrameIsoSpeedCapabilities class --------------------
    constexpr const char* const _type_name_FrameIsoSpeedCapabilities = "FrameIsoSpeedCapabilities";

    static PyObject* _new_FrameIsoSpeedCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameIsoSpeedCapabilities);
        return nullptr;
    }

    static void _dealloc_FrameIsoSpeedCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameIsoSpeedCapabilities_get_Max(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameIsoSpeedCapabilities_get_Min(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameIsoSpeedCapabilities_get_Step(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameIsoSpeedCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FrameIsoSpeedCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameIsoSpeedCapabilities[] = {
        { "_from", (PyCFunction)_from_FrameIsoSpeedCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FrameIsoSpeedCapabilities[] = {
        { const_cast<char*>("max"), (getter)FrameIsoSpeedCapabilities_get_Max, nullptr, nullptr, nullptr },
        { const_cast<char*>("min"), (getter)FrameIsoSpeedCapabilities_get_Min, nullptr, nullptr, nullptr },
        { const_cast<char*>("step"), (getter)FrameIsoSpeedCapabilities_get_Step, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)FrameIsoSpeedCapabilities_get_Supported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FrameIsoSpeedCapabilities[] = 
    {
        { Py_tp_new, _new_FrameIsoSpeedCapabilities },
        { Py_tp_dealloc, _dealloc_FrameIsoSpeedCapabilities },
        { Py_tp_methods, _methods_FrameIsoSpeedCapabilities },
        { Py_tp_getset, _getset_FrameIsoSpeedCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameIsoSpeedCapabilities =
    {
        "_winrt_Windows_Media_Devices_Core.FrameIsoSpeedCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameIsoSpeedCapabilities
    };

    // ----- FrameIsoSpeedControl class --------------------
    constexpr const char* const _type_name_FrameIsoSpeedControl = "FrameIsoSpeedControl";

    static PyObject* _new_FrameIsoSpeedControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameIsoSpeedControl);
        return nullptr;
    }

    static void _dealloc_FrameIsoSpeedControl(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameIsoSpeedControl_get_Value(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameIsoSpeedControl_put_Value(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameIsoSpeedControl_get_Auto(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Auto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameIsoSpeedControl_put_Auto(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Auto(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_FrameIsoSpeedControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameIsoSpeedControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameIsoSpeedControl[] = {
        { "_from", (PyCFunction)_from_FrameIsoSpeedControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FrameIsoSpeedControl[] = {
        { const_cast<char*>("value"), (getter)FrameIsoSpeedControl_get_Value, (setter)FrameIsoSpeedControl_put_Value, nullptr, nullptr },
        { const_cast<char*>("auto"), (getter)FrameIsoSpeedControl_get_Auto, (setter)FrameIsoSpeedControl_put_Auto, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FrameIsoSpeedControl[] = 
    {
        { Py_tp_new, _new_FrameIsoSpeedControl },
        { Py_tp_dealloc, _dealloc_FrameIsoSpeedControl },
        { Py_tp_methods, _methods_FrameIsoSpeedControl },
        { Py_tp_getset, _getset_FrameIsoSpeedControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameIsoSpeedControl =
    {
        "_winrt_Windows_Media_Devices_Core.FrameIsoSpeedControl",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameIsoSpeedControl
    };

    // ----- VariablePhotoSequenceController class --------------------
    constexpr const char* const _type_name_VariablePhotoSequenceController = "VariablePhotoSequenceController";

    static PyObject* _new_VariablePhotoSequenceController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VariablePhotoSequenceController);
        return nullptr;
    }

    static void _dealloc_VariablePhotoSequenceController(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VariablePhotoSequenceController_GetCurrentFrameRate(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentFrameRate());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VariablePhotoSequenceController_GetHighestConcurrentFrameRate(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 0);

                return py::convert(self->obj.GetHighestConcurrentFrameRate(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VariablePhotoSequenceController_get_PhotosPerSecondLimit(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhotosPerSecondLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VariablePhotoSequenceController_put_PhotosPerSecondLimit(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.PhotosPerSecondLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VariablePhotoSequenceController_get_DesiredFrameControllers(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredFrameControllers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VariablePhotoSequenceController_get_FrameCapabilities(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VariablePhotoSequenceController_get_MaxPhotosPerSecond(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPhotosPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VariablePhotoSequenceController_get_Supported(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VariablePhotoSequenceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::VariablePhotoSequenceController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VariablePhotoSequenceController[] = {
        { "get_current_frame_rate", (PyCFunction)VariablePhotoSequenceController_GetCurrentFrameRate, METH_VARARGS, nullptr },
        { "get_highest_concurrent_frame_rate", (PyCFunction)VariablePhotoSequenceController_GetHighestConcurrentFrameRate, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_VariablePhotoSequenceController, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VariablePhotoSequenceController[] = {
        { const_cast<char*>("photos_per_second_limit"), (getter)VariablePhotoSequenceController_get_PhotosPerSecondLimit, (setter)VariablePhotoSequenceController_put_PhotosPerSecondLimit, nullptr, nullptr },
        { const_cast<char*>("desired_frame_controllers"), (getter)VariablePhotoSequenceController_get_DesiredFrameControllers, nullptr, nullptr, nullptr },
        { const_cast<char*>("frame_capabilities"), (getter)VariablePhotoSequenceController_get_FrameCapabilities, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_photos_per_second"), (getter)VariablePhotoSequenceController_get_MaxPhotosPerSecond, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)VariablePhotoSequenceController_get_Supported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VariablePhotoSequenceController[] = 
    {
        { Py_tp_new, _new_VariablePhotoSequenceController },
        { Py_tp_dealloc, _dealloc_VariablePhotoSequenceController },
        { Py_tp_methods, _methods_VariablePhotoSequenceController },
        { Py_tp_getset, _getset_VariablePhotoSequenceController },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VariablePhotoSequenceController =
    {
        "_winrt_Windows_Media_Devices_Core.VariablePhotoSequenceController",
        sizeof(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VariablePhotoSequenceController
    };

    // ----- Windows.Media.Devices.Core Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Media::Devices::Core::CameraIntrinsics>::python_type = py::register_python_type(module, _type_name_CameraIntrinsics, &_type_spec_CameraIntrinsics, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper>::python_type = py::register_python_type(module, _type_name_DepthCorrelatedCoordinateMapper, &_type_spec_DepthCorrelatedCoordinateMapper, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameControlCapabilities>::python_type = py::register_python_type(module, _type_name_FrameControlCapabilities, &_type_spec_FrameControlCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameController>::python_type = py::register_python_type(module, _type_name_FrameController, &_type_spec_FrameController, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameExposureCapabilities>::python_type = py::register_python_type(module, _type_name_FrameExposureCapabilities, &_type_spec_FrameExposureCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities>::python_type = py::register_python_type(module, _type_name_FrameExposureCompensationCapabilities, &_type_spec_FrameExposureCompensationCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameExposureCompensationControl>::python_type = py::register_python_type(module, _type_name_FrameExposureCompensationControl, &_type_spec_FrameExposureCompensationControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameExposureControl>::python_type = py::register_python_type(module, _type_name_FrameExposureControl, &_type_spec_FrameExposureControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameFlashCapabilities>::python_type = py::register_python_type(module, _type_name_FrameFlashCapabilities, &_type_spec_FrameFlashCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameFlashControl>::python_type = py::register_python_type(module, _type_name_FrameFlashControl, &_type_spec_FrameFlashControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameFocusCapabilities>::python_type = py::register_python_type(module, _type_name_FrameFocusCapabilities, &_type_spec_FrameFocusCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameFocusControl>::python_type = py::register_python_type(module, _type_name_FrameFocusControl, &_type_spec_FrameFocusControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities>::python_type = py::register_python_type(module, _type_name_FrameIsoSpeedCapabilities, &_type_spec_FrameIsoSpeedCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameIsoSpeedControl>::python_type = py::register_python_type(module, _type_name_FrameIsoSpeedControl, &_type_spec_FrameIsoSpeedControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::VariablePhotoSequenceController>::python_type = py::register_python_type(module, _type_name_VariablePhotoSequenceController, &_type_spec_VariablePhotoSequenceController, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Media.Devices.Core");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Media_Devices_Core",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Media::Devices::Core

PyMODINIT_FUNC
PyInit__winrt_Windows_Media_Devices_Core (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Media::Devices::Core::module_def);
}
