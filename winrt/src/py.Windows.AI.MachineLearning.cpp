// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.AI.MachineLearning.h"

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ImageFeatureValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModel>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelBinding>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelDevice>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelSession>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelSessionOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorBoolean>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorDouble>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFloat>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt16Bit>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt32Bit>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt64Bit>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt8Bit>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorString>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ITensor>::python_type;

namespace py::cpp::Windows::AI::MachineLearning
{
    // ----- ImageFeatureDescriptor class --------------------
    constexpr const char* const _type_name_ImageFeatureDescriptor = "ImageFeatureDescriptor";

    static PyObject* _new_ImageFeatureDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ImageFeatureDescriptor);
        return nullptr;
    }

    static void _dealloc_ImageFeatureDescriptor(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ImageFeatureDescriptor_get_BitmapAlphaMode(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_BitmapPixelFormat(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_Height(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_Width(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_PixelRange(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_Description(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_IsRequired(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_Kind(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_Name(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ImageFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageFeatureDescriptor[] = {
        { "_from", (PyCFunction)_from_ImageFeatureDescriptor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ImageFeatureDescriptor[] = {
        { const_cast<char*>("bitmap_alpha_mode"), (getter)ImageFeatureDescriptor_get_BitmapAlphaMode, nullptr, nullptr, nullptr },
        { const_cast<char*>("bitmap_pixel_format"), (getter)ImageFeatureDescriptor_get_BitmapPixelFormat, nullptr, nullptr, nullptr },
        { const_cast<char*>("height"), (getter)ImageFeatureDescriptor_get_Height, nullptr, nullptr, nullptr },
        { const_cast<char*>("width"), (getter)ImageFeatureDescriptor_get_Width, nullptr, nullptr, nullptr },
        { const_cast<char*>("pixel_range"), (getter)ImageFeatureDescriptor_get_PixelRange, nullptr, nullptr, nullptr },
        { const_cast<char*>("description"), (getter)ImageFeatureDescriptor_get_Description, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_required"), (getter)ImageFeatureDescriptor_get_IsRequired, nullptr, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)ImageFeatureDescriptor_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)ImageFeatureDescriptor_get_Name, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ImageFeatureDescriptor[] = 
    {
        { Py_tp_new, _new_ImageFeatureDescriptor },
        { Py_tp_dealloc, _dealloc_ImageFeatureDescriptor },
        { Py_tp_methods, _methods_ImageFeatureDescriptor },
        { Py_tp_getset, _getset_ImageFeatureDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ImageFeatureDescriptor =
    {
        "_winrt_Windows_AI_MachineLearning.ImageFeatureDescriptor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageFeatureDescriptor
    };

    // ----- ImageFeatureValue class --------------------
    constexpr const char* const _type_name_ImageFeatureValue = "ImageFeatureValue";

    static PyObject* _new_ImageFeatureValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ImageFeatureValue);
        return nullptr;
    }

    static void _dealloc_ImageFeatureValue(py::wrapper::Windows::AI::MachineLearning::ImageFeatureValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ImageFeatureValue_CreateFromVideoFrame(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::VideoFrame>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::ImageFeatureValue::CreateFromVideoFrame(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageFeatureValue_get_VideoFrame(py::wrapper::Windows::AI::MachineLearning::ImageFeatureValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureValue_get_Kind(py::wrapper::Windows::AI::MachineLearning::ImageFeatureValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ImageFeatureValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ImageFeatureValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageFeatureValue[] = {
        { "create_from_video_frame", (PyCFunction)ImageFeatureValue_CreateFromVideoFrame, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_ImageFeatureValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ImageFeatureValue[] = {
        { const_cast<char*>("video_frame"), (getter)ImageFeatureValue_get_VideoFrame, nullptr, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)ImageFeatureValue_get_Kind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ImageFeatureValue[] = 
    {
        { Py_tp_new, _new_ImageFeatureValue },
        { Py_tp_dealloc, _dealloc_ImageFeatureValue },
        { Py_tp_methods, _methods_ImageFeatureValue },
        { Py_tp_getset, _getset_ImageFeatureValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ImageFeatureValue =
    {
        "_winrt_Windows_AI_MachineLearning.ImageFeatureValue",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ImageFeatureValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageFeatureValue
    };

    // ----- LearningModel class --------------------
    constexpr const char* const _type_name_LearningModel = "LearningModel";

    static PyObject* _new_LearningModel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LearningModel);
        return nullptr;
    }

    static void _dealloc_LearningModel(py::wrapper::Windows::AI::MachineLearning::LearningModel* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LearningModel_Close(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModel_LoadFromFilePath(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromFilePath(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromFilePath(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModel_LoadFromStorageFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStorageFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStorageFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModel_LoadFromStream(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStream(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStream(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModel_LoadFromStreamAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Author(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Author());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Description(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Domain(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Domain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_InputFeatures(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputFeatures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Metadata(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Metadata());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Name(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_OutputFeatures(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputFeatures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Version(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LearningModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LearningModel(py::wrapper::Windows::AI::MachineLearning::LearningModel* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_LearningModel(py::wrapper::Windows::AI::MachineLearning::LearningModel* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModel[] = {
        { "close", (PyCFunction)LearningModel_Close, METH_VARARGS, nullptr },
        { "load_from_file_path", (PyCFunction)LearningModel_LoadFromFilePath, METH_VARARGS | METH_STATIC, nullptr },
        { "load_from_storage_file_async", (PyCFunction)LearningModel_LoadFromStorageFileAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "load_from_stream", (PyCFunction)LearningModel_LoadFromStream, METH_VARARGS | METH_STATIC, nullptr },
        { "load_from_stream_async", (PyCFunction)LearningModel_LoadFromStreamAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_LearningModel, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_LearningModel, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_LearningModel, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LearningModel[] = {
        { const_cast<char*>("author"), (getter)LearningModel_get_Author, nullptr, nullptr, nullptr },
        { const_cast<char*>("description"), (getter)LearningModel_get_Description, nullptr, nullptr, nullptr },
        { const_cast<char*>("domain"), (getter)LearningModel_get_Domain, nullptr, nullptr, nullptr },
        { const_cast<char*>("input_features"), (getter)LearningModel_get_InputFeatures, nullptr, nullptr, nullptr },
        { const_cast<char*>("metadata"), (getter)LearningModel_get_Metadata, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)LearningModel_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("output_features"), (getter)LearningModel_get_OutputFeatures, nullptr, nullptr, nullptr },
        { const_cast<char*>("version"), (getter)LearningModel_get_Version, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LearningModel[] = 
    {
        { Py_tp_new, _new_LearningModel },
        { Py_tp_dealloc, _dealloc_LearningModel },
        { Py_tp_methods, _methods_LearningModel },
        { Py_tp_getset, _getset_LearningModel },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LearningModel =
    {
        "_winrt_Windows_AI_MachineLearning.LearningModel",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModel
    };

    // ----- LearningModelBinding class --------------------
    constexpr const char* const _type_name_LearningModelBinding = "LearningModelBinding";

    static PyObject* _new_LearningModelBinding(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelSession>(args, 0);

                winrt::Windows::AI::MachineLearning::LearningModelBinding instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LearningModelBinding(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LearningModelBinding_Bind(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.Bind(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                self->obj.Bind(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_Clear(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_First(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_HasKey(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_Lookup(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_Split(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable> param0 { nullptr };
                winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable> param1 { nullptr };

                self->obj.Split(param0, param1);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out0.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_get_Size(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LearningModelBinding(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModelBinding>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_LearningModelBinding(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _map_length_LearningModelBinding(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_LearningModelBinding(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* key) noexcept
    {
        try
        {
            return py::convert(self->obj.Lookup(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModelBinding[] = {
        { "bind", (PyCFunction)LearningModelBinding_Bind, METH_VARARGS, nullptr },
        { "clear", (PyCFunction)LearningModelBinding_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)LearningModelBinding_First, METH_VARARGS, nullptr },
        { "has_key", (PyCFunction)LearningModelBinding_HasKey, METH_VARARGS, nullptr },
        { "lookup", (PyCFunction)LearningModelBinding_Lookup, METH_VARARGS, nullptr },
        { "split", (PyCFunction)LearningModelBinding_Split, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_LearningModelBinding, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LearningModelBinding[] = {
        { const_cast<char*>("size"), (getter)LearningModelBinding_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LearningModelBinding[] = 
    {
        { Py_tp_new, _new_LearningModelBinding },
        { Py_tp_dealloc, _dealloc_LearningModelBinding },
        { Py_tp_methods, _methods_LearningModelBinding },
        { Py_tp_getset, _getset_LearningModelBinding },
        { Py_tp_iter, _iterator_LearningModelBinding },
        { Py_mp_length, _map_length_LearningModelBinding },
        { Py_mp_subscript, _map_subscript_LearningModelBinding },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LearningModelBinding =
    {
        "_winrt_Windows_AI_MachineLearning.LearningModelBinding",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModelBinding
    };

    // ----- LearningModelDevice class --------------------
    constexpr const char* const _type_name_LearningModelDevice = "LearningModelDevice";

    static PyObject* _new_LearningModelDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelDeviceKind>(args, 0);

                winrt::Windows::AI::MachineLearning::LearningModelDevice instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LearningModelDevice(py::wrapper::Windows::AI::MachineLearning::LearningModelDevice* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LearningModelDevice_CreateFromDirect3D11Device(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DDevice>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModelDevice::CreateFromDirect3D11Device(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelDevice_get_AdapterId(py::wrapper::Windows::AI::MachineLearning::LearningModelDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdapterId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelDevice_get_Direct3D11Device(py::wrapper::Windows::AI::MachineLearning::LearningModelDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Direct3D11Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LearningModelDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModelDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModelDevice[] = {
        { "create_from_direct3_d11_device", (PyCFunction)LearningModelDevice_CreateFromDirect3D11Device, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_LearningModelDevice, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LearningModelDevice[] = {
        { const_cast<char*>("adapter_id"), (getter)LearningModelDevice_get_AdapterId, nullptr, nullptr, nullptr },
        { const_cast<char*>("direct3_d11_device"), (getter)LearningModelDevice_get_Direct3D11Device, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LearningModelDevice[] = 
    {
        { Py_tp_new, _new_LearningModelDevice },
        { Py_tp_dealloc, _dealloc_LearningModelDevice },
        { Py_tp_methods, _methods_LearningModelDevice },
        { Py_tp_getset, _getset_LearningModelDevice },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LearningModelDevice =
    {
        "_winrt_Windows_AI_MachineLearning.LearningModelDevice",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModelDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModelDevice
    };

    // ----- LearningModelEvaluationResult class --------------------
    constexpr const char* const _type_name_LearningModelEvaluationResult = "LearningModelEvaluationResult";

    static PyObject* _new_LearningModelEvaluationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LearningModelEvaluationResult);
        return nullptr;
    }

    static void _dealloc_LearningModelEvaluationResult(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LearningModelEvaluationResult_get_CorrelationId(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CorrelationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelEvaluationResult_get_ErrorStatus(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelEvaluationResult_get_Outputs(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Outputs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelEvaluationResult_get_Succeeded(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LearningModelEvaluationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModelEvaluationResult[] = {
        { "_from", (PyCFunction)_from_LearningModelEvaluationResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LearningModelEvaluationResult[] = {
        { const_cast<char*>("correlation_id"), (getter)LearningModelEvaluationResult_get_CorrelationId, nullptr, nullptr, nullptr },
        { const_cast<char*>("error_status"), (getter)LearningModelEvaluationResult_get_ErrorStatus, nullptr, nullptr, nullptr },
        { const_cast<char*>("outputs"), (getter)LearningModelEvaluationResult_get_Outputs, nullptr, nullptr, nullptr },
        { const_cast<char*>("succeeded"), (getter)LearningModelEvaluationResult_get_Succeeded, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LearningModelEvaluationResult[] = 
    {
        { Py_tp_new, _new_LearningModelEvaluationResult },
        { Py_tp_dealloc, _dealloc_LearningModelEvaluationResult },
        { Py_tp_methods, _methods_LearningModelEvaluationResult },
        { Py_tp_getset, _getset_LearningModelEvaluationResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LearningModelEvaluationResult =
    {
        "_winrt_Windows_AI_MachineLearning.LearningModelEvaluationResult",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModelEvaluationResult
    };

    // ----- LearningModelSession class --------------------
    constexpr const char* const _type_name_LearningModelSession = "LearningModelSession";

    static PyObject* _new_LearningModelSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelDevice>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelSessionOptions>(args, 2);

                winrt::Windows::AI::MachineLearning::LearningModelSession instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModel>(args, 0);

                winrt::Windows::AI::MachineLearning::LearningModelSession instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelDevice>(args, 1);

                winrt::Windows::AI::MachineLearning::LearningModelSession instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LearningModelSession(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LearningModelSession_Close(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_Evaluate(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelBinding>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.Evaluate(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_EvaluateAsync(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelBinding>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.EvaluateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_EvaluateFeatures(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.EvaluateFeatures(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_EvaluateFeaturesAsync(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.EvaluateFeaturesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_get_Device(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_get_EvaluationProperties(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EvaluationProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_get_Model(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Model());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LearningModelSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModelSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LearningModelSession(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_LearningModelSession(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModelSession[] = {
        { "close", (PyCFunction)LearningModelSession_Close, METH_VARARGS, nullptr },
        { "evaluate", (PyCFunction)LearningModelSession_Evaluate, METH_VARARGS, nullptr },
        { "evaluate_async", (PyCFunction)LearningModelSession_EvaluateAsync, METH_VARARGS, nullptr },
        { "evaluate_features", (PyCFunction)LearningModelSession_EvaluateFeatures, METH_VARARGS, nullptr },
        { "evaluate_features_async", (PyCFunction)LearningModelSession_EvaluateFeaturesAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_LearningModelSession, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_LearningModelSession, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_LearningModelSession, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LearningModelSession[] = {
        { const_cast<char*>("device"), (getter)LearningModelSession_get_Device, nullptr, nullptr, nullptr },
        { const_cast<char*>("evaluation_properties"), (getter)LearningModelSession_get_EvaluationProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("model"), (getter)LearningModelSession_get_Model, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LearningModelSession[] = 
    {
        { Py_tp_new, _new_LearningModelSession },
        { Py_tp_dealloc, _dealloc_LearningModelSession },
        { Py_tp_methods, _methods_LearningModelSession },
        { Py_tp_getset, _getset_LearningModelSession },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LearningModelSession =
    {
        "_winrt_Windows_AI_MachineLearning.LearningModelSession",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModelSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModelSession
    };

    // ----- LearningModelSessionOptions class --------------------
    constexpr const char* const _type_name_LearningModelSessionOptions = "LearningModelSessionOptions";

    static PyObject* _new_LearningModelSessionOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::AI::MachineLearning::LearningModelSessionOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LearningModelSessionOptions(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LearningModelSessionOptions_OverrideNamedDimension(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.OverrideNamedDimension(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSessionOptions_get_BatchSizeOverride(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BatchSizeOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LearningModelSessionOptions_put_BatchSizeOverride(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.BatchSizeOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LearningModelSessionOptions_get_CloseModelOnSessionCreation(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CloseModelOnSessionCreation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LearningModelSessionOptions_put_CloseModelOnSessionCreation(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CloseModelOnSessionCreation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_LearningModelSessionOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModelSessionOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModelSessionOptions[] = {
        { "override_named_dimension", (PyCFunction)LearningModelSessionOptions_OverrideNamedDimension, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_LearningModelSessionOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LearningModelSessionOptions[] = {
        { const_cast<char*>("batch_size_override"), (getter)LearningModelSessionOptions_get_BatchSizeOverride, (setter)LearningModelSessionOptions_put_BatchSizeOverride, nullptr, nullptr },
        { const_cast<char*>("close_model_on_session_creation"), (getter)LearningModelSessionOptions_get_CloseModelOnSessionCreation, (setter)LearningModelSessionOptions_put_CloseModelOnSessionCreation, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LearningModelSessionOptions[] = 
    {
        { Py_tp_new, _new_LearningModelSessionOptions },
        { Py_tp_dealloc, _dealloc_LearningModelSessionOptions },
        { Py_tp_methods, _methods_LearningModelSessionOptions },
        { Py_tp_getset, _getset_LearningModelSessionOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LearningModelSessionOptions =
    {
        "_winrt_Windows_AI_MachineLearning.LearningModelSessionOptions",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModelSessionOptions
    };

    // ----- MapFeatureDescriptor class --------------------
    constexpr const char* const _type_name_MapFeatureDescriptor = "MapFeatureDescriptor";

    static PyObject* _new_MapFeatureDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MapFeatureDescriptor);
        return nullptr;
    }

    static void _dealloc_MapFeatureDescriptor(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MapFeatureDescriptor_get_Description(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapFeatureDescriptor_get_IsRequired(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapFeatureDescriptor_get_Kind(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapFeatureDescriptor_get_Name(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapFeatureDescriptor_get_KeyKind(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapFeatureDescriptor_get_ValueDescriptor(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ValueDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MapFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapFeatureDescriptor[] = {
        { "_from", (PyCFunction)_from_MapFeatureDescriptor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MapFeatureDescriptor[] = {
        { const_cast<char*>("description"), (getter)MapFeatureDescriptor_get_Description, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_required"), (getter)MapFeatureDescriptor_get_IsRequired, nullptr, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)MapFeatureDescriptor_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)MapFeatureDescriptor_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("key_kind"), (getter)MapFeatureDescriptor_get_KeyKind, nullptr, nullptr, nullptr },
        { const_cast<char*>("value_descriptor"), (getter)MapFeatureDescriptor_get_ValueDescriptor, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MapFeatureDescriptor[] = 
    {
        { Py_tp_new, _new_MapFeatureDescriptor },
        { Py_tp_dealloc, _dealloc_MapFeatureDescriptor },
        { Py_tp_methods, _methods_MapFeatureDescriptor },
        { Py_tp_getset, _getset_MapFeatureDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MapFeatureDescriptor =
    {
        "_winrt_Windows_AI_MachineLearning.MapFeatureDescriptor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapFeatureDescriptor
    };

    // ----- SequenceFeatureDescriptor class --------------------
    constexpr const char* const _type_name_SequenceFeatureDescriptor = "SequenceFeatureDescriptor";

    static PyObject* _new_SequenceFeatureDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SequenceFeatureDescriptor);
        return nullptr;
    }

    static void _dealloc_SequenceFeatureDescriptor(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SequenceFeatureDescriptor_get_Description(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SequenceFeatureDescriptor_get_IsRequired(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SequenceFeatureDescriptor_get_Kind(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SequenceFeatureDescriptor_get_Name(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SequenceFeatureDescriptor_get_ElementDescriptor(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ElementDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SequenceFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SequenceFeatureDescriptor[] = {
        { "_from", (PyCFunction)_from_SequenceFeatureDescriptor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SequenceFeatureDescriptor[] = {
        { const_cast<char*>("description"), (getter)SequenceFeatureDescriptor_get_Description, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_required"), (getter)SequenceFeatureDescriptor_get_IsRequired, nullptr, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)SequenceFeatureDescriptor_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)SequenceFeatureDescriptor_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("element_descriptor"), (getter)SequenceFeatureDescriptor_get_ElementDescriptor, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SequenceFeatureDescriptor[] = 
    {
        { Py_tp_new, _new_SequenceFeatureDescriptor },
        { Py_tp_dealloc, _dealloc_SequenceFeatureDescriptor },
        { Py_tp_methods, _methods_SequenceFeatureDescriptor },
        { Py_tp_getset, _getset_SequenceFeatureDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SequenceFeatureDescriptor =
    {
        "_winrt_Windows_AI_MachineLearning.SequenceFeatureDescriptor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SequenceFeatureDescriptor
    };

    // ----- TensorBoolean class --------------------
    constexpr const char* const _type_name_TensorBoolean = "TensorBoolean";

    static PyObject* _new_TensorBoolean(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorBoolean);
        return nullptr;
    }

    static void _dealloc_TensorBoolean(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorBoolean_Close(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<bool>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<bool>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<bool>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorBoolean(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorBoolean>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorBoolean(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_TensorBoolean(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorBoolean[] = {
        { "close", (PyCFunction)TensorBoolean_Close, METH_VARARGS, nullptr },
        { "create", (PyCFunction)TensorBoolean_Create, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", (PyCFunction)TensorBoolean_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", (PyCFunction)TensorBoolean_CreateFromBuffer, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", (PyCFunction)TensorBoolean_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", (PyCFunction)TensorBoolean_CreateFromShapeArrayAndDataArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", (PyCFunction)TensorBoolean_CreateReference, METH_VARARGS, nullptr },
        { "get_as_vector_view", (PyCFunction)TensorBoolean_GetAsVectorView, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_TensorBoolean, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_TensorBoolean, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_TensorBoolean, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TensorBoolean[] = {
        { const_cast<char*>("kind"), (getter)TensorBoolean_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("shape"), (getter)TensorBoolean_get_Shape, nullptr, nullptr, nullptr },
        { const_cast<char*>("tensor_kind"), (getter)TensorBoolean_get_TensorKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TensorBoolean[] = 
    {
        { Py_tp_new, _new_TensorBoolean },
        { Py_tp_dealloc, _dealloc_TensorBoolean },
        { Py_tp_methods, _methods_TensorBoolean },
        { Py_tp_getset, _getset_TensorBoolean },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TensorBoolean =
    {
        "_winrt_Windows_AI_MachineLearning.TensorBoolean",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorBoolean),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorBoolean
    };

    // ----- TensorDouble class --------------------
    constexpr const char* const _type_name_TensorDouble = "TensorDouble";

    static PyObject* _new_TensorDouble(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorDouble);
        return nullptr;
    }

    static void _dealloc_TensorDouble(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorDouble_Close(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<double>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<double>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<double>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorDouble_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorDouble_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorDouble(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorDouble>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorDouble(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_TensorDouble(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorDouble[] = {
        { "close", (PyCFunction)TensorDouble_Close, METH_VARARGS, nullptr },
        { "create", (PyCFunction)TensorDouble_Create, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", (PyCFunction)TensorDouble_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", (PyCFunction)TensorDouble_CreateFromBuffer, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", (PyCFunction)TensorDouble_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", (PyCFunction)TensorDouble_CreateFromShapeArrayAndDataArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", (PyCFunction)TensorDouble_CreateReference, METH_VARARGS, nullptr },
        { "get_as_vector_view", (PyCFunction)TensorDouble_GetAsVectorView, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_TensorDouble, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_TensorDouble, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_TensorDouble, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TensorDouble[] = {
        { const_cast<char*>("kind"), (getter)TensorDouble_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("shape"), (getter)TensorDouble_get_Shape, nullptr, nullptr, nullptr },
        { const_cast<char*>("tensor_kind"), (getter)TensorDouble_get_TensorKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TensorDouble[] = 
    {
        { Py_tp_new, _new_TensorDouble },
        { Py_tp_dealloc, _dealloc_TensorDouble },
        { Py_tp_methods, _methods_TensorDouble },
        { Py_tp_getset, _getset_TensorDouble },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TensorDouble =
    {
        "_winrt_Windows_AI_MachineLearning.TensorDouble",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorDouble),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorDouble
    };

    // ----- TensorFeatureDescriptor class --------------------
    constexpr const char* const _type_name_TensorFeatureDescriptor = "TensorFeatureDescriptor";

    static PyObject* _new_TensorFeatureDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorFeatureDescriptor);
        return nullptr;
    }

    static void _dealloc_TensorFeatureDescriptor(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorFeatureDescriptor_get_Description(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFeatureDescriptor_get_IsRequired(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFeatureDescriptor_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFeatureDescriptor_get_Name(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFeatureDescriptor_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFeatureDescriptor_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorFeatureDescriptor[] = {
        { "_from", (PyCFunction)_from_TensorFeatureDescriptor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TensorFeatureDescriptor[] = {
        { const_cast<char*>("description"), (getter)TensorFeatureDescriptor_get_Description, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_required"), (getter)TensorFeatureDescriptor_get_IsRequired, nullptr, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)TensorFeatureDescriptor_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)TensorFeatureDescriptor_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("shape"), (getter)TensorFeatureDescriptor_get_Shape, nullptr, nullptr, nullptr },
        { const_cast<char*>("tensor_kind"), (getter)TensorFeatureDescriptor_get_TensorKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TensorFeatureDescriptor[] = 
    {
        { Py_tp_new, _new_TensorFeatureDescriptor },
        { Py_tp_dealloc, _dealloc_TensorFeatureDescriptor },
        { Py_tp_methods, _methods_TensorFeatureDescriptor },
        { Py_tp_getset, _getset_TensorFeatureDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TensorFeatureDescriptor =
    {
        "_winrt_Windows_AI_MachineLearning.TensorFeatureDescriptor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorFeatureDescriptor
    };

    // ----- TensorFloat class --------------------
    constexpr const char* const _type_name_TensorFloat = "TensorFloat";

    static PyObject* _new_TensorFloat(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorFloat);
        return nullptr;
    }

    static void _dealloc_TensorFloat(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorFloat_Close(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<float>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<float>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<float>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFloat_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFloat_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorFloat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorFloat>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorFloat(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_TensorFloat(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorFloat[] = {
        { "close", (PyCFunction)TensorFloat_Close, METH_VARARGS, nullptr },
        { "create", (PyCFunction)TensorFloat_Create, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", (PyCFunction)TensorFloat_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", (PyCFunction)TensorFloat_CreateFromBuffer, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", (PyCFunction)TensorFloat_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", (PyCFunction)TensorFloat_CreateFromShapeArrayAndDataArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", (PyCFunction)TensorFloat_CreateReference, METH_VARARGS, nullptr },
        { "get_as_vector_view", (PyCFunction)TensorFloat_GetAsVectorView, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_TensorFloat, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_TensorFloat, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_TensorFloat, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TensorFloat[] = {
        { const_cast<char*>("kind"), (getter)TensorFloat_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("shape"), (getter)TensorFloat_get_Shape, nullptr, nullptr, nullptr },
        { const_cast<char*>("tensor_kind"), (getter)TensorFloat_get_TensorKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TensorFloat[] = 
    {
        { Py_tp_new, _new_TensorFloat },
        { Py_tp_dealloc, _dealloc_TensorFloat },
        { Py_tp_methods, _methods_TensorFloat },
        { Py_tp_getset, _getset_TensorFloat },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TensorFloat =
    {
        "_winrt_Windows_AI_MachineLearning.TensorFloat",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorFloat),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorFloat
    };

    // ----- TensorFloat16Bit class --------------------
    constexpr const char* const _type_name_TensorFloat16Bit = "TensorFloat16Bit";

    static PyObject* _new_TensorFloat16Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorFloat16Bit);
        return nullptr;
    }

    static void _dealloc_TensorFloat16Bit(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorFloat16Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<float>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<float>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<float>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorFloat16Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorFloat16Bit(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_TensorFloat16Bit(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorFloat16Bit[] = {
        { "close", (PyCFunction)TensorFloat16Bit_Close, METH_VARARGS, nullptr },
        { "create", (PyCFunction)TensorFloat16Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", (PyCFunction)TensorFloat16Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", (PyCFunction)TensorFloat16Bit_CreateFromBuffer, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", (PyCFunction)TensorFloat16Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", (PyCFunction)TensorFloat16Bit_CreateFromShapeArrayAndDataArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", (PyCFunction)TensorFloat16Bit_CreateReference, METH_VARARGS, nullptr },
        { "get_as_vector_view", (PyCFunction)TensorFloat16Bit_GetAsVectorView, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_TensorFloat16Bit, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_TensorFloat16Bit, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_TensorFloat16Bit, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TensorFloat16Bit[] = {
        { const_cast<char*>("kind"), (getter)TensorFloat16Bit_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("shape"), (getter)TensorFloat16Bit_get_Shape, nullptr, nullptr, nullptr },
        { const_cast<char*>("tensor_kind"), (getter)TensorFloat16Bit_get_TensorKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TensorFloat16Bit[] = 
    {
        { Py_tp_new, _new_TensorFloat16Bit },
        { Py_tp_dealloc, _dealloc_TensorFloat16Bit },
        { Py_tp_methods, _methods_TensorFloat16Bit },
        { Py_tp_getset, _getset_TensorFloat16Bit },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TensorFloat16Bit =
    {
        "_winrt_Windows_AI_MachineLearning.TensorFloat16Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorFloat16Bit
    };

    // ----- TensorInt16Bit class --------------------
    constexpr const char* const _type_name_TensorInt16Bit = "TensorInt16Bit";

    static PyObject* _new_TensorInt16Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorInt16Bit);
        return nullptr;
    }

    static void _dealloc_TensorInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorInt16Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int16_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int16_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int16_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorInt16Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorInt16Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_TensorInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorInt16Bit[] = {
        { "close", (PyCFunction)TensorInt16Bit_Close, METH_VARARGS, nullptr },
        { "create", (PyCFunction)TensorInt16Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", (PyCFunction)TensorInt16Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", (PyCFunction)TensorInt16Bit_CreateFromBuffer, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", (PyCFunction)TensorInt16Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", (PyCFunction)TensorInt16Bit_CreateFromShapeArrayAndDataArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", (PyCFunction)TensorInt16Bit_CreateReference, METH_VARARGS, nullptr },
        { "get_as_vector_view", (PyCFunction)TensorInt16Bit_GetAsVectorView, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_TensorInt16Bit, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_TensorInt16Bit, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_TensorInt16Bit, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TensorInt16Bit[] = {
        { const_cast<char*>("kind"), (getter)TensorInt16Bit_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("shape"), (getter)TensorInt16Bit_get_Shape, nullptr, nullptr, nullptr },
        { const_cast<char*>("tensor_kind"), (getter)TensorInt16Bit_get_TensorKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TensorInt16Bit[] = 
    {
        { Py_tp_new, _new_TensorInt16Bit },
        { Py_tp_dealloc, _dealloc_TensorInt16Bit },
        { Py_tp_methods, _methods_TensorInt16Bit },
        { Py_tp_getset, _getset_TensorInt16Bit },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TensorInt16Bit =
    {
        "_winrt_Windows_AI_MachineLearning.TensorInt16Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorInt16Bit
    };

    // ----- TensorInt32Bit class --------------------
    constexpr const char* const _type_name_TensorInt32Bit = "TensorInt32Bit";

    static PyObject* _new_TensorInt32Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorInt32Bit);
        return nullptr;
    }

    static void _dealloc_TensorInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorInt32Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int32_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorInt32Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorInt32Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_TensorInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorInt32Bit[] = {
        { "close", (PyCFunction)TensorInt32Bit_Close, METH_VARARGS, nullptr },
        { "create", (PyCFunction)TensorInt32Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", (PyCFunction)TensorInt32Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", (PyCFunction)TensorInt32Bit_CreateFromBuffer, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", (PyCFunction)TensorInt32Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", (PyCFunction)TensorInt32Bit_CreateFromShapeArrayAndDataArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", (PyCFunction)TensorInt32Bit_CreateReference, METH_VARARGS, nullptr },
        { "get_as_vector_view", (PyCFunction)TensorInt32Bit_GetAsVectorView, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_TensorInt32Bit, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_TensorInt32Bit, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_TensorInt32Bit, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TensorInt32Bit[] = {
        { const_cast<char*>("kind"), (getter)TensorInt32Bit_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("shape"), (getter)TensorInt32Bit_get_Shape, nullptr, nullptr, nullptr },
        { const_cast<char*>("tensor_kind"), (getter)TensorInt32Bit_get_TensorKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TensorInt32Bit[] = 
    {
        { Py_tp_new, _new_TensorInt32Bit },
        { Py_tp_dealloc, _dealloc_TensorInt32Bit },
        { Py_tp_methods, _methods_TensorInt32Bit },
        { Py_tp_getset, _getset_TensorInt32Bit },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TensorInt32Bit =
    {
        "_winrt_Windows_AI_MachineLearning.TensorInt32Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorInt32Bit
    };

    // ----- TensorInt64Bit class --------------------
    constexpr const char* const _type_name_TensorInt64Bit = "TensorInt64Bit";

    static PyObject* _new_TensorInt64Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorInt64Bit);
        return nullptr;
    }

    static void _dealloc_TensorInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorInt64Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int64_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int64_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorInt64Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorInt64Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_TensorInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorInt64Bit[] = {
        { "close", (PyCFunction)TensorInt64Bit_Close, METH_VARARGS, nullptr },
        { "create", (PyCFunction)TensorInt64Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", (PyCFunction)TensorInt64Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", (PyCFunction)TensorInt64Bit_CreateFromBuffer, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", (PyCFunction)TensorInt64Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", (PyCFunction)TensorInt64Bit_CreateFromShapeArrayAndDataArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", (PyCFunction)TensorInt64Bit_CreateReference, METH_VARARGS, nullptr },
        { "get_as_vector_view", (PyCFunction)TensorInt64Bit_GetAsVectorView, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_TensorInt64Bit, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_TensorInt64Bit, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_TensorInt64Bit, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TensorInt64Bit[] = {
        { const_cast<char*>("kind"), (getter)TensorInt64Bit_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("shape"), (getter)TensorInt64Bit_get_Shape, nullptr, nullptr, nullptr },
        { const_cast<char*>("tensor_kind"), (getter)TensorInt64Bit_get_TensorKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TensorInt64Bit[] = 
    {
        { Py_tp_new, _new_TensorInt64Bit },
        { Py_tp_dealloc, _dealloc_TensorInt64Bit },
        { Py_tp_methods, _methods_TensorInt64Bit },
        { Py_tp_getset, _getset_TensorInt64Bit },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TensorInt64Bit =
    {
        "_winrt_Windows_AI_MachineLearning.TensorInt64Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorInt64Bit
    };

    // ----- TensorInt8Bit class --------------------
    constexpr const char* const _type_name_TensorInt8Bit = "TensorInt8Bit";

    static PyObject* _new_TensorInt8Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorInt8Bit);
        return nullptr;
    }

    static void _dealloc_TensorInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorInt8Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint8_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorInt8Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorInt8Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_TensorInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorInt8Bit[] = {
        { "close", (PyCFunction)TensorInt8Bit_Close, METH_VARARGS, nullptr },
        { "create", (PyCFunction)TensorInt8Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", (PyCFunction)TensorInt8Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", (PyCFunction)TensorInt8Bit_CreateFromBuffer, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", (PyCFunction)TensorInt8Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", (PyCFunction)TensorInt8Bit_CreateFromShapeArrayAndDataArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", (PyCFunction)TensorInt8Bit_CreateReference, METH_VARARGS, nullptr },
        { "get_as_vector_view", (PyCFunction)TensorInt8Bit_GetAsVectorView, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_TensorInt8Bit, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_TensorInt8Bit, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_TensorInt8Bit, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TensorInt8Bit[] = {
        { const_cast<char*>("kind"), (getter)TensorInt8Bit_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("shape"), (getter)TensorInt8Bit_get_Shape, nullptr, nullptr, nullptr },
        { const_cast<char*>("tensor_kind"), (getter)TensorInt8Bit_get_TensorKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TensorInt8Bit[] = 
    {
        { Py_tp_new, _new_TensorInt8Bit },
        { Py_tp_dealloc, _dealloc_TensorInt8Bit },
        { Py_tp_methods, _methods_TensorInt8Bit },
        { Py_tp_getset, _getset_TensorInt8Bit },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TensorInt8Bit =
    {
        "_winrt_Windows_AI_MachineLearning.TensorInt8Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorInt8Bit
    };

    // ----- TensorString class --------------------
    constexpr const char* const _type_name_TensorString = "TensorString";

    static PyObject* _new_TensorString(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorString);
        return nullptr;
    }

    static void _dealloc_TensorString(py::wrapper::Windows::AI::MachineLearning::TensorString* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorString_Close(py::wrapper::Windows::AI::MachineLearning::TensorString* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorString::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorString::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorString::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorString::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorString::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorString* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorString* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorString* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorString_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorString* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorString_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorString* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorString(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorString>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorString(py::wrapper::Windows::AI::MachineLearning::TensorString* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_TensorString(py::wrapper::Windows::AI::MachineLearning::TensorString* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorString[] = {
        { "close", (PyCFunction)TensorString_Close, METH_VARARGS, nullptr },
        { "create", (PyCFunction)TensorString_Create, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", (PyCFunction)TensorString_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", (PyCFunction)TensorString_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", (PyCFunction)TensorString_CreateFromShapeArrayAndDataArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", (PyCFunction)TensorString_CreateReference, METH_VARARGS, nullptr },
        { "get_as_vector_view", (PyCFunction)TensorString_GetAsVectorView, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_TensorString, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_TensorString, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_TensorString, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TensorString[] = {
        { const_cast<char*>("kind"), (getter)TensorString_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("shape"), (getter)TensorString_get_Shape, nullptr, nullptr, nullptr },
        { const_cast<char*>("tensor_kind"), (getter)TensorString_get_TensorKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TensorString[] = 
    {
        { Py_tp_new, _new_TensorString },
        { Py_tp_dealloc, _dealloc_TensorString },
        { Py_tp_methods, _methods_TensorString },
        { Py_tp_getset, _getset_TensorString },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TensorString =
    {
        "_winrt_Windows_AI_MachineLearning.TensorString",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorString),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorString
    };

    // ----- TensorUInt16Bit class --------------------
    constexpr const char* const _type_name_TensorUInt16Bit = "TensorUInt16Bit";

    static PyObject* _new_TensorUInt16Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorUInt16Bit);
        return nullptr;
    }

    static void _dealloc_TensorUInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorUInt16Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint16_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint16_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint16_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorUInt16Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorUInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_TensorUInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorUInt16Bit[] = {
        { "close", (PyCFunction)TensorUInt16Bit_Close, METH_VARARGS, nullptr },
        { "create", (PyCFunction)TensorUInt16Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", (PyCFunction)TensorUInt16Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", (PyCFunction)TensorUInt16Bit_CreateFromBuffer, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", (PyCFunction)TensorUInt16Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", (PyCFunction)TensorUInt16Bit_CreateFromShapeArrayAndDataArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", (PyCFunction)TensorUInt16Bit_CreateReference, METH_VARARGS, nullptr },
        { "get_as_vector_view", (PyCFunction)TensorUInt16Bit_GetAsVectorView, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_TensorUInt16Bit, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_TensorUInt16Bit, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_TensorUInt16Bit, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TensorUInt16Bit[] = {
        { const_cast<char*>("kind"), (getter)TensorUInt16Bit_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("shape"), (getter)TensorUInt16Bit_get_Shape, nullptr, nullptr, nullptr },
        { const_cast<char*>("tensor_kind"), (getter)TensorUInt16Bit_get_TensorKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TensorUInt16Bit[] = 
    {
        { Py_tp_new, _new_TensorUInt16Bit },
        { Py_tp_dealloc, _dealloc_TensorUInt16Bit },
        { Py_tp_methods, _methods_TensorUInt16Bit },
        { Py_tp_getset, _getset_TensorUInt16Bit },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TensorUInt16Bit =
    {
        "_winrt_Windows_AI_MachineLearning.TensorUInt16Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorUInt16Bit
    };

    // ----- TensorUInt32Bit class --------------------
    constexpr const char* const _type_name_TensorUInt32Bit = "TensorUInt32Bit";

    static PyObject* _new_TensorUInt32Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorUInt32Bit);
        return nullptr;
    }

    static void _dealloc_TensorUInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorUInt32Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint32_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint32_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint32_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorUInt32Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorUInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_TensorUInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorUInt32Bit[] = {
        { "close", (PyCFunction)TensorUInt32Bit_Close, METH_VARARGS, nullptr },
        { "create", (PyCFunction)TensorUInt32Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", (PyCFunction)TensorUInt32Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", (PyCFunction)TensorUInt32Bit_CreateFromBuffer, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", (PyCFunction)TensorUInt32Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", (PyCFunction)TensorUInt32Bit_CreateFromShapeArrayAndDataArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", (PyCFunction)TensorUInt32Bit_CreateReference, METH_VARARGS, nullptr },
        { "get_as_vector_view", (PyCFunction)TensorUInt32Bit_GetAsVectorView, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_TensorUInt32Bit, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_TensorUInt32Bit, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_TensorUInt32Bit, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TensorUInt32Bit[] = {
        { const_cast<char*>("kind"), (getter)TensorUInt32Bit_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("shape"), (getter)TensorUInt32Bit_get_Shape, nullptr, nullptr, nullptr },
        { const_cast<char*>("tensor_kind"), (getter)TensorUInt32Bit_get_TensorKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TensorUInt32Bit[] = 
    {
        { Py_tp_new, _new_TensorUInt32Bit },
        { Py_tp_dealloc, _dealloc_TensorUInt32Bit },
        { Py_tp_methods, _methods_TensorUInt32Bit },
        { Py_tp_getset, _getset_TensorUInt32Bit },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TensorUInt32Bit =
    {
        "_winrt_Windows_AI_MachineLearning.TensorUInt32Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorUInt32Bit
    };

    // ----- TensorUInt64Bit class --------------------
    constexpr const char* const _type_name_TensorUInt64Bit = "TensorUInt64Bit";

    static PyObject* _new_TensorUInt64Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorUInt64Bit);
        return nullptr;
    }

    static void _dealloc_TensorUInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorUInt64Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint64_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint64_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint64_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorUInt64Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorUInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_TensorUInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorUInt64Bit[] = {
        { "close", (PyCFunction)TensorUInt64Bit_Close, METH_VARARGS, nullptr },
        { "create", (PyCFunction)TensorUInt64Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", (PyCFunction)TensorUInt64Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", (PyCFunction)TensorUInt64Bit_CreateFromBuffer, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", (PyCFunction)TensorUInt64Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", (PyCFunction)TensorUInt64Bit_CreateFromShapeArrayAndDataArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", (PyCFunction)TensorUInt64Bit_CreateReference, METH_VARARGS, nullptr },
        { "get_as_vector_view", (PyCFunction)TensorUInt64Bit_GetAsVectorView, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_TensorUInt64Bit, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_TensorUInt64Bit, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_TensorUInt64Bit, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TensorUInt64Bit[] = {
        { const_cast<char*>("kind"), (getter)TensorUInt64Bit_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("shape"), (getter)TensorUInt64Bit_get_Shape, nullptr, nullptr, nullptr },
        { const_cast<char*>("tensor_kind"), (getter)TensorUInt64Bit_get_TensorKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TensorUInt64Bit[] = 
    {
        { Py_tp_new, _new_TensorUInt64Bit },
        { Py_tp_dealloc, _dealloc_TensorUInt64Bit },
        { Py_tp_methods, _methods_TensorUInt64Bit },
        { Py_tp_getset, _getset_TensorUInt64Bit },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TensorUInt64Bit =
    {
        "_winrt_Windows_AI_MachineLearning.TensorUInt64Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorUInt64Bit
    };

    // ----- TensorUInt8Bit class --------------------
    constexpr const char* const _type_name_TensorUInt8Bit = "TensorUInt8Bit";

    static PyObject* _new_TensorUInt8Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorUInt8Bit);
        return nullptr;
    }

    static void _dealloc_TensorUInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorUInt8Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint8_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorUInt8Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorUInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_TensorUInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorUInt8Bit[] = {
        { "close", (PyCFunction)TensorUInt8Bit_Close, METH_VARARGS, nullptr },
        { "create", (PyCFunction)TensorUInt8Bit_Create, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", (PyCFunction)TensorUInt8Bit_CreateFromArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", (PyCFunction)TensorUInt8Bit_CreateFromBuffer, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", (PyCFunction)TensorUInt8Bit_CreateFromIterable, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", (PyCFunction)TensorUInt8Bit_CreateFromShapeArrayAndDataArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", (PyCFunction)TensorUInt8Bit_CreateReference, METH_VARARGS, nullptr },
        { "get_as_vector_view", (PyCFunction)TensorUInt8Bit_GetAsVectorView, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_TensorUInt8Bit, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_TensorUInt8Bit, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_TensorUInt8Bit, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TensorUInt8Bit[] = {
        { const_cast<char*>("kind"), (getter)TensorUInt8Bit_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("shape"), (getter)TensorUInt8Bit_get_Shape, nullptr, nullptr, nullptr },
        { const_cast<char*>("tensor_kind"), (getter)TensorUInt8Bit_get_TensorKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TensorUInt8Bit[] = 
    {
        { Py_tp_new, _new_TensorUInt8Bit },
        { Py_tp_dealloc, _dealloc_TensorUInt8Bit },
        { Py_tp_methods, _methods_TensorUInt8Bit },
        { Py_tp_getset, _getset_TensorUInt8Bit },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TensorUInt8Bit =
    {
        "_winrt_Windows_AI_MachineLearning.TensorUInt8Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorUInt8Bit
    };

    // ----- ILearningModelFeatureDescriptor interface --------------------
    constexpr const char* const _type_name_ILearningModelFeatureDescriptor = "ILearningModelFeatureDescriptor";

    static PyObject* _new_ILearningModelFeatureDescriptor(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ILearningModelFeatureDescriptor);
        return nullptr;
    }

    static void _dealloc_ILearningModelFeatureDescriptor(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ILearningModelFeatureDescriptor_get_Description(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILearningModelFeatureDescriptor_get_IsRequired(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILearningModelFeatureDescriptor_get_Kind(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILearningModelFeatureDescriptor_get_Name(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ILearningModelFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILearningModelFeatureDescriptor[] = {
        { "_from", (PyCFunction)_from_ILearningModelFeatureDescriptor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ILearningModelFeatureDescriptor[] = {
        { const_cast<char*>("description"), (getter)ILearningModelFeatureDescriptor_get_Description, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_required"), (getter)ILearningModelFeatureDescriptor_get_IsRequired, nullptr, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)ILearningModelFeatureDescriptor_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)ILearningModelFeatureDescriptor_get_Name, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ILearningModelFeatureDescriptor[] = 
    {
        { Py_tp_new, _new_ILearningModelFeatureDescriptor },
        { Py_tp_dealloc, _dealloc_ILearningModelFeatureDescriptor },
        { Py_tp_methods, _methods_ILearningModelFeatureDescriptor },
        { Py_tp_getset, _getset_ILearningModelFeatureDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ILearningModelFeatureDescriptor =
    {
        "_winrt_Windows_AI_MachineLearning.ILearningModelFeatureDescriptor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILearningModelFeatureDescriptor
    };

    // ----- ILearningModelFeatureValue interface --------------------
    constexpr const char* const _type_name_ILearningModelFeatureValue = "ILearningModelFeatureValue";

    static PyObject* _new_ILearningModelFeatureValue(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ILearningModelFeatureValue);
        return nullptr;
    }

    static void _dealloc_ILearningModelFeatureValue(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ILearningModelFeatureValue_get_Kind(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ILearningModelFeatureValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILearningModelFeatureValue[] = {
        { "_from", (PyCFunction)_from_ILearningModelFeatureValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ILearningModelFeatureValue[] = {
        { const_cast<char*>("kind"), (getter)ILearningModelFeatureValue_get_Kind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ILearningModelFeatureValue[] = 
    {
        { Py_tp_new, _new_ILearningModelFeatureValue },
        { Py_tp_dealloc, _dealloc_ILearningModelFeatureValue },
        { Py_tp_methods, _methods_ILearningModelFeatureValue },
        { Py_tp_getset, _getset_ILearningModelFeatureValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ILearningModelFeatureValue =
    {
        "_winrt_Windows_AI_MachineLearning.ILearningModelFeatureValue",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILearningModelFeatureValue
    };

    // ----- ILearningModelOperatorProvider interface --------------------
    constexpr const char* const _type_name_ILearningModelOperatorProvider = "ILearningModelOperatorProvider";

    static PyObject* _new_ILearningModelOperatorProvider(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ILearningModelOperatorProvider);
        return nullptr;
    }

    static void _dealloc_ILearningModelOperatorProvider(py::wrapper::Windows::AI::MachineLearning::ILearningModelOperatorProvider* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ILearningModelOperatorProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILearningModelOperatorProvider[] = {
        { "_from", (PyCFunction)_from_ILearningModelOperatorProvider, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ILearningModelOperatorProvider[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ILearningModelOperatorProvider[] = 
    {
        { Py_tp_new, _new_ILearningModelOperatorProvider },
        { Py_tp_dealloc, _dealloc_ILearningModelOperatorProvider },
        { Py_tp_methods, _methods_ILearningModelOperatorProvider },
        { Py_tp_getset, _getset_ILearningModelOperatorProvider },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ILearningModelOperatorProvider =
    {
        "_winrt_Windows_AI_MachineLearning.ILearningModelOperatorProvider",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ILearningModelOperatorProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILearningModelOperatorProvider
    };

    // ----- ITensor interface --------------------
    constexpr const char* const _type_name_ITensor = "ITensor";

    static PyObject* _new_ITensor(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ITensor);
        return nullptr;
    }

    static void _dealloc_ITensor(py::wrapper::Windows::AI::MachineLearning::ITensor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ITensor_get_Shape(py::wrapper::Windows::AI::MachineLearning::ITensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITensor_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::ITensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITensor_get_Kind(py::wrapper::Windows::AI::MachineLearning::ITensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ITensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ITensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITensor[] = {
        { "_from", (PyCFunction)_from_ITensor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ITensor[] = {
        { const_cast<char*>("shape"), (getter)ITensor_get_Shape, nullptr, nullptr, nullptr },
        { const_cast<char*>("tensor_kind"), (getter)ITensor_get_TensorKind, nullptr, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)ITensor_get_Kind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ITensor[] = 
    {
        { Py_tp_new, _new_ITensor },
        { Py_tp_dealloc, _dealloc_ITensor },
        { Py_tp_methods, _methods_ITensor },
        { Py_tp_getset, _getset_ITensor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ITensor =
    {
        "_winrt_Windows_AI_MachineLearning.ITensor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ITensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITensor
    };

    // ----- Windows.AI.MachineLearning Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>::python_type = py::register_python_type(module, _type_name_ImageFeatureDescriptor, &_type_spec_ImageFeatureDescriptor, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::ImageFeatureValue>::python_type = py::register_python_type(module, _type_name_ImageFeatureValue, &_type_spec_ImageFeatureValue, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModel>::python_type = py::register_python_type(module, _type_name_LearningModel, &_type_spec_LearningModel, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelBinding>::python_type = py::register_python_type(module, _type_name_LearningModelBinding, &_type_spec_LearningModelBinding, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelDevice>::python_type = py::register_python_type(module, _type_name_LearningModelDevice, &_type_spec_LearningModelDevice, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>::python_type = py::register_python_type(module, _type_name_LearningModelEvaluationResult, &_type_spec_LearningModelEvaluationResult, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelSession>::python_type = py::register_python_type(module, _type_name_LearningModelSession, &_type_spec_LearningModelSession, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelSessionOptions>::python_type = py::register_python_type(module, _type_name_LearningModelSessionOptions, &_type_spec_LearningModelSessionOptions, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>::python_type = py::register_python_type(module, _type_name_MapFeatureDescriptor, &_type_spec_MapFeatureDescriptor, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>::python_type = py::register_python_type(module, _type_name_SequenceFeatureDescriptor, &_type_spec_SequenceFeatureDescriptor, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorBoolean>::python_type = py::register_python_type(module, _type_name_TensorBoolean, &_type_spec_TensorBoolean, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorDouble>::python_type = py::register_python_type(module, _type_name_TensorDouble, &_type_spec_TensorDouble, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>::python_type = py::register_python_type(module, _type_name_TensorFeatureDescriptor, &_type_spec_TensorFeatureDescriptor, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFloat>::python_type = py::register_python_type(module, _type_name_TensorFloat, &_type_spec_TensorFloat, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>::python_type = py::register_python_type(module, _type_name_TensorFloat16Bit, &_type_spec_TensorFloat16Bit, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt16Bit>::python_type = py::register_python_type(module, _type_name_TensorInt16Bit, &_type_spec_TensorInt16Bit, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt32Bit>::python_type = py::register_python_type(module, _type_name_TensorInt32Bit, &_type_spec_TensorInt32Bit, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt64Bit>::python_type = py::register_python_type(module, _type_name_TensorInt64Bit, &_type_spec_TensorInt64Bit, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt8Bit>::python_type = py::register_python_type(module, _type_name_TensorInt8Bit, &_type_spec_TensorInt8Bit, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorString>::python_type = py::register_python_type(module, _type_name_TensorString, &_type_spec_TensorString, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>::python_type = py::register_python_type(module, _type_name_TensorUInt16Bit, &_type_spec_TensorUInt16Bit, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>::python_type = py::register_python_type(module, _type_name_TensorUInt32Bit, &_type_spec_TensorUInt32Bit, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>::python_type = py::register_python_type(module, _type_name_TensorUInt64Bit, &_type_spec_TensorUInt64Bit, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>::python_type = py::register_python_type(module, _type_name_TensorUInt8Bit, &_type_spec_TensorUInt8Bit, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>::python_type = py::register_python_type(module, _type_name_ILearningModelFeatureDescriptor, &_type_spec_ILearningModelFeatureDescriptor, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>::python_type = py::register_python_type(module, _type_name_ILearningModelFeatureValue, &_type_spec_ILearningModelFeatureValue, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>::python_type = py::register_python_type(module, _type_name_ILearningModelOperatorProvider, &_type_spec_ILearningModelOperatorProvider, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::ITensor>::python_type = py::register_python_type(module, _type_name_ITensor, &_type_spec_ITensor, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.AI.MachineLearning");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_AI_MachineLearning",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::AI::MachineLearning

PyMODINIT_FUNC
PyInit__winrt_Windows_AI_MachineLearning (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::AI::MachineLearning::module_def);
}
