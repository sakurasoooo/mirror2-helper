// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Services.Store.h"

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreAcquireLicenseResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreAppLicense>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreAvailability>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreCanAcquireLicenseResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreCollectionData>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreConsumableResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreContext>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreImage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreLicense>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePackageInstallOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePackageLicense>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePackageUpdate>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePackageUpdateResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePrice>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreProduct>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreProductOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreProductPagedQueryResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreProductQueryResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreProductResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePurchaseProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePurchaseResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreQueueItem>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreQueueItemStatus>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreRateAndReviewResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreRequestHelper>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreSendRequestResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreSku>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreSubscriptionInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreUninstallStorePackageResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreVideo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePackageUpdateStatus>::python_type;

PyObject* py::converter<winrt::Windows::Services::Store::StorePackageUpdateStatus>::convert(winrt::Windows::Services::Store::StorePackageUpdateStatus instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Services::Store::StorePackageUpdateStatus>());
}
winrt::Windows::Services::Store::StorePackageUpdateStatus py::converter<winrt::Windows::Services::Store::StorePackageUpdateStatus>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Services::Store::StorePackageUpdateStatus>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Services::Store::StorePackageUpdateStatus>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Services::Store::StorePackageUpdateStatus return_value{};

    PyObject* py_PackageFamilyName = PyDict_GetItemString(obj, "package_family_name");
    if (!py_PackageFamilyName) { throw winrt::hresult_invalid_argument(); }
    return_value.PackageFamilyName = converter<winrt::hstring>::convert_to(py_PackageFamilyName);

    PyObject* py_PackageDownloadSizeInBytes = PyDict_GetItemString(obj, "package_download_size_in_bytes");
    if (!py_PackageDownloadSizeInBytes) { throw winrt::hresult_invalid_argument(); }
    return_value.PackageDownloadSizeInBytes = converter<uint64_t>::convert_to(py_PackageDownloadSizeInBytes);

    PyObject* py_PackageBytesDownloaded = PyDict_GetItemString(obj, "package_bytes_downloaded");
    if (!py_PackageBytesDownloaded) { throw winrt::hresult_invalid_argument(); }
    return_value.PackageBytesDownloaded = converter<uint64_t>::convert_to(py_PackageBytesDownloaded);

    PyObject* py_PackageDownloadProgress = PyDict_GetItemString(obj, "package_download_progress");
    if (!py_PackageDownloadProgress) { throw winrt::hresult_invalid_argument(); }
    return_value.PackageDownloadProgress = converter<double>::convert_to(py_PackageDownloadProgress);

    PyObject* py_TotalDownloadProgress = PyDict_GetItemString(obj, "total_download_progress");
    if (!py_TotalDownloadProgress) { throw winrt::hresult_invalid_argument(); }
    return_value.TotalDownloadProgress = converter<double>::convert_to(py_TotalDownloadProgress);

    PyObject* py_PackageUpdateState = PyDict_GetItemString(obj, "package_update_state");
    if (!py_PackageUpdateState) { throw winrt::hresult_invalid_argument(); }
    return_value.PackageUpdateState = converter<winrt::Windows::Services::Store::StorePackageUpdateState>::convert_to(py_PackageUpdateState);

    return return_value;
}

namespace py::cpp::Windows::Services::Store
{
    // ----- StoreAcquireLicenseResult class --------------------
    constexpr const char* const _type_name_StoreAcquireLicenseResult = "StoreAcquireLicenseResult";

    static PyObject* _new_StoreAcquireLicenseResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreAcquireLicenseResult);
        return nullptr;
    }

    static void _dealloc_StoreAcquireLicenseResult(py::wrapper::Windows::Services::Store::StoreAcquireLicenseResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreAcquireLicenseResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAcquireLicenseResult_get_StorePackageLicense(py::wrapper::Windows::Services::Store::StoreAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StorePackageLicense());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreAcquireLicenseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreAcquireLicenseResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreAcquireLicenseResult[] = {
        { "_from", (PyCFunction)_from_StoreAcquireLicenseResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreAcquireLicenseResult[] = {
        { const_cast<char*>("extended_error"), (getter)StoreAcquireLicenseResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("store_package_license"), (getter)StoreAcquireLicenseResult_get_StorePackageLicense, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreAcquireLicenseResult[] = 
    {
        { Py_tp_new, _new_StoreAcquireLicenseResult },
        { Py_tp_dealloc, _dealloc_StoreAcquireLicenseResult },
        { Py_tp_methods, _methods_StoreAcquireLicenseResult },
        { Py_tp_getset, _getset_StoreAcquireLicenseResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreAcquireLicenseResult =
    {
        "_winrt_Windows_Services_Store.StoreAcquireLicenseResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreAcquireLicenseResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreAcquireLicenseResult
    };

    // ----- StoreAppLicense class --------------------
    constexpr const char* const _type_name_StoreAppLicense = "StoreAppLicense";

    static PyObject* _new_StoreAppLicense(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreAppLicense);
        return nullptr;
    }

    static void _dealloc_StoreAppLicense(py::wrapper::Windows::Services::Store::StoreAppLicense* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreAppLicense_get_AddOnLicenses(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AddOnLicenses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_ExpirationDate(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_IsActive(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_IsTrial(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTrial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_IsTrialOwnedByThisUser(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTrialOwnedByThisUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_SkuStoreId(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SkuStoreId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_TrialTimeRemaining(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrialTimeRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_TrialUniqueId(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrialUniqueId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_IsDiscLicense(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDiscLicense());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreAppLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreAppLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreAppLicense[] = {
        { "_from", (PyCFunction)_from_StoreAppLicense, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreAppLicense[] = {
        { const_cast<char*>("add_on_licenses"), (getter)StoreAppLicense_get_AddOnLicenses, nullptr, nullptr, nullptr },
        { const_cast<char*>("expiration_date"), (getter)StoreAppLicense_get_ExpirationDate, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_json_data"), (getter)StoreAppLicense_get_ExtendedJsonData, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_active"), (getter)StoreAppLicense_get_IsActive, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_trial"), (getter)StoreAppLicense_get_IsTrial, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_trial_owned_by_this_user"), (getter)StoreAppLicense_get_IsTrialOwnedByThisUser, nullptr, nullptr, nullptr },
        { const_cast<char*>("sku_store_id"), (getter)StoreAppLicense_get_SkuStoreId, nullptr, nullptr, nullptr },
        { const_cast<char*>("trial_time_remaining"), (getter)StoreAppLicense_get_TrialTimeRemaining, nullptr, nullptr, nullptr },
        { const_cast<char*>("trial_unique_id"), (getter)StoreAppLicense_get_TrialUniqueId, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_disc_license"), (getter)StoreAppLicense_get_IsDiscLicense, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreAppLicense[] = 
    {
        { Py_tp_new, _new_StoreAppLicense },
        { Py_tp_dealloc, _dealloc_StoreAppLicense },
        { Py_tp_methods, _methods_StoreAppLicense },
        { Py_tp_getset, _getset_StoreAppLicense },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreAppLicense =
    {
        "_winrt_Windows_Services_Store.StoreAppLicense",
        sizeof(py::wrapper::Windows::Services::Store::StoreAppLicense),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreAppLicense
    };

    // ----- StoreAvailability class --------------------
    constexpr const char* const _type_name_StoreAvailability = "StoreAvailability";

    static PyObject* _new_StoreAvailability(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreAvailability);
        return nullptr;
    }

    static void _dealloc_StoreAvailability(py::wrapper::Windows::Services::Store::StoreAvailability* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreAvailability_RequestPurchaseAsync(py::wrapper::Windows::Services::Store::StoreAvailability* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestPurchaseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Store::StorePurchaseProperties>(args, 0);

                return py::convert(self->obj.RequestPurchaseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreAvailability_get_EndDate(py::wrapper::Windows::Services::Store::StoreAvailability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAvailability_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreAvailability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAvailability_get_Price(py::wrapper::Windows::Services::Store::StoreAvailability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Price());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAvailability_get_StoreId(py::wrapper::Windows::Services::Store::StoreAvailability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StoreId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreAvailability(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreAvailability>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreAvailability[] = {
        { "request_purchase_async", (PyCFunction)StoreAvailability_RequestPurchaseAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_StoreAvailability, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreAvailability[] = {
        { const_cast<char*>("end_date"), (getter)StoreAvailability_get_EndDate, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_json_data"), (getter)StoreAvailability_get_ExtendedJsonData, nullptr, nullptr, nullptr },
        { const_cast<char*>("price"), (getter)StoreAvailability_get_Price, nullptr, nullptr, nullptr },
        { const_cast<char*>("store_id"), (getter)StoreAvailability_get_StoreId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreAvailability[] = 
    {
        { Py_tp_new, _new_StoreAvailability },
        { Py_tp_dealloc, _dealloc_StoreAvailability },
        { Py_tp_methods, _methods_StoreAvailability },
        { Py_tp_getset, _getset_StoreAvailability },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreAvailability =
    {
        "_winrt_Windows_Services_Store.StoreAvailability",
        sizeof(py::wrapper::Windows::Services::Store::StoreAvailability),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreAvailability
    };

    // ----- StoreCanAcquireLicenseResult class --------------------
    constexpr const char* const _type_name_StoreCanAcquireLicenseResult = "StoreCanAcquireLicenseResult";

    static PyObject* _new_StoreCanAcquireLicenseResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreCanAcquireLicenseResult);
        return nullptr;
    }

    static void _dealloc_StoreCanAcquireLicenseResult(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreCanAcquireLicenseResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCanAcquireLicenseResult_get_LicensableSku(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LicensableSku());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCanAcquireLicenseResult_get_Status(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreCanAcquireLicenseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreCanAcquireLicenseResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreCanAcquireLicenseResult[] = {
        { "_from", (PyCFunction)_from_StoreCanAcquireLicenseResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreCanAcquireLicenseResult[] = {
        { const_cast<char*>("extended_error"), (getter)StoreCanAcquireLicenseResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("licensable_sku"), (getter)StoreCanAcquireLicenseResult_get_LicensableSku, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)StoreCanAcquireLicenseResult_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreCanAcquireLicenseResult[] = 
    {
        { Py_tp_new, _new_StoreCanAcquireLicenseResult },
        { Py_tp_dealloc, _dealloc_StoreCanAcquireLicenseResult },
        { Py_tp_methods, _methods_StoreCanAcquireLicenseResult },
        { Py_tp_getset, _getset_StoreCanAcquireLicenseResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreCanAcquireLicenseResult =
    {
        "_winrt_Windows_Services_Store.StoreCanAcquireLicenseResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreCanAcquireLicenseResult
    };

    // ----- StoreCollectionData class --------------------
    constexpr const char* const _type_name_StoreCollectionData = "StoreCollectionData";

    static PyObject* _new_StoreCollectionData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreCollectionData);
        return nullptr;
    }

    static void _dealloc_StoreCollectionData(py::wrapper::Windows::Services::Store::StoreCollectionData* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreCollectionData_get_AcquiredDate(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AcquiredDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_CampaignId(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CampaignId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_DeveloperOfferId(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeveloperOfferId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_EndDate(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_IsTrial(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTrial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_StartDate(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_TrialTimeRemaining(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrialTimeRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreCollectionData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreCollectionData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreCollectionData[] = {
        { "_from", (PyCFunction)_from_StoreCollectionData, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreCollectionData[] = {
        { const_cast<char*>("acquired_date"), (getter)StoreCollectionData_get_AcquiredDate, nullptr, nullptr, nullptr },
        { const_cast<char*>("campaign_id"), (getter)StoreCollectionData_get_CampaignId, nullptr, nullptr, nullptr },
        { const_cast<char*>("developer_offer_id"), (getter)StoreCollectionData_get_DeveloperOfferId, nullptr, nullptr, nullptr },
        { const_cast<char*>("end_date"), (getter)StoreCollectionData_get_EndDate, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_json_data"), (getter)StoreCollectionData_get_ExtendedJsonData, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_trial"), (getter)StoreCollectionData_get_IsTrial, nullptr, nullptr, nullptr },
        { const_cast<char*>("start_date"), (getter)StoreCollectionData_get_StartDate, nullptr, nullptr, nullptr },
        { const_cast<char*>("trial_time_remaining"), (getter)StoreCollectionData_get_TrialTimeRemaining, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreCollectionData[] = 
    {
        { Py_tp_new, _new_StoreCollectionData },
        { Py_tp_dealloc, _dealloc_StoreCollectionData },
        { Py_tp_methods, _methods_StoreCollectionData },
        { Py_tp_getset, _getset_StoreCollectionData },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreCollectionData =
    {
        "_winrt_Windows_Services_Store.StoreCollectionData",
        sizeof(py::wrapper::Windows::Services::Store::StoreCollectionData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreCollectionData
    };

    // ----- StoreConsumableResult class --------------------
    constexpr const char* const _type_name_StoreConsumableResult = "StoreConsumableResult";

    static PyObject* _new_StoreConsumableResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreConsumableResult);
        return nullptr;
    }

    static void _dealloc_StoreConsumableResult(py::wrapper::Windows::Services::Store::StoreConsumableResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreConsumableResult_get_BalanceRemaining(py::wrapper::Windows::Services::Store::StoreConsumableResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BalanceRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreConsumableResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreConsumableResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreConsumableResult_get_Status(py::wrapper::Windows::Services::Store::StoreConsumableResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreConsumableResult_get_TrackingId(py::wrapper::Windows::Services::Store::StoreConsumableResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrackingId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreConsumableResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreConsumableResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreConsumableResult[] = {
        { "_from", (PyCFunction)_from_StoreConsumableResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreConsumableResult[] = {
        { const_cast<char*>("balance_remaining"), (getter)StoreConsumableResult_get_BalanceRemaining, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_error"), (getter)StoreConsumableResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)StoreConsumableResult_get_Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("tracking_id"), (getter)StoreConsumableResult_get_TrackingId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreConsumableResult[] = 
    {
        { Py_tp_new, _new_StoreConsumableResult },
        { Py_tp_dealloc, _dealloc_StoreConsumableResult },
        { Py_tp_methods, _methods_StoreConsumableResult },
        { Py_tp_getset, _getset_StoreConsumableResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreConsumableResult =
    {
        "_winrt_Windows_Services_Store.StoreConsumableResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreConsumableResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreConsumableResult
    };

    // ----- StoreContext class --------------------
    constexpr const char* const _type_name_StoreContext = "StoreContext";

    static PyObject* _new_StoreContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreContext);
        return nullptr;
    }

    static void _dealloc_StoreContext(py::wrapper::Windows::Services::Store::StoreContext* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreContext_AcquireStoreLicenseForOptionalPackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert(self->obj.AcquireStoreLicenseForOptionalPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_CanAcquireStoreLicenseAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CanAcquireStoreLicenseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_CanAcquireStoreLicenseForOptionalPackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert(self->obj.CanAcquireStoreLicenseForOptionalPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_DownloadAndInstallStorePackagesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.DownloadAndInstallStorePackagesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_FindStoreProductForPackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 1);

                return py::convert(self->obj.FindStoreProductForPackageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAppAndOptionalStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAppAndOptionalStorePackageUpdatesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAppLicenseAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAppLicenseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAssociatedStoreProductsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetAssociatedStoreProductsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAssociatedStoreProductsWithPagingAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetAssociatedStoreProductsWithPagingAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAssociatedStoreQueueItemsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAssociatedStoreQueueItemsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetConsumableBalanceRemainingAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetConsumableBalanceRemainingAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetCustomerCollectionsIdAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetCustomerCollectionsIdAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetCustomerPurchaseIdAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetCustomerPurchaseIdAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Services::Store::StoreContext::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::Services::Store::StoreContext::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetStoreProductForCurrentAppAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetStoreProductForCurrentAppAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetStoreProductsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(self->obj.GetStoreProductsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Services::Store::StoreProductOptions>(args, 2);

                return py::convert(self->obj.GetStoreProductsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetStoreQueueItemsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetStoreQueueItemsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetUserCollectionAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetUserCollectionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetUserCollectionWithPagingAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetUserCollectionWithPagingAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_ReportConsumableFulfillmentAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                return py::convert(self->obj.ReportConsumableFulfillmentAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestDownloadAndInstallStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StorePackageUpdate>>(args, 0);

                return py::convert(self->obj.RequestDownloadAndInstallStorePackageUpdatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestDownloadAndInstallStorePackagesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.RequestDownloadAndInstallStorePackagesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Services::Store::StorePackageInstallOptions>(args, 1);

                return py::convert(self->obj.RequestDownloadAndInstallStorePackagesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestDownloadStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StorePackageUpdate>>(args, 0);

                return py::convert(self->obj.RequestDownloadStorePackageUpdatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestPurchaseAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RequestPurchaseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Services::Store::StorePurchaseProperties>(args, 1);

                return py::convert(self->obj.RequestPurchaseAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestRateAndReviewAppAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestRateAndReviewAppAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestUninstallStorePackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert(self->obj.RequestUninstallStorePackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestUninstallStorePackageByStoreIdAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RequestUninstallStorePackageByStoreIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_SetInstallOrderForAssociatedStoreQueueItemsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StoreQueueItem>>(args, 0);

                return py::convert(self->obj.SetInstallOrderForAssociatedStoreQueueItemsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_TrySilentDownloadAndInstallStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StorePackageUpdate>>(args, 0);

                return py::convert(self->obj.TrySilentDownloadAndInstallStorePackageUpdatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_TrySilentDownloadStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StorePackageUpdate>>(args, 0);

                return py::convert(self->obj.TrySilentDownloadStorePackageUpdatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_UninstallStorePackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert(self->obj.UninstallStorePackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_UninstallStorePackageByStoreIdAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.UninstallStorePackageByStoreIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_get_User(py::wrapper::Windows::Services::Store::StoreContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreContext_get_CanSilentlyDownloadStorePackageUpdates(py::wrapper::Windows::Services::Store::StoreContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanSilentlyDownloadStorePackageUpdates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreContext_add_OfflineLicensesChanged(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Store::StoreContext, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.OfflineLicensesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreContext_remove_OfflineLicensesChanged(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OfflineLicensesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreContext[] = {
        { "acquire_store_license_for_optional_package_async", (PyCFunction)StoreContext_AcquireStoreLicenseForOptionalPackageAsync, METH_VARARGS, nullptr },
        { "can_acquire_store_license_async", (PyCFunction)StoreContext_CanAcquireStoreLicenseAsync, METH_VARARGS, nullptr },
        { "can_acquire_store_license_for_optional_package_async", (PyCFunction)StoreContext_CanAcquireStoreLicenseForOptionalPackageAsync, METH_VARARGS, nullptr },
        { "download_and_install_store_packages_async", (PyCFunction)StoreContext_DownloadAndInstallStorePackagesAsync, METH_VARARGS, nullptr },
        { "find_store_product_for_package_async", (PyCFunction)StoreContext_FindStoreProductForPackageAsync, METH_VARARGS, nullptr },
        { "get_app_and_optional_store_package_updates_async", (PyCFunction)StoreContext_GetAppAndOptionalStorePackageUpdatesAsync, METH_VARARGS, nullptr },
        { "get_app_license_async", (PyCFunction)StoreContext_GetAppLicenseAsync, METH_VARARGS, nullptr },
        { "get_associated_store_products_async", (PyCFunction)StoreContext_GetAssociatedStoreProductsAsync, METH_VARARGS, nullptr },
        { "get_associated_store_products_with_paging_async", (PyCFunction)StoreContext_GetAssociatedStoreProductsWithPagingAsync, METH_VARARGS, nullptr },
        { "get_associated_store_queue_items_async", (PyCFunction)StoreContext_GetAssociatedStoreQueueItemsAsync, METH_VARARGS, nullptr },
        { "get_consumable_balance_remaining_async", (PyCFunction)StoreContext_GetConsumableBalanceRemainingAsync, METH_VARARGS, nullptr },
        { "get_customer_collections_id_async", (PyCFunction)StoreContext_GetCustomerCollectionsIdAsync, METH_VARARGS, nullptr },
        { "get_customer_purchase_id_async", (PyCFunction)StoreContext_GetCustomerPurchaseIdAsync, METH_VARARGS, nullptr },
        { "get_default", (PyCFunction)StoreContext_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", (PyCFunction)StoreContext_GetForUser, METH_VARARGS | METH_STATIC, nullptr },
        { "get_store_product_for_current_app_async", (PyCFunction)StoreContext_GetStoreProductForCurrentAppAsync, METH_VARARGS, nullptr },
        { "get_store_products_async", (PyCFunction)StoreContext_GetStoreProductsAsync, METH_VARARGS, nullptr },
        { "get_store_queue_items_async", (PyCFunction)StoreContext_GetStoreQueueItemsAsync, METH_VARARGS, nullptr },
        { "get_user_collection_async", (PyCFunction)StoreContext_GetUserCollectionAsync, METH_VARARGS, nullptr },
        { "get_user_collection_with_paging_async", (PyCFunction)StoreContext_GetUserCollectionWithPagingAsync, METH_VARARGS, nullptr },
        { "report_consumable_fulfillment_async", (PyCFunction)StoreContext_ReportConsumableFulfillmentAsync, METH_VARARGS, nullptr },
        { "request_download_and_install_store_package_updates_async", (PyCFunction)StoreContext_RequestDownloadAndInstallStorePackageUpdatesAsync, METH_VARARGS, nullptr },
        { "request_download_and_install_store_packages_async", (PyCFunction)StoreContext_RequestDownloadAndInstallStorePackagesAsync, METH_VARARGS, nullptr },
        { "request_download_store_package_updates_async", (PyCFunction)StoreContext_RequestDownloadStorePackageUpdatesAsync, METH_VARARGS, nullptr },
        { "request_purchase_async", (PyCFunction)StoreContext_RequestPurchaseAsync, METH_VARARGS, nullptr },
        { "request_rate_and_review_app_async", (PyCFunction)StoreContext_RequestRateAndReviewAppAsync, METH_VARARGS, nullptr },
        { "request_uninstall_store_package_async", (PyCFunction)StoreContext_RequestUninstallStorePackageAsync, METH_VARARGS, nullptr },
        { "request_uninstall_store_package_by_store_id_async", (PyCFunction)StoreContext_RequestUninstallStorePackageByStoreIdAsync, METH_VARARGS, nullptr },
        { "set_install_order_for_associated_store_queue_items_async", (PyCFunction)StoreContext_SetInstallOrderForAssociatedStoreQueueItemsAsync, METH_VARARGS, nullptr },
        { "try_silent_download_and_install_store_package_updates_async", (PyCFunction)StoreContext_TrySilentDownloadAndInstallStorePackageUpdatesAsync, METH_VARARGS, nullptr },
        { "try_silent_download_store_package_updates_async", (PyCFunction)StoreContext_TrySilentDownloadStorePackageUpdatesAsync, METH_VARARGS, nullptr },
        { "uninstall_store_package_async", (PyCFunction)StoreContext_UninstallStorePackageAsync, METH_VARARGS, nullptr },
        { "uninstall_store_package_by_store_id_async", (PyCFunction)StoreContext_UninstallStorePackageByStoreIdAsync, METH_VARARGS, nullptr },
        { "add_offline_licenses_changed", (PyCFunction)StoreContext_add_OfflineLicensesChanged, METH_O, nullptr },
        { "remove_offline_licenses_changed", (PyCFunction)StoreContext_remove_OfflineLicensesChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_StoreContext, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreContext[] = {
        { const_cast<char*>("user"), (getter)StoreContext_get_User, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_silently_download_store_package_updates"), (getter)StoreContext_get_CanSilentlyDownloadStorePackageUpdates, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreContext[] = 
    {
        { Py_tp_new, _new_StoreContext },
        { Py_tp_dealloc, _dealloc_StoreContext },
        { Py_tp_methods, _methods_StoreContext },
        { Py_tp_getset, _getset_StoreContext },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreContext =
    {
        "_winrt_Windows_Services_Store.StoreContext",
        sizeof(py::wrapper::Windows::Services::Store::StoreContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreContext
    };

    // ----- StoreImage class --------------------
    constexpr const char* const _type_name_StoreImage = "StoreImage";

    static PyObject* _new_StoreImage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreImage);
        return nullptr;
    }

    static void _dealloc_StoreImage(py::wrapper::Windows::Services::Store::StoreImage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreImage_get_Caption(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Caption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreImage_get_Height(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreImage_get_ImagePurposeTag(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ImagePurposeTag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreImage_get_Uri(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreImage_get_Width(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreImage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreImage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreImage[] = {
        { "_from", (PyCFunction)_from_StoreImage, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreImage[] = {
        { const_cast<char*>("caption"), (getter)StoreImage_get_Caption, nullptr, nullptr, nullptr },
        { const_cast<char*>("height"), (getter)StoreImage_get_Height, nullptr, nullptr, nullptr },
        { const_cast<char*>("image_purpose_tag"), (getter)StoreImage_get_ImagePurposeTag, nullptr, nullptr, nullptr },
        { const_cast<char*>("uri"), (getter)StoreImage_get_Uri, nullptr, nullptr, nullptr },
        { const_cast<char*>("width"), (getter)StoreImage_get_Width, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreImage[] = 
    {
        { Py_tp_new, _new_StoreImage },
        { Py_tp_dealloc, _dealloc_StoreImage },
        { Py_tp_methods, _methods_StoreImage },
        { Py_tp_getset, _getset_StoreImage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreImage =
    {
        "_winrt_Windows_Services_Store.StoreImage",
        sizeof(py::wrapper::Windows::Services::Store::StoreImage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreImage
    };

    // ----- StoreLicense class --------------------
    constexpr const char* const _type_name_StoreLicense = "StoreLicense";

    static PyObject* _new_StoreLicense(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreLicense);
        return nullptr;
    }

    static void _dealloc_StoreLicense(py::wrapper::Windows::Services::Store::StoreLicense* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreLicense_get_ExpirationDate(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreLicense_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreLicense_get_InAppOfferToken(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InAppOfferToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreLicense_get_IsActive(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreLicense_get_SkuStoreId(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SkuStoreId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreLicense[] = {
        { "_from", (PyCFunction)_from_StoreLicense, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreLicense[] = {
        { const_cast<char*>("expiration_date"), (getter)StoreLicense_get_ExpirationDate, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_json_data"), (getter)StoreLicense_get_ExtendedJsonData, nullptr, nullptr, nullptr },
        { const_cast<char*>("in_app_offer_token"), (getter)StoreLicense_get_InAppOfferToken, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_active"), (getter)StoreLicense_get_IsActive, nullptr, nullptr, nullptr },
        { const_cast<char*>("sku_store_id"), (getter)StoreLicense_get_SkuStoreId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreLicense[] = 
    {
        { Py_tp_new, _new_StoreLicense },
        { Py_tp_dealloc, _dealloc_StoreLicense },
        { Py_tp_methods, _methods_StoreLicense },
        { Py_tp_getset, _getset_StoreLicense },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreLicense =
    {
        "_winrt_Windows_Services_Store.StoreLicense",
        sizeof(py::wrapper::Windows::Services::Store::StoreLicense),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreLicense
    };

    // ----- StorePackageInstallOptions class --------------------
    constexpr const char* const _type_name_StorePackageInstallOptions = "StorePackageInstallOptions";

    static PyObject* _new_StorePackageInstallOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Services::Store::StorePackageInstallOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorePackageInstallOptions(py::wrapper::Windows::Services::Store::StorePackageInstallOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorePackageInstallOptions_get_AllowForcedAppRestart(py::wrapper::Windows::Services::Store::StorePackageInstallOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowForcedAppRestart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageInstallOptions_put_AllowForcedAppRestart(py::wrapper::Windows::Services::Store::StorePackageInstallOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowForcedAppRestart(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StorePackageInstallOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePackageInstallOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePackageInstallOptions[] = {
        { "_from", (PyCFunction)_from_StorePackageInstallOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorePackageInstallOptions[] = {
        { const_cast<char*>("allow_forced_app_restart"), (getter)StorePackageInstallOptions_get_AllowForcedAppRestart, (setter)StorePackageInstallOptions_put_AllowForcedAppRestart, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorePackageInstallOptions[] = 
    {
        { Py_tp_new, _new_StorePackageInstallOptions },
        { Py_tp_dealloc, _dealloc_StorePackageInstallOptions },
        { Py_tp_methods, _methods_StorePackageInstallOptions },
        { Py_tp_getset, _getset_StorePackageInstallOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorePackageInstallOptions =
    {
        "_winrt_Windows_Services_Store.StorePackageInstallOptions",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageInstallOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageInstallOptions
    };

    // ----- StorePackageLicense class --------------------
    constexpr const char* const _type_name_StorePackageLicense = "StorePackageLicense";

    static PyObject* _new_StorePackageLicense(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorePackageLicense);
        return nullptr;
    }

    static void _dealloc_StorePackageLicense(py::wrapper::Windows::Services::Store::StorePackageLicense* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorePackageLicense_Close(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_ReleaseLicense(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ReleaseLicense();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_get_IsValid(py::wrapper::Windows::Services::Store::StorePackageLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsValid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_get_Package(py::wrapper::Windows::Services::Store::StorePackageLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_add_LicenseLost(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Store::StorePackageLicense, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.LicenseLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_remove_LicenseLost(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LicenseLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorePackageLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePackageLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StorePackageLicense(py::wrapper::Windows::Services::Store::StorePackageLicense* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_StorePackageLicense(py::wrapper::Windows::Services::Store::StorePackageLicense* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePackageLicense[] = {
        { "close", (PyCFunction)StorePackageLicense_Close, METH_VARARGS, nullptr },
        { "release_license", (PyCFunction)StorePackageLicense_ReleaseLicense, METH_VARARGS, nullptr },
        { "add_license_lost", (PyCFunction)StorePackageLicense_add_LicenseLost, METH_O, nullptr },
        { "remove_license_lost", (PyCFunction)StorePackageLicense_remove_LicenseLost, METH_O, nullptr },
        { "_from", (PyCFunction)_from_StorePackageLicense, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_StorePackageLicense, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_StorePackageLicense, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorePackageLicense[] = {
        { const_cast<char*>("is_valid"), (getter)StorePackageLicense_get_IsValid, nullptr, nullptr, nullptr },
        { const_cast<char*>("package"), (getter)StorePackageLicense_get_Package, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorePackageLicense[] = 
    {
        { Py_tp_new, _new_StorePackageLicense },
        { Py_tp_dealloc, _dealloc_StorePackageLicense },
        { Py_tp_methods, _methods_StorePackageLicense },
        { Py_tp_getset, _getset_StorePackageLicense },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorePackageLicense =
    {
        "_winrt_Windows_Services_Store.StorePackageLicense",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageLicense),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageLicense
    };

    // ----- StorePackageUpdate class --------------------
    constexpr const char* const _type_name_StorePackageUpdate = "StorePackageUpdate";

    static PyObject* _new_StorePackageUpdate(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorePackageUpdate);
        return nullptr;
    }

    static void _dealloc_StorePackageUpdate(py::wrapper::Windows::Services::Store::StorePackageUpdate* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorePackageUpdate_get_Mandatory(py::wrapper::Windows::Services::Store::StorePackageUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mandatory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageUpdate_get_Package(py::wrapper::Windows::Services::Store::StorePackageUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorePackageUpdate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePackageUpdate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePackageUpdate[] = {
        { "_from", (PyCFunction)_from_StorePackageUpdate, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorePackageUpdate[] = {
        { const_cast<char*>("mandatory"), (getter)StorePackageUpdate_get_Mandatory, nullptr, nullptr, nullptr },
        { const_cast<char*>("package"), (getter)StorePackageUpdate_get_Package, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorePackageUpdate[] = 
    {
        { Py_tp_new, _new_StorePackageUpdate },
        { Py_tp_dealloc, _dealloc_StorePackageUpdate },
        { Py_tp_methods, _methods_StorePackageUpdate },
        { Py_tp_getset, _getset_StorePackageUpdate },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorePackageUpdate =
    {
        "_winrt_Windows_Services_Store.StorePackageUpdate",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageUpdate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageUpdate
    };

    // ----- StorePackageUpdateResult class --------------------
    constexpr const char* const _type_name_StorePackageUpdateResult = "StorePackageUpdateResult";

    static PyObject* _new_StorePackageUpdateResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorePackageUpdateResult);
        return nullptr;
    }

    static void _dealloc_StorePackageUpdateResult(py::wrapper::Windows::Services::Store::StorePackageUpdateResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorePackageUpdateResult_get_OverallState(py::wrapper::Windows::Services::Store::StorePackageUpdateResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OverallState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageUpdateResult_get_StorePackageUpdateStatuses(py::wrapper::Windows::Services::Store::StorePackageUpdateResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StorePackageUpdateStatuses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageUpdateResult_get_StoreQueueItems(py::wrapper::Windows::Services::Store::StorePackageUpdateResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StoreQueueItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorePackageUpdateResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePackageUpdateResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePackageUpdateResult[] = {
        { "_from", (PyCFunction)_from_StorePackageUpdateResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorePackageUpdateResult[] = {
        { const_cast<char*>("overall_state"), (getter)StorePackageUpdateResult_get_OverallState, nullptr, nullptr, nullptr },
        { const_cast<char*>("store_package_update_statuses"), (getter)StorePackageUpdateResult_get_StorePackageUpdateStatuses, nullptr, nullptr, nullptr },
        { const_cast<char*>("store_queue_items"), (getter)StorePackageUpdateResult_get_StoreQueueItems, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorePackageUpdateResult[] = 
    {
        { Py_tp_new, _new_StorePackageUpdateResult },
        { Py_tp_dealloc, _dealloc_StorePackageUpdateResult },
        { Py_tp_methods, _methods_StorePackageUpdateResult },
        { Py_tp_getset, _getset_StorePackageUpdateResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorePackageUpdateResult =
    {
        "_winrt_Windows_Services_Store.StorePackageUpdateResult",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageUpdateResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageUpdateResult
    };

    // ----- StorePrice class --------------------
    constexpr const char* const _type_name_StorePrice = "StorePrice";

    static PyObject* _new_StorePrice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorePrice);
        return nullptr;
    }

    static void _dealloc_StorePrice(py::wrapper::Windows::Services::Store::StorePrice* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorePrice_get_CurrencyCode(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrencyCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_FormattedBasePrice(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FormattedBasePrice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_FormattedPrice(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FormattedPrice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_FormattedRecurrencePrice(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FormattedRecurrencePrice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_IsOnSale(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOnSale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_SaleEndDate(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SaleEndDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorePrice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePrice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePrice[] = {
        { "_from", (PyCFunction)_from_StorePrice, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorePrice[] = {
        { const_cast<char*>("currency_code"), (getter)StorePrice_get_CurrencyCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("formatted_base_price"), (getter)StorePrice_get_FormattedBasePrice, nullptr, nullptr, nullptr },
        { const_cast<char*>("formatted_price"), (getter)StorePrice_get_FormattedPrice, nullptr, nullptr, nullptr },
        { const_cast<char*>("formatted_recurrence_price"), (getter)StorePrice_get_FormattedRecurrencePrice, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_on_sale"), (getter)StorePrice_get_IsOnSale, nullptr, nullptr, nullptr },
        { const_cast<char*>("sale_end_date"), (getter)StorePrice_get_SaleEndDate, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorePrice[] = 
    {
        { Py_tp_new, _new_StorePrice },
        { Py_tp_dealloc, _dealloc_StorePrice },
        { Py_tp_methods, _methods_StorePrice },
        { Py_tp_getset, _getset_StorePrice },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorePrice =
    {
        "_winrt_Windows_Services_Store.StorePrice",
        sizeof(py::wrapper::Windows::Services::Store::StorePrice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePrice
    };

    // ----- StoreProduct class --------------------
    constexpr const char* const _type_name_StoreProduct = "StoreProduct";

    static PyObject* _new_StoreProduct(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreProduct);
        return nullptr;
    }

    static void _dealloc_StoreProduct(py::wrapper::Windows::Services::Store::StoreProduct* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreProduct_GetIsAnySkuInstalledAsync(py::wrapper::Windows::Services::Store::StoreProduct* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetIsAnySkuInstalledAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreProduct_RequestPurchaseAsync(py::wrapper::Windows::Services::Store::StoreProduct* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestPurchaseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Store::StorePurchaseProperties>(args, 0);

                return py::convert(self->obj.RequestPurchaseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Description(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_HasDigitalDownload(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasDigitalDownload());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Images(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Images());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_InAppOfferToken(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InAppOfferToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_IsInUserCollection(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInUserCollection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Keywords(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Keywords());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Language(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_LinkUri(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LinkUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Price(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Price());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_ProductKind(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProductKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Skus(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Skus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_StoreId(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StoreId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Title(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Videos(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Videos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreProduct(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProduct>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProduct[] = {
        { "get_is_any_sku_installed_async", (PyCFunction)StoreProduct_GetIsAnySkuInstalledAsync, METH_VARARGS, nullptr },
        { "request_purchase_async", (PyCFunction)StoreProduct_RequestPurchaseAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_StoreProduct, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreProduct[] = {
        { const_cast<char*>("description"), (getter)StoreProduct_get_Description, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_json_data"), (getter)StoreProduct_get_ExtendedJsonData, nullptr, nullptr, nullptr },
        { const_cast<char*>("has_digital_download"), (getter)StoreProduct_get_HasDigitalDownload, nullptr, nullptr, nullptr },
        { const_cast<char*>("images"), (getter)StoreProduct_get_Images, nullptr, nullptr, nullptr },
        { const_cast<char*>("in_app_offer_token"), (getter)StoreProduct_get_InAppOfferToken, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_in_user_collection"), (getter)StoreProduct_get_IsInUserCollection, nullptr, nullptr, nullptr },
        { const_cast<char*>("keywords"), (getter)StoreProduct_get_Keywords, nullptr, nullptr, nullptr },
        { const_cast<char*>("language"), (getter)StoreProduct_get_Language, nullptr, nullptr, nullptr },
        { const_cast<char*>("link_uri"), (getter)StoreProduct_get_LinkUri, nullptr, nullptr, nullptr },
        { const_cast<char*>("price"), (getter)StoreProduct_get_Price, nullptr, nullptr, nullptr },
        { const_cast<char*>("product_kind"), (getter)StoreProduct_get_ProductKind, nullptr, nullptr, nullptr },
        { const_cast<char*>("skus"), (getter)StoreProduct_get_Skus, nullptr, nullptr, nullptr },
        { const_cast<char*>("store_id"), (getter)StoreProduct_get_StoreId, nullptr, nullptr, nullptr },
        { const_cast<char*>("title"), (getter)StoreProduct_get_Title, nullptr, nullptr, nullptr },
        { const_cast<char*>("videos"), (getter)StoreProduct_get_Videos, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreProduct[] = 
    {
        { Py_tp_new, _new_StoreProduct },
        { Py_tp_dealloc, _dealloc_StoreProduct },
        { Py_tp_methods, _methods_StoreProduct },
        { Py_tp_getset, _getset_StoreProduct },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreProduct =
    {
        "_winrt_Windows_Services_Store.StoreProduct",
        sizeof(py::wrapper::Windows::Services::Store::StoreProduct),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProduct
    };

    // ----- StoreProductOptions class --------------------
    constexpr const char* const _type_name_StoreProductOptions = "StoreProductOptions";

    static PyObject* _new_StoreProductOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Services::Store::StoreProductOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StoreProductOptions(py::wrapper::Windows::Services::Store::StoreProductOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreProductOptions_get_ActionFilters(py::wrapper::Windows::Services::Store::StoreProductOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActionFilters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreProductOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProductOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProductOptions[] = {
        { "_from", (PyCFunction)_from_StoreProductOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreProductOptions[] = {
        { const_cast<char*>("action_filters"), (getter)StoreProductOptions_get_ActionFilters, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreProductOptions[] = 
    {
        { Py_tp_new, _new_StoreProductOptions },
        { Py_tp_dealloc, _dealloc_StoreProductOptions },
        { Py_tp_methods, _methods_StoreProductOptions },
        { Py_tp_getset, _getset_StoreProductOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreProductOptions =
    {
        "_winrt_Windows_Services_Store.StoreProductOptions",
        sizeof(py::wrapper::Windows::Services::Store::StoreProductOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProductOptions
    };

    // ----- StoreProductPagedQueryResult class --------------------
    constexpr const char* const _type_name_StoreProductPagedQueryResult = "StoreProductPagedQueryResult";

    static PyObject* _new_StoreProductPagedQueryResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreProductPagedQueryResult);
        return nullptr;
    }

    static void _dealloc_StoreProductPagedQueryResult(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreProductPagedQueryResult_GetNextAsync(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetNextAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreProductPagedQueryResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProductPagedQueryResult_get_HasMoreResults(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasMoreResults());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProductPagedQueryResult_get_Products(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Products());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreProductPagedQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProductPagedQueryResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProductPagedQueryResult[] = {
        { "get_next_async", (PyCFunction)StoreProductPagedQueryResult_GetNextAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_StoreProductPagedQueryResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreProductPagedQueryResult[] = {
        { const_cast<char*>("extended_error"), (getter)StoreProductPagedQueryResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("has_more_results"), (getter)StoreProductPagedQueryResult_get_HasMoreResults, nullptr, nullptr, nullptr },
        { const_cast<char*>("products"), (getter)StoreProductPagedQueryResult_get_Products, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreProductPagedQueryResult[] = 
    {
        { Py_tp_new, _new_StoreProductPagedQueryResult },
        { Py_tp_dealloc, _dealloc_StoreProductPagedQueryResult },
        { Py_tp_methods, _methods_StoreProductPagedQueryResult },
        { Py_tp_getset, _getset_StoreProductPagedQueryResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreProductPagedQueryResult =
    {
        "_winrt_Windows_Services_Store.StoreProductPagedQueryResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProductPagedQueryResult
    };

    // ----- StoreProductQueryResult class --------------------
    constexpr const char* const _type_name_StoreProductQueryResult = "StoreProductQueryResult";

    static PyObject* _new_StoreProductQueryResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreProductQueryResult);
        return nullptr;
    }

    static void _dealloc_StoreProductQueryResult(py::wrapper::Windows::Services::Store::StoreProductQueryResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreProductQueryResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreProductQueryResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProductQueryResult_get_Products(py::wrapper::Windows::Services::Store::StoreProductQueryResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Products());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreProductQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProductQueryResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProductQueryResult[] = {
        { "_from", (PyCFunction)_from_StoreProductQueryResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreProductQueryResult[] = {
        { const_cast<char*>("extended_error"), (getter)StoreProductQueryResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("products"), (getter)StoreProductQueryResult_get_Products, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreProductQueryResult[] = 
    {
        { Py_tp_new, _new_StoreProductQueryResult },
        { Py_tp_dealloc, _dealloc_StoreProductQueryResult },
        { Py_tp_methods, _methods_StoreProductQueryResult },
        { Py_tp_getset, _getset_StoreProductQueryResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreProductQueryResult =
    {
        "_winrt_Windows_Services_Store.StoreProductQueryResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreProductQueryResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProductQueryResult
    };

    // ----- StoreProductResult class --------------------
    constexpr const char* const _type_name_StoreProductResult = "StoreProductResult";

    static PyObject* _new_StoreProductResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreProductResult);
        return nullptr;
    }

    static void _dealloc_StoreProductResult(py::wrapper::Windows::Services::Store::StoreProductResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreProductResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreProductResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProductResult_get_Product(py::wrapper::Windows::Services::Store::StoreProductResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Product());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreProductResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProductResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProductResult[] = {
        { "_from", (PyCFunction)_from_StoreProductResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreProductResult[] = {
        { const_cast<char*>("extended_error"), (getter)StoreProductResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("product"), (getter)StoreProductResult_get_Product, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreProductResult[] = 
    {
        { Py_tp_new, _new_StoreProductResult },
        { Py_tp_dealloc, _dealloc_StoreProductResult },
        { Py_tp_methods, _methods_StoreProductResult },
        { Py_tp_getset, _getset_StoreProductResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreProductResult =
    {
        "_winrt_Windows_Services_Store.StoreProductResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreProductResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProductResult
    };

    // ----- StorePurchaseProperties class --------------------
    constexpr const char* const _type_name_StorePurchaseProperties = "StorePurchaseProperties";

    static PyObject* _new_StorePurchaseProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Services::Store::StorePurchaseProperties instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Services::Store::StorePurchaseProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorePurchaseProperties(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorePurchaseProperties_get_Name(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePurchaseProperties_put_Name(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePurchaseProperties_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePurchaseProperties_put_ExtendedJsonData(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ExtendedJsonData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StorePurchaseProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePurchaseProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePurchaseProperties[] = {
        { "_from", (PyCFunction)_from_StorePurchaseProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorePurchaseProperties[] = {
        { const_cast<char*>("name"), (getter)StorePurchaseProperties_get_Name, (setter)StorePurchaseProperties_put_Name, nullptr, nullptr },
        { const_cast<char*>("extended_json_data"), (getter)StorePurchaseProperties_get_ExtendedJsonData, (setter)StorePurchaseProperties_put_ExtendedJsonData, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorePurchaseProperties[] = 
    {
        { Py_tp_new, _new_StorePurchaseProperties },
        { Py_tp_dealloc, _dealloc_StorePurchaseProperties },
        { Py_tp_methods, _methods_StorePurchaseProperties },
        { Py_tp_getset, _getset_StorePurchaseProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorePurchaseProperties =
    {
        "_winrt_Windows_Services_Store.StorePurchaseProperties",
        sizeof(py::wrapper::Windows::Services::Store::StorePurchaseProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePurchaseProperties
    };

    // ----- StorePurchaseResult class --------------------
    constexpr const char* const _type_name_StorePurchaseResult = "StorePurchaseResult";

    static PyObject* _new_StorePurchaseResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorePurchaseResult);
        return nullptr;
    }

    static void _dealloc_StorePurchaseResult(py::wrapper::Windows::Services::Store::StorePurchaseResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorePurchaseResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StorePurchaseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePurchaseResult_get_Status(py::wrapper::Windows::Services::Store::StorePurchaseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorePurchaseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePurchaseResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePurchaseResult[] = {
        { "_from", (PyCFunction)_from_StorePurchaseResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorePurchaseResult[] = {
        { const_cast<char*>("extended_error"), (getter)StorePurchaseResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)StorePurchaseResult_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorePurchaseResult[] = 
    {
        { Py_tp_new, _new_StorePurchaseResult },
        { Py_tp_dealloc, _dealloc_StorePurchaseResult },
        { Py_tp_methods, _methods_StorePurchaseResult },
        { Py_tp_getset, _getset_StorePurchaseResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorePurchaseResult =
    {
        "_winrt_Windows_Services_Store.StorePurchaseResult",
        sizeof(py::wrapper::Windows::Services::Store::StorePurchaseResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePurchaseResult
    };

    // ----- StoreQueueItem class --------------------
    constexpr const char* const _type_name_StoreQueueItem = "StoreQueueItem";

    static PyObject* _new_StoreQueueItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreQueueItem);
        return nullptr;
    }

    static void _dealloc_StoreQueueItem(py::wrapper::Windows::Services::Store::StoreQueueItem* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreQueueItem_CancelInstallAsync(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CancelInstallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_GetCurrentStatus(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_PauseInstallAsync(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.PauseInstallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_ResumeInstallAsync(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ResumeInstallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_get_InstallKind(py::wrapper::Windows::Services::Store::StoreQueueItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstallKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_get_PackageFamilyName(py::wrapper::Windows::Services::Store::StoreQueueItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_get_ProductId(py::wrapper::Windows::Services::Store::StoreQueueItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_add_Completed(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Store::StoreQueueItem, winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_remove_Completed(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_add_StatusChanged(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Store::StoreQueueItem, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_remove_StatusChanged(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreQueueItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreQueueItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreQueueItem[] = {
        { "cancel_install_async", (PyCFunction)StoreQueueItem_CancelInstallAsync, METH_VARARGS, nullptr },
        { "get_current_status", (PyCFunction)StoreQueueItem_GetCurrentStatus, METH_VARARGS, nullptr },
        { "pause_install_async", (PyCFunction)StoreQueueItem_PauseInstallAsync, METH_VARARGS, nullptr },
        { "resume_install_async", (PyCFunction)StoreQueueItem_ResumeInstallAsync, METH_VARARGS, nullptr },
        { "add_completed", (PyCFunction)StoreQueueItem_add_Completed, METH_O, nullptr },
        { "remove_completed", (PyCFunction)StoreQueueItem_remove_Completed, METH_O, nullptr },
        { "add_status_changed", (PyCFunction)StoreQueueItem_add_StatusChanged, METH_O, nullptr },
        { "remove_status_changed", (PyCFunction)StoreQueueItem_remove_StatusChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_StoreQueueItem, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreQueueItem[] = {
        { const_cast<char*>("install_kind"), (getter)StoreQueueItem_get_InstallKind, nullptr, nullptr, nullptr },
        { const_cast<char*>("package_family_name"), (getter)StoreQueueItem_get_PackageFamilyName, nullptr, nullptr, nullptr },
        { const_cast<char*>("product_id"), (getter)StoreQueueItem_get_ProductId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreQueueItem[] = 
    {
        { Py_tp_new, _new_StoreQueueItem },
        { Py_tp_dealloc, _dealloc_StoreQueueItem },
        { Py_tp_methods, _methods_StoreQueueItem },
        { Py_tp_getset, _getset_StoreQueueItem },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreQueueItem =
    {
        "_winrt_Windows_Services_Store.StoreQueueItem",
        sizeof(py::wrapper::Windows::Services::Store::StoreQueueItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreQueueItem
    };

    // ----- StoreQueueItemCompletedEventArgs class --------------------
    constexpr const char* const _type_name_StoreQueueItemCompletedEventArgs = "StoreQueueItemCompletedEventArgs";

    static PyObject* _new_StoreQueueItemCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreQueueItemCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_StoreQueueItemCompletedEventArgs(py::wrapper::Windows::Services::Store::StoreQueueItemCompletedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreQueueItemCompletedEventArgs_get_Status(py::wrapper::Windows::Services::Store::StoreQueueItemCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreQueueItemCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreQueueItemCompletedEventArgs[] = {
        { "_from", (PyCFunction)_from_StoreQueueItemCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreQueueItemCompletedEventArgs[] = {
        { const_cast<char*>("status"), (getter)StoreQueueItemCompletedEventArgs_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreQueueItemCompletedEventArgs[] = 
    {
        { Py_tp_new, _new_StoreQueueItemCompletedEventArgs },
        { Py_tp_dealloc, _dealloc_StoreQueueItemCompletedEventArgs },
        { Py_tp_methods, _methods_StoreQueueItemCompletedEventArgs },
        { Py_tp_getset, _getset_StoreQueueItemCompletedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreQueueItemCompletedEventArgs =
    {
        "_winrt_Windows_Services_Store.StoreQueueItemCompletedEventArgs",
        sizeof(py::wrapper::Windows::Services::Store::StoreQueueItemCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreQueueItemCompletedEventArgs
    };

    // ----- StoreQueueItemStatus class --------------------
    constexpr const char* const _type_name_StoreQueueItemStatus = "StoreQueueItemStatus";

    static PyObject* _new_StoreQueueItemStatus(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreQueueItemStatus);
        return nullptr;
    }

    static void _dealloc_StoreQueueItemStatus(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreQueueItemStatus_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItemStatus_get_PackageInstallExtendedState(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageInstallExtendedState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItemStatus_get_PackageInstallState(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageInstallState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItemStatus_get_UpdateStatus(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreQueueItemStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreQueueItemStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreQueueItemStatus[] = {
        { "_from", (PyCFunction)_from_StoreQueueItemStatus, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreQueueItemStatus[] = {
        { const_cast<char*>("extended_error"), (getter)StoreQueueItemStatus_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("package_install_extended_state"), (getter)StoreQueueItemStatus_get_PackageInstallExtendedState, nullptr, nullptr, nullptr },
        { const_cast<char*>("package_install_state"), (getter)StoreQueueItemStatus_get_PackageInstallState, nullptr, nullptr, nullptr },
        { const_cast<char*>("update_status"), (getter)StoreQueueItemStatus_get_UpdateStatus, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreQueueItemStatus[] = 
    {
        { Py_tp_new, _new_StoreQueueItemStatus },
        { Py_tp_dealloc, _dealloc_StoreQueueItemStatus },
        { Py_tp_methods, _methods_StoreQueueItemStatus },
        { Py_tp_getset, _getset_StoreQueueItemStatus },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreQueueItemStatus =
    {
        "_winrt_Windows_Services_Store.StoreQueueItemStatus",
        sizeof(py::wrapper::Windows::Services::Store::StoreQueueItemStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreQueueItemStatus
    };

    // ----- StoreRateAndReviewResult class --------------------
    constexpr const char* const _type_name_StoreRateAndReviewResult = "StoreRateAndReviewResult";

    static PyObject* _new_StoreRateAndReviewResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreRateAndReviewResult);
        return nullptr;
    }

    static void _dealloc_StoreRateAndReviewResult(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreRateAndReviewResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreRateAndReviewResult_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreRateAndReviewResult_get_Status(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreRateAndReviewResult_get_WasUpdated(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WasUpdated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreRateAndReviewResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreRateAndReviewResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreRateAndReviewResult[] = {
        { "_from", (PyCFunction)_from_StoreRateAndReviewResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreRateAndReviewResult[] = {
        { const_cast<char*>("extended_error"), (getter)StoreRateAndReviewResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_json_data"), (getter)StoreRateAndReviewResult_get_ExtendedJsonData, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)StoreRateAndReviewResult_get_Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("was_updated"), (getter)StoreRateAndReviewResult_get_WasUpdated, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreRateAndReviewResult[] = 
    {
        { Py_tp_new, _new_StoreRateAndReviewResult },
        { Py_tp_dealloc, _dealloc_StoreRateAndReviewResult },
        { Py_tp_methods, _methods_StoreRateAndReviewResult },
        { Py_tp_getset, _getset_StoreRateAndReviewResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreRateAndReviewResult =
    {
        "_winrt_Windows_Services_Store.StoreRateAndReviewResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreRateAndReviewResult
    };

    // ----- StoreRequestHelper class --------------------
    constexpr const char* const _type_name_StoreRequestHelper = "StoreRequestHelper";

    static PyObject* _new_StoreRequestHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreRequestHelper);
        return nullptr;
    }

    static PyObject* StoreRequestHelper_SendRequestAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Store::StoreContext>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::Services::Store::StoreRequestHelper::SendRequestAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreRequestHelper[] = {
        { "send_request_async", (PyCFunction)StoreRequestHelper_SendRequestAsync, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreRequestHelper[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreRequestHelper[] = 
    {
        { Py_tp_new, _new_StoreRequestHelper },
        { Py_tp_methods, _methods_StoreRequestHelper },
        { Py_tp_getset, _getset_StoreRequestHelper },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreRequestHelper =
    {
        "_winrt_Windows_Services_Store.StoreRequestHelper",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreRequestHelper
    };

    // ----- StoreSendRequestResult class --------------------
    constexpr const char* const _type_name_StoreSendRequestResult = "StoreSendRequestResult";

    static PyObject* _new_StoreSendRequestResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreSendRequestResult);
        return nullptr;
    }

    static void _dealloc_StoreSendRequestResult(py::wrapper::Windows::Services::Store::StoreSendRequestResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreSendRequestResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreSendRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSendRequestResult_get_Response(py::wrapper::Windows::Services::Store::StoreSendRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Response());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSendRequestResult_get_HttpStatusCode(py::wrapper::Windows::Services::Store::StoreSendRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HttpStatusCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreSendRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreSendRequestResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreSendRequestResult[] = {
        { "_from", (PyCFunction)_from_StoreSendRequestResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreSendRequestResult[] = {
        { const_cast<char*>("extended_error"), (getter)StoreSendRequestResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("response"), (getter)StoreSendRequestResult_get_Response, nullptr, nullptr, nullptr },
        { const_cast<char*>("http_status_code"), (getter)StoreSendRequestResult_get_HttpStatusCode, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreSendRequestResult[] = 
    {
        { Py_tp_new, _new_StoreSendRequestResult },
        { Py_tp_dealloc, _dealloc_StoreSendRequestResult },
        { Py_tp_methods, _methods_StoreSendRequestResult },
        { Py_tp_getset, _getset_StoreSendRequestResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreSendRequestResult =
    {
        "_winrt_Windows_Services_Store.StoreSendRequestResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreSendRequestResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreSendRequestResult
    };

    // ----- StoreSku class --------------------
    constexpr const char* const _type_name_StoreSku = "StoreSku";

    static PyObject* _new_StoreSku(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreSku);
        return nullptr;
    }

    static void _dealloc_StoreSku(py::wrapper::Windows::Services::Store::StoreSku* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreSku_GetIsInstalledAsync(py::wrapper::Windows::Services::Store::StoreSku* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetIsInstalledAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreSku_RequestPurchaseAsync(py::wrapper::Windows::Services::Store::StoreSku* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestPurchaseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Store::StorePurchaseProperties>(args, 0);

                return py::convert(self->obj.RequestPurchaseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Availabilities(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Availabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_BundledSkus(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BundledSkus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_CollectionData(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CollectionData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_CustomDeveloperData(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CustomDeveloperData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Description(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Images(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Images());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_IsInUserCollection(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInUserCollection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_IsSubscription(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSubscription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_IsTrial(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTrial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Language(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Price(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Price());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_StoreId(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StoreId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_SubscriptionInfo(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SubscriptionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Title(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Videos(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Videos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreSku(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreSku>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreSku[] = {
        { "get_is_installed_async", (PyCFunction)StoreSku_GetIsInstalledAsync, METH_VARARGS, nullptr },
        { "request_purchase_async", (PyCFunction)StoreSku_RequestPurchaseAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_StoreSku, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreSku[] = {
        { const_cast<char*>("availabilities"), (getter)StoreSku_get_Availabilities, nullptr, nullptr, nullptr },
        { const_cast<char*>("bundled_skus"), (getter)StoreSku_get_BundledSkus, nullptr, nullptr, nullptr },
        { const_cast<char*>("collection_data"), (getter)StoreSku_get_CollectionData, nullptr, nullptr, nullptr },
        { const_cast<char*>("custom_developer_data"), (getter)StoreSku_get_CustomDeveloperData, nullptr, nullptr, nullptr },
        { const_cast<char*>("description"), (getter)StoreSku_get_Description, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_json_data"), (getter)StoreSku_get_ExtendedJsonData, nullptr, nullptr, nullptr },
        { const_cast<char*>("images"), (getter)StoreSku_get_Images, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_in_user_collection"), (getter)StoreSku_get_IsInUserCollection, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_subscription"), (getter)StoreSku_get_IsSubscription, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_trial"), (getter)StoreSku_get_IsTrial, nullptr, nullptr, nullptr },
        { const_cast<char*>("language"), (getter)StoreSku_get_Language, nullptr, nullptr, nullptr },
        { const_cast<char*>("price"), (getter)StoreSku_get_Price, nullptr, nullptr, nullptr },
        { const_cast<char*>("store_id"), (getter)StoreSku_get_StoreId, nullptr, nullptr, nullptr },
        { const_cast<char*>("subscription_info"), (getter)StoreSku_get_SubscriptionInfo, nullptr, nullptr, nullptr },
        { const_cast<char*>("title"), (getter)StoreSku_get_Title, nullptr, nullptr, nullptr },
        { const_cast<char*>("videos"), (getter)StoreSku_get_Videos, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreSku[] = 
    {
        { Py_tp_new, _new_StoreSku },
        { Py_tp_dealloc, _dealloc_StoreSku },
        { Py_tp_methods, _methods_StoreSku },
        { Py_tp_getset, _getset_StoreSku },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreSku =
    {
        "_winrt_Windows_Services_Store.StoreSku",
        sizeof(py::wrapper::Windows::Services::Store::StoreSku),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreSku
    };

    // ----- StoreSubscriptionInfo class --------------------
    constexpr const char* const _type_name_StoreSubscriptionInfo = "StoreSubscriptionInfo";

    static PyObject* _new_StoreSubscriptionInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreSubscriptionInfo);
        return nullptr;
    }

    static void _dealloc_StoreSubscriptionInfo(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreSubscriptionInfo_get_BillingPeriod(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BillingPeriod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSubscriptionInfo_get_BillingPeriodUnit(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BillingPeriodUnit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSubscriptionInfo_get_HasTrialPeriod(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasTrialPeriod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSubscriptionInfo_get_TrialPeriod(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrialPeriod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSubscriptionInfo_get_TrialPeriodUnit(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrialPeriodUnit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreSubscriptionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreSubscriptionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreSubscriptionInfo[] = {
        { "_from", (PyCFunction)_from_StoreSubscriptionInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreSubscriptionInfo[] = {
        { const_cast<char*>("billing_period"), (getter)StoreSubscriptionInfo_get_BillingPeriod, nullptr, nullptr, nullptr },
        { const_cast<char*>("billing_period_unit"), (getter)StoreSubscriptionInfo_get_BillingPeriodUnit, nullptr, nullptr, nullptr },
        { const_cast<char*>("has_trial_period"), (getter)StoreSubscriptionInfo_get_HasTrialPeriod, nullptr, nullptr, nullptr },
        { const_cast<char*>("trial_period"), (getter)StoreSubscriptionInfo_get_TrialPeriod, nullptr, nullptr, nullptr },
        { const_cast<char*>("trial_period_unit"), (getter)StoreSubscriptionInfo_get_TrialPeriodUnit, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreSubscriptionInfo[] = 
    {
        { Py_tp_new, _new_StoreSubscriptionInfo },
        { Py_tp_dealloc, _dealloc_StoreSubscriptionInfo },
        { Py_tp_methods, _methods_StoreSubscriptionInfo },
        { Py_tp_getset, _getset_StoreSubscriptionInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreSubscriptionInfo =
    {
        "_winrt_Windows_Services_Store.StoreSubscriptionInfo",
        sizeof(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreSubscriptionInfo
    };

    // ----- StoreUninstallStorePackageResult class --------------------
    constexpr const char* const _type_name_StoreUninstallStorePackageResult = "StoreUninstallStorePackageResult";

    static PyObject* _new_StoreUninstallStorePackageResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreUninstallStorePackageResult);
        return nullptr;
    }

    static void _dealloc_StoreUninstallStorePackageResult(py::wrapper::Windows::Services::Store::StoreUninstallStorePackageResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreUninstallStorePackageResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreUninstallStorePackageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreUninstallStorePackageResult_get_Status(py::wrapper::Windows::Services::Store::StoreUninstallStorePackageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreUninstallStorePackageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreUninstallStorePackageResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreUninstallStorePackageResult[] = {
        { "_from", (PyCFunction)_from_StoreUninstallStorePackageResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreUninstallStorePackageResult[] = {
        { const_cast<char*>("extended_error"), (getter)StoreUninstallStorePackageResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)StoreUninstallStorePackageResult_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreUninstallStorePackageResult[] = 
    {
        { Py_tp_new, _new_StoreUninstallStorePackageResult },
        { Py_tp_dealloc, _dealloc_StoreUninstallStorePackageResult },
        { Py_tp_methods, _methods_StoreUninstallStorePackageResult },
        { Py_tp_getset, _getset_StoreUninstallStorePackageResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreUninstallStorePackageResult =
    {
        "_winrt_Windows_Services_Store.StoreUninstallStorePackageResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreUninstallStorePackageResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreUninstallStorePackageResult
    };

    // ----- StoreVideo class --------------------
    constexpr const char* const _type_name_StoreVideo = "StoreVideo";

    static PyObject* _new_StoreVideo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreVideo);
        return nullptr;
    }

    static void _dealloc_StoreVideo(py::wrapper::Windows::Services::Store::StoreVideo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreVideo_get_Caption(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Caption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_Height(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_PreviewImage(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviewImage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_Uri(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_VideoPurposeTag(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoPurposeTag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_Width(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreVideo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreVideo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreVideo[] = {
        { "_from", (PyCFunction)_from_StoreVideo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StoreVideo[] = {
        { const_cast<char*>("caption"), (getter)StoreVideo_get_Caption, nullptr, nullptr, nullptr },
        { const_cast<char*>("height"), (getter)StoreVideo_get_Height, nullptr, nullptr, nullptr },
        { const_cast<char*>("preview_image"), (getter)StoreVideo_get_PreviewImage, nullptr, nullptr, nullptr },
        { const_cast<char*>("uri"), (getter)StoreVideo_get_Uri, nullptr, nullptr, nullptr },
        { const_cast<char*>("video_purpose_tag"), (getter)StoreVideo_get_VideoPurposeTag, nullptr, nullptr, nullptr },
        { const_cast<char*>("width"), (getter)StoreVideo_get_Width, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StoreVideo[] = 
    {
        { Py_tp_new, _new_StoreVideo },
        { Py_tp_dealloc, _dealloc_StoreVideo },
        { Py_tp_methods, _methods_StoreVideo },
        { Py_tp_getset, _getset_StoreVideo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreVideo =
    {
        "_winrt_Windows_Services_Store.StoreVideo",
        sizeof(py::wrapper::Windows::Services::Store::StoreVideo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreVideo
    };

    // ----- StorePackageUpdateStatus struct --------------------
    constexpr const char* const _type_name_StorePackageUpdateStatus = "StorePackageUpdateStatus";

    PyObject* _new_StorePackageUpdateStatus(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Services::Store::StorePackageUpdateStatus return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Services::Store::StorePackageUpdateStatus>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        winrt::hstring _PackageFamilyName{};
        uint64_t _PackageDownloadSizeInBytes{};
        uint64_t _PackageBytesDownloaded{};
        double _PackageDownloadProgress{};
        double _TotalDownloadProgress{};
        int32_t _PackageUpdateState{};

        static const char* kwlist[] = {"package_family_name", "package_download_size_in_bytes", "package_bytes_downloaded", "package_download_progress", "total_download_progress", "package_update_state", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "uKKddi", const_cast<char**>(kwlist), &_PackageFamilyName, &_PackageDownloadSizeInBytes, &_PackageBytesDownloaded, &_PackageDownloadProgress, &_TotalDownloadProgress, &_PackageUpdateState))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Services::Store::StorePackageUpdateStatus return_value{ _PackageFamilyName, _PackageDownloadSizeInBytes, _PackageBytesDownloaded, _PackageDownloadProgress, _TotalDownloadProgress, static_cast<winrt::Windows::Services::Store::StorePackageUpdateState>(_PackageUpdateState) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_StorePackageUpdateStatus(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self)
    {
    }

    static PyObject* StorePackageUpdateStatus_get_PackageFamilyName(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageFamilyName);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_PackageFamilyName(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PackageFamilyName = py::converter<winrt::hstring>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_PackageDownloadSizeInBytes(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageDownloadSizeInBytes);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_PackageDownloadSizeInBytes(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PackageDownloadSizeInBytes = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_PackageBytesDownloaded(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageBytesDownloaded);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_PackageBytesDownloaded(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PackageBytesDownloaded = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_PackageDownloadProgress(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageDownloadProgress);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_PackageDownloadProgress(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PackageDownloadProgress = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_TotalDownloadProgress(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalDownloadProgress);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_TotalDownloadProgress(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.TotalDownloadProgress = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_PackageUpdateState(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageUpdateState);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_PackageUpdateState(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PackageUpdateState = py::converter<winrt::Windows::Services::Store::StorePackageUpdateState>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_StorePackageUpdateStatus[] = {
        { const_cast<char*>("package_family_name"), (getter)StorePackageUpdateStatus_get_PackageFamilyName, (setter)StorePackageUpdateStatus_set_PackageFamilyName, nullptr, nullptr },
        { const_cast<char*>("package_download_size_in_bytes"), (getter)StorePackageUpdateStatus_get_PackageDownloadSizeInBytes, (setter)StorePackageUpdateStatus_set_PackageDownloadSizeInBytes, nullptr, nullptr },
        { const_cast<char*>("package_bytes_downloaded"), (getter)StorePackageUpdateStatus_get_PackageBytesDownloaded, (setter)StorePackageUpdateStatus_set_PackageBytesDownloaded, nullptr, nullptr },
        { const_cast<char*>("package_download_progress"), (getter)StorePackageUpdateStatus_get_PackageDownloadProgress, (setter)StorePackageUpdateStatus_set_PackageDownloadProgress, nullptr, nullptr },
        { const_cast<char*>("total_download_progress"), (getter)StorePackageUpdateStatus_get_TotalDownloadProgress, (setter)StorePackageUpdateStatus_set_TotalDownloadProgress, nullptr, nullptr },
        { const_cast<char*>("package_update_state"), (getter)StorePackageUpdateStatus_get_PackageUpdateState, (setter)StorePackageUpdateStatus_set_PackageUpdateState, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StorePackageUpdateStatus[] = 
    {
        { Py_tp_new, _new_StorePackageUpdateStatus },
        { Py_tp_dealloc, _dealloc_StorePackageUpdateStatus },
        { Py_tp_getset, _getset_StorePackageUpdateStatus },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorePackageUpdateStatus =
    {
        "_winrt_Windows_Services_Store.StorePackageUpdateStatus",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageUpdateStatus
    };

    // ----- Windows.Services.Store Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Services::Store::StoreAcquireLicenseResult>::python_type = py::register_python_type(module, _type_name_StoreAcquireLicenseResult, &_type_spec_StoreAcquireLicenseResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreAppLicense>::python_type = py::register_python_type(module, _type_name_StoreAppLicense, &_type_spec_StoreAppLicense, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreAvailability>::python_type = py::register_python_type(module, _type_name_StoreAvailability, &_type_spec_StoreAvailability, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreCanAcquireLicenseResult>::python_type = py::register_python_type(module, _type_name_StoreCanAcquireLicenseResult, &_type_spec_StoreCanAcquireLicenseResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreCollectionData>::python_type = py::register_python_type(module, _type_name_StoreCollectionData, &_type_spec_StoreCollectionData, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreConsumableResult>::python_type = py::register_python_type(module, _type_name_StoreConsumableResult, &_type_spec_StoreConsumableResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreContext>::python_type = py::register_python_type(module, _type_name_StoreContext, &_type_spec_StoreContext, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreImage>::python_type = py::register_python_type(module, _type_name_StoreImage, &_type_spec_StoreImage, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreLicense>::python_type = py::register_python_type(module, _type_name_StoreLicense, &_type_spec_StoreLicense, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StorePackageInstallOptions>::python_type = py::register_python_type(module, _type_name_StorePackageInstallOptions, &_type_spec_StorePackageInstallOptions, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StorePackageLicense>::python_type = py::register_python_type(module, _type_name_StorePackageLicense, &_type_spec_StorePackageLicense, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StorePackageUpdate>::python_type = py::register_python_type(module, _type_name_StorePackageUpdate, &_type_spec_StorePackageUpdate, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StorePackageUpdateResult>::python_type = py::register_python_type(module, _type_name_StorePackageUpdateResult, &_type_spec_StorePackageUpdateResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StorePrice>::python_type = py::register_python_type(module, _type_name_StorePrice, &_type_spec_StorePrice, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreProduct>::python_type = py::register_python_type(module, _type_name_StoreProduct, &_type_spec_StoreProduct, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreProductOptions>::python_type = py::register_python_type(module, _type_name_StoreProductOptions, &_type_spec_StoreProductOptions, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreProductPagedQueryResult>::python_type = py::register_python_type(module, _type_name_StoreProductPagedQueryResult, &_type_spec_StoreProductPagedQueryResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreProductQueryResult>::python_type = py::register_python_type(module, _type_name_StoreProductQueryResult, &_type_spec_StoreProductQueryResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreProductResult>::python_type = py::register_python_type(module, _type_name_StoreProductResult, &_type_spec_StoreProductResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StorePurchaseProperties>::python_type = py::register_python_type(module, _type_name_StorePurchaseProperties, &_type_spec_StorePurchaseProperties, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StorePurchaseResult>::python_type = py::register_python_type(module, _type_name_StorePurchaseResult, &_type_spec_StorePurchaseResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreQueueItem>::python_type = py::register_python_type(module, _type_name_StoreQueueItem, &_type_spec_StoreQueueItem, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>::python_type = py::register_python_type(module, _type_name_StoreQueueItemCompletedEventArgs, &_type_spec_StoreQueueItemCompletedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreQueueItemStatus>::python_type = py::register_python_type(module, _type_name_StoreQueueItemStatus, &_type_spec_StoreQueueItemStatus, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreRateAndReviewResult>::python_type = py::register_python_type(module, _type_name_StoreRateAndReviewResult, &_type_spec_StoreRateAndReviewResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreRequestHelper>::python_type = py::register_python_type(module, _type_name_StoreRequestHelper, &_type_spec_StoreRequestHelper, nullptr);
            py::winrt_type<winrt::Windows::Services::Store::StoreSendRequestResult>::python_type = py::register_python_type(module, _type_name_StoreSendRequestResult, &_type_spec_StoreSendRequestResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreSku>::python_type = py::register_python_type(module, _type_name_StoreSku, &_type_spec_StoreSku, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreSubscriptionInfo>::python_type = py::register_python_type(module, _type_name_StoreSubscriptionInfo, &_type_spec_StoreSubscriptionInfo, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreUninstallStorePackageResult>::python_type = py::register_python_type(module, _type_name_StoreUninstallStorePackageResult, &_type_spec_StoreUninstallStorePackageResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreVideo>::python_type = py::register_python_type(module, _type_name_StoreVideo, &_type_spec_StoreVideo, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StorePackageUpdateStatus>::python_type = py::register_python_type(module, _type_name_StorePackageUpdateStatus, &_type_spec_StorePackageUpdateStatus, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Services.Store");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Services_Store",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Services::Store

PyMODINIT_FUNC
PyInit__winrt_Windows_Services_Store (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Services::Store::module_def);
}
