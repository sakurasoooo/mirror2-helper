// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Media.Streaming.Adaptive.h"

PyTypeObject* py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCorrelatedTimes>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCreationResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnostics>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadBitrateChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadStatistics>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourcePlaybackBitrateChangedEventArgs>::python_type;

namespace py::cpp::Windows::Media::Streaming::Adaptive
{
    // ----- AdaptiveMediaSource class --------------------
    constexpr const char* const _type_name_AdaptiveMediaSource = "AdaptiveMediaSource";

    static PyObject* _new_AdaptiveMediaSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AdaptiveMediaSource);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSource(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdaptiveMediaSource_Close(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_CreateFromStreamAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource::CreateFromStreamAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Web::Http::HttpClient>(args, 3);

                return py::convert(winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource::CreateFromStreamAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_CreateFromUriAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource::CreateFromUriAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::HttpClient>(args, 1);

                return py::convert(winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource::CreateFromUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_GetCorrelatedTimes(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCorrelatedTimes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_IsContentTypeSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource::IsContentTypeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_get_InitialBitrate(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InitialBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSource_put_InitialBitrate(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.InitialBitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSource_get_InboundBitsPerSecondWindow(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundBitsPerSecondWindow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSource_put_InboundBitsPerSecondWindow(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.InboundBitsPerSecondWindow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSource_get_DesiredMaxBitrate(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredMaxBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSource_put_DesiredMaxBitrate(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.DesiredMaxBitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSource_get_DesiredLiveOffset(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredLiveOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSource_put_DesiredLiveOffset(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DesiredLiveOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSource_get_DesiredMinBitrate(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredMinBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSource_put_DesiredMinBitrate(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.DesiredMinBitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSource_get_CurrentPlaybackBitrate(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentPlaybackBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_get_AudioOnlyPlayback(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioOnlyPlayback());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_get_InboundBitsPerSecond(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundBitsPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_get_AvailableBitrates(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AvailableBitrates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_get_CurrentDownloadBitrate(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentDownloadBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_get_IsLive(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_get_AdvancedSettings(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdvancedSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_get_DesiredSeekableWindowSize(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredSeekableWindowSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSource_put_DesiredSeekableWindowSize(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.DesiredSeekableWindowSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSource_get_Diagnostics(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Diagnostics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_get_MaxSeekableWindowSize(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxSeekableWindowSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_get_MinLiveOffset(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinLiveOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_add_DownloadBitrateChanged(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource, winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadBitrateChangedEventArgs>>(arg);

            return py::convert(self->obj.DownloadBitrateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_remove_DownloadBitrateChanged(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DownloadBitrateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_add_DownloadCompleted(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource, winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs>>(arg);

            return py::convert(self->obj.DownloadCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_remove_DownloadCompleted(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DownloadCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_add_DownloadFailed(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource, winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs>>(arg);

            return py::convert(self->obj.DownloadFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_remove_DownloadFailed(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DownloadFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_add_DownloadRequested(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource, winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs>>(arg);

            return py::convert(self->obj.DownloadRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_remove_DownloadRequested(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DownloadRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_add_PlaybackBitrateChanged(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource, winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourcePlaybackBitrateChangedEventArgs>>(arg);

            return py::convert(self->obj.PlaybackBitrateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_remove_PlaybackBitrateChanged(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlaybackBitrateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AdaptiveMediaSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AdaptiveMediaSource(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_AdaptiveMediaSource(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSource[] = {
        { "close", (PyCFunction)AdaptiveMediaSource_Close, METH_VARARGS, nullptr },
        { "create_from_stream_async", (PyCFunction)AdaptiveMediaSource_CreateFromStreamAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_uri_async", (PyCFunction)AdaptiveMediaSource_CreateFromUriAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_correlated_times", (PyCFunction)AdaptiveMediaSource_GetCorrelatedTimes, METH_VARARGS, nullptr },
        { "is_content_type_supported", (PyCFunction)AdaptiveMediaSource_IsContentTypeSupported, METH_VARARGS | METH_STATIC, nullptr },
        { "add_download_bitrate_changed", (PyCFunction)AdaptiveMediaSource_add_DownloadBitrateChanged, METH_O, nullptr },
        { "remove_download_bitrate_changed", (PyCFunction)AdaptiveMediaSource_remove_DownloadBitrateChanged, METH_O, nullptr },
        { "add_download_completed", (PyCFunction)AdaptiveMediaSource_add_DownloadCompleted, METH_O, nullptr },
        { "remove_download_completed", (PyCFunction)AdaptiveMediaSource_remove_DownloadCompleted, METH_O, nullptr },
        { "add_download_failed", (PyCFunction)AdaptiveMediaSource_add_DownloadFailed, METH_O, nullptr },
        { "remove_download_failed", (PyCFunction)AdaptiveMediaSource_remove_DownloadFailed, METH_O, nullptr },
        { "add_download_requested", (PyCFunction)AdaptiveMediaSource_add_DownloadRequested, METH_O, nullptr },
        { "remove_download_requested", (PyCFunction)AdaptiveMediaSource_remove_DownloadRequested, METH_O, nullptr },
        { "add_playback_bitrate_changed", (PyCFunction)AdaptiveMediaSource_add_PlaybackBitrateChanged, METH_O, nullptr },
        { "remove_playback_bitrate_changed", (PyCFunction)AdaptiveMediaSource_remove_PlaybackBitrateChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_AdaptiveMediaSource, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_AdaptiveMediaSource, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_AdaptiveMediaSource, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AdaptiveMediaSource[] = {
        { const_cast<char*>("initial_bitrate"), (getter)AdaptiveMediaSource_get_InitialBitrate, (setter)AdaptiveMediaSource_put_InitialBitrate, nullptr, nullptr },
        { const_cast<char*>("inbound_bits_per_second_window"), (getter)AdaptiveMediaSource_get_InboundBitsPerSecondWindow, (setter)AdaptiveMediaSource_put_InboundBitsPerSecondWindow, nullptr, nullptr },
        { const_cast<char*>("desired_max_bitrate"), (getter)AdaptiveMediaSource_get_DesiredMaxBitrate, (setter)AdaptiveMediaSource_put_DesiredMaxBitrate, nullptr, nullptr },
        { const_cast<char*>("desired_live_offset"), (getter)AdaptiveMediaSource_get_DesiredLiveOffset, (setter)AdaptiveMediaSource_put_DesiredLiveOffset, nullptr, nullptr },
        { const_cast<char*>("desired_min_bitrate"), (getter)AdaptiveMediaSource_get_DesiredMinBitrate, (setter)AdaptiveMediaSource_put_DesiredMinBitrate, nullptr, nullptr },
        { const_cast<char*>("current_playback_bitrate"), (getter)AdaptiveMediaSource_get_CurrentPlaybackBitrate, nullptr, nullptr, nullptr },
        { const_cast<char*>("audio_only_playback"), (getter)AdaptiveMediaSource_get_AudioOnlyPlayback, nullptr, nullptr, nullptr },
        { const_cast<char*>("inbound_bits_per_second"), (getter)AdaptiveMediaSource_get_InboundBitsPerSecond, nullptr, nullptr, nullptr },
        { const_cast<char*>("available_bitrates"), (getter)AdaptiveMediaSource_get_AvailableBitrates, nullptr, nullptr, nullptr },
        { const_cast<char*>("current_download_bitrate"), (getter)AdaptiveMediaSource_get_CurrentDownloadBitrate, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_live"), (getter)AdaptiveMediaSource_get_IsLive, nullptr, nullptr, nullptr },
        { const_cast<char*>("advanced_settings"), (getter)AdaptiveMediaSource_get_AdvancedSettings, nullptr, nullptr, nullptr },
        { const_cast<char*>("desired_seekable_window_size"), (getter)AdaptiveMediaSource_get_DesiredSeekableWindowSize, (setter)AdaptiveMediaSource_put_DesiredSeekableWindowSize, nullptr, nullptr },
        { const_cast<char*>("diagnostics"), (getter)AdaptiveMediaSource_get_Diagnostics, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_seekable_window_size"), (getter)AdaptiveMediaSource_get_MaxSeekableWindowSize, nullptr, nullptr, nullptr },
        { const_cast<char*>("min_live_offset"), (getter)AdaptiveMediaSource_get_MinLiveOffset, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSource[] = 
    {
        { Py_tp_new, _new_AdaptiveMediaSource },
        { Py_tp_dealloc, _dealloc_AdaptiveMediaSource },
        { Py_tp_methods, _methods_AdaptiveMediaSource },
        { Py_tp_getset, _getset_AdaptiveMediaSource },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AdaptiveMediaSource =
    {
        "_winrt_Windows_Media_Streaming_Adaptive.AdaptiveMediaSource",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSource
    };

    // ----- AdaptiveMediaSourceAdvancedSettings class --------------------
    constexpr const char* const _type_name_AdaptiveMediaSourceAdvancedSettings = "AdaptiveMediaSourceAdvancedSettings";

    static PyObject* _new_AdaptiveMediaSourceAdvancedSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AdaptiveMediaSourceAdvancedSettings);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceAdvancedSettings(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdaptiveMediaSourceAdvancedSettings_get_DesiredBitrateHeadroomRatio(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredBitrateHeadroomRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSourceAdvancedSettings_put_DesiredBitrateHeadroomRatio(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(arg);

            self->obj.DesiredBitrateHeadroomRatio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSourceAdvancedSettings_get_BitrateDowngradeTriggerRatio(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitrateDowngradeTriggerRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSourceAdvancedSettings_put_BitrateDowngradeTriggerRatio(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(arg);

            self->obj.BitrateDowngradeTriggerRatio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSourceAdvancedSettings_get_AllSegmentsIndependent(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllSegmentsIndependent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSourceAdvancedSettings_put_AllSegmentsIndependent(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllSegmentsIndependent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AdaptiveMediaSourceAdvancedSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceAdvancedSettings[] = {
        { "_from", (PyCFunction)_from_AdaptiveMediaSourceAdvancedSettings, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceAdvancedSettings[] = {
        { const_cast<char*>("desired_bitrate_headroom_ratio"), (getter)AdaptiveMediaSourceAdvancedSettings_get_DesiredBitrateHeadroomRatio, (setter)AdaptiveMediaSourceAdvancedSettings_put_DesiredBitrateHeadroomRatio, nullptr, nullptr },
        { const_cast<char*>("bitrate_downgrade_trigger_ratio"), (getter)AdaptiveMediaSourceAdvancedSettings_get_BitrateDowngradeTriggerRatio, (setter)AdaptiveMediaSourceAdvancedSettings_put_BitrateDowngradeTriggerRatio, nullptr, nullptr },
        { const_cast<char*>("all_segments_independent"), (getter)AdaptiveMediaSourceAdvancedSettings_get_AllSegmentsIndependent, (setter)AdaptiveMediaSourceAdvancedSettings_put_AllSegmentsIndependent, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceAdvancedSettings[] = 
    {
        { Py_tp_new, _new_AdaptiveMediaSourceAdvancedSettings },
        { Py_tp_dealloc, _dealloc_AdaptiveMediaSourceAdvancedSettings },
        { Py_tp_methods, _methods_AdaptiveMediaSourceAdvancedSettings },
        { Py_tp_getset, _getset_AdaptiveMediaSourceAdvancedSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AdaptiveMediaSourceAdvancedSettings =
    {
        "_winrt_Windows_Media_Streaming_Adaptive.AdaptiveMediaSourceAdvancedSettings",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceAdvancedSettings
    };

    // ----- AdaptiveMediaSourceCorrelatedTimes class --------------------
    constexpr const char* const _type_name_AdaptiveMediaSourceCorrelatedTimes = "AdaptiveMediaSourceCorrelatedTimes";

    static PyObject* _new_AdaptiveMediaSourceCorrelatedTimes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AdaptiveMediaSourceCorrelatedTimes);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceCorrelatedTimes(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCorrelatedTimes* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdaptiveMediaSourceCorrelatedTimes_get_Position(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCorrelatedTimes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceCorrelatedTimes_get_PresentationTimeStamp(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCorrelatedTimes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PresentationTimeStamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceCorrelatedTimes_get_ProgramDateTime(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCorrelatedTimes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProgramDateTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AdaptiveMediaSourceCorrelatedTimes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCorrelatedTimes>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceCorrelatedTimes[] = {
        { "_from", (PyCFunction)_from_AdaptiveMediaSourceCorrelatedTimes, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceCorrelatedTimes[] = {
        { const_cast<char*>("position"), (getter)AdaptiveMediaSourceCorrelatedTimes_get_Position, nullptr, nullptr, nullptr },
        { const_cast<char*>("presentation_time_stamp"), (getter)AdaptiveMediaSourceCorrelatedTimes_get_PresentationTimeStamp, nullptr, nullptr, nullptr },
        { const_cast<char*>("program_date_time"), (getter)AdaptiveMediaSourceCorrelatedTimes_get_ProgramDateTime, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceCorrelatedTimes[] = 
    {
        { Py_tp_new, _new_AdaptiveMediaSourceCorrelatedTimes },
        { Py_tp_dealloc, _dealloc_AdaptiveMediaSourceCorrelatedTimes },
        { Py_tp_methods, _methods_AdaptiveMediaSourceCorrelatedTimes },
        { Py_tp_getset, _getset_AdaptiveMediaSourceCorrelatedTimes },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AdaptiveMediaSourceCorrelatedTimes =
    {
        "_winrt_Windows_Media_Streaming_Adaptive.AdaptiveMediaSourceCorrelatedTimes",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCorrelatedTimes),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceCorrelatedTimes
    };

    // ----- AdaptiveMediaSourceCreationResult class --------------------
    constexpr const char* const _type_name_AdaptiveMediaSourceCreationResult = "AdaptiveMediaSourceCreationResult";

    static PyObject* _new_AdaptiveMediaSourceCreationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AdaptiveMediaSourceCreationResult);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceCreationResult(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCreationResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdaptiveMediaSourceCreationResult_get_HttpResponseMessage(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCreationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HttpResponseMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceCreationResult_get_MediaSource(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCreationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceCreationResult_get_Status(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCreationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceCreationResult_get_ExtendedError(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCreationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AdaptiveMediaSourceCreationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCreationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceCreationResult[] = {
        { "_from", (PyCFunction)_from_AdaptiveMediaSourceCreationResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceCreationResult[] = {
        { const_cast<char*>("http_response_message"), (getter)AdaptiveMediaSourceCreationResult_get_HttpResponseMessage, nullptr, nullptr, nullptr },
        { const_cast<char*>("media_source"), (getter)AdaptiveMediaSourceCreationResult_get_MediaSource, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)AdaptiveMediaSourceCreationResult_get_Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_error"), (getter)AdaptiveMediaSourceCreationResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceCreationResult[] = 
    {
        { Py_tp_new, _new_AdaptiveMediaSourceCreationResult },
        { Py_tp_dealloc, _dealloc_AdaptiveMediaSourceCreationResult },
        { Py_tp_methods, _methods_AdaptiveMediaSourceCreationResult },
        { Py_tp_getset, _getset_AdaptiveMediaSourceCreationResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AdaptiveMediaSourceCreationResult =
    {
        "_winrt_Windows_Media_Streaming_Adaptive.AdaptiveMediaSourceCreationResult",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCreationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceCreationResult
    };

    // ----- AdaptiveMediaSourceDiagnosticAvailableEventArgs class --------------------
    constexpr const char* const _type_name_AdaptiveMediaSourceDiagnosticAvailableEventArgs = "AdaptiveMediaSourceDiagnosticAvailableEventArgs";

    static PyObject* _new_AdaptiveMediaSourceDiagnosticAvailableEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AdaptiveMediaSourceDiagnosticAvailableEventArgs);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceDiagnosticAvailableEventArgs(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_Bitrate(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_DiagnosticType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DiagnosticType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_Position(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_RequestId(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceByteRangeLength(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceByteRangeLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceByteRangeOffset(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceByteRangeOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceUri(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_SegmentId(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SegmentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ExtendedError(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceContentType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceDuration(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AdaptiveMediaSourceDiagnosticAvailableEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceDiagnosticAvailableEventArgs[] = {
        { "_from", (PyCFunction)_from_AdaptiveMediaSourceDiagnosticAvailableEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceDiagnosticAvailableEventArgs[] = {
        { const_cast<char*>("bitrate"), (getter)AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_Bitrate, nullptr, nullptr, nullptr },
        { const_cast<char*>("diagnostic_type"), (getter)AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_DiagnosticType, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_Position, nullptr, nullptr, nullptr },
        { const_cast<char*>("request_id"), (getter)AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_RequestId, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_byte_range_length"), (getter)AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceByteRangeLength, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_byte_range_offset"), (getter)AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceByteRangeOffset, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_type"), (getter)AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceType, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_uri"), (getter)AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceUri, nullptr, nullptr, nullptr },
        { const_cast<char*>("segment_id"), (getter)AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_SegmentId, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_error"), (getter)AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_content_type"), (getter)AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceContentType, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_duration"), (getter)AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceDuration, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceDiagnosticAvailableEventArgs[] = 
    {
        { Py_tp_new, _new_AdaptiveMediaSourceDiagnosticAvailableEventArgs },
        { Py_tp_dealloc, _dealloc_AdaptiveMediaSourceDiagnosticAvailableEventArgs },
        { Py_tp_methods, _methods_AdaptiveMediaSourceDiagnosticAvailableEventArgs },
        { Py_tp_getset, _getset_AdaptiveMediaSourceDiagnosticAvailableEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AdaptiveMediaSourceDiagnosticAvailableEventArgs =
    {
        "_winrt_Windows_Media_Streaming_Adaptive.AdaptiveMediaSourceDiagnosticAvailableEventArgs",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceDiagnosticAvailableEventArgs
    };

    // ----- AdaptiveMediaSourceDiagnostics class --------------------
    constexpr const char* const _type_name_AdaptiveMediaSourceDiagnostics = "AdaptiveMediaSourceDiagnostics";

    static PyObject* _new_AdaptiveMediaSourceDiagnostics(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AdaptiveMediaSourceDiagnostics);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceDiagnostics(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnostics* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdaptiveMediaSourceDiagnostics_add_DiagnosticAvailable(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnostics* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnostics, winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs>>(arg);

            return py::convert(self->obj.DiagnosticAvailable(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnostics_remove_DiagnosticAvailable(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnostics* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DiagnosticAvailable(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AdaptiveMediaSourceDiagnostics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnostics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceDiagnostics[] = {
        { "add_diagnostic_available", (PyCFunction)AdaptiveMediaSourceDiagnostics_add_DiagnosticAvailable, METH_O, nullptr },
        { "remove_diagnostic_available", (PyCFunction)AdaptiveMediaSourceDiagnostics_remove_DiagnosticAvailable, METH_O, nullptr },
        { "_from", (PyCFunction)_from_AdaptiveMediaSourceDiagnostics, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceDiagnostics[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceDiagnostics[] = 
    {
        { Py_tp_new, _new_AdaptiveMediaSourceDiagnostics },
        { Py_tp_dealloc, _dealloc_AdaptiveMediaSourceDiagnostics },
        { Py_tp_methods, _methods_AdaptiveMediaSourceDiagnostics },
        { Py_tp_getset, _getset_AdaptiveMediaSourceDiagnostics },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AdaptiveMediaSourceDiagnostics =
    {
        "_winrt_Windows_Media_Streaming_Adaptive.AdaptiveMediaSourceDiagnostics",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnostics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceDiagnostics
    };

    // ----- AdaptiveMediaSourceDownloadBitrateChangedEventArgs class --------------------
    constexpr const char* const _type_name_AdaptiveMediaSourceDownloadBitrateChangedEventArgs = "AdaptiveMediaSourceDownloadBitrateChangedEventArgs";

    static PyObject* _new_AdaptiveMediaSourceDownloadBitrateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AdaptiveMediaSourceDownloadBitrateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceDownloadBitrateChangedEventArgs(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadBitrateChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdaptiveMediaSourceDownloadBitrateChangedEventArgs_get_NewValue(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadBitrateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NewValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadBitrateChangedEventArgs_get_OldValue(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadBitrateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OldValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadBitrateChangedEventArgs_get_Reason(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadBitrateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AdaptiveMediaSourceDownloadBitrateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadBitrateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceDownloadBitrateChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_AdaptiveMediaSourceDownloadBitrateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceDownloadBitrateChangedEventArgs[] = {
        { const_cast<char*>("new_value"), (getter)AdaptiveMediaSourceDownloadBitrateChangedEventArgs_get_NewValue, nullptr, nullptr, nullptr },
        { const_cast<char*>("old_value"), (getter)AdaptiveMediaSourceDownloadBitrateChangedEventArgs_get_OldValue, nullptr, nullptr, nullptr },
        { const_cast<char*>("reason"), (getter)AdaptiveMediaSourceDownloadBitrateChangedEventArgs_get_Reason, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceDownloadBitrateChangedEventArgs[] = 
    {
        { Py_tp_new, _new_AdaptiveMediaSourceDownloadBitrateChangedEventArgs },
        { Py_tp_dealloc, _dealloc_AdaptiveMediaSourceDownloadBitrateChangedEventArgs },
        { Py_tp_methods, _methods_AdaptiveMediaSourceDownloadBitrateChangedEventArgs },
        { Py_tp_getset, _getset_AdaptiveMediaSourceDownloadBitrateChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AdaptiveMediaSourceDownloadBitrateChangedEventArgs =
    {
        "_winrt_Windows_Media_Streaming_Adaptive.AdaptiveMediaSourceDownloadBitrateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadBitrateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceDownloadBitrateChangedEventArgs
    };

    // ----- AdaptiveMediaSourceDownloadCompletedEventArgs class --------------------
    constexpr const char* const _type_name_AdaptiveMediaSourceDownloadCompletedEventArgs = "AdaptiveMediaSourceDownloadCompletedEventArgs";

    static PyObject* _new_AdaptiveMediaSourceDownloadCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AdaptiveMediaSourceDownloadCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceDownloadCompletedEventArgs(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdaptiveMediaSourceDownloadCompletedEventArgs_get_HttpResponseMessage(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HttpResponseMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceByteRangeLength(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceByteRangeLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceByteRangeOffset(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceByteRangeOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceUri(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadCompletedEventArgs_get_Position(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadCompletedEventArgs_get_RequestId(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadCompletedEventArgs_get_Statistics(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Statistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceContentType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceDuration(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AdaptiveMediaSourceDownloadCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceDownloadCompletedEventArgs[] = {
        { "_from", (PyCFunction)_from_AdaptiveMediaSourceDownloadCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceDownloadCompletedEventArgs[] = {
        { const_cast<char*>("http_response_message"), (getter)AdaptiveMediaSourceDownloadCompletedEventArgs_get_HttpResponseMessage, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_byte_range_length"), (getter)AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceByteRangeLength, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_byte_range_offset"), (getter)AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceByteRangeOffset, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_type"), (getter)AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceType, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_uri"), (getter)AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceUri, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)AdaptiveMediaSourceDownloadCompletedEventArgs_get_Position, nullptr, nullptr, nullptr },
        { const_cast<char*>("request_id"), (getter)AdaptiveMediaSourceDownloadCompletedEventArgs_get_RequestId, nullptr, nullptr, nullptr },
        { const_cast<char*>("statistics"), (getter)AdaptiveMediaSourceDownloadCompletedEventArgs_get_Statistics, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_content_type"), (getter)AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceContentType, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_duration"), (getter)AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceDuration, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceDownloadCompletedEventArgs[] = 
    {
        { Py_tp_new, _new_AdaptiveMediaSourceDownloadCompletedEventArgs },
        { Py_tp_dealloc, _dealloc_AdaptiveMediaSourceDownloadCompletedEventArgs },
        { Py_tp_methods, _methods_AdaptiveMediaSourceDownloadCompletedEventArgs },
        { Py_tp_getset, _getset_AdaptiveMediaSourceDownloadCompletedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AdaptiveMediaSourceDownloadCompletedEventArgs =
    {
        "_winrt_Windows_Media_Streaming_Adaptive.AdaptiveMediaSourceDownloadCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceDownloadCompletedEventArgs
    };

    // ----- AdaptiveMediaSourceDownloadFailedEventArgs class --------------------
    constexpr const char* const _type_name_AdaptiveMediaSourceDownloadFailedEventArgs = "AdaptiveMediaSourceDownloadFailedEventArgs";

    static PyObject* _new_AdaptiveMediaSourceDownloadFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AdaptiveMediaSourceDownloadFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceDownloadFailedEventArgs(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_HttpResponseMessage(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HttpResponseMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceByteRangeLength(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceByteRangeLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceByteRangeOffset(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceByteRangeOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceUri(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_ExtendedError(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_Position(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_RequestId(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_Statistics(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Statistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceContentType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceDuration(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AdaptiveMediaSourceDownloadFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceDownloadFailedEventArgs[] = {
        { "_from", (PyCFunction)_from_AdaptiveMediaSourceDownloadFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceDownloadFailedEventArgs[] = {
        { const_cast<char*>("http_response_message"), (getter)AdaptiveMediaSourceDownloadFailedEventArgs_get_HttpResponseMessage, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_byte_range_length"), (getter)AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceByteRangeLength, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_byte_range_offset"), (getter)AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceByteRangeOffset, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_type"), (getter)AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceType, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_uri"), (getter)AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceUri, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_error"), (getter)AdaptiveMediaSourceDownloadFailedEventArgs_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)AdaptiveMediaSourceDownloadFailedEventArgs_get_Position, nullptr, nullptr, nullptr },
        { const_cast<char*>("request_id"), (getter)AdaptiveMediaSourceDownloadFailedEventArgs_get_RequestId, nullptr, nullptr, nullptr },
        { const_cast<char*>("statistics"), (getter)AdaptiveMediaSourceDownloadFailedEventArgs_get_Statistics, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_content_type"), (getter)AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceContentType, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_duration"), (getter)AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceDuration, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceDownloadFailedEventArgs[] = 
    {
        { Py_tp_new, _new_AdaptiveMediaSourceDownloadFailedEventArgs },
        { Py_tp_dealloc, _dealloc_AdaptiveMediaSourceDownloadFailedEventArgs },
        { Py_tp_methods, _methods_AdaptiveMediaSourceDownloadFailedEventArgs },
        { Py_tp_getset, _getset_AdaptiveMediaSourceDownloadFailedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AdaptiveMediaSourceDownloadFailedEventArgs =
    {
        "_winrt_Windows_Media_Streaming_Adaptive.AdaptiveMediaSourceDownloadFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceDownloadFailedEventArgs
    };

    // ----- AdaptiveMediaSourceDownloadRequestedDeferral class --------------------
    constexpr const char* const _type_name_AdaptiveMediaSourceDownloadRequestedDeferral = "AdaptiveMediaSourceDownloadRequestedDeferral";

    static PyObject* _new_AdaptiveMediaSourceDownloadRequestedDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AdaptiveMediaSourceDownloadRequestedDeferral);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceDownloadRequestedDeferral(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedDeferral_Complete(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_AdaptiveMediaSourceDownloadRequestedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceDownloadRequestedDeferral[] = {
        { "complete", (PyCFunction)AdaptiveMediaSourceDownloadRequestedDeferral_Complete, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AdaptiveMediaSourceDownloadRequestedDeferral, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceDownloadRequestedDeferral[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceDownloadRequestedDeferral[] = 
    {
        { Py_tp_new, _new_AdaptiveMediaSourceDownloadRequestedDeferral },
        { Py_tp_dealloc, _dealloc_AdaptiveMediaSourceDownloadRequestedDeferral },
        { Py_tp_methods, _methods_AdaptiveMediaSourceDownloadRequestedDeferral },
        { Py_tp_getset, _getset_AdaptiveMediaSourceDownloadRequestedDeferral },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AdaptiveMediaSourceDownloadRequestedDeferral =
    {
        "_winrt_Windows_Media_Streaming_Adaptive.AdaptiveMediaSourceDownloadRequestedDeferral",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceDownloadRequestedDeferral
    };

    // ----- AdaptiveMediaSourceDownloadRequestedEventArgs class --------------------
    constexpr const char* const _type_name_AdaptiveMediaSourceDownloadRequestedEventArgs = "AdaptiveMediaSourceDownloadRequestedEventArgs";

    static PyObject* _new_AdaptiveMediaSourceDownloadRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AdaptiveMediaSourceDownloadRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceDownloadRequestedEventArgs(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedEventArgs_GetDeferral(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceByteRangeLength(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceByteRangeLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceByteRangeOffset(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceByteRangeOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceUri(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedEventArgs_get_Result(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedEventArgs_get_Position(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedEventArgs_get_RequestId(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceContentType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceDuration(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AdaptiveMediaSourceDownloadRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceDownloadRequestedEventArgs[] = {
        { "get_deferral", (PyCFunction)AdaptiveMediaSourceDownloadRequestedEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AdaptiveMediaSourceDownloadRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceDownloadRequestedEventArgs[] = {
        { const_cast<char*>("resource_byte_range_length"), (getter)AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceByteRangeLength, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_byte_range_offset"), (getter)AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceByteRangeOffset, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_type"), (getter)AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceType, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_uri"), (getter)AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceUri, nullptr, nullptr, nullptr },
        { const_cast<char*>("result"), (getter)AdaptiveMediaSourceDownloadRequestedEventArgs_get_Result, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)AdaptiveMediaSourceDownloadRequestedEventArgs_get_Position, nullptr, nullptr, nullptr },
        { const_cast<char*>("request_id"), (getter)AdaptiveMediaSourceDownloadRequestedEventArgs_get_RequestId, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_content_type"), (getter)AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceContentType, nullptr, nullptr, nullptr },
        { const_cast<char*>("resource_duration"), (getter)AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceDuration, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceDownloadRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_AdaptiveMediaSourceDownloadRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_AdaptiveMediaSourceDownloadRequestedEventArgs },
        { Py_tp_methods, _methods_AdaptiveMediaSourceDownloadRequestedEventArgs },
        { Py_tp_getset, _getset_AdaptiveMediaSourceDownloadRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AdaptiveMediaSourceDownloadRequestedEventArgs =
    {
        "_winrt_Windows_Media_Streaming_Adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceDownloadRequestedEventArgs
    };

    // ----- AdaptiveMediaSourceDownloadResult class --------------------
    constexpr const char* const _type_name_AdaptiveMediaSourceDownloadResult = "AdaptiveMediaSourceDownloadResult";

    static PyObject* _new_AdaptiveMediaSourceDownloadResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AdaptiveMediaSourceDownloadResult);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceDownloadResult(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdaptiveMediaSourceDownloadResult_get_ResourceUri(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSourceDownloadResult_put_ResourceUri(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ResourceUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadResult_get_InputStream(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSourceDownloadResult_put_InputStream(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(arg);

            self->obj.InputStream(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadResult_get_ExtendedStatus(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSourceDownloadResult_put_ExtendedStatus(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ExtendedStatus(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadResult_get_ContentType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSourceDownloadResult_put_ContentType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContentType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadResult_get_Buffer(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buffer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSourceDownloadResult_put_Buffer(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.Buffer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadResult_get_ResourceByteRangeOffset(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceByteRangeOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSourceDownloadResult_put_ResourceByteRangeOffset(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint64_t>>(arg);

            self->obj.ResourceByteRangeOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadResult_get_ResourceByteRangeLength(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceByteRangeLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSourceDownloadResult_put_ResourceByteRangeLength(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint64_t>>(arg);

            self->obj.ResourceByteRangeLength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AdaptiveMediaSourceDownloadResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceDownloadResult[] = {
        { "_from", (PyCFunction)_from_AdaptiveMediaSourceDownloadResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceDownloadResult[] = {
        { const_cast<char*>("resource_uri"), (getter)AdaptiveMediaSourceDownloadResult_get_ResourceUri, (setter)AdaptiveMediaSourceDownloadResult_put_ResourceUri, nullptr, nullptr },
        { const_cast<char*>("input_stream"), (getter)AdaptiveMediaSourceDownloadResult_get_InputStream, (setter)AdaptiveMediaSourceDownloadResult_put_InputStream, nullptr, nullptr },
        { const_cast<char*>("extended_status"), (getter)AdaptiveMediaSourceDownloadResult_get_ExtendedStatus, (setter)AdaptiveMediaSourceDownloadResult_put_ExtendedStatus, nullptr, nullptr },
        { const_cast<char*>("content_type"), (getter)AdaptiveMediaSourceDownloadResult_get_ContentType, (setter)AdaptiveMediaSourceDownloadResult_put_ContentType, nullptr, nullptr },
        { const_cast<char*>("buffer"), (getter)AdaptiveMediaSourceDownloadResult_get_Buffer, (setter)AdaptiveMediaSourceDownloadResult_put_Buffer, nullptr, nullptr },
        { const_cast<char*>("resource_byte_range_offset"), (getter)AdaptiveMediaSourceDownloadResult_get_ResourceByteRangeOffset, (setter)AdaptiveMediaSourceDownloadResult_put_ResourceByteRangeOffset, nullptr, nullptr },
        { const_cast<char*>("resource_byte_range_length"), (getter)AdaptiveMediaSourceDownloadResult_get_ResourceByteRangeLength, (setter)AdaptiveMediaSourceDownloadResult_put_ResourceByteRangeLength, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceDownloadResult[] = 
    {
        { Py_tp_new, _new_AdaptiveMediaSourceDownloadResult },
        { Py_tp_dealloc, _dealloc_AdaptiveMediaSourceDownloadResult },
        { Py_tp_methods, _methods_AdaptiveMediaSourceDownloadResult },
        { Py_tp_getset, _getset_AdaptiveMediaSourceDownloadResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AdaptiveMediaSourceDownloadResult =
    {
        "_winrt_Windows_Media_Streaming_Adaptive.AdaptiveMediaSourceDownloadResult",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceDownloadResult
    };

    // ----- AdaptiveMediaSourceDownloadStatistics class --------------------
    constexpr const char* const _type_name_AdaptiveMediaSourceDownloadStatistics = "AdaptiveMediaSourceDownloadStatistics";

    static PyObject* _new_AdaptiveMediaSourceDownloadStatistics(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AdaptiveMediaSourceDownloadStatistics);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceDownloadStatistics(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadStatistics* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdaptiveMediaSourceDownloadStatistics_get_ContentBytesReceivedCount(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentBytesReceivedCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadStatistics_get_TimeToFirstByteReceived(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimeToFirstByteReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadStatistics_get_TimeToHeadersReceived(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimeToHeadersReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadStatistics_get_TimeToLastByteReceived(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimeToLastByteReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AdaptiveMediaSourceDownloadStatistics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadStatistics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceDownloadStatistics[] = {
        { "_from", (PyCFunction)_from_AdaptiveMediaSourceDownloadStatistics, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceDownloadStatistics[] = {
        { const_cast<char*>("content_bytes_received_count"), (getter)AdaptiveMediaSourceDownloadStatistics_get_ContentBytesReceivedCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("time_to_first_byte_received"), (getter)AdaptiveMediaSourceDownloadStatistics_get_TimeToFirstByteReceived, nullptr, nullptr, nullptr },
        { const_cast<char*>("time_to_headers_received"), (getter)AdaptiveMediaSourceDownloadStatistics_get_TimeToHeadersReceived, nullptr, nullptr, nullptr },
        { const_cast<char*>("time_to_last_byte_received"), (getter)AdaptiveMediaSourceDownloadStatistics_get_TimeToLastByteReceived, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceDownloadStatistics[] = 
    {
        { Py_tp_new, _new_AdaptiveMediaSourceDownloadStatistics },
        { Py_tp_dealloc, _dealloc_AdaptiveMediaSourceDownloadStatistics },
        { Py_tp_methods, _methods_AdaptiveMediaSourceDownloadStatistics },
        { Py_tp_getset, _getset_AdaptiveMediaSourceDownloadStatistics },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AdaptiveMediaSourceDownloadStatistics =
    {
        "_winrt_Windows_Media_Streaming_Adaptive.AdaptiveMediaSourceDownloadStatistics",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadStatistics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceDownloadStatistics
    };

    // ----- AdaptiveMediaSourcePlaybackBitrateChangedEventArgs class --------------------
    constexpr const char* const _type_name_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs = "AdaptiveMediaSourcePlaybackBitrateChangedEventArgs";

    static PyObject* _new_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourcePlaybackBitrateChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdaptiveMediaSourcePlaybackBitrateChangedEventArgs_get_AudioOnly(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourcePlaybackBitrateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourcePlaybackBitrateChangedEventArgs_get_NewValue(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourcePlaybackBitrateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NewValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourcePlaybackBitrateChangedEventArgs_get_OldValue(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourcePlaybackBitrateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OldValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourcePlaybackBitrateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs[] = {
        { const_cast<char*>("audio_only"), (getter)AdaptiveMediaSourcePlaybackBitrateChangedEventArgs_get_AudioOnly, nullptr, nullptr, nullptr },
        { const_cast<char*>("new_value"), (getter)AdaptiveMediaSourcePlaybackBitrateChangedEventArgs_get_NewValue, nullptr, nullptr, nullptr },
        { const_cast<char*>("old_value"), (getter)AdaptiveMediaSourcePlaybackBitrateChangedEventArgs_get_OldValue, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs[] = 
    {
        { Py_tp_new, _new_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs },
        { Py_tp_dealloc, _dealloc_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs },
        { Py_tp_methods, _methods_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs },
        { Py_tp_getset, _getset_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs =
    {
        "_winrt_Windows_Media_Streaming_Adaptive.AdaptiveMediaSourcePlaybackBitrateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourcePlaybackBitrateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs
    };

    // ----- Windows.Media.Streaming.Adaptive Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource>::python_type = py::register_python_type(module, _type_name_AdaptiveMediaSource, &_type_spec_AdaptiveMediaSource, bases.get());
            py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings>::python_type = py::register_python_type(module, _type_name_AdaptiveMediaSourceAdvancedSettings, &_type_spec_AdaptiveMediaSourceAdvancedSettings, bases.get());
            py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCorrelatedTimes>::python_type = py::register_python_type(module, _type_name_AdaptiveMediaSourceCorrelatedTimes, &_type_spec_AdaptiveMediaSourceCorrelatedTimes, bases.get());
            py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCreationResult>::python_type = py::register_python_type(module, _type_name_AdaptiveMediaSourceCreationResult, &_type_spec_AdaptiveMediaSourceCreationResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs>::python_type = py::register_python_type(module, _type_name_AdaptiveMediaSourceDiagnosticAvailableEventArgs, &_type_spec_AdaptiveMediaSourceDiagnosticAvailableEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnostics>::python_type = py::register_python_type(module, _type_name_AdaptiveMediaSourceDiagnostics, &_type_spec_AdaptiveMediaSourceDiagnostics, bases.get());
            py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadBitrateChangedEventArgs>::python_type = py::register_python_type(module, _type_name_AdaptiveMediaSourceDownloadBitrateChangedEventArgs, &_type_spec_AdaptiveMediaSourceDownloadBitrateChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs>::python_type = py::register_python_type(module, _type_name_AdaptiveMediaSourceDownloadCompletedEventArgs, &_type_spec_AdaptiveMediaSourceDownloadCompletedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs>::python_type = py::register_python_type(module, _type_name_AdaptiveMediaSourceDownloadFailedEventArgs, &_type_spec_AdaptiveMediaSourceDownloadFailedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedDeferral>::python_type = py::register_python_type(module, _type_name_AdaptiveMediaSourceDownloadRequestedDeferral, &_type_spec_AdaptiveMediaSourceDownloadRequestedDeferral, bases.get());
            py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_AdaptiveMediaSourceDownloadRequestedEventArgs, &_type_spec_AdaptiveMediaSourceDownloadRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult>::python_type = py::register_python_type(module, _type_name_AdaptiveMediaSourceDownloadResult, &_type_spec_AdaptiveMediaSourceDownloadResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadStatistics>::python_type = py::register_python_type(module, _type_name_AdaptiveMediaSourceDownloadStatistics, &_type_spec_AdaptiveMediaSourceDownloadStatistics, bases.get());
            py::winrt_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourcePlaybackBitrateChangedEventArgs>::python_type = py::register_python_type(module, _type_name_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs, &_type_spec_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Media.Streaming.Adaptive");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Media_Streaming_Adaptive",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Media::Streaming::Adaptive

PyMODINIT_FUNC
PyInit__winrt_Windows_Media_Streaming_Adaptive (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Media::Streaming::Adaptive::module_def);
}
