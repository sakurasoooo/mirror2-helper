// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Media.Audio.h"

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioDeviceInputNode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioDeviceOutputNode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioFileInputNode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioFileOutputNode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioFrameInputNode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioFrameOutputNode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioGraph>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioGraphBatchUpdater>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioGraphConnection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioGraphSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitterConeProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitterShape>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioNodeListener>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioPlaybackConnection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioPlaybackConnectionOpenResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioStateMonitor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioSubmixNode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::CreateAudioDeviceInputNodeResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::CreateAudioFileInputNodeResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::CreateAudioFileOutputNodeResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::CreateAudioGraphResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::EchoEffectDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::EqualizerBand>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::EqualizerEffectDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::LimiterEffectDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::MediaSourceAudioInputNode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::ReverbEffectDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::SpatialAudioFormatSubtype>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::IAudioInputNode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::IAudioInputNode2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::IAudioNode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::IAudioNodeWithListener>::python_type;

namespace py::cpp::Windows::Media::Audio
{
    // ----- AudioDeviceInputNode class --------------------
    constexpr const char* const _type_name_AudioDeviceInputNode = "AudioDeviceInputNode";

    static PyObject* _new_AudioDeviceInputNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioDeviceInputNode);
        return nullptr;
    }

    static void _dealloc_AudioDeviceInputNode(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioDeviceInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_Close(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_Reset(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_Start(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_Stop(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_Device(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_Emitter(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioDeviceInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioDeviceInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioDeviceInputNode(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_AudioDeviceInputNode(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceInputNode[] = {
        { "add_outgoing_connection", (PyCFunction)AudioDeviceInputNode_AddOutgoingConnection, METH_VARARGS, nullptr },
        { "close", (PyCFunction)AudioDeviceInputNode_Close, METH_VARARGS, nullptr },
        { "disable_effects_by_definition", (PyCFunction)AudioDeviceInputNode_DisableEffectsByDefinition, METH_VARARGS, nullptr },
        { "enable_effects_by_definition", (PyCFunction)AudioDeviceInputNode_EnableEffectsByDefinition, METH_VARARGS, nullptr },
        { "remove_outgoing_connection", (PyCFunction)AudioDeviceInputNode_RemoveOutgoingConnection, METH_VARARGS, nullptr },
        { "reset", (PyCFunction)AudioDeviceInputNode_Reset, METH_VARARGS, nullptr },
        { "start", (PyCFunction)AudioDeviceInputNode_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)AudioDeviceInputNode_Stop, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AudioDeviceInputNode, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_AudioDeviceInputNode, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_AudioDeviceInputNode, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioDeviceInputNode[] = {
        { const_cast<char*>("device"), (getter)AudioDeviceInputNode_get_Device, nullptr, nullptr, nullptr },
        { const_cast<char*>("outgoing_connections"), (getter)AudioDeviceInputNode_get_OutgoingConnections, nullptr, nullptr, nullptr },
        { const_cast<char*>("emitter"), (getter)AudioDeviceInputNode_get_Emitter, nullptr, nullptr, nullptr },
        { const_cast<char*>("outgoing_gain"), (getter)AudioDeviceInputNode_get_OutgoingGain, (setter)AudioDeviceInputNode_put_OutgoingGain, nullptr, nullptr },
        { const_cast<char*>("consume_input"), (getter)AudioDeviceInputNode_get_ConsumeInput, (setter)AudioDeviceInputNode_put_ConsumeInput, nullptr, nullptr },
        { const_cast<char*>("effect_definitions"), (getter)AudioDeviceInputNode_get_EffectDefinitions, nullptr, nullptr, nullptr },
        { const_cast<char*>("encoding_properties"), (getter)AudioDeviceInputNode_get_EncodingProperties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioDeviceInputNode[] = 
    {
        { Py_tp_new, _new_AudioDeviceInputNode },
        { Py_tp_dealloc, _dealloc_AudioDeviceInputNode },
        { Py_tp_methods, _methods_AudioDeviceInputNode },
        { Py_tp_getset, _getset_AudioDeviceInputNode },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioDeviceInputNode =
    {
        "_winrt_Windows_Media_Audio.AudioDeviceInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceInputNode
    };

    // ----- AudioDeviceOutputNode class --------------------
    constexpr const char* const _type_name_AudioDeviceOutputNode = "AudioDeviceOutputNode";

    static PyObject* _new_AudioDeviceOutputNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioDeviceOutputNode);
        return nullptr;
    }

    static void _dealloc_AudioDeviceOutputNode(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioDeviceOutputNode_Close(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_Reset(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_Start(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_Stop(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_Device(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceOutputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceOutputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_Listener(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Listener());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceOutputNode_put_Listener(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeListener>(arg);

            self->obj.Listener(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AudioDeviceOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioDeviceOutputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioDeviceOutputNode(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_AudioDeviceOutputNode(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceOutputNode[] = {
        { "close", (PyCFunction)AudioDeviceOutputNode_Close, METH_VARARGS, nullptr },
        { "disable_effects_by_definition", (PyCFunction)AudioDeviceOutputNode_DisableEffectsByDefinition, METH_VARARGS, nullptr },
        { "enable_effects_by_definition", (PyCFunction)AudioDeviceOutputNode_EnableEffectsByDefinition, METH_VARARGS, nullptr },
        { "reset", (PyCFunction)AudioDeviceOutputNode_Reset, METH_VARARGS, nullptr },
        { "start", (PyCFunction)AudioDeviceOutputNode_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)AudioDeviceOutputNode_Stop, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AudioDeviceOutputNode, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_AudioDeviceOutputNode, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_AudioDeviceOutputNode, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioDeviceOutputNode[] = {
        { const_cast<char*>("device"), (getter)AudioDeviceOutputNode_get_Device, nullptr, nullptr, nullptr },
        { const_cast<char*>("outgoing_gain"), (getter)AudioDeviceOutputNode_get_OutgoingGain, (setter)AudioDeviceOutputNode_put_OutgoingGain, nullptr, nullptr },
        { const_cast<char*>("consume_input"), (getter)AudioDeviceOutputNode_get_ConsumeInput, (setter)AudioDeviceOutputNode_put_ConsumeInput, nullptr, nullptr },
        { const_cast<char*>("effect_definitions"), (getter)AudioDeviceOutputNode_get_EffectDefinitions, nullptr, nullptr, nullptr },
        { const_cast<char*>("encoding_properties"), (getter)AudioDeviceOutputNode_get_EncodingProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("listener"), (getter)AudioDeviceOutputNode_get_Listener, (setter)AudioDeviceOutputNode_put_Listener, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioDeviceOutputNode[] = 
    {
        { Py_tp_new, _new_AudioDeviceOutputNode },
        { Py_tp_dealloc, _dealloc_AudioDeviceOutputNode },
        { Py_tp_methods, _methods_AudioDeviceOutputNode },
        { Py_tp_getset, _getset_AudioDeviceOutputNode },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioDeviceOutputNode =
    {
        "_winrt_Windows_Media_Audio.AudioDeviceOutputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceOutputNode
    };

    // ----- AudioFileInputNode class --------------------
    constexpr const char* const _type_name_AudioFileInputNode = "AudioFileInputNode";

    static PyObject* _new_AudioFileInputNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioFileInputNode);
        return nullptr;
    }

    static void _dealloc_AudioFileInputNode(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioFileInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Close(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Reset(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Seek(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Start(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Stop(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackSpeedFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.PlaybackSpeedFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_LoopCount(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LoopCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_LoopCount(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.LoopCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_EndTime(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_EndTime(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.EndTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_StartTime(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_StartTime(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_Position(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_SourceFile(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceFile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_Duration(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_Emitter(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_add_FileCompleted(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioFileInputNode, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.FileCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_remove_FileCompleted(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FileCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioFileInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFileInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFileInputNode(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_AudioFileInputNode(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFileInputNode[] = {
        { "add_outgoing_connection", (PyCFunction)AudioFileInputNode_AddOutgoingConnection, METH_VARARGS, nullptr },
        { "close", (PyCFunction)AudioFileInputNode_Close, METH_VARARGS, nullptr },
        { "disable_effects_by_definition", (PyCFunction)AudioFileInputNode_DisableEffectsByDefinition, METH_VARARGS, nullptr },
        { "enable_effects_by_definition", (PyCFunction)AudioFileInputNode_EnableEffectsByDefinition, METH_VARARGS, nullptr },
        { "remove_outgoing_connection", (PyCFunction)AudioFileInputNode_RemoveOutgoingConnection, METH_VARARGS, nullptr },
        { "reset", (PyCFunction)AudioFileInputNode_Reset, METH_VARARGS, nullptr },
        { "seek", (PyCFunction)AudioFileInputNode_Seek, METH_VARARGS, nullptr },
        { "start", (PyCFunction)AudioFileInputNode_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)AudioFileInputNode_Stop, METH_VARARGS, nullptr },
        { "add_file_completed", (PyCFunction)AudioFileInputNode_add_FileCompleted, METH_O, nullptr },
        { "remove_file_completed", (PyCFunction)AudioFileInputNode_remove_FileCompleted, METH_O, nullptr },
        { "_from", (PyCFunction)_from_AudioFileInputNode, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_AudioFileInputNode, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_AudioFileInputNode, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioFileInputNode[] = {
        { const_cast<char*>("playback_speed_factor"), (getter)AudioFileInputNode_get_PlaybackSpeedFactor, (setter)AudioFileInputNode_put_PlaybackSpeedFactor, nullptr, nullptr },
        { const_cast<char*>("loop_count"), (getter)AudioFileInputNode_get_LoopCount, (setter)AudioFileInputNode_put_LoopCount, nullptr, nullptr },
        { const_cast<char*>("end_time"), (getter)AudioFileInputNode_get_EndTime, (setter)AudioFileInputNode_put_EndTime, nullptr, nullptr },
        { const_cast<char*>("start_time"), (getter)AudioFileInputNode_get_StartTime, (setter)AudioFileInputNode_put_StartTime, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)AudioFileInputNode_get_Position, nullptr, nullptr, nullptr },
        { const_cast<char*>("source_file"), (getter)AudioFileInputNode_get_SourceFile, nullptr, nullptr, nullptr },
        { const_cast<char*>("duration"), (getter)AudioFileInputNode_get_Duration, nullptr, nullptr, nullptr },
        { const_cast<char*>("outgoing_connections"), (getter)AudioFileInputNode_get_OutgoingConnections, nullptr, nullptr, nullptr },
        { const_cast<char*>("emitter"), (getter)AudioFileInputNode_get_Emitter, nullptr, nullptr, nullptr },
        { const_cast<char*>("outgoing_gain"), (getter)AudioFileInputNode_get_OutgoingGain, (setter)AudioFileInputNode_put_OutgoingGain, nullptr, nullptr },
        { const_cast<char*>("consume_input"), (getter)AudioFileInputNode_get_ConsumeInput, (setter)AudioFileInputNode_put_ConsumeInput, nullptr, nullptr },
        { const_cast<char*>("effect_definitions"), (getter)AudioFileInputNode_get_EffectDefinitions, nullptr, nullptr, nullptr },
        { const_cast<char*>("encoding_properties"), (getter)AudioFileInputNode_get_EncodingProperties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioFileInputNode[] = 
    {
        { Py_tp_new, _new_AudioFileInputNode },
        { Py_tp_dealloc, _dealloc_AudioFileInputNode },
        { Py_tp_methods, _methods_AudioFileInputNode },
        { Py_tp_getset, _getset_AudioFileInputNode },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioFileInputNode =
    {
        "_winrt_Windows_Media_Audio.AudioFileInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFileInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFileInputNode
    };

    // ----- AudioFileOutputNode class --------------------
    constexpr const char* const _type_name_AudioFileOutputNode = "AudioFileOutputNode";

    static PyObject* _new_AudioFileOutputNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioFileOutputNode);
        return nullptr;
    }

    static void _dealloc_AudioFileOutputNode(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioFileOutputNode_Close(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_FinalizeAsync(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FinalizeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_Reset(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_Start(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_Stop(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_get_File(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_get_FileEncodingProfile(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileEncodingProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileOutputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileOutputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileOutputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileOutputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioFileOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFileOutputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFileOutputNode(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_AudioFileOutputNode(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFileOutputNode[] = {
        { "close", (PyCFunction)AudioFileOutputNode_Close, METH_VARARGS, nullptr },
        { "disable_effects_by_definition", (PyCFunction)AudioFileOutputNode_DisableEffectsByDefinition, METH_VARARGS, nullptr },
        { "enable_effects_by_definition", (PyCFunction)AudioFileOutputNode_EnableEffectsByDefinition, METH_VARARGS, nullptr },
        { "finalize_async", (PyCFunction)AudioFileOutputNode_FinalizeAsync, METH_VARARGS, nullptr },
        { "reset", (PyCFunction)AudioFileOutputNode_Reset, METH_VARARGS, nullptr },
        { "start", (PyCFunction)AudioFileOutputNode_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)AudioFileOutputNode_Stop, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AudioFileOutputNode, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_AudioFileOutputNode, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_AudioFileOutputNode, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioFileOutputNode[] = {
        { const_cast<char*>("file"), (getter)AudioFileOutputNode_get_File, nullptr, nullptr, nullptr },
        { const_cast<char*>("file_encoding_profile"), (getter)AudioFileOutputNode_get_FileEncodingProfile, nullptr, nullptr, nullptr },
        { const_cast<char*>("outgoing_gain"), (getter)AudioFileOutputNode_get_OutgoingGain, (setter)AudioFileOutputNode_put_OutgoingGain, nullptr, nullptr },
        { const_cast<char*>("consume_input"), (getter)AudioFileOutputNode_get_ConsumeInput, (setter)AudioFileOutputNode_put_ConsumeInput, nullptr, nullptr },
        { const_cast<char*>("effect_definitions"), (getter)AudioFileOutputNode_get_EffectDefinitions, nullptr, nullptr, nullptr },
        { const_cast<char*>("encoding_properties"), (getter)AudioFileOutputNode_get_EncodingProperties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioFileOutputNode[] = 
    {
        { Py_tp_new, _new_AudioFileOutputNode },
        { Py_tp_dealloc, _dealloc_AudioFileOutputNode },
        { Py_tp_methods, _methods_AudioFileOutputNode },
        { Py_tp_getset, _getset_AudioFileOutputNode },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioFileOutputNode =
    {
        "_winrt_Windows_Media_Audio.AudioFileOutputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFileOutputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFileOutputNode
    };

    // ----- AudioFrameCompletedEventArgs class --------------------
    constexpr const char* const _type_name_AudioFrameCompletedEventArgs = "AudioFrameCompletedEventArgs";

    static PyObject* _new_AudioFrameCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioFrameCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_AudioFrameCompletedEventArgs(py::wrapper::Windows::Media::Audio::AudioFrameCompletedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioFrameCompletedEventArgs_get_Frame(py::wrapper::Windows::Media::Audio::AudioFrameCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioFrameCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFrameCompletedEventArgs[] = {
        { "_from", (PyCFunction)_from_AudioFrameCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioFrameCompletedEventArgs[] = {
        { const_cast<char*>("frame"), (getter)AudioFrameCompletedEventArgs_get_Frame, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioFrameCompletedEventArgs[] = 
    {
        { Py_tp_new, _new_AudioFrameCompletedEventArgs },
        { Py_tp_dealloc, _dealloc_AudioFrameCompletedEventArgs },
        { Py_tp_methods, _methods_AudioFrameCompletedEventArgs },
        { Py_tp_getset, _getset_AudioFrameCompletedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioFrameCompletedEventArgs =
    {
        "_winrt_Windows_Media_Audio.AudioFrameCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFrameCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFrameCompletedEventArgs
    };

    // ----- AudioFrameInputNode class --------------------
    constexpr const char* const _type_name_AudioFrameInputNode = "AudioFrameInputNode";

    static PyObject* _new_AudioFrameInputNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioFrameInputNode);
        return nullptr;
    }

    static void _dealloc_AudioFrameInputNode(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioFrameInputNode_AddFrame(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::AudioFrame>(args, 0);

                self->obj.AddFrame(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_Close(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_DiscardQueuedFrames(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.DiscardQueuedFrames();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_Reset(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_Start(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_Stop(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackSpeedFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameInputNode_put_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.PlaybackSpeedFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameInputNode_get_QueuedSampleCount(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.QueuedSampleCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_Emitter(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_add_AudioFrameCompleted(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioFrameInputNode, winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>>(arg);

            return py::convert(self->obj.AudioFrameCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_remove_AudioFrameCompleted(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioFrameCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_add_QuantumStarted(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioFrameInputNode, winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>>(arg);

            return py::convert(self->obj.QuantumStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_remove_QuantumStarted(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.QuantumStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioFrameInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFrameInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFrameInputNode(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_AudioFrameInputNode(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFrameInputNode[] = {
        { "add_frame", (PyCFunction)AudioFrameInputNode_AddFrame, METH_VARARGS, nullptr },
        { "add_outgoing_connection", (PyCFunction)AudioFrameInputNode_AddOutgoingConnection, METH_VARARGS, nullptr },
        { "close", (PyCFunction)AudioFrameInputNode_Close, METH_VARARGS, nullptr },
        { "disable_effects_by_definition", (PyCFunction)AudioFrameInputNode_DisableEffectsByDefinition, METH_VARARGS, nullptr },
        { "discard_queued_frames", (PyCFunction)AudioFrameInputNode_DiscardQueuedFrames, METH_VARARGS, nullptr },
        { "enable_effects_by_definition", (PyCFunction)AudioFrameInputNode_EnableEffectsByDefinition, METH_VARARGS, nullptr },
        { "remove_outgoing_connection", (PyCFunction)AudioFrameInputNode_RemoveOutgoingConnection, METH_VARARGS, nullptr },
        { "reset", (PyCFunction)AudioFrameInputNode_Reset, METH_VARARGS, nullptr },
        { "start", (PyCFunction)AudioFrameInputNode_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)AudioFrameInputNode_Stop, METH_VARARGS, nullptr },
        { "add_audio_frame_completed", (PyCFunction)AudioFrameInputNode_add_AudioFrameCompleted, METH_O, nullptr },
        { "remove_audio_frame_completed", (PyCFunction)AudioFrameInputNode_remove_AudioFrameCompleted, METH_O, nullptr },
        { "add_quantum_started", (PyCFunction)AudioFrameInputNode_add_QuantumStarted, METH_O, nullptr },
        { "remove_quantum_started", (PyCFunction)AudioFrameInputNode_remove_QuantumStarted, METH_O, nullptr },
        { "_from", (PyCFunction)_from_AudioFrameInputNode, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_AudioFrameInputNode, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_AudioFrameInputNode, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioFrameInputNode[] = {
        { const_cast<char*>("playback_speed_factor"), (getter)AudioFrameInputNode_get_PlaybackSpeedFactor, (setter)AudioFrameInputNode_put_PlaybackSpeedFactor, nullptr, nullptr },
        { const_cast<char*>("queued_sample_count"), (getter)AudioFrameInputNode_get_QueuedSampleCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("outgoing_connections"), (getter)AudioFrameInputNode_get_OutgoingConnections, nullptr, nullptr, nullptr },
        { const_cast<char*>("emitter"), (getter)AudioFrameInputNode_get_Emitter, nullptr, nullptr, nullptr },
        { const_cast<char*>("outgoing_gain"), (getter)AudioFrameInputNode_get_OutgoingGain, (setter)AudioFrameInputNode_put_OutgoingGain, nullptr, nullptr },
        { const_cast<char*>("consume_input"), (getter)AudioFrameInputNode_get_ConsumeInput, (setter)AudioFrameInputNode_put_ConsumeInput, nullptr, nullptr },
        { const_cast<char*>("effect_definitions"), (getter)AudioFrameInputNode_get_EffectDefinitions, nullptr, nullptr, nullptr },
        { const_cast<char*>("encoding_properties"), (getter)AudioFrameInputNode_get_EncodingProperties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioFrameInputNode[] = 
    {
        { Py_tp_new, _new_AudioFrameInputNode },
        { Py_tp_dealloc, _dealloc_AudioFrameInputNode },
        { Py_tp_methods, _methods_AudioFrameInputNode },
        { Py_tp_getset, _getset_AudioFrameInputNode },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioFrameInputNode =
    {
        "_winrt_Windows_Media_Audio.AudioFrameInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFrameInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFrameInputNode
    };

    // ----- AudioFrameOutputNode class --------------------
    constexpr const char* const _type_name_AudioFrameOutputNode = "AudioFrameOutputNode";

    static PyObject* _new_AudioFrameOutputNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioFrameOutputNode);
        return nullptr;
    }

    static void _dealloc_AudioFrameOutputNode(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioFrameOutputNode_Close(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_GetFrame(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_Reset(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_Start(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_Stop(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameOutputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameOutputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameOutputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameOutputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioFrameOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFrameOutputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFrameOutputNode(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_AudioFrameOutputNode(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFrameOutputNode[] = {
        { "close", (PyCFunction)AudioFrameOutputNode_Close, METH_VARARGS, nullptr },
        { "disable_effects_by_definition", (PyCFunction)AudioFrameOutputNode_DisableEffectsByDefinition, METH_VARARGS, nullptr },
        { "enable_effects_by_definition", (PyCFunction)AudioFrameOutputNode_EnableEffectsByDefinition, METH_VARARGS, nullptr },
        { "get_frame", (PyCFunction)AudioFrameOutputNode_GetFrame, METH_VARARGS, nullptr },
        { "reset", (PyCFunction)AudioFrameOutputNode_Reset, METH_VARARGS, nullptr },
        { "start", (PyCFunction)AudioFrameOutputNode_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)AudioFrameOutputNode_Stop, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AudioFrameOutputNode, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_AudioFrameOutputNode, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_AudioFrameOutputNode, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioFrameOutputNode[] = {
        { const_cast<char*>("outgoing_gain"), (getter)AudioFrameOutputNode_get_OutgoingGain, (setter)AudioFrameOutputNode_put_OutgoingGain, nullptr, nullptr },
        { const_cast<char*>("consume_input"), (getter)AudioFrameOutputNode_get_ConsumeInput, (setter)AudioFrameOutputNode_put_ConsumeInput, nullptr, nullptr },
        { const_cast<char*>("effect_definitions"), (getter)AudioFrameOutputNode_get_EffectDefinitions, nullptr, nullptr, nullptr },
        { const_cast<char*>("encoding_properties"), (getter)AudioFrameOutputNode_get_EncodingProperties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioFrameOutputNode[] = 
    {
        { Py_tp_new, _new_AudioFrameOutputNode },
        { Py_tp_dealloc, _dealloc_AudioFrameOutputNode },
        { Py_tp_methods, _methods_AudioFrameOutputNode },
        { Py_tp_getset, _getset_AudioFrameOutputNode },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioFrameOutputNode =
    {
        "_winrt_Windows_Media_Audio.AudioFrameOutputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFrameOutputNode
    };

    // ----- AudioGraph class --------------------
    constexpr const char* const _type_name_AudioGraph = "AudioGraph";

    static PyObject* _new_AudioGraph(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioGraph);
        return nullptr;
    }

    static void _dealloc_AudioGraph(py::wrapper::Windows::Media::Audio::AudioGraph* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioGraph_Close(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraphSettings>(args, 0);

                return py::convert(winrt::Windows::Media::Audio::AudioGraph::CreateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateBatchUpdater(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateBatchUpdater());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateDeviceInputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);

                return py::convert(self->obj.CreateDeviceInputNodeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 1);

                return py::convert(self->obj.CreateDeviceInputNodeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 2);

                return py::convert(self->obj.CreateDeviceInputNodeAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 3);

                return py::convert(self->obj.CreateDeviceInputNodeAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateDeviceOutputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateDeviceOutputNodeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFileInputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.CreateFileInputNodeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 1);

                return py::convert(self->obj.CreateFileInputNodeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFileOutputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.CreateFileOutputNodeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 1);

                return py::convert(self->obj.CreateFileOutputNodeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFrameInputNode(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateFrameInputNode());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                return py::convert(self->obj.CreateFrameInputNode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 1);

                return py::convert(self->obj.CreateFrameInputNode(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFrameOutputNode(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateFrameOutputNode());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                return py::convert(self->obj.CreateFrameOutputNode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateMediaSourceAudioInputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaSource>(args, 0);

                return py::convert(self->obj.CreateMediaSourceAudioInputNodeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaSource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 1);

                return py::convert(self->obj.CreateMediaSourceAudioInputNodeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateSubmixNode(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateSubmixNode());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                return py::convert(self->obj.CreateSubmixNode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 1);

                return py::convert(self->obj.CreateSubmixNode(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_ResetAllNodes(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ResetAllNodes();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_Start(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_Stop(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_CompletedQuantumCount(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CompletedQuantumCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_LatencyInSamples(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LatencyInSamples());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_PrimaryRenderDevice(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrimaryRenderDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_RenderDeviceAudioProcessing(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RenderDeviceAudioProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_SamplesPerQuantum(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SamplesPerQuantum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_add_QuantumProcessed(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioGraph, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.QuantumProcessed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_remove_QuantumProcessed(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.QuantumProcessed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_add_QuantumStarted(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioGraph, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.QuantumStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_remove_QuantumStarted(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.QuantumStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_add_UnrecoverableErrorOccurred(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioGraph, winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>>(arg);

            return py::convert(self->obj.UnrecoverableErrorOccurred(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_remove_UnrecoverableErrorOccurred(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UnrecoverableErrorOccurred(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioGraph(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraph>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioGraph(py::wrapper::Windows::Media::Audio::AudioGraph* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_AudioGraph(py::wrapper::Windows::Media::Audio::AudioGraph* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraph[] = {
        { "close", (PyCFunction)AudioGraph_Close, METH_VARARGS, nullptr },
        { "create_async", (PyCFunction)AudioGraph_CreateAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "create_batch_updater", (PyCFunction)AudioGraph_CreateBatchUpdater, METH_VARARGS, nullptr },
        { "create_device_input_node_async", (PyCFunction)AudioGraph_CreateDeviceInputNodeAsync, METH_VARARGS, nullptr },
        { "create_device_output_node_async", (PyCFunction)AudioGraph_CreateDeviceOutputNodeAsync, METH_VARARGS, nullptr },
        { "create_file_input_node_async", (PyCFunction)AudioGraph_CreateFileInputNodeAsync, METH_VARARGS, nullptr },
        { "create_file_output_node_async", (PyCFunction)AudioGraph_CreateFileOutputNodeAsync, METH_VARARGS, nullptr },
        { "create_frame_input_node", (PyCFunction)AudioGraph_CreateFrameInputNode, METH_VARARGS, nullptr },
        { "create_frame_output_node", (PyCFunction)AudioGraph_CreateFrameOutputNode, METH_VARARGS, nullptr },
        { "create_media_source_audio_input_node_async", (PyCFunction)AudioGraph_CreateMediaSourceAudioInputNodeAsync, METH_VARARGS, nullptr },
        { "create_submix_node", (PyCFunction)AudioGraph_CreateSubmixNode, METH_VARARGS, nullptr },
        { "reset_all_nodes", (PyCFunction)AudioGraph_ResetAllNodes, METH_VARARGS, nullptr },
        { "start", (PyCFunction)AudioGraph_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)AudioGraph_Stop, METH_VARARGS, nullptr },
        { "add_quantum_processed", (PyCFunction)AudioGraph_add_QuantumProcessed, METH_O, nullptr },
        { "remove_quantum_processed", (PyCFunction)AudioGraph_remove_QuantumProcessed, METH_O, nullptr },
        { "add_quantum_started", (PyCFunction)AudioGraph_add_QuantumStarted, METH_O, nullptr },
        { "remove_quantum_started", (PyCFunction)AudioGraph_remove_QuantumStarted, METH_O, nullptr },
        { "add_unrecoverable_error_occurred", (PyCFunction)AudioGraph_add_UnrecoverableErrorOccurred, METH_O, nullptr },
        { "remove_unrecoverable_error_occurred", (PyCFunction)AudioGraph_remove_UnrecoverableErrorOccurred, METH_O, nullptr },
        { "_from", (PyCFunction)_from_AudioGraph, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_AudioGraph, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_AudioGraph, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioGraph[] = {
        { const_cast<char*>("completed_quantum_count"), (getter)AudioGraph_get_CompletedQuantumCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("encoding_properties"), (getter)AudioGraph_get_EncodingProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("latency_in_samples"), (getter)AudioGraph_get_LatencyInSamples, nullptr, nullptr, nullptr },
        { const_cast<char*>("primary_render_device"), (getter)AudioGraph_get_PrimaryRenderDevice, nullptr, nullptr, nullptr },
        { const_cast<char*>("render_device_audio_processing"), (getter)AudioGraph_get_RenderDeviceAudioProcessing, nullptr, nullptr, nullptr },
        { const_cast<char*>("samples_per_quantum"), (getter)AudioGraph_get_SamplesPerQuantum, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioGraph[] = 
    {
        { Py_tp_new, _new_AudioGraph },
        { Py_tp_dealloc, _dealloc_AudioGraph },
        { Py_tp_methods, _methods_AudioGraph },
        { Py_tp_getset, _getset_AudioGraph },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioGraph =
    {
        "_winrt_Windows_Media_Audio.AudioGraph",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraph),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraph
    };

    // ----- AudioGraphBatchUpdater class --------------------
    constexpr const char* const _type_name_AudioGraphBatchUpdater = "AudioGraphBatchUpdater";

    static PyObject* _new_AudioGraphBatchUpdater(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioGraphBatchUpdater);
        return nullptr;
    }

    static void _dealloc_AudioGraphBatchUpdater(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioGraphBatchUpdater_Close(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_AudioGraphBatchUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraphBatchUpdater>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioGraphBatchUpdater(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_AudioGraphBatchUpdater(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraphBatchUpdater[] = {
        { "close", (PyCFunction)AudioGraphBatchUpdater_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AudioGraphBatchUpdater, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_AudioGraphBatchUpdater, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_AudioGraphBatchUpdater, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioGraphBatchUpdater[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioGraphBatchUpdater[] = 
    {
        { Py_tp_new, _new_AudioGraphBatchUpdater },
        { Py_tp_dealloc, _dealloc_AudioGraphBatchUpdater },
        { Py_tp_methods, _methods_AudioGraphBatchUpdater },
        { Py_tp_getset, _getset_AudioGraphBatchUpdater },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioGraphBatchUpdater =
    {
        "_winrt_Windows_Media_Audio.AudioGraphBatchUpdater",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraphBatchUpdater
    };

    // ----- AudioGraphConnection class --------------------
    constexpr const char* const _type_name_AudioGraphConnection = "AudioGraphConnection";

    static PyObject* _new_AudioGraphConnection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioGraphConnection);
        return nullptr;
    }

    static void _dealloc_AudioGraphConnection(py::wrapper::Windows::Media::Audio::AudioGraphConnection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioGraphConnection_get_Gain(py::wrapper::Windows::Media::Audio::AudioGraphConnection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Gain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphConnection_put_Gain(py::wrapper::Windows::Media::Audio::AudioGraphConnection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Gain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphConnection_get_Destination(py::wrapper::Windows::Media::Audio::AudioGraphConnection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Destination());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioGraphConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraphConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraphConnection[] = {
        { "_from", (PyCFunction)_from_AudioGraphConnection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioGraphConnection[] = {
        { const_cast<char*>("gain"), (getter)AudioGraphConnection_get_Gain, (setter)AudioGraphConnection_put_Gain, nullptr, nullptr },
        { const_cast<char*>("destination"), (getter)AudioGraphConnection_get_Destination, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioGraphConnection[] = 
    {
        { Py_tp_new, _new_AudioGraphConnection },
        { Py_tp_dealloc, _dealloc_AudioGraphConnection },
        { Py_tp_methods, _methods_AudioGraphConnection },
        { Py_tp_getset, _getset_AudioGraphConnection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioGraphConnection =
    {
        "_winrt_Windows_Media_Audio.AudioGraphConnection",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraphConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraphConnection
    };

    // ----- AudioGraphSettings class --------------------
    constexpr const char* const _type_name_AudioGraphSettings = "AudioGraphSettings";

    static PyObject* _new_AudioGraphSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 0);

                winrt::Windows::Media::Audio::AudioGraphSettings instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioGraphSettings(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioGraphSettings_get_QuantumSizeSelectionMode(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.QuantumSizeSelectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_QuantumSizeSelectionMode(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Audio::QuantumSizeSelectionMode>(arg);

            self->obj.QuantumSizeSelectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_PrimaryRenderDevice(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrimaryRenderDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_PrimaryRenderDevice(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(arg);

            self->obj.PrimaryRenderDevice(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(arg);

            self->obj.EncodingProperties(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_DesiredSamplesPerQuantum(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredSamplesPerQuantum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_DesiredSamplesPerQuantum(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.DesiredSamplesPerQuantum(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_DesiredRenderDeviceAudioProcessing(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredRenderDeviceAudioProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_DesiredRenderDeviceAudioProcessing(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::AudioProcessing>(arg);

            self->obj.DesiredRenderDeviceAudioProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_AudioRenderCategory(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioRenderCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_AudioRenderCategory(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(arg);

            self->obj.AudioRenderCategory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_MaxPlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPlaybackSpeedFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_MaxPlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.MaxPlaybackSpeedFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AudioGraphSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraphSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraphSettings[] = {
        { "_from", (PyCFunction)_from_AudioGraphSettings, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioGraphSettings[] = {
        { const_cast<char*>("quantum_size_selection_mode"), (getter)AudioGraphSettings_get_QuantumSizeSelectionMode, (setter)AudioGraphSettings_put_QuantumSizeSelectionMode, nullptr, nullptr },
        { const_cast<char*>("primary_render_device"), (getter)AudioGraphSettings_get_PrimaryRenderDevice, (setter)AudioGraphSettings_put_PrimaryRenderDevice, nullptr, nullptr },
        { const_cast<char*>("encoding_properties"), (getter)AudioGraphSettings_get_EncodingProperties, (setter)AudioGraphSettings_put_EncodingProperties, nullptr, nullptr },
        { const_cast<char*>("desired_samples_per_quantum"), (getter)AudioGraphSettings_get_DesiredSamplesPerQuantum, (setter)AudioGraphSettings_put_DesiredSamplesPerQuantum, nullptr, nullptr },
        { const_cast<char*>("desired_render_device_audio_processing"), (getter)AudioGraphSettings_get_DesiredRenderDeviceAudioProcessing, (setter)AudioGraphSettings_put_DesiredRenderDeviceAudioProcessing, nullptr, nullptr },
        { const_cast<char*>("audio_render_category"), (getter)AudioGraphSettings_get_AudioRenderCategory, (setter)AudioGraphSettings_put_AudioRenderCategory, nullptr, nullptr },
        { const_cast<char*>("max_playback_speed_factor"), (getter)AudioGraphSettings_get_MaxPlaybackSpeedFactor, (setter)AudioGraphSettings_put_MaxPlaybackSpeedFactor, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioGraphSettings[] = 
    {
        { Py_tp_new, _new_AudioGraphSettings },
        { Py_tp_dealloc, _dealloc_AudioGraphSettings },
        { Py_tp_methods, _methods_AudioGraphSettings },
        { Py_tp_getset, _getset_AudioGraphSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioGraphSettings =
    {
        "_winrt_Windows_Media_Audio.AudioGraphSettings",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraphSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraphSettings
    };

    // ----- AudioGraphUnrecoverableErrorOccurredEventArgs class --------------------
    constexpr const char* const _type_name_AudioGraphUnrecoverableErrorOccurredEventArgs = "AudioGraphUnrecoverableErrorOccurredEventArgs";

    static PyObject* _new_AudioGraphUnrecoverableErrorOccurredEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioGraphUnrecoverableErrorOccurredEventArgs);
        return nullptr;
    }

    static void _dealloc_AudioGraphUnrecoverableErrorOccurredEventArgs(py::wrapper::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioGraphUnrecoverableErrorOccurredEventArgs_get_Error(py::wrapper::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioGraphUnrecoverableErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraphUnrecoverableErrorOccurredEventArgs[] = {
        { "_from", (PyCFunction)_from_AudioGraphUnrecoverableErrorOccurredEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioGraphUnrecoverableErrorOccurredEventArgs[] = {
        { const_cast<char*>("error"), (getter)AudioGraphUnrecoverableErrorOccurredEventArgs_get_Error, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioGraphUnrecoverableErrorOccurredEventArgs[] = 
    {
        { Py_tp_new, _new_AudioGraphUnrecoverableErrorOccurredEventArgs },
        { Py_tp_dealloc, _dealloc_AudioGraphUnrecoverableErrorOccurredEventArgs },
        { Py_tp_methods, _methods_AudioGraphUnrecoverableErrorOccurredEventArgs },
        { Py_tp_getset, _getset_AudioGraphUnrecoverableErrorOccurredEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioGraphUnrecoverableErrorOccurredEventArgs =
    {
        "_winrt_Windows_Media_Audio.AudioGraphUnrecoverableErrorOccurredEventArgs",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraphUnrecoverableErrorOccurredEventArgs
    };

    // ----- AudioNodeEmitter class --------------------
    constexpr const char* const _type_name_AudioNodeEmitter = "AudioNodeEmitter";

    static PyObject* _new_AudioNodeEmitter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitterShape>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitterSettings>(args, 2);

                winrt::Windows::Media::Audio::AudioNodeEmitter instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Audio::AudioNodeEmitter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioNodeEmitter(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioNodeEmitter_get_Position(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_Position(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_Gain(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Gain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_Gain(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Gain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_DopplerVelocity(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DopplerVelocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_DopplerVelocity(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.DopplerVelocity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_DopplerScale(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DopplerScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_DopplerScale(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DopplerScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_DistanceScale(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DistanceScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_DistanceScale(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DistanceScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_Direction(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Direction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_Direction(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Direction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_DecayModel(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecayModel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitter_get_IsDopplerDisabled(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDopplerDisabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitter_get_Shape(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitter_get_SpatialAudioModel(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SpatialAudioModel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_SpatialAudioModel(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Audio::SpatialAudioModel>(arg);

            self->obj.SpatialAudioModel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AudioNodeEmitter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitter[] = {
        { "_from", (PyCFunction)_from_AudioNodeEmitter, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioNodeEmitter[] = {
        { const_cast<char*>("position"), (getter)AudioNodeEmitter_get_Position, (setter)AudioNodeEmitter_put_Position, nullptr, nullptr },
        { const_cast<char*>("gain"), (getter)AudioNodeEmitter_get_Gain, (setter)AudioNodeEmitter_put_Gain, nullptr, nullptr },
        { const_cast<char*>("doppler_velocity"), (getter)AudioNodeEmitter_get_DopplerVelocity, (setter)AudioNodeEmitter_put_DopplerVelocity, nullptr, nullptr },
        { const_cast<char*>("doppler_scale"), (getter)AudioNodeEmitter_get_DopplerScale, (setter)AudioNodeEmitter_put_DopplerScale, nullptr, nullptr },
        { const_cast<char*>("distance_scale"), (getter)AudioNodeEmitter_get_DistanceScale, (setter)AudioNodeEmitter_put_DistanceScale, nullptr, nullptr },
        { const_cast<char*>("direction"), (getter)AudioNodeEmitter_get_Direction, (setter)AudioNodeEmitter_put_Direction, nullptr, nullptr },
        { const_cast<char*>("decay_model"), (getter)AudioNodeEmitter_get_DecayModel, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_doppler_disabled"), (getter)AudioNodeEmitter_get_IsDopplerDisabled, nullptr, nullptr, nullptr },
        { const_cast<char*>("shape"), (getter)AudioNodeEmitter_get_Shape, nullptr, nullptr, nullptr },
        { const_cast<char*>("spatial_audio_model"), (getter)AudioNodeEmitter_get_SpatialAudioModel, (setter)AudioNodeEmitter_put_SpatialAudioModel, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioNodeEmitter[] = 
    {
        { Py_tp_new, _new_AudioNodeEmitter },
        { Py_tp_dealloc, _dealloc_AudioNodeEmitter },
        { Py_tp_methods, _methods_AudioNodeEmitter },
        { Py_tp_getset, _getset_AudioNodeEmitter },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioNodeEmitter =
    {
        "_winrt_Windows_Media_Audio.AudioNodeEmitter",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitter
    };

    // ----- AudioNodeEmitterConeProperties class --------------------
    constexpr const char* const _type_name_AudioNodeEmitterConeProperties = "AudioNodeEmitterConeProperties";

    static PyObject* _new_AudioNodeEmitterConeProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioNodeEmitterConeProperties);
        return nullptr;
    }

    static void _dealloc_AudioNodeEmitterConeProperties(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioNodeEmitterConeProperties_get_InnerAngle(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InnerAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterConeProperties_get_OuterAngle(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OuterAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterConeProperties_get_OuterAngleGain(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OuterAngleGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioNodeEmitterConeProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitterConeProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitterConeProperties[] = {
        { "_from", (PyCFunction)_from_AudioNodeEmitterConeProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioNodeEmitterConeProperties[] = {
        { const_cast<char*>("inner_angle"), (getter)AudioNodeEmitterConeProperties_get_InnerAngle, nullptr, nullptr, nullptr },
        { const_cast<char*>("outer_angle"), (getter)AudioNodeEmitterConeProperties_get_OuterAngle, nullptr, nullptr, nullptr },
        { const_cast<char*>("outer_angle_gain"), (getter)AudioNodeEmitterConeProperties_get_OuterAngleGain, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioNodeEmitterConeProperties[] = 
    {
        { Py_tp_new, _new_AudioNodeEmitterConeProperties },
        { Py_tp_dealloc, _dealloc_AudioNodeEmitterConeProperties },
        { Py_tp_methods, _methods_AudioNodeEmitterConeProperties },
        { Py_tp_getset, _getset_AudioNodeEmitterConeProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioNodeEmitterConeProperties =
    {
        "_winrt_Windows_Media_Audio.AudioNodeEmitterConeProperties",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitterConeProperties
    };

    // ----- AudioNodeEmitterDecayModel class --------------------
    constexpr const char* const _type_name_AudioNodeEmitterDecayModel = "AudioNodeEmitterDecayModel";

    static PyObject* _new_AudioNodeEmitterDecayModel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioNodeEmitterDecayModel);
        return nullptr;
    }

    static void _dealloc_AudioNodeEmitterDecayModel(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioNodeEmitterDecayModel_CreateCustom(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                return py::convert(winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel::CreateCustom(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_CreateNatural(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);

                return py::convert(winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel::CreateNatural(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_get_Kind(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_get_MaxGain(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_get_MinGain(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_get_NaturalProperties(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NaturalProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioNodeEmitterDecayModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitterDecayModel[] = {
        { "create_custom", (PyCFunction)AudioNodeEmitterDecayModel_CreateCustom, METH_VARARGS | METH_STATIC, nullptr },
        { "create_natural", (PyCFunction)AudioNodeEmitterDecayModel_CreateNatural, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_AudioNodeEmitterDecayModel, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioNodeEmitterDecayModel[] = {
        { const_cast<char*>("kind"), (getter)AudioNodeEmitterDecayModel_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_gain"), (getter)AudioNodeEmitterDecayModel_get_MaxGain, nullptr, nullptr, nullptr },
        { const_cast<char*>("min_gain"), (getter)AudioNodeEmitterDecayModel_get_MinGain, nullptr, nullptr, nullptr },
        { const_cast<char*>("natural_properties"), (getter)AudioNodeEmitterDecayModel_get_NaturalProperties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioNodeEmitterDecayModel[] = 
    {
        { Py_tp_new, _new_AudioNodeEmitterDecayModel },
        { Py_tp_dealloc, _dealloc_AudioNodeEmitterDecayModel },
        { Py_tp_methods, _methods_AudioNodeEmitterDecayModel },
        { Py_tp_getset, _getset_AudioNodeEmitterDecayModel },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioNodeEmitterDecayModel =
    {
        "_winrt_Windows_Media_Audio.AudioNodeEmitterDecayModel",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitterDecayModel
    };

    // ----- AudioNodeEmitterNaturalDecayModelProperties class --------------------
    constexpr const char* const _type_name_AudioNodeEmitterNaturalDecayModelProperties = "AudioNodeEmitterNaturalDecayModelProperties";

    static PyObject* _new_AudioNodeEmitterNaturalDecayModelProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioNodeEmitterNaturalDecayModelProperties);
        return nullptr;
    }

    static void _dealloc_AudioNodeEmitterNaturalDecayModelProperties(py::wrapper::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioNodeEmitterNaturalDecayModelProperties_get_CutoffDistance(py::wrapper::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CutoffDistance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterNaturalDecayModelProperties_get_UnityGainDistance(py::wrapper::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UnityGainDistance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioNodeEmitterNaturalDecayModelProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitterNaturalDecayModelProperties[] = {
        { "_from", (PyCFunction)_from_AudioNodeEmitterNaturalDecayModelProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioNodeEmitterNaturalDecayModelProperties[] = {
        { const_cast<char*>("cutoff_distance"), (getter)AudioNodeEmitterNaturalDecayModelProperties_get_CutoffDistance, nullptr, nullptr, nullptr },
        { const_cast<char*>("unity_gain_distance"), (getter)AudioNodeEmitterNaturalDecayModelProperties_get_UnityGainDistance, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioNodeEmitterNaturalDecayModelProperties[] = 
    {
        { Py_tp_new, _new_AudioNodeEmitterNaturalDecayModelProperties },
        { Py_tp_dealloc, _dealloc_AudioNodeEmitterNaturalDecayModelProperties },
        { Py_tp_methods, _methods_AudioNodeEmitterNaturalDecayModelProperties },
        { Py_tp_getset, _getset_AudioNodeEmitterNaturalDecayModelProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioNodeEmitterNaturalDecayModelProperties =
    {
        "_winrt_Windows_Media_Audio.AudioNodeEmitterNaturalDecayModelProperties",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitterNaturalDecayModelProperties
    };

    // ----- AudioNodeEmitterShape class --------------------
    constexpr const char* const _type_name_AudioNodeEmitterShape = "AudioNodeEmitterShape";

    static PyObject* _new_AudioNodeEmitterShape(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioNodeEmitterShape);
        return nullptr;
    }

    static void _dealloc_AudioNodeEmitterShape(py::wrapper::Windows::Media::Audio::AudioNodeEmitterShape* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioNodeEmitterShape_CreateCone(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);

                return py::convert(winrt::Windows::Media::Audio::AudioNodeEmitterShape::CreateCone(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterShape_CreateOmnidirectional(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::Audio::AudioNodeEmitterShape::CreateOmnidirectional());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterShape_get_ConeProperties(py::wrapper::Windows::Media::Audio::AudioNodeEmitterShape* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConeProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterShape_get_Kind(py::wrapper::Windows::Media::Audio::AudioNodeEmitterShape* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioNodeEmitterShape(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitterShape>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitterShape[] = {
        { "create_cone", (PyCFunction)AudioNodeEmitterShape_CreateCone, METH_VARARGS | METH_STATIC, nullptr },
        { "create_omnidirectional", (PyCFunction)AudioNodeEmitterShape_CreateOmnidirectional, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_AudioNodeEmitterShape, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioNodeEmitterShape[] = {
        { const_cast<char*>("cone_properties"), (getter)AudioNodeEmitterShape_get_ConeProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)AudioNodeEmitterShape_get_Kind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioNodeEmitterShape[] = 
    {
        { Py_tp_new, _new_AudioNodeEmitterShape },
        { Py_tp_dealloc, _dealloc_AudioNodeEmitterShape },
        { Py_tp_methods, _methods_AudioNodeEmitterShape },
        { Py_tp_getset, _getset_AudioNodeEmitterShape },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioNodeEmitterShape =
    {
        "_winrt_Windows_Media_Audio.AudioNodeEmitterShape",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitterShape),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitterShape
    };

    // ----- AudioNodeListener class --------------------
    constexpr const char* const _type_name_AudioNodeListener = "AudioNodeListener";

    static PyObject* _new_AudioNodeListener(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Audio::AudioNodeListener instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioNodeListener(py::wrapper::Windows::Media::Audio::AudioNodeListener* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioNodeListener_get_SpeedOfSound(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SpeedOfSound());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeListener_put_SpeedOfSound(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.SpeedOfSound(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeListener_get_Position(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeListener_put_Position(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeListener_get_Orientation(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeListener_put_Orientation(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);

            self->obj.Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeListener_get_DopplerVelocity(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DopplerVelocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeListener_put_DopplerVelocity(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.DopplerVelocity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AudioNodeListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeListener[] = {
        { "_from", (PyCFunction)_from_AudioNodeListener, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioNodeListener[] = {
        { const_cast<char*>("speed_of_sound"), (getter)AudioNodeListener_get_SpeedOfSound, (setter)AudioNodeListener_put_SpeedOfSound, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)AudioNodeListener_get_Position, (setter)AudioNodeListener_put_Position, nullptr, nullptr },
        { const_cast<char*>("orientation"), (getter)AudioNodeListener_get_Orientation, (setter)AudioNodeListener_put_Orientation, nullptr, nullptr },
        { const_cast<char*>("doppler_velocity"), (getter)AudioNodeListener_get_DopplerVelocity, (setter)AudioNodeListener_put_DopplerVelocity, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioNodeListener[] = 
    {
        { Py_tp_new, _new_AudioNodeListener },
        { Py_tp_dealloc, _dealloc_AudioNodeListener },
        { Py_tp_methods, _methods_AudioNodeListener },
        { Py_tp_getset, _getset_AudioNodeListener },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioNodeListener =
    {
        "_winrt_Windows_Media_Audio.AudioNodeListener",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeListener
    };

    // ----- AudioPlaybackConnection class --------------------
    constexpr const char* const _type_name_AudioPlaybackConnection = "AudioPlaybackConnection";

    static PyObject* _new_AudioPlaybackConnection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioPlaybackConnection);
        return nullptr;
    }

    static void _dealloc_AudioPlaybackConnection(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioPlaybackConnection_Close(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::Audio::AudioPlaybackConnection::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_Open(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Open());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_OpenAsync(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_Start(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_StartAsync(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_TryCreateFromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Audio::AudioPlaybackConnection::TryCreateFromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_get_DeviceId(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_get_State(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_add_StateChanged(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioPlaybackConnection, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_remove_StateChanged(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioPlaybackConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioPlaybackConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioPlaybackConnection(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_AudioPlaybackConnection(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioPlaybackConnection[] = {
        { "close", (PyCFunction)AudioPlaybackConnection_Close, METH_VARARGS, nullptr },
        { "get_device_selector", (PyCFunction)AudioPlaybackConnection_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "open", (PyCFunction)AudioPlaybackConnection_Open, METH_VARARGS, nullptr },
        { "open_async", (PyCFunction)AudioPlaybackConnection_OpenAsync, METH_VARARGS, nullptr },
        { "start", (PyCFunction)AudioPlaybackConnection_Start, METH_VARARGS, nullptr },
        { "start_async", (PyCFunction)AudioPlaybackConnection_StartAsync, METH_VARARGS, nullptr },
        { "try_create_from_id", (PyCFunction)AudioPlaybackConnection_TryCreateFromId, METH_VARARGS | METH_STATIC, nullptr },
        { "add_state_changed", (PyCFunction)AudioPlaybackConnection_add_StateChanged, METH_O, nullptr },
        { "remove_state_changed", (PyCFunction)AudioPlaybackConnection_remove_StateChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_AudioPlaybackConnection, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_AudioPlaybackConnection, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_AudioPlaybackConnection, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioPlaybackConnection[] = {
        { const_cast<char*>("device_id"), (getter)AudioPlaybackConnection_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("state"), (getter)AudioPlaybackConnection_get_State, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioPlaybackConnection[] = 
    {
        { Py_tp_new, _new_AudioPlaybackConnection },
        { Py_tp_dealloc, _dealloc_AudioPlaybackConnection },
        { Py_tp_methods, _methods_AudioPlaybackConnection },
        { Py_tp_getset, _getset_AudioPlaybackConnection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioPlaybackConnection =
    {
        "_winrt_Windows_Media_Audio.AudioPlaybackConnection",
        sizeof(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioPlaybackConnection
    };

    // ----- AudioPlaybackConnectionOpenResult class --------------------
    constexpr const char* const _type_name_AudioPlaybackConnectionOpenResult = "AudioPlaybackConnectionOpenResult";

    static PyObject* _new_AudioPlaybackConnectionOpenResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioPlaybackConnectionOpenResult);
        return nullptr;
    }

    static void _dealloc_AudioPlaybackConnectionOpenResult(py::wrapper::Windows::Media::Audio::AudioPlaybackConnectionOpenResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioPlaybackConnectionOpenResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::AudioPlaybackConnectionOpenResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnectionOpenResult_get_Status(py::wrapper::Windows::Media::Audio::AudioPlaybackConnectionOpenResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioPlaybackConnectionOpenResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioPlaybackConnectionOpenResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioPlaybackConnectionOpenResult[] = {
        { "_from", (PyCFunction)_from_AudioPlaybackConnectionOpenResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioPlaybackConnectionOpenResult[] = {
        { const_cast<char*>("extended_error"), (getter)AudioPlaybackConnectionOpenResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)AudioPlaybackConnectionOpenResult_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioPlaybackConnectionOpenResult[] = 
    {
        { Py_tp_new, _new_AudioPlaybackConnectionOpenResult },
        { Py_tp_dealloc, _dealloc_AudioPlaybackConnectionOpenResult },
        { Py_tp_methods, _methods_AudioPlaybackConnectionOpenResult },
        { Py_tp_getset, _getset_AudioPlaybackConnectionOpenResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioPlaybackConnectionOpenResult =
    {
        "_winrt_Windows_Media_Audio.AudioPlaybackConnectionOpenResult",
        sizeof(py::wrapper::Windows::Media::Audio::AudioPlaybackConnectionOpenResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioPlaybackConnectionOpenResult
    };

    // ----- AudioStateMonitor class --------------------
    constexpr const char* const _type_name_AudioStateMonitor = "AudioStateMonitor";

    static PyObject* _new_AudioStateMonitor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioStateMonitor);
        return nullptr;
    }

    static void _dealloc_AudioStateMonitor(py::wrapper::Windows::Media::Audio::AudioStateMonitor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioStateMonitor_CreateForCaptureMonitoring(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForCaptureMonitoring());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForCaptureMonitoring(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Devices::AudioDeviceRole>(args, 1);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForCaptureMonitoring(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_CreateForCaptureMonitoringWithCategoryAndDeviceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForCaptureMonitoringWithCategoryAndDeviceId(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_CreateForRenderMonitoring(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForRenderMonitoring());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 0);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForRenderMonitoring(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Devices::AudioDeviceRole>(args, 1);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForRenderMonitoring(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_CreateForRenderMonitoringWithCategoryAndDeviceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForRenderMonitoringWithCategoryAndDeviceId(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_get_SoundLevel(py::wrapper::Windows::Media::Audio::AudioStateMonitor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SoundLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_add_SoundLevelChanged(py::wrapper::Windows::Media::Audio::AudioStateMonitor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioStateMonitor, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SoundLevelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_remove_SoundLevelChanged(py::wrapper::Windows::Media::Audio::AudioStateMonitor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SoundLevelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioStateMonitor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioStateMonitor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioStateMonitor[] = {
        { "create_for_capture_monitoring", (PyCFunction)AudioStateMonitor_CreateForCaptureMonitoring, METH_VARARGS | METH_STATIC, nullptr },
        { "create_for_capture_monitoring_with_category_and_device_id", (PyCFunction)AudioStateMonitor_CreateForCaptureMonitoringWithCategoryAndDeviceId, METH_VARARGS | METH_STATIC, nullptr },
        { "create_for_render_monitoring", (PyCFunction)AudioStateMonitor_CreateForRenderMonitoring, METH_VARARGS | METH_STATIC, nullptr },
        { "create_for_render_monitoring_with_category_and_device_id", (PyCFunction)AudioStateMonitor_CreateForRenderMonitoringWithCategoryAndDeviceId, METH_VARARGS | METH_STATIC, nullptr },
        { "add_sound_level_changed", (PyCFunction)AudioStateMonitor_add_SoundLevelChanged, METH_O, nullptr },
        { "remove_sound_level_changed", (PyCFunction)AudioStateMonitor_remove_SoundLevelChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_AudioStateMonitor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioStateMonitor[] = {
        { const_cast<char*>("sound_level"), (getter)AudioStateMonitor_get_SoundLevel, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioStateMonitor[] = 
    {
        { Py_tp_new, _new_AudioStateMonitor },
        { Py_tp_dealloc, _dealloc_AudioStateMonitor },
        { Py_tp_methods, _methods_AudioStateMonitor },
        { Py_tp_getset, _getset_AudioStateMonitor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioStateMonitor =
    {
        "_winrt_Windows_Media_Audio.AudioStateMonitor",
        sizeof(py::wrapper::Windows::Media::Audio::AudioStateMonitor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioStateMonitor
    };

    // ----- AudioSubmixNode class --------------------
    constexpr const char* const _type_name_AudioSubmixNode = "AudioSubmixNode";

    static PyObject* _new_AudioSubmixNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioSubmixNode);
        return nullptr;
    }

    static void _dealloc_AudioSubmixNode(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioSubmixNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_Close(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_Reset(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_Start(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_Stop(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_get_Emitter(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioSubmixNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioSubmixNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioSubmixNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioSubmixNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioSubmixNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioSubmixNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioSubmixNode(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_AudioSubmixNode(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioSubmixNode[] = {
        { "add_outgoing_connection", (PyCFunction)AudioSubmixNode_AddOutgoingConnection, METH_VARARGS, nullptr },
        { "close", (PyCFunction)AudioSubmixNode_Close, METH_VARARGS, nullptr },
        { "disable_effects_by_definition", (PyCFunction)AudioSubmixNode_DisableEffectsByDefinition, METH_VARARGS, nullptr },
        { "enable_effects_by_definition", (PyCFunction)AudioSubmixNode_EnableEffectsByDefinition, METH_VARARGS, nullptr },
        { "remove_outgoing_connection", (PyCFunction)AudioSubmixNode_RemoveOutgoingConnection, METH_VARARGS, nullptr },
        { "reset", (PyCFunction)AudioSubmixNode_Reset, METH_VARARGS, nullptr },
        { "start", (PyCFunction)AudioSubmixNode_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)AudioSubmixNode_Stop, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AudioSubmixNode, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_AudioSubmixNode, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_AudioSubmixNode, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioSubmixNode[] = {
        { const_cast<char*>("outgoing_connections"), (getter)AudioSubmixNode_get_OutgoingConnections, nullptr, nullptr, nullptr },
        { const_cast<char*>("emitter"), (getter)AudioSubmixNode_get_Emitter, nullptr, nullptr, nullptr },
        { const_cast<char*>("outgoing_gain"), (getter)AudioSubmixNode_get_OutgoingGain, (setter)AudioSubmixNode_put_OutgoingGain, nullptr, nullptr },
        { const_cast<char*>("consume_input"), (getter)AudioSubmixNode_get_ConsumeInput, (setter)AudioSubmixNode_put_ConsumeInput, nullptr, nullptr },
        { const_cast<char*>("effect_definitions"), (getter)AudioSubmixNode_get_EffectDefinitions, nullptr, nullptr, nullptr },
        { const_cast<char*>("encoding_properties"), (getter)AudioSubmixNode_get_EncodingProperties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioSubmixNode[] = 
    {
        { Py_tp_new, _new_AudioSubmixNode },
        { Py_tp_dealloc, _dealloc_AudioSubmixNode },
        { Py_tp_methods, _methods_AudioSubmixNode },
        { Py_tp_getset, _getset_AudioSubmixNode },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioSubmixNode =
    {
        "_winrt_Windows_Media_Audio.AudioSubmixNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioSubmixNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioSubmixNode
    };

    // ----- CreateAudioDeviceInputNodeResult class --------------------
    constexpr const char* const _type_name_CreateAudioDeviceInputNodeResult = "CreateAudioDeviceInputNodeResult";

    static PyObject* _new_CreateAudioDeviceInputNodeResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CreateAudioDeviceInputNodeResult);
        return nullptr;
    }

    static void _dealloc_CreateAudioDeviceInputNodeResult(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CreateAudioDeviceInputNodeResult_get_DeviceInputNode(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceInputNode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioDeviceInputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioDeviceInputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CreateAudioDeviceInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioDeviceInputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioDeviceInputNodeResult[] = {
        { "_from", (PyCFunction)_from_CreateAudioDeviceInputNodeResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CreateAudioDeviceInputNodeResult[] = {
        { const_cast<char*>("device_input_node"), (getter)CreateAudioDeviceInputNodeResult_get_DeviceInputNode, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)CreateAudioDeviceInputNodeResult_get_Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_error"), (getter)CreateAudioDeviceInputNodeResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CreateAudioDeviceInputNodeResult[] = 
    {
        { Py_tp_new, _new_CreateAudioDeviceInputNodeResult },
        { Py_tp_dealloc, _dealloc_CreateAudioDeviceInputNodeResult },
        { Py_tp_methods, _methods_CreateAudioDeviceInputNodeResult },
        { Py_tp_getset, _getset_CreateAudioDeviceInputNodeResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CreateAudioDeviceInputNodeResult =
    {
        "_winrt_Windows_Media_Audio.CreateAudioDeviceInputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioDeviceInputNodeResult
    };

    // ----- CreateAudioDeviceOutputNodeResult class --------------------
    constexpr const char* const _type_name_CreateAudioDeviceOutputNodeResult = "CreateAudioDeviceOutputNodeResult";

    static PyObject* _new_CreateAudioDeviceOutputNodeResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CreateAudioDeviceOutputNodeResult);
        return nullptr;
    }

    static void _dealloc_CreateAudioDeviceOutputNodeResult(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CreateAudioDeviceOutputNodeResult_get_DeviceOutputNode(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceOutputNode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioDeviceOutputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioDeviceOutputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CreateAudioDeviceOutputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioDeviceOutputNodeResult[] = {
        { "_from", (PyCFunction)_from_CreateAudioDeviceOutputNodeResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CreateAudioDeviceOutputNodeResult[] = {
        { const_cast<char*>("device_output_node"), (getter)CreateAudioDeviceOutputNodeResult_get_DeviceOutputNode, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)CreateAudioDeviceOutputNodeResult_get_Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_error"), (getter)CreateAudioDeviceOutputNodeResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CreateAudioDeviceOutputNodeResult[] = 
    {
        { Py_tp_new, _new_CreateAudioDeviceOutputNodeResult },
        { Py_tp_dealloc, _dealloc_CreateAudioDeviceOutputNodeResult },
        { Py_tp_methods, _methods_CreateAudioDeviceOutputNodeResult },
        { Py_tp_getset, _getset_CreateAudioDeviceOutputNodeResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CreateAudioDeviceOutputNodeResult =
    {
        "_winrt_Windows_Media_Audio.CreateAudioDeviceOutputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioDeviceOutputNodeResult
    };

    // ----- CreateAudioFileInputNodeResult class --------------------
    constexpr const char* const _type_name_CreateAudioFileInputNodeResult = "CreateAudioFileInputNodeResult";

    static PyObject* _new_CreateAudioFileInputNodeResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CreateAudioFileInputNodeResult);
        return nullptr;
    }

    static void _dealloc_CreateAudioFileInputNodeResult(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CreateAudioFileInputNodeResult_get_FileInputNode(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileInputNode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioFileInputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioFileInputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CreateAudioFileInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioFileInputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioFileInputNodeResult[] = {
        { "_from", (PyCFunction)_from_CreateAudioFileInputNodeResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CreateAudioFileInputNodeResult[] = {
        { const_cast<char*>("file_input_node"), (getter)CreateAudioFileInputNodeResult_get_FileInputNode, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)CreateAudioFileInputNodeResult_get_Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_error"), (getter)CreateAudioFileInputNodeResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CreateAudioFileInputNodeResult[] = 
    {
        { Py_tp_new, _new_CreateAudioFileInputNodeResult },
        { Py_tp_dealloc, _dealloc_CreateAudioFileInputNodeResult },
        { Py_tp_methods, _methods_CreateAudioFileInputNodeResult },
        { Py_tp_getset, _getset_CreateAudioFileInputNodeResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CreateAudioFileInputNodeResult =
    {
        "_winrt_Windows_Media_Audio.CreateAudioFileInputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioFileInputNodeResult
    };

    // ----- CreateAudioFileOutputNodeResult class --------------------
    constexpr const char* const _type_name_CreateAudioFileOutputNodeResult = "CreateAudioFileOutputNodeResult";

    static PyObject* _new_CreateAudioFileOutputNodeResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CreateAudioFileOutputNodeResult);
        return nullptr;
    }

    static void _dealloc_CreateAudioFileOutputNodeResult(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CreateAudioFileOutputNodeResult_get_FileOutputNode(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileOutputNode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioFileOutputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioFileOutputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CreateAudioFileOutputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioFileOutputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioFileOutputNodeResult[] = {
        { "_from", (PyCFunction)_from_CreateAudioFileOutputNodeResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CreateAudioFileOutputNodeResult[] = {
        { const_cast<char*>("file_output_node"), (getter)CreateAudioFileOutputNodeResult_get_FileOutputNode, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)CreateAudioFileOutputNodeResult_get_Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_error"), (getter)CreateAudioFileOutputNodeResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CreateAudioFileOutputNodeResult[] = 
    {
        { Py_tp_new, _new_CreateAudioFileOutputNodeResult },
        { Py_tp_dealloc, _dealloc_CreateAudioFileOutputNodeResult },
        { Py_tp_methods, _methods_CreateAudioFileOutputNodeResult },
        { Py_tp_getset, _getset_CreateAudioFileOutputNodeResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CreateAudioFileOutputNodeResult =
    {
        "_winrt_Windows_Media_Audio.CreateAudioFileOutputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioFileOutputNodeResult
    };

    // ----- CreateAudioGraphResult class --------------------
    constexpr const char* const _type_name_CreateAudioGraphResult = "CreateAudioGraphResult";

    static PyObject* _new_CreateAudioGraphResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CreateAudioGraphResult);
        return nullptr;
    }

    static void _dealloc_CreateAudioGraphResult(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CreateAudioGraphResult_get_Graph(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Graph());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioGraphResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioGraphResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CreateAudioGraphResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioGraphResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioGraphResult[] = {
        { "_from", (PyCFunction)_from_CreateAudioGraphResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CreateAudioGraphResult[] = {
        { const_cast<char*>("graph"), (getter)CreateAudioGraphResult_get_Graph, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)CreateAudioGraphResult_get_Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_error"), (getter)CreateAudioGraphResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CreateAudioGraphResult[] = 
    {
        { Py_tp_new, _new_CreateAudioGraphResult },
        { Py_tp_dealloc, _dealloc_CreateAudioGraphResult },
        { Py_tp_methods, _methods_CreateAudioGraphResult },
        { Py_tp_getset, _getset_CreateAudioGraphResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CreateAudioGraphResult =
    {
        "_winrt_Windows_Media_Audio.CreateAudioGraphResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioGraphResult
    };

    // ----- CreateMediaSourceAudioInputNodeResult class --------------------
    constexpr const char* const _type_name_CreateMediaSourceAudioInputNodeResult = "CreateMediaSourceAudioInputNodeResult";

    static PyObject* _new_CreateMediaSourceAudioInputNodeResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CreateMediaSourceAudioInputNodeResult);
        return nullptr;
    }

    static void _dealloc_CreateMediaSourceAudioInputNodeResult(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CreateMediaSourceAudioInputNodeResult_get_Node(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Node());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateMediaSourceAudioInputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateMediaSourceAudioInputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CreateMediaSourceAudioInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateMediaSourceAudioInputNodeResult[] = {
        { "_from", (PyCFunction)_from_CreateMediaSourceAudioInputNodeResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CreateMediaSourceAudioInputNodeResult[] = {
        { const_cast<char*>("node"), (getter)CreateMediaSourceAudioInputNodeResult_get_Node, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)CreateMediaSourceAudioInputNodeResult_get_Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_error"), (getter)CreateMediaSourceAudioInputNodeResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CreateMediaSourceAudioInputNodeResult[] = 
    {
        { Py_tp_new, _new_CreateMediaSourceAudioInputNodeResult },
        { Py_tp_dealloc, _dealloc_CreateMediaSourceAudioInputNodeResult },
        { Py_tp_methods, _methods_CreateMediaSourceAudioInputNodeResult },
        { Py_tp_getset, _getset_CreateMediaSourceAudioInputNodeResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CreateMediaSourceAudioInputNodeResult =
    {
        "_winrt_Windows_Media_Audio.CreateMediaSourceAudioInputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateMediaSourceAudioInputNodeResult
    };

    // ----- EchoEffectDefinition class --------------------
    constexpr const char* const _type_name_EchoEffectDefinition = "EchoEffectDefinition";

    static PyObject* _new_EchoEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                winrt::Windows::Media::Audio::EchoEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EchoEffectDefinition(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EchoEffectDefinition_get_WetDryMix(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WetDryMix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EchoEffectDefinition_put_WetDryMix(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.WetDryMix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EchoEffectDefinition_get_Feedback(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Feedback());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EchoEffectDefinition_put_Feedback(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Feedback(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EchoEffectDefinition_get_Delay(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Delay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EchoEffectDefinition_put_Delay(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Delay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EchoEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EchoEffectDefinition_get_Properties(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EchoEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::EchoEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EchoEffectDefinition[] = {
        { "_from", (PyCFunction)_from_EchoEffectDefinition, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EchoEffectDefinition[] = {
        { const_cast<char*>("wet_dry_mix"), (getter)EchoEffectDefinition_get_WetDryMix, (setter)EchoEffectDefinition_put_WetDryMix, nullptr, nullptr },
        { const_cast<char*>("feedback"), (getter)EchoEffectDefinition_get_Feedback, (setter)EchoEffectDefinition_put_Feedback, nullptr, nullptr },
        { const_cast<char*>("delay"), (getter)EchoEffectDefinition_get_Delay, (setter)EchoEffectDefinition_put_Delay, nullptr, nullptr },
        { const_cast<char*>("activatable_class_id"), (getter)EchoEffectDefinition_get_ActivatableClassId, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)EchoEffectDefinition_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EchoEffectDefinition[] = 
    {
        { Py_tp_new, _new_EchoEffectDefinition },
        { Py_tp_dealloc, _dealloc_EchoEffectDefinition },
        { Py_tp_methods, _methods_EchoEffectDefinition },
        { Py_tp_getset, _getset_EchoEffectDefinition },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EchoEffectDefinition =
    {
        "_winrt_Windows_Media_Audio.EchoEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Audio::EchoEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EchoEffectDefinition
    };

    // ----- EqualizerBand class --------------------
    constexpr const char* const _type_name_EqualizerBand = "EqualizerBand";

    static PyObject* _new_EqualizerBand(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EqualizerBand);
        return nullptr;
    }

    static void _dealloc_EqualizerBand(py::wrapper::Windows::Media::Audio::EqualizerBand* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EqualizerBand_get_Gain(py::wrapper::Windows::Media::Audio::EqualizerBand* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Gain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EqualizerBand_put_Gain(py::wrapper::Windows::Media::Audio::EqualizerBand* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Gain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EqualizerBand_get_FrequencyCenter(py::wrapper::Windows::Media::Audio::EqualizerBand* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrequencyCenter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EqualizerBand_put_FrequencyCenter(py::wrapper::Windows::Media::Audio::EqualizerBand* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.FrequencyCenter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EqualizerBand_get_Bandwidth(py::wrapper::Windows::Media::Audio::EqualizerBand* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bandwidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EqualizerBand_put_Bandwidth(py::wrapper::Windows::Media::Audio::EqualizerBand* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Bandwidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_EqualizerBand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::EqualizerBand>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EqualizerBand[] = {
        { "_from", (PyCFunction)_from_EqualizerBand, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EqualizerBand[] = {
        { const_cast<char*>("gain"), (getter)EqualizerBand_get_Gain, (setter)EqualizerBand_put_Gain, nullptr, nullptr },
        { const_cast<char*>("frequency_center"), (getter)EqualizerBand_get_FrequencyCenter, (setter)EqualizerBand_put_FrequencyCenter, nullptr, nullptr },
        { const_cast<char*>("bandwidth"), (getter)EqualizerBand_get_Bandwidth, (setter)EqualizerBand_put_Bandwidth, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EqualizerBand[] = 
    {
        { Py_tp_new, _new_EqualizerBand },
        { Py_tp_dealloc, _dealloc_EqualizerBand },
        { Py_tp_methods, _methods_EqualizerBand },
        { Py_tp_getset, _getset_EqualizerBand },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EqualizerBand =
    {
        "_winrt_Windows_Media_Audio.EqualizerBand",
        sizeof(py::wrapper::Windows::Media::Audio::EqualizerBand),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EqualizerBand
    };

    // ----- EqualizerEffectDefinition class --------------------
    constexpr const char* const _type_name_EqualizerEffectDefinition = "EqualizerEffectDefinition";

    static PyObject* _new_EqualizerEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                winrt::Windows::Media::Audio::EqualizerEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EqualizerEffectDefinition(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EqualizerEffectDefinition_get_Bands(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EqualizerEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EqualizerEffectDefinition_get_Properties(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EqualizerEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::EqualizerEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EqualizerEffectDefinition[] = {
        { "_from", (PyCFunction)_from_EqualizerEffectDefinition, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EqualizerEffectDefinition[] = {
        { const_cast<char*>("bands"), (getter)EqualizerEffectDefinition_get_Bands, nullptr, nullptr, nullptr },
        { const_cast<char*>("activatable_class_id"), (getter)EqualizerEffectDefinition_get_ActivatableClassId, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)EqualizerEffectDefinition_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EqualizerEffectDefinition[] = 
    {
        { Py_tp_new, _new_EqualizerEffectDefinition },
        { Py_tp_dealloc, _dealloc_EqualizerEffectDefinition },
        { Py_tp_methods, _methods_EqualizerEffectDefinition },
        { Py_tp_getset, _getset_EqualizerEffectDefinition },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EqualizerEffectDefinition =
    {
        "_winrt_Windows_Media_Audio.EqualizerEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EqualizerEffectDefinition
    };

    // ----- FrameInputNodeQuantumStartedEventArgs class --------------------
    constexpr const char* const _type_name_FrameInputNodeQuantumStartedEventArgs = "FrameInputNodeQuantumStartedEventArgs";

    static PyObject* _new_FrameInputNodeQuantumStartedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameInputNodeQuantumStartedEventArgs);
        return nullptr;
    }

    static void _dealloc_FrameInputNodeQuantumStartedEventArgs(py::wrapper::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameInputNodeQuantumStartedEventArgs_get_RequiredSamples(py::wrapper::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequiredSamples());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FrameInputNodeQuantumStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameInputNodeQuantumStartedEventArgs[] = {
        { "_from", (PyCFunction)_from_FrameInputNodeQuantumStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FrameInputNodeQuantumStartedEventArgs[] = {
        { const_cast<char*>("required_samples"), (getter)FrameInputNodeQuantumStartedEventArgs_get_RequiredSamples, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FrameInputNodeQuantumStartedEventArgs[] = 
    {
        { Py_tp_new, _new_FrameInputNodeQuantumStartedEventArgs },
        { Py_tp_dealloc, _dealloc_FrameInputNodeQuantumStartedEventArgs },
        { Py_tp_methods, _methods_FrameInputNodeQuantumStartedEventArgs },
        { Py_tp_getset, _getset_FrameInputNodeQuantumStartedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameInputNodeQuantumStartedEventArgs =
    {
        "_winrt_Windows_Media_Audio.FrameInputNodeQuantumStartedEventArgs",
        sizeof(py::wrapper::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameInputNodeQuantumStartedEventArgs
    };

    // ----- LimiterEffectDefinition class --------------------
    constexpr const char* const _type_name_LimiterEffectDefinition = "LimiterEffectDefinition";

    static PyObject* _new_LimiterEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                winrt::Windows::Media::Audio::LimiterEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LimiterEffectDefinition(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LimiterEffectDefinition_get_Release(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LimiterEffectDefinition_put_Release(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Release(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LimiterEffectDefinition_get_Loudness(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Loudness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LimiterEffectDefinition_put_Loudness(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Loudness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LimiterEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LimiterEffectDefinition_get_Properties(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LimiterEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::LimiterEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LimiterEffectDefinition[] = {
        { "_from", (PyCFunction)_from_LimiterEffectDefinition, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LimiterEffectDefinition[] = {
        { const_cast<char*>("release"), (getter)LimiterEffectDefinition_get_Release, (setter)LimiterEffectDefinition_put_Release, nullptr, nullptr },
        { const_cast<char*>("loudness"), (getter)LimiterEffectDefinition_get_Loudness, (setter)LimiterEffectDefinition_put_Loudness, nullptr, nullptr },
        { const_cast<char*>("activatable_class_id"), (getter)LimiterEffectDefinition_get_ActivatableClassId, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)LimiterEffectDefinition_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LimiterEffectDefinition[] = 
    {
        { Py_tp_new, _new_LimiterEffectDefinition },
        { Py_tp_dealloc, _dealloc_LimiterEffectDefinition },
        { Py_tp_methods, _methods_LimiterEffectDefinition },
        { Py_tp_getset, _getset_LimiterEffectDefinition },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LimiterEffectDefinition =
    {
        "_winrt_Windows_Media_Audio.LimiterEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LimiterEffectDefinition
    };

    // ----- MediaSourceAudioInputNode class --------------------
    constexpr const char* const _type_name_MediaSourceAudioInputNode = "MediaSourceAudioInputNode";

    static PyObject* _new_MediaSourceAudioInputNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaSourceAudioInputNode);
        return nullptr;
    }

    static void _dealloc_MediaSourceAudioInputNode(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaSourceAudioInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Close(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Reset(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Seek(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Start(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Stop(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_Emitter(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_StartTime(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_StartTime(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackSpeedFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.PlaybackSpeedFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_LoopCount(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LoopCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_LoopCount(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.LoopCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_EndTime(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_EndTime(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.EndTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_Duration(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_MediaSource(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_Position(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_add_MediaSourceCompleted(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::MediaSourceAudioInputNode, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.MediaSourceCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_remove_MediaSourceCompleted(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MediaSourceCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaSourceAudioInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::MediaSourceAudioInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaSourceAudioInputNode(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_MediaSourceAudioInputNode(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceAudioInputNode[] = {
        { "add_outgoing_connection", (PyCFunction)MediaSourceAudioInputNode_AddOutgoingConnection, METH_VARARGS, nullptr },
        { "close", (PyCFunction)MediaSourceAudioInputNode_Close, METH_VARARGS, nullptr },
        { "disable_effects_by_definition", (PyCFunction)MediaSourceAudioInputNode_DisableEffectsByDefinition, METH_VARARGS, nullptr },
        { "enable_effects_by_definition", (PyCFunction)MediaSourceAudioInputNode_EnableEffectsByDefinition, METH_VARARGS, nullptr },
        { "remove_outgoing_connection", (PyCFunction)MediaSourceAudioInputNode_RemoveOutgoingConnection, METH_VARARGS, nullptr },
        { "reset", (PyCFunction)MediaSourceAudioInputNode_Reset, METH_VARARGS, nullptr },
        { "seek", (PyCFunction)MediaSourceAudioInputNode_Seek, METH_VARARGS, nullptr },
        { "start", (PyCFunction)MediaSourceAudioInputNode_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)MediaSourceAudioInputNode_Stop, METH_VARARGS, nullptr },
        { "add_media_source_completed", (PyCFunction)MediaSourceAudioInputNode_add_MediaSourceCompleted, METH_O, nullptr },
        { "remove_media_source_completed", (PyCFunction)MediaSourceAudioInputNode_remove_MediaSourceCompleted, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MediaSourceAudioInputNode, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_MediaSourceAudioInputNode, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_MediaSourceAudioInputNode, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaSourceAudioInputNode[] = {
        { const_cast<char*>("outgoing_connections"), (getter)MediaSourceAudioInputNode_get_OutgoingConnections, nullptr, nullptr, nullptr },
        { const_cast<char*>("emitter"), (getter)MediaSourceAudioInputNode_get_Emitter, nullptr, nullptr, nullptr },
        { const_cast<char*>("outgoing_gain"), (getter)MediaSourceAudioInputNode_get_OutgoingGain, (setter)MediaSourceAudioInputNode_put_OutgoingGain, nullptr, nullptr },
        { const_cast<char*>("consume_input"), (getter)MediaSourceAudioInputNode_get_ConsumeInput, (setter)MediaSourceAudioInputNode_put_ConsumeInput, nullptr, nullptr },
        { const_cast<char*>("effect_definitions"), (getter)MediaSourceAudioInputNode_get_EffectDefinitions, nullptr, nullptr, nullptr },
        { const_cast<char*>("encoding_properties"), (getter)MediaSourceAudioInputNode_get_EncodingProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("start_time"), (getter)MediaSourceAudioInputNode_get_StartTime, (setter)MediaSourceAudioInputNode_put_StartTime, nullptr, nullptr },
        { const_cast<char*>("playback_speed_factor"), (getter)MediaSourceAudioInputNode_get_PlaybackSpeedFactor, (setter)MediaSourceAudioInputNode_put_PlaybackSpeedFactor, nullptr, nullptr },
        { const_cast<char*>("loop_count"), (getter)MediaSourceAudioInputNode_get_LoopCount, (setter)MediaSourceAudioInputNode_put_LoopCount, nullptr, nullptr },
        { const_cast<char*>("end_time"), (getter)MediaSourceAudioInputNode_get_EndTime, (setter)MediaSourceAudioInputNode_put_EndTime, nullptr, nullptr },
        { const_cast<char*>("duration"), (getter)MediaSourceAudioInputNode_get_Duration, nullptr, nullptr, nullptr },
        { const_cast<char*>("media_source"), (getter)MediaSourceAudioInputNode_get_MediaSource, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)MediaSourceAudioInputNode_get_Position, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaSourceAudioInputNode[] = 
    {
        { Py_tp_new, _new_MediaSourceAudioInputNode },
        { Py_tp_dealloc, _dealloc_MediaSourceAudioInputNode },
        { Py_tp_methods, _methods_MediaSourceAudioInputNode },
        { Py_tp_getset, _getset_MediaSourceAudioInputNode },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaSourceAudioInputNode =
    {
        "_winrt_Windows_Media_Audio.MediaSourceAudioInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceAudioInputNode
    };

    // ----- ReverbEffectDefinition class --------------------
    constexpr const char* const _type_name_ReverbEffectDefinition = "ReverbEffectDefinition";

    static PyObject* _new_ReverbEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                winrt::Windows::Media::Audio::ReverbEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ReverbEffectDefinition(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ReverbEffectDefinition_get_HighEQGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HighEQGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_HighEQGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.HighEQGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_HighEQCutoff(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HighEQCutoff());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_HighEQCutoff(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.HighEQCutoff(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_DisableLateField(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisableLateField());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_DisableLateField(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DisableLateField(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_Density(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Density());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_Density(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Density(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_PositionRight(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PositionRight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_PositionRight(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.PositionRight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_DecayTime(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecayTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_DecayTime(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DecayTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_LateDiffusion(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LateDiffusion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_LateDiffusion(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.LateDiffusion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_PositionMatrixRight(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PositionMatrixRight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_PositionMatrixRight(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.PositionMatrixRight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_PositionMatrixLeft(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PositionMatrixLeft());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_PositionMatrixLeft(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.PositionMatrixLeft(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_PositionLeft(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PositionLeft());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_PositionLeft(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.PositionLeft(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_LowEQGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LowEQGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_LowEQGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.LowEQGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_LowEQCutoff(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LowEQCutoff());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_LowEQCutoff(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.LowEQCutoff(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RoomFilterFreq(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoomFilterFreq());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RoomFilterFreq(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RoomFilterFreq(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ReverbGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReverbGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_ReverbGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ReverbGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ReverbDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReverbDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_ReverbDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.ReverbDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ReflectionsGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReflectionsGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_ReflectionsGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ReflectionsGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ReflectionsDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReflectionsDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_ReflectionsDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReflectionsDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RearDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RearDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RearDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.RearDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_WetDryMix(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WetDryMix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_WetDryMix(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.WetDryMix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_EarlyDiffusion(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EarlyDiffusion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_EarlyDiffusion(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.EarlyDiffusion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RoomSize(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoomSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RoomSize(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RoomSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RoomFilterMain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoomFilterMain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RoomFilterMain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RoomFilterMain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RoomFilterHF(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoomFilterHF());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RoomFilterHF(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RoomFilterHF(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReverbEffectDefinition_get_Properties(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ReverbEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::ReverbEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ReverbEffectDefinition[] = {
        { "_from", (PyCFunction)_from_ReverbEffectDefinition, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ReverbEffectDefinition[] = {
        { const_cast<char*>("high_e_q_gain"), (getter)ReverbEffectDefinition_get_HighEQGain, (setter)ReverbEffectDefinition_put_HighEQGain, nullptr, nullptr },
        { const_cast<char*>("high_e_q_cutoff"), (getter)ReverbEffectDefinition_get_HighEQCutoff, (setter)ReverbEffectDefinition_put_HighEQCutoff, nullptr, nullptr },
        { const_cast<char*>("disable_late_field"), (getter)ReverbEffectDefinition_get_DisableLateField, (setter)ReverbEffectDefinition_put_DisableLateField, nullptr, nullptr },
        { const_cast<char*>("density"), (getter)ReverbEffectDefinition_get_Density, (setter)ReverbEffectDefinition_put_Density, nullptr, nullptr },
        { const_cast<char*>("position_right"), (getter)ReverbEffectDefinition_get_PositionRight, (setter)ReverbEffectDefinition_put_PositionRight, nullptr, nullptr },
        { const_cast<char*>("decay_time"), (getter)ReverbEffectDefinition_get_DecayTime, (setter)ReverbEffectDefinition_put_DecayTime, nullptr, nullptr },
        { const_cast<char*>("late_diffusion"), (getter)ReverbEffectDefinition_get_LateDiffusion, (setter)ReverbEffectDefinition_put_LateDiffusion, nullptr, nullptr },
        { const_cast<char*>("position_matrix_right"), (getter)ReverbEffectDefinition_get_PositionMatrixRight, (setter)ReverbEffectDefinition_put_PositionMatrixRight, nullptr, nullptr },
        { const_cast<char*>("position_matrix_left"), (getter)ReverbEffectDefinition_get_PositionMatrixLeft, (setter)ReverbEffectDefinition_put_PositionMatrixLeft, nullptr, nullptr },
        { const_cast<char*>("position_left"), (getter)ReverbEffectDefinition_get_PositionLeft, (setter)ReverbEffectDefinition_put_PositionLeft, nullptr, nullptr },
        { const_cast<char*>("low_e_q_gain"), (getter)ReverbEffectDefinition_get_LowEQGain, (setter)ReverbEffectDefinition_put_LowEQGain, nullptr, nullptr },
        { const_cast<char*>("low_e_q_cutoff"), (getter)ReverbEffectDefinition_get_LowEQCutoff, (setter)ReverbEffectDefinition_put_LowEQCutoff, nullptr, nullptr },
        { const_cast<char*>("room_filter_freq"), (getter)ReverbEffectDefinition_get_RoomFilterFreq, (setter)ReverbEffectDefinition_put_RoomFilterFreq, nullptr, nullptr },
        { const_cast<char*>("reverb_gain"), (getter)ReverbEffectDefinition_get_ReverbGain, (setter)ReverbEffectDefinition_put_ReverbGain, nullptr, nullptr },
        { const_cast<char*>("reverb_delay"), (getter)ReverbEffectDefinition_get_ReverbDelay, (setter)ReverbEffectDefinition_put_ReverbDelay, nullptr, nullptr },
        { const_cast<char*>("reflections_gain"), (getter)ReverbEffectDefinition_get_ReflectionsGain, (setter)ReverbEffectDefinition_put_ReflectionsGain, nullptr, nullptr },
        { const_cast<char*>("reflections_delay"), (getter)ReverbEffectDefinition_get_ReflectionsDelay, (setter)ReverbEffectDefinition_put_ReflectionsDelay, nullptr, nullptr },
        { const_cast<char*>("rear_delay"), (getter)ReverbEffectDefinition_get_RearDelay, (setter)ReverbEffectDefinition_put_RearDelay, nullptr, nullptr },
        { const_cast<char*>("wet_dry_mix"), (getter)ReverbEffectDefinition_get_WetDryMix, (setter)ReverbEffectDefinition_put_WetDryMix, nullptr, nullptr },
        { const_cast<char*>("early_diffusion"), (getter)ReverbEffectDefinition_get_EarlyDiffusion, (setter)ReverbEffectDefinition_put_EarlyDiffusion, nullptr, nullptr },
        { const_cast<char*>("room_size"), (getter)ReverbEffectDefinition_get_RoomSize, (setter)ReverbEffectDefinition_put_RoomSize, nullptr, nullptr },
        { const_cast<char*>("room_filter_main"), (getter)ReverbEffectDefinition_get_RoomFilterMain, (setter)ReverbEffectDefinition_put_RoomFilterMain, nullptr, nullptr },
        { const_cast<char*>("room_filter_h_f"), (getter)ReverbEffectDefinition_get_RoomFilterHF, (setter)ReverbEffectDefinition_put_RoomFilterHF, nullptr, nullptr },
        { const_cast<char*>("activatable_class_id"), (getter)ReverbEffectDefinition_get_ActivatableClassId, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)ReverbEffectDefinition_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ReverbEffectDefinition[] = 
    {
        { Py_tp_new, _new_ReverbEffectDefinition },
        { Py_tp_dealloc, _dealloc_ReverbEffectDefinition },
        { Py_tp_methods, _methods_ReverbEffectDefinition },
        { Py_tp_getset, _getset_ReverbEffectDefinition },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ReverbEffectDefinition =
    {
        "_winrt_Windows_Media_Audio.ReverbEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ReverbEffectDefinition
    };

    // ----- SetDefaultSpatialAudioFormatResult class --------------------
    constexpr const char* const _type_name_SetDefaultSpatialAudioFormatResult = "SetDefaultSpatialAudioFormatResult";

    static PyObject* _new_SetDefaultSpatialAudioFormatResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SetDefaultSpatialAudioFormatResult);
        return nullptr;
    }

    static void _dealloc_SetDefaultSpatialAudioFormatResult(py::wrapper::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SetDefaultSpatialAudioFormatResult_get_Status(py::wrapper::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SetDefaultSpatialAudioFormatResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SetDefaultSpatialAudioFormatResult[] = {
        { "_from", (PyCFunction)_from_SetDefaultSpatialAudioFormatResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SetDefaultSpatialAudioFormatResult[] = {
        { const_cast<char*>("status"), (getter)SetDefaultSpatialAudioFormatResult_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SetDefaultSpatialAudioFormatResult[] = 
    {
        { Py_tp_new, _new_SetDefaultSpatialAudioFormatResult },
        { Py_tp_dealloc, _dealloc_SetDefaultSpatialAudioFormatResult },
        { Py_tp_methods, _methods_SetDefaultSpatialAudioFormatResult },
        { Py_tp_getset, _getset_SetDefaultSpatialAudioFormatResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SetDefaultSpatialAudioFormatResult =
    {
        "_winrt_Windows_Media_Audio.SetDefaultSpatialAudioFormatResult",
        sizeof(py::wrapper::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SetDefaultSpatialAudioFormatResult
    };

    // ----- SpatialAudioDeviceConfiguration class --------------------
    constexpr const char* const _type_name_SpatialAudioDeviceConfiguration = "SpatialAudioDeviceConfiguration";

    static PyObject* _new_SpatialAudioDeviceConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpatialAudioDeviceConfiguration);
        return nullptr;
    }

    static void _dealloc_SpatialAudioDeviceConfiguration(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpatialAudioDeviceConfiguration_GetForDeviceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration::GetForDeviceId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_IsSpatialAudioFormatSupported(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsSpatialAudioFormatSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_SetDefaultSpatialAudioFormatAsync(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetDefaultSpatialAudioFormatAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_get_ActiveSpatialAudioFormat(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActiveSpatialAudioFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_get_DefaultSpatialAudioFormat(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DefaultSpatialAudioFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_get_DeviceId(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_get_IsSpatialAudioSupported(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSpatialAudioSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_add_ConfigurationChanged(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ConfigurationChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_remove_ConfigurationChanged(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConfigurationChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpatialAudioDeviceConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialAudioDeviceConfiguration[] = {
        { "get_for_device_id", (PyCFunction)SpatialAudioDeviceConfiguration_GetForDeviceId, METH_VARARGS | METH_STATIC, nullptr },
        { "is_spatial_audio_format_supported", (PyCFunction)SpatialAudioDeviceConfiguration_IsSpatialAudioFormatSupported, METH_VARARGS, nullptr },
        { "set_default_spatial_audio_format_async", (PyCFunction)SpatialAudioDeviceConfiguration_SetDefaultSpatialAudioFormatAsync, METH_VARARGS, nullptr },
        { "add_configuration_changed", (PyCFunction)SpatialAudioDeviceConfiguration_add_ConfigurationChanged, METH_O, nullptr },
        { "remove_configuration_changed", (PyCFunction)SpatialAudioDeviceConfiguration_remove_ConfigurationChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_SpatialAudioDeviceConfiguration, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SpatialAudioDeviceConfiguration[] = {
        { const_cast<char*>("active_spatial_audio_format"), (getter)SpatialAudioDeviceConfiguration_get_ActiveSpatialAudioFormat, nullptr, nullptr, nullptr },
        { const_cast<char*>("default_spatial_audio_format"), (getter)SpatialAudioDeviceConfiguration_get_DefaultSpatialAudioFormat, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)SpatialAudioDeviceConfiguration_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_spatial_audio_supported"), (getter)SpatialAudioDeviceConfiguration_get_IsSpatialAudioSupported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SpatialAudioDeviceConfiguration[] = 
    {
        { Py_tp_new, _new_SpatialAudioDeviceConfiguration },
        { Py_tp_dealloc, _dealloc_SpatialAudioDeviceConfiguration },
        { Py_tp_methods, _methods_SpatialAudioDeviceConfiguration },
        { Py_tp_getset, _getset_SpatialAudioDeviceConfiguration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpatialAudioDeviceConfiguration =
    {
        "_winrt_Windows_Media_Audio.SpatialAudioDeviceConfiguration",
        sizeof(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialAudioDeviceConfiguration
    };

    // ----- SpatialAudioFormatConfiguration class --------------------
    constexpr const char* const _type_name_SpatialAudioFormatConfiguration = "SpatialAudioFormatConfiguration";

    static PyObject* _new_SpatialAudioFormatConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpatialAudioFormatConfiguration);
        return nullptr;
    }

    static void _dealloc_SpatialAudioFormatConfiguration(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpatialAudioFormatConfiguration_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatConfiguration_ReportConfigurationChangedAsync(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ReportConfigurationChangedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatConfiguration_ReportLicenseChangedAsync(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ReportLicenseChangedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatConfiguration_get_MixedRealityExclusiveModePolicy(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MixedRealityExclusiveModePolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpatialAudioFormatConfiguration_put_MixedRealityExclusiveModePolicy(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Audio::MixedRealitySpatialAudioFormatPolicy>(arg);

            self->obj.MixedRealityExclusiveModePolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_SpatialAudioFormatConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialAudioFormatConfiguration[] = {
        { "get_default", (PyCFunction)SpatialAudioFormatConfiguration_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "report_configuration_changed_async", (PyCFunction)SpatialAudioFormatConfiguration_ReportConfigurationChangedAsync, METH_VARARGS, nullptr },
        { "report_license_changed_async", (PyCFunction)SpatialAudioFormatConfiguration_ReportLicenseChangedAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_SpatialAudioFormatConfiguration, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SpatialAudioFormatConfiguration[] = {
        { const_cast<char*>("mixed_reality_exclusive_mode_policy"), (getter)SpatialAudioFormatConfiguration_get_MixedRealityExclusiveModePolicy, (setter)SpatialAudioFormatConfiguration_put_MixedRealityExclusiveModePolicy, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SpatialAudioFormatConfiguration[] = 
    {
        { Py_tp_new, _new_SpatialAudioFormatConfiguration },
        { Py_tp_dealloc, _dealloc_SpatialAudioFormatConfiguration },
        { Py_tp_methods, _methods_SpatialAudioFormatConfiguration },
        { Py_tp_getset, _getset_SpatialAudioFormatConfiguration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpatialAudioFormatConfiguration =
    {
        "_winrt_Windows_Media_Audio.SpatialAudioFormatConfiguration",
        sizeof(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialAudioFormatConfiguration
    };

    // ----- SpatialAudioFormatSubtype class --------------------
    constexpr const char* const _type_name_SpatialAudioFormatSubtype = "SpatialAudioFormatSubtype";

    static PyObject* _new_SpatialAudioFormatSubtype(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpatialAudioFormatSubtype);
        return nullptr;
    }

    static PyObject* SpatialAudioFormatSubtype_get_DTSHeadphoneX(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DTSHeadphoneX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DTSXUltra(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DTSXUltra());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DolbyAtmosForHeadphones(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DolbyAtmosForHeadphones());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DolbyAtmosForHomeTheater(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DolbyAtmosForHomeTheater());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DolbyAtmosForSpeakers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DolbyAtmosForSpeakers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_WindowsSonic(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::WindowsSonic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DTSXForHomeTheater(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DTSXForHomeTheater());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialAudioFormatSubtype[] = {
        { "get_d_t_s_headphone_x", (PyCFunction)SpatialAudioFormatSubtype_get_DTSHeadphoneX, METH_NOARGS | METH_STATIC, nullptr },
        { "get_d_t_s_x_ultra", (PyCFunction)SpatialAudioFormatSubtype_get_DTSXUltra, METH_NOARGS | METH_STATIC, nullptr },
        { "get_dolby_atmos_for_headphones", (PyCFunction)SpatialAudioFormatSubtype_get_DolbyAtmosForHeadphones, METH_NOARGS | METH_STATIC, nullptr },
        { "get_dolby_atmos_for_home_theater", (PyCFunction)SpatialAudioFormatSubtype_get_DolbyAtmosForHomeTheater, METH_NOARGS | METH_STATIC, nullptr },
        { "get_dolby_atmos_for_speakers", (PyCFunction)SpatialAudioFormatSubtype_get_DolbyAtmosForSpeakers, METH_NOARGS | METH_STATIC, nullptr },
        { "get_windows_sonic", (PyCFunction)SpatialAudioFormatSubtype_get_WindowsSonic, METH_NOARGS | METH_STATIC, nullptr },
        { "get_d_t_s_x_for_home_theater", (PyCFunction)SpatialAudioFormatSubtype_get_DTSXForHomeTheater, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SpatialAudioFormatSubtype[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_SpatialAudioFormatSubtype[] = 
    {
        { Py_tp_new, _new_SpatialAudioFormatSubtype },
        { Py_tp_methods, _methods_SpatialAudioFormatSubtype },
        { Py_tp_getset, _getset_SpatialAudioFormatSubtype },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpatialAudioFormatSubtype =
    {
        "_winrt_Windows_Media_Audio.SpatialAudioFormatSubtype",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialAudioFormatSubtype
    };

    // ----- IAudioInputNode interface --------------------
    constexpr const char* const _type_name_IAudioInputNode = "IAudioInputNode";

    static PyObject* _new_IAudioInputNode(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IAudioInputNode);
        return nullptr;
    }

    static void _dealloc_IAudioInputNode(py::wrapper::Windows::Media::Audio::IAudioInputNode* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IAudioInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_Close(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_Reset(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_Start(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_Stop(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IAudioInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::IAudioInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IAudioInputNode(py::wrapper::Windows::Media::Audio::IAudioInputNode* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_IAudioInputNode(py::wrapper::Windows::Media::Audio::IAudioInputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioInputNode[] = {
        { "add_outgoing_connection", (PyCFunction)IAudioInputNode_AddOutgoingConnection, METH_VARARGS, nullptr },
        { "remove_outgoing_connection", (PyCFunction)IAudioInputNode_RemoveOutgoingConnection, METH_VARARGS, nullptr },
        { "disable_effects_by_definition", (PyCFunction)IAudioInputNode_DisableEffectsByDefinition, METH_VARARGS, nullptr },
        { "enable_effects_by_definition", (PyCFunction)IAudioInputNode_EnableEffectsByDefinition, METH_VARARGS, nullptr },
        { "reset", (PyCFunction)IAudioInputNode_Reset, METH_VARARGS, nullptr },
        { "start", (PyCFunction)IAudioInputNode_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)IAudioInputNode_Stop, METH_VARARGS, nullptr },
        { "close", (PyCFunction)IAudioInputNode_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IAudioInputNode, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_IAudioInputNode, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_IAudioInputNode, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IAudioInputNode[] = {
        { const_cast<char*>("outgoing_connections"), (getter)IAudioInputNode_get_OutgoingConnections, nullptr, nullptr, nullptr },
        { const_cast<char*>("consume_input"), (getter)IAudioInputNode_get_ConsumeInput, (setter)IAudioInputNode_put_ConsumeInput, nullptr, nullptr },
        { const_cast<char*>("effect_definitions"), (getter)IAudioInputNode_get_EffectDefinitions, nullptr, nullptr, nullptr },
        { const_cast<char*>("encoding_properties"), (getter)IAudioInputNode_get_EncodingProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("outgoing_gain"), (getter)IAudioInputNode_get_OutgoingGain, (setter)IAudioInputNode_put_OutgoingGain, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IAudioInputNode[] = 
    {
        { Py_tp_new, _new_IAudioInputNode },
        { Py_tp_dealloc, _dealloc_IAudioInputNode },
        { Py_tp_methods, _methods_IAudioInputNode },
        { Py_tp_getset, _getset_IAudioInputNode },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IAudioInputNode =
    {
        "_winrt_Windows_Media_Audio.IAudioInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::IAudioInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAudioInputNode
    };

    // ----- IAudioInputNode2 interface --------------------
    constexpr const char* const _type_name_IAudioInputNode2 = "IAudioInputNode2";

    static PyObject* _new_IAudioInputNode2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IAudioInputNode2);
        return nullptr;
    }

    static void _dealloc_IAudioInputNode2(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IAudioInputNode2_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_Close(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_Reset(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_Start(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_Stop(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_get_Emitter(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_get_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioInputNode2_put_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioInputNode2_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_get_EncodingProperties(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_get_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioInputNode2_put_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioInputNode2_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IAudioInputNode2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::IAudioInputNode2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IAudioInputNode2(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_IAudioInputNode2(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioInputNode2[] = {
        { "disable_effects_by_definition", (PyCFunction)IAudioInputNode2_DisableEffectsByDefinition, METH_VARARGS, nullptr },
        { "enable_effects_by_definition", (PyCFunction)IAudioInputNode2_EnableEffectsByDefinition, METH_VARARGS, nullptr },
        { "reset", (PyCFunction)IAudioInputNode2_Reset, METH_VARARGS, nullptr },
        { "start", (PyCFunction)IAudioInputNode2_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)IAudioInputNode2_Stop, METH_VARARGS, nullptr },
        { "close", (PyCFunction)IAudioInputNode2_Close, METH_VARARGS, nullptr },
        { "add_outgoing_connection", (PyCFunction)IAudioInputNode2_AddOutgoingConnection, METH_VARARGS, nullptr },
        { "remove_outgoing_connection", (PyCFunction)IAudioInputNode2_RemoveOutgoingConnection, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IAudioInputNode2, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_IAudioInputNode2, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_IAudioInputNode2, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IAudioInputNode2[] = {
        { const_cast<char*>("emitter"), (getter)IAudioInputNode2_get_Emitter, nullptr, nullptr, nullptr },
        { const_cast<char*>("consume_input"), (getter)IAudioInputNode2_get_ConsumeInput, (setter)IAudioInputNode2_put_ConsumeInput, nullptr, nullptr },
        { const_cast<char*>("effect_definitions"), (getter)IAudioInputNode2_get_EffectDefinitions, nullptr, nullptr, nullptr },
        { const_cast<char*>("encoding_properties"), (getter)IAudioInputNode2_get_EncodingProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("outgoing_gain"), (getter)IAudioInputNode2_get_OutgoingGain, (setter)IAudioInputNode2_put_OutgoingGain, nullptr, nullptr },
        { const_cast<char*>("outgoing_connections"), (getter)IAudioInputNode2_get_OutgoingConnections, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IAudioInputNode2[] = 
    {
        { Py_tp_new, _new_IAudioInputNode2 },
        { Py_tp_dealloc, _dealloc_IAudioInputNode2 },
        { Py_tp_methods, _methods_IAudioInputNode2 },
        { Py_tp_getset, _getset_IAudioInputNode2 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IAudioInputNode2 =
    {
        "_winrt_Windows_Media_Audio.IAudioInputNode2",
        sizeof(py::wrapper::Windows::Media::Audio::IAudioInputNode2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAudioInputNode2
    };

    // ----- IAudioNode interface --------------------
    constexpr const char* const _type_name_IAudioNode = "IAudioNode";

    static PyObject* _new_IAudioNode(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IAudioNode);
        return nullptr;
    }

    static void _dealloc_IAudioNode(py::wrapper::Windows::Media::Audio::IAudioNode* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IAudioNode_Close(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_Reset(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_Start(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_Stop(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::IAudioNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::IAudioNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IAudioNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::IAudioNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IAudioNode(py::wrapper::Windows::Media::Audio::IAudioNode* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_IAudioNode(py::wrapper::Windows::Media::Audio::IAudioNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioNode[] = {
        { "disable_effects_by_definition", (PyCFunction)IAudioNode_DisableEffectsByDefinition, METH_VARARGS, nullptr },
        { "enable_effects_by_definition", (PyCFunction)IAudioNode_EnableEffectsByDefinition, METH_VARARGS, nullptr },
        { "reset", (PyCFunction)IAudioNode_Reset, METH_VARARGS, nullptr },
        { "start", (PyCFunction)IAudioNode_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)IAudioNode_Stop, METH_VARARGS, nullptr },
        { "close", (PyCFunction)IAudioNode_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IAudioNode, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_IAudioNode, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_IAudioNode, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IAudioNode[] = {
        { const_cast<char*>("consume_input"), (getter)IAudioNode_get_ConsumeInput, (setter)IAudioNode_put_ConsumeInput, nullptr, nullptr },
        { const_cast<char*>("effect_definitions"), (getter)IAudioNode_get_EffectDefinitions, nullptr, nullptr, nullptr },
        { const_cast<char*>("encoding_properties"), (getter)IAudioNode_get_EncodingProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("outgoing_gain"), (getter)IAudioNode_get_OutgoingGain, (setter)IAudioNode_put_OutgoingGain, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IAudioNode[] = 
    {
        { Py_tp_new, _new_IAudioNode },
        { Py_tp_dealloc, _dealloc_IAudioNode },
        { Py_tp_methods, _methods_IAudioNode },
        { Py_tp_getset, _getset_IAudioNode },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IAudioNode =
    {
        "_winrt_Windows_Media_Audio.IAudioNode",
        sizeof(py::wrapper::Windows::Media::Audio::IAudioNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAudioNode
    };

    // ----- IAudioNodeWithListener interface --------------------
    constexpr const char* const _type_name_IAudioNodeWithListener = "IAudioNodeWithListener";

    static PyObject* _new_IAudioNodeWithListener(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IAudioNodeWithListener);
        return nullptr;
    }

    static void _dealloc_IAudioNodeWithListener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IAudioNodeWithListener_Close(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_Reset(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_Start(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_Stop(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_get_Listener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Listener());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNodeWithListener_put_Listener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeListener>(arg);

            self->obj.Listener(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioNodeWithListener_get_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNodeWithListener_put_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioNodeWithListener_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_get_EncodingProperties(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_get_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNodeWithListener_put_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IAudioNodeWithListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::IAudioNodeWithListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IAudioNodeWithListener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_IAudioNodeWithListener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioNodeWithListener[] = {
        { "close", (PyCFunction)IAudioNodeWithListener_Close, METH_VARARGS, nullptr },
        { "disable_effects_by_definition", (PyCFunction)IAudioNodeWithListener_DisableEffectsByDefinition, METH_VARARGS, nullptr },
        { "enable_effects_by_definition", (PyCFunction)IAudioNodeWithListener_EnableEffectsByDefinition, METH_VARARGS, nullptr },
        { "reset", (PyCFunction)IAudioNodeWithListener_Reset, METH_VARARGS, nullptr },
        { "start", (PyCFunction)IAudioNodeWithListener_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)IAudioNodeWithListener_Stop, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IAudioNodeWithListener, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_IAudioNodeWithListener, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_IAudioNodeWithListener, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IAudioNodeWithListener[] = {
        { const_cast<char*>("listener"), (getter)IAudioNodeWithListener_get_Listener, (setter)IAudioNodeWithListener_put_Listener, nullptr, nullptr },
        { const_cast<char*>("consume_input"), (getter)IAudioNodeWithListener_get_ConsumeInput, (setter)IAudioNodeWithListener_put_ConsumeInput, nullptr, nullptr },
        { const_cast<char*>("effect_definitions"), (getter)IAudioNodeWithListener_get_EffectDefinitions, nullptr, nullptr, nullptr },
        { const_cast<char*>("encoding_properties"), (getter)IAudioNodeWithListener_get_EncodingProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("outgoing_gain"), (getter)IAudioNodeWithListener_get_OutgoingGain, (setter)IAudioNodeWithListener_put_OutgoingGain, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IAudioNodeWithListener[] = 
    {
        { Py_tp_new, _new_IAudioNodeWithListener },
        { Py_tp_dealloc, _dealloc_IAudioNodeWithListener },
        { Py_tp_methods, _methods_IAudioNodeWithListener },
        { Py_tp_getset, _getset_IAudioNodeWithListener },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IAudioNodeWithListener =
    {
        "_winrt_Windows_Media_Audio.IAudioNodeWithListener",
        sizeof(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAudioNodeWithListener
    };

    // ----- Windows.Media.Audio Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Media::Audio::AudioDeviceInputNode>::python_type = py::register_python_type(module, _type_name_AudioDeviceInputNode, &_type_spec_AudioDeviceInputNode, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioDeviceOutputNode>::python_type = py::register_python_type(module, _type_name_AudioDeviceOutputNode, &_type_spec_AudioDeviceOutputNode, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioFileInputNode>::python_type = py::register_python_type(module, _type_name_AudioFileInputNode, &_type_spec_AudioFileInputNode, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioFileOutputNode>::python_type = py::register_python_type(module, _type_name_AudioFileOutputNode, &_type_spec_AudioFileOutputNode, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>::python_type = py::register_python_type(module, _type_name_AudioFrameCompletedEventArgs, &_type_spec_AudioFrameCompletedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioFrameInputNode>::python_type = py::register_python_type(module, _type_name_AudioFrameInputNode, &_type_spec_AudioFrameInputNode, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioFrameOutputNode>::python_type = py::register_python_type(module, _type_name_AudioFrameOutputNode, &_type_spec_AudioFrameOutputNode, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioGraph>::python_type = py::register_python_type(module, _type_name_AudioGraph, &_type_spec_AudioGraph, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioGraphBatchUpdater>::python_type = py::register_python_type(module, _type_name_AudioGraphBatchUpdater, &_type_spec_AudioGraphBatchUpdater, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioGraphConnection>::python_type = py::register_python_type(module, _type_name_AudioGraphConnection, &_type_spec_AudioGraphConnection, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioGraphSettings>::python_type = py::register_python_type(module, _type_name_AudioGraphSettings, &_type_spec_AudioGraphSettings, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>::python_type = py::register_python_type(module, _type_name_AudioGraphUnrecoverableErrorOccurredEventArgs, &_type_spec_AudioGraphUnrecoverableErrorOccurredEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitter>::python_type = py::register_python_type(module, _type_name_AudioNodeEmitter, &_type_spec_AudioNodeEmitter, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitterConeProperties>::python_type = py::register_python_type(module, _type_name_AudioNodeEmitterConeProperties, &_type_spec_AudioNodeEmitterConeProperties, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>::python_type = py::register_python_type(module, _type_name_AudioNodeEmitterDecayModel, &_type_spec_AudioNodeEmitterDecayModel, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties>::python_type = py::register_python_type(module, _type_name_AudioNodeEmitterNaturalDecayModelProperties, &_type_spec_AudioNodeEmitterNaturalDecayModelProperties, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitterShape>::python_type = py::register_python_type(module, _type_name_AudioNodeEmitterShape, &_type_spec_AudioNodeEmitterShape, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioNodeListener>::python_type = py::register_python_type(module, _type_name_AudioNodeListener, &_type_spec_AudioNodeListener, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioPlaybackConnection>::python_type = py::register_python_type(module, _type_name_AudioPlaybackConnection, &_type_spec_AudioPlaybackConnection, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioPlaybackConnectionOpenResult>::python_type = py::register_python_type(module, _type_name_AudioPlaybackConnectionOpenResult, &_type_spec_AudioPlaybackConnectionOpenResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioStateMonitor>::python_type = py::register_python_type(module, _type_name_AudioStateMonitor, &_type_spec_AudioStateMonitor, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioSubmixNode>::python_type = py::register_python_type(module, _type_name_AudioSubmixNode, &_type_spec_AudioSubmixNode, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::CreateAudioDeviceInputNodeResult>::python_type = py::register_python_type(module, _type_name_CreateAudioDeviceInputNodeResult, &_type_spec_CreateAudioDeviceInputNodeResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult>::python_type = py::register_python_type(module, _type_name_CreateAudioDeviceOutputNodeResult, &_type_spec_CreateAudioDeviceOutputNodeResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::CreateAudioFileInputNodeResult>::python_type = py::register_python_type(module, _type_name_CreateAudioFileInputNodeResult, &_type_spec_CreateAudioFileInputNodeResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::CreateAudioFileOutputNodeResult>::python_type = py::register_python_type(module, _type_name_CreateAudioFileOutputNodeResult, &_type_spec_CreateAudioFileOutputNodeResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::CreateAudioGraphResult>::python_type = py::register_python_type(module, _type_name_CreateAudioGraphResult, &_type_spec_CreateAudioGraphResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult>::python_type = py::register_python_type(module, _type_name_CreateMediaSourceAudioInputNodeResult, &_type_spec_CreateMediaSourceAudioInputNodeResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::EchoEffectDefinition>::python_type = py::register_python_type(module, _type_name_EchoEffectDefinition, &_type_spec_EchoEffectDefinition, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::EqualizerBand>::python_type = py::register_python_type(module, _type_name_EqualizerBand, &_type_spec_EqualizerBand, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::EqualizerEffectDefinition>::python_type = py::register_python_type(module, _type_name_EqualizerEffectDefinition, &_type_spec_EqualizerEffectDefinition, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>::python_type = py::register_python_type(module, _type_name_FrameInputNodeQuantumStartedEventArgs, &_type_spec_FrameInputNodeQuantumStartedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::LimiterEffectDefinition>::python_type = py::register_python_type(module, _type_name_LimiterEffectDefinition, &_type_spec_LimiterEffectDefinition, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::MediaSourceAudioInputNode>::python_type = py::register_python_type(module, _type_name_MediaSourceAudioInputNode, &_type_spec_MediaSourceAudioInputNode, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::ReverbEffectDefinition>::python_type = py::register_python_type(module, _type_name_ReverbEffectDefinition, &_type_spec_ReverbEffectDefinition, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult>::python_type = py::register_python_type(module, _type_name_SetDefaultSpatialAudioFormatResult, &_type_spec_SetDefaultSpatialAudioFormatResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration>::python_type = py::register_python_type(module, _type_name_SpatialAudioDeviceConfiguration, &_type_spec_SpatialAudioDeviceConfiguration, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration>::python_type = py::register_python_type(module, _type_name_SpatialAudioFormatConfiguration, &_type_spec_SpatialAudioFormatConfiguration, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::SpatialAudioFormatSubtype>::python_type = py::register_python_type(module, _type_name_SpatialAudioFormatSubtype, &_type_spec_SpatialAudioFormatSubtype, nullptr);
            py::winrt_type<winrt::Windows::Media::Audio::IAudioInputNode>::python_type = py::register_python_type(module, _type_name_IAudioInputNode, &_type_spec_IAudioInputNode, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::IAudioInputNode2>::python_type = py::register_python_type(module, _type_name_IAudioInputNode2, &_type_spec_IAudioInputNode2, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::IAudioNode>::python_type = py::register_python_type(module, _type_name_IAudioNode, &_type_spec_IAudioNode, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::IAudioNodeWithListener>::python_type = py::register_python_type(module, _type_name_IAudioNodeWithListener, &_type_spec_IAudioNodeWithListener, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Media.Audio");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Media_Audio",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Media::Audio

PyMODINIT_FUNC
PyInit__winrt_Windows_Media_Audio (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Media::Audio::module_def);
}
