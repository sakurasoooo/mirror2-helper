// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.ApplicationModel.Email.h"

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailAttachment>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailConversation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailConversationBatch>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailConversationReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailFolder>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailIrmInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailIrmTemplate>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailItemCounts>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailbox>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxAction>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReply>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChange>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeTracker>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxPolicies>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxSyncManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailManagerForUser>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMeetingInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMessage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMessageBatch>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMessageReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailQueryTextSearch>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailRecipient>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailRecipientResolutionResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailStore>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailStoreNotificationTriggerDetails>::python_type;

namespace py::cpp::Windows::ApplicationModel::Email
{
    // ----- EmailAttachment class --------------------
    constexpr const char* const _type_name_EmailAttachment = "EmailAttachment";

    static PyObject* _new_EmailAttachment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::ApplicationModel::Email::EmailAttachment instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 1);

                winrt::Windows::ApplicationModel::Email::EmailAttachment instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailAttachment instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailAttachment(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailAttachment_get_FileName(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_FileName(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FileName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_Data(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_Data(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Data(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_MimeType(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MimeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_MimeType(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MimeType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_IsInline(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_IsInline(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsInline(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_EstimatedDownloadSizeInBytes(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EstimatedDownloadSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_EstimatedDownloadSizeInBytes(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.EstimatedDownloadSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_DownloadState(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DownloadState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_DownloadState(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailAttachmentDownloadState>(arg);

            self->obj.DownloadState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_ContentLocation(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_ContentLocation(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContentLocation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_ContentId(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_ContentId(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContentId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_Id(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailAttachment_get_IsFromBaseMessage(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsFromBaseMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EmailAttachment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailAttachment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailAttachment[] = {
        { "_from", (PyCFunction)_from_EmailAttachment, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailAttachment[] = {
        { const_cast<char*>("file_name"), (getter)EmailAttachment_get_FileName, (setter)EmailAttachment_put_FileName, nullptr, nullptr },
        { const_cast<char*>("data"), (getter)EmailAttachment_get_Data, (setter)EmailAttachment_put_Data, nullptr, nullptr },
        { const_cast<char*>("mime_type"), (getter)EmailAttachment_get_MimeType, (setter)EmailAttachment_put_MimeType, nullptr, nullptr },
        { const_cast<char*>("is_inline"), (getter)EmailAttachment_get_IsInline, (setter)EmailAttachment_put_IsInline, nullptr, nullptr },
        { const_cast<char*>("estimated_download_size_in_bytes"), (getter)EmailAttachment_get_EstimatedDownloadSizeInBytes, (setter)EmailAttachment_put_EstimatedDownloadSizeInBytes, nullptr, nullptr },
        { const_cast<char*>("download_state"), (getter)EmailAttachment_get_DownloadState, (setter)EmailAttachment_put_DownloadState, nullptr, nullptr },
        { const_cast<char*>("content_location"), (getter)EmailAttachment_get_ContentLocation, (setter)EmailAttachment_put_ContentLocation, nullptr, nullptr },
        { const_cast<char*>("content_id"), (getter)EmailAttachment_get_ContentId, (setter)EmailAttachment_put_ContentId, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)EmailAttachment_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_from_base_message"), (getter)EmailAttachment_get_IsFromBaseMessage, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailAttachment[] = 
    {
        { Py_tp_new, _new_EmailAttachment },
        { Py_tp_dealloc, _dealloc_EmailAttachment },
        { Py_tp_methods, _methods_EmailAttachment },
        { Py_tp_getset, _getset_EmailAttachment },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailAttachment =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailAttachment",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailAttachment
    };

    // ----- EmailConversation class --------------------
    constexpr const char* const _type_name_EmailConversation = "EmailConversation";

    static PyObject* _new_EmailConversation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailConversation);
        return nullptr;
    }

    static void _dealloc_EmailConversation(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailConversation_FindMessagesAsync(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindMessagesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.FindMessagesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_FlagState(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FlagState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_HasAttachment(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasAttachment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_Id(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_Importance(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Importance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_LastEmailResponseKind(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastEmailResponseKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_LatestSender(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LatestSender());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_MailboxId(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_MessageCount(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_MostRecentMessageId(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MostRecentMessageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_MostRecentMessageTime(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MostRecentMessageTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_Preview(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Preview());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_Subject(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_UnreadMessageCount(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UnreadMessageCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EmailConversation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailConversation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailConversation[] = {
        { "find_messages_async", (PyCFunction)EmailConversation_FindMessagesAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_EmailConversation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailConversation[] = {
        { const_cast<char*>("flag_state"), (getter)EmailConversation_get_FlagState, nullptr, nullptr, nullptr },
        { const_cast<char*>("has_attachment"), (getter)EmailConversation_get_HasAttachment, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)EmailConversation_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("importance"), (getter)EmailConversation_get_Importance, nullptr, nullptr, nullptr },
        { const_cast<char*>("last_email_response_kind"), (getter)EmailConversation_get_LastEmailResponseKind, nullptr, nullptr, nullptr },
        { const_cast<char*>("latest_sender"), (getter)EmailConversation_get_LatestSender, nullptr, nullptr, nullptr },
        { const_cast<char*>("mailbox_id"), (getter)EmailConversation_get_MailboxId, nullptr, nullptr, nullptr },
        { const_cast<char*>("message_count"), (getter)EmailConversation_get_MessageCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("most_recent_message_id"), (getter)EmailConversation_get_MostRecentMessageId, nullptr, nullptr, nullptr },
        { const_cast<char*>("most_recent_message_time"), (getter)EmailConversation_get_MostRecentMessageTime, nullptr, nullptr, nullptr },
        { const_cast<char*>("preview"), (getter)EmailConversation_get_Preview, nullptr, nullptr, nullptr },
        { const_cast<char*>("subject"), (getter)EmailConversation_get_Subject, nullptr, nullptr, nullptr },
        { const_cast<char*>("unread_message_count"), (getter)EmailConversation_get_UnreadMessageCount, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailConversation[] = 
    {
        { Py_tp_new, _new_EmailConversation },
        { Py_tp_dealloc, _dealloc_EmailConversation },
        { Py_tp_methods, _methods_EmailConversation },
        { Py_tp_getset, _getset_EmailConversation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailConversation =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailConversation",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailConversation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailConversation
    };

    // ----- EmailConversationBatch class --------------------
    constexpr const char* const _type_name_EmailConversationBatch = "EmailConversationBatch";

    static PyObject* _new_EmailConversationBatch(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailConversationBatch);
        return nullptr;
    }

    static void _dealloc_EmailConversationBatch(py::wrapper::Windows::ApplicationModel::Email::EmailConversationBatch* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailConversationBatch_get_Conversations(py::wrapper::Windows::ApplicationModel::Email::EmailConversationBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Conversations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversationBatch_get_Status(py::wrapper::Windows::ApplicationModel::Email::EmailConversationBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EmailConversationBatch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailConversationBatch>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailConversationBatch[] = {
        { "_from", (PyCFunction)_from_EmailConversationBatch, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailConversationBatch[] = {
        { const_cast<char*>("conversations"), (getter)EmailConversationBatch_get_Conversations, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)EmailConversationBatch_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailConversationBatch[] = 
    {
        { Py_tp_new, _new_EmailConversationBatch },
        { Py_tp_dealloc, _dealloc_EmailConversationBatch },
        { Py_tp_methods, _methods_EmailConversationBatch },
        { Py_tp_getset, _getset_EmailConversationBatch },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailConversationBatch =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailConversationBatch",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailConversationBatch),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailConversationBatch
    };

    // ----- EmailConversationReader class --------------------
    constexpr const char* const _type_name_EmailConversationReader = "EmailConversationReader";

    static PyObject* _new_EmailConversationReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailConversationReader);
        return nullptr;
    }

    static void _dealloc_EmailConversationReader(py::wrapper::Windows::ApplicationModel::Email::EmailConversationReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailConversationReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Email::EmailConversationReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_EmailConversationReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailConversationReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailConversationReader[] = {
        { "read_batch_async", (PyCFunction)EmailConversationReader_ReadBatchAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_EmailConversationReader, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailConversationReader[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailConversationReader[] = 
    {
        { Py_tp_new, _new_EmailConversationReader },
        { Py_tp_dealloc, _dealloc_EmailConversationReader },
        { Py_tp_methods, _methods_EmailConversationReader },
        { Py_tp_getset, _getset_EmailConversationReader },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailConversationReader =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailConversationReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailConversationReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailConversationReader
    };

    // ----- EmailFolder class --------------------
    constexpr const char* const _type_name_EmailFolder = "EmailFolder";

    static PyObject* _new_EmailFolder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailFolder);
        return nullptr;
    }

    static void _dealloc_EmailFolder(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailFolder_CreateFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_DeleteAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_FindChildFoldersAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindChildFoldersAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_GetConversationReader(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConversationReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>(args, 0);

                return py::convert(self->obj.GetConversationReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_GetMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_GetMessageCountsAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetMessageCountsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_GetMessageReader(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetMessageReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>(args, 0);

                return py::convert(self->obj.GetMessageReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_SaveMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);

                return py::convert(self->obj.SaveMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_TryMoveAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailFolder>(args, 0);

                return py::convert(self->obj.TryMoveAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.TryMoveAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_TrySaveAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TrySaveAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_get_RemoteId(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailFolder_put_RemoteId(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailFolder_get_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastSuccessfulSyncTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailFolder_put_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.LastSuccessfulSyncTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailFolder_get_IsSyncEnabled(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSyncEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailFolder_put_IsSyncEnabled(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSyncEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailFolder_get_DisplayName(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailFolder_put_DisplayName(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailFolder_get_Id(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailFolder_get_Kind(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailFolder_get_MailboxId(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailFolder_get_ParentFolderId(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ParentFolderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EmailFolder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailFolder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailFolder[] = {
        { "create_folder_async", (PyCFunction)EmailFolder_CreateFolderAsync, METH_VARARGS, nullptr },
        { "delete_async", (PyCFunction)EmailFolder_DeleteAsync, METH_VARARGS, nullptr },
        { "find_child_folders_async", (PyCFunction)EmailFolder_FindChildFoldersAsync, METH_VARARGS, nullptr },
        { "get_conversation_reader", (PyCFunction)EmailFolder_GetConversationReader, METH_VARARGS, nullptr },
        { "get_message_async", (PyCFunction)EmailFolder_GetMessageAsync, METH_VARARGS, nullptr },
        { "get_message_counts_async", (PyCFunction)EmailFolder_GetMessageCountsAsync, METH_VARARGS, nullptr },
        { "get_message_reader", (PyCFunction)EmailFolder_GetMessageReader, METH_VARARGS, nullptr },
        { "save_message_async", (PyCFunction)EmailFolder_SaveMessageAsync, METH_VARARGS, nullptr },
        { "try_move_async", (PyCFunction)EmailFolder_TryMoveAsync, METH_VARARGS, nullptr },
        { "try_save_async", (PyCFunction)EmailFolder_TrySaveAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_EmailFolder, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailFolder[] = {
        { const_cast<char*>("remote_id"), (getter)EmailFolder_get_RemoteId, (setter)EmailFolder_put_RemoteId, nullptr, nullptr },
        { const_cast<char*>("last_successful_sync_time"), (getter)EmailFolder_get_LastSuccessfulSyncTime, (setter)EmailFolder_put_LastSuccessfulSyncTime, nullptr, nullptr },
        { const_cast<char*>("is_sync_enabled"), (getter)EmailFolder_get_IsSyncEnabled, (setter)EmailFolder_put_IsSyncEnabled, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)EmailFolder_get_DisplayName, (setter)EmailFolder_put_DisplayName, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)EmailFolder_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)EmailFolder_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("mailbox_id"), (getter)EmailFolder_get_MailboxId, nullptr, nullptr, nullptr },
        { const_cast<char*>("parent_folder_id"), (getter)EmailFolder_get_ParentFolderId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailFolder[] = 
    {
        { Py_tp_new, _new_EmailFolder },
        { Py_tp_dealloc, _dealloc_EmailFolder },
        { Py_tp_methods, _methods_EmailFolder },
        { Py_tp_getset, _getset_EmailFolder },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailFolder =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailFolder",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailFolder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailFolder
    };

    // ----- EmailIrmInfo class --------------------
    constexpr const char* const _type_name_EmailIrmInfo = "EmailIrmInfo";

    static PyObject* _new_EmailIrmInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailIrmTemplate>(args, 1);

                winrt::Windows::ApplicationModel::Email::EmailIrmInfo instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailIrmInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailIrmInfo(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailIrmInfo_get_CanRemoveIrmOnResponse(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanRemoveIrmOnResponse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanRemoveIrmOnResponse(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanRemoveIrmOnResponse(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_CanPrintData(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanPrintData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanPrintData(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanPrintData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_CanModifyRecipientsOnResponse(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanModifyRecipientsOnResponse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanModifyRecipientsOnResponse(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanModifyRecipientsOnResponse(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_CanForward(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanForward());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanForward(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanForward(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_CanExtractData(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanExtractData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanExtractData(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanExtractData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_CanReply(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanReply());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanReply(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanReply(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_CanEdit(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanEdit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanEdit(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanEdit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_Template(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Template());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_Template(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailIrmTemplate>(arg);

            self->obj.Template(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_IsProgramaticAccessAllowed(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsProgramaticAccessAllowed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_IsProgramaticAccessAllowed(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsProgramaticAccessAllowed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_IsIrmOriginator(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsIrmOriginator());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_IsIrmOriginator(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsIrmOriginator(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_ExpirationDate(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_ExpirationDate(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.ExpirationDate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_CanReplyAll(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanReplyAll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanReplyAll(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanReplyAll(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_EmailIrmInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailIrmInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailIrmInfo[] = {
        { "_from", (PyCFunction)_from_EmailIrmInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailIrmInfo[] = {
        { const_cast<char*>("can_remove_irm_on_response"), (getter)EmailIrmInfo_get_CanRemoveIrmOnResponse, (setter)EmailIrmInfo_put_CanRemoveIrmOnResponse, nullptr, nullptr },
        { const_cast<char*>("can_print_data"), (getter)EmailIrmInfo_get_CanPrintData, (setter)EmailIrmInfo_put_CanPrintData, nullptr, nullptr },
        { const_cast<char*>("can_modify_recipients_on_response"), (getter)EmailIrmInfo_get_CanModifyRecipientsOnResponse, (setter)EmailIrmInfo_put_CanModifyRecipientsOnResponse, nullptr, nullptr },
        { const_cast<char*>("can_forward"), (getter)EmailIrmInfo_get_CanForward, (setter)EmailIrmInfo_put_CanForward, nullptr, nullptr },
        { const_cast<char*>("can_extract_data"), (getter)EmailIrmInfo_get_CanExtractData, (setter)EmailIrmInfo_put_CanExtractData, nullptr, nullptr },
        { const_cast<char*>("can_reply"), (getter)EmailIrmInfo_get_CanReply, (setter)EmailIrmInfo_put_CanReply, nullptr, nullptr },
        { const_cast<char*>("can_edit"), (getter)EmailIrmInfo_get_CanEdit, (setter)EmailIrmInfo_put_CanEdit, nullptr, nullptr },
        { const_cast<char*>("template"), (getter)EmailIrmInfo_get_Template, (setter)EmailIrmInfo_put_Template, nullptr, nullptr },
        { const_cast<char*>("is_programatic_access_allowed"), (getter)EmailIrmInfo_get_IsProgramaticAccessAllowed, (setter)EmailIrmInfo_put_IsProgramaticAccessAllowed, nullptr, nullptr },
        { const_cast<char*>("is_irm_originator"), (getter)EmailIrmInfo_get_IsIrmOriginator, (setter)EmailIrmInfo_put_IsIrmOriginator, nullptr, nullptr },
        { const_cast<char*>("expiration_date"), (getter)EmailIrmInfo_get_ExpirationDate, (setter)EmailIrmInfo_put_ExpirationDate, nullptr, nullptr },
        { const_cast<char*>("can_reply_all"), (getter)EmailIrmInfo_get_CanReplyAll, (setter)EmailIrmInfo_put_CanReplyAll, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailIrmInfo[] = 
    {
        { Py_tp_new, _new_EmailIrmInfo },
        { Py_tp_dealloc, _dealloc_EmailIrmInfo },
        { Py_tp_methods, _methods_EmailIrmInfo },
        { Py_tp_getset, _getset_EmailIrmInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailIrmInfo =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailIrmInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailIrmInfo
    };

    // ----- EmailIrmTemplate class --------------------
    constexpr const char* const _type_name_EmailIrmTemplate = "EmailIrmTemplate";

    static PyObject* _new_EmailIrmTemplate(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::ApplicationModel::Email::EmailIrmTemplate instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailIrmTemplate instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailIrmTemplate(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailIrmTemplate_get_Name(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmTemplate_put_Name(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmTemplate_get_Id(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmTemplate_put_Id(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmTemplate_get_Description(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmTemplate_put_Description(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_EmailIrmTemplate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailIrmTemplate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailIrmTemplate[] = {
        { "_from", (PyCFunction)_from_EmailIrmTemplate, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailIrmTemplate[] = {
        { const_cast<char*>("name"), (getter)EmailIrmTemplate_get_Name, (setter)EmailIrmTemplate_put_Name, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)EmailIrmTemplate_get_Id, (setter)EmailIrmTemplate_put_Id, nullptr, nullptr },
        { const_cast<char*>("description"), (getter)EmailIrmTemplate_get_Description, (setter)EmailIrmTemplate_put_Description, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailIrmTemplate[] = 
    {
        { Py_tp_new, _new_EmailIrmTemplate },
        { Py_tp_dealloc, _dealloc_EmailIrmTemplate },
        { Py_tp_methods, _methods_EmailIrmTemplate },
        { Py_tp_getset, _getset_EmailIrmTemplate },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailIrmTemplate =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailIrmTemplate",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailIrmTemplate
    };

    // ----- EmailItemCounts class --------------------
    constexpr const char* const _type_name_EmailItemCounts = "EmailItemCounts";

    static PyObject* _new_EmailItemCounts(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailItemCounts);
        return nullptr;
    }

    static void _dealloc_EmailItemCounts(py::wrapper::Windows::ApplicationModel::Email::EmailItemCounts* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailItemCounts_get_Flagged(py::wrapper::Windows::ApplicationModel::Email::EmailItemCounts* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Flagged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailItemCounts_get_Important(py::wrapper::Windows::ApplicationModel::Email::EmailItemCounts* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Important());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailItemCounts_get_Total(py::wrapper::Windows::ApplicationModel::Email::EmailItemCounts* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Total());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailItemCounts_get_Unread(py::wrapper::Windows::ApplicationModel::Email::EmailItemCounts* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unread());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EmailItemCounts(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailItemCounts>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailItemCounts[] = {
        { "_from", (PyCFunction)_from_EmailItemCounts, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailItemCounts[] = {
        { const_cast<char*>("flagged"), (getter)EmailItemCounts_get_Flagged, nullptr, nullptr, nullptr },
        { const_cast<char*>("important"), (getter)EmailItemCounts_get_Important, nullptr, nullptr, nullptr },
        { const_cast<char*>("total"), (getter)EmailItemCounts_get_Total, nullptr, nullptr, nullptr },
        { const_cast<char*>("unread"), (getter)EmailItemCounts_get_Unread, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailItemCounts[] = 
    {
        { Py_tp_new, _new_EmailItemCounts },
        { Py_tp_dealloc, _dealloc_EmailItemCounts },
        { Py_tp_methods, _methods_EmailItemCounts },
        { Py_tp_getset, _getset_EmailItemCounts },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailItemCounts =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailItemCounts",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailItemCounts),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailItemCounts
    };

    // ----- EmailMailbox class --------------------
    constexpr const char* const _type_name_EmailMailbox = "EmailMailbox";

    static PyObject* _new_EmailMailbox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailMailbox);
        return nullptr;
    }

    static void _dealloc_EmailMailbox(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailMailbox_ChangeMessageFlagStateAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailFlagState>(args, 1);

                return py::convert(self->obj.ChangeMessageFlagStateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_CreateResponseMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageResponseKind>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageBodyKind>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);

                return py::convert(self->obj.CreateResponseMessageAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_DeleteAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_DeleteMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeleteMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_DownloadAttachmentAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DownloadAttachmentAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_DownloadMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DownloadMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetChangeTracker(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetChangeTracker(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetConversationAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetConversationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetConversationReader(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConversationReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>(args, 0);

                return py::convert(self->obj.GetConversationReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetMessageReader(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetMessageReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>(args, 0);

                return py::convert(self->obj.GetMessageReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetSpecialFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailSpecialFolderKind>(args, 0);

                return py::convert(self->obj.GetSpecialFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_MarkFolderAsSeenAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.MarkFolderAsSeenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_MarkFolderSyncEnabledAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.MarkFolderSyncEnabledAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_MarkMessageAsSeenAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.MarkMessageAsSeenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_MarkMessageReadAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.MarkMessageReadAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_RegisterSyncManagerAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RegisterSyncManagerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_ResolveRecipientsAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.ResolveRecipientsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_SaveAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.SaveAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_SaveDraftAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);

                return py::convert(self->obj.SaveDraftAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_SendMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);

                return py::convert(self->obj.SendMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.SendMessageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryCreateFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.TryCreateFolderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryDeleteFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryDeleteFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryEmptyFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryEmptyFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryForwardMeetingAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Email::EmailRecipient>>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageBodyKind>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);

                return py::convert(self->obj.TryForwardMeetingAsync(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryGetAutoReplySettingsAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReplyMessageResponseKind>(args, 0);

                return py::convert(self->obj.TryGetAutoReplySettingsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryMoveFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.TryMoveFolderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.TryMoveFolderAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryMoveMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.TryMoveMessageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryProposeNewTimeForMeetingAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);

                return py::convert(self->obj.TryProposeNewTimeForMeetingAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TrySetAutoReplySettingsAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings>(args, 0);

                return py::convert(self->obj.TrySetAutoReplySettingsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryUpdateMeetingResponseAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMeetingResponseType>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<bool>(args, 4);

                return py::convert(self->obj.TryUpdateMeetingResponseAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_ValidateCertificatesAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 0);

                return py::convert(self->obj.ValidateCertificatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_OtherAppWriteAccess(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OtherAppWriteAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailbox_put_OtherAppWriteAccess(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxOtherAppWriteAccess>(arg);

            self->obj.OtherAppWriteAccess(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailbox_get_MailAddress(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MailAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailbox_put_MailAddress(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MailAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailbox_get_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OtherAppReadAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailbox_put_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxOtherAppReadAccess>(arg);

            self->obj.OtherAppReadAccess(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailbox_get_DisplayName(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailbox_put_DisplayName(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailbox_get_Id(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_IsDataEncryptedUnderLock(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDataEncryptedUnderLock());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_IsOwnedByCurrentApp(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOwnedByCurrentApp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_MailAddressAliases(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MailAddressAliases());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_Capabilities(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_ChangeTracker(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeTracker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_Policies(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Policies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_SourceDisplayName(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_SyncManager(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SyncManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_UserDataAccountId(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserDataAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_LinkedMailboxId(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LinkedMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_NetworkAccountId(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_NetworkId(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_add_MailboxChanged(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::EmailMailbox, winrt::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs>>(arg);

            return py::convert(self->obj.MailboxChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_remove_MailboxChanged(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MailboxChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EmailMailbox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailbox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailbox[] = {
        { "change_message_flag_state_async", (PyCFunction)EmailMailbox_ChangeMessageFlagStateAsync, METH_VARARGS, nullptr },
        { "create_response_message_async", (PyCFunction)EmailMailbox_CreateResponseMessageAsync, METH_VARARGS, nullptr },
        { "delete_async", (PyCFunction)EmailMailbox_DeleteAsync, METH_VARARGS, nullptr },
        { "delete_message_async", (PyCFunction)EmailMailbox_DeleteMessageAsync, METH_VARARGS, nullptr },
        { "download_attachment_async", (PyCFunction)EmailMailbox_DownloadAttachmentAsync, METH_VARARGS, nullptr },
        { "download_message_async", (PyCFunction)EmailMailbox_DownloadMessageAsync, METH_VARARGS, nullptr },
        { "get_change_tracker", (PyCFunction)EmailMailbox_GetChangeTracker, METH_VARARGS, nullptr },
        { "get_conversation_async", (PyCFunction)EmailMailbox_GetConversationAsync, METH_VARARGS, nullptr },
        { "get_conversation_reader", (PyCFunction)EmailMailbox_GetConversationReader, METH_VARARGS, nullptr },
        { "get_folder_async", (PyCFunction)EmailMailbox_GetFolderAsync, METH_VARARGS, nullptr },
        { "get_message_async", (PyCFunction)EmailMailbox_GetMessageAsync, METH_VARARGS, nullptr },
        { "get_message_reader", (PyCFunction)EmailMailbox_GetMessageReader, METH_VARARGS, nullptr },
        { "get_special_folder_async", (PyCFunction)EmailMailbox_GetSpecialFolderAsync, METH_VARARGS, nullptr },
        { "mark_folder_as_seen_async", (PyCFunction)EmailMailbox_MarkFolderAsSeenAsync, METH_VARARGS, nullptr },
        { "mark_folder_sync_enabled_async", (PyCFunction)EmailMailbox_MarkFolderSyncEnabledAsync, METH_VARARGS, nullptr },
        { "mark_message_as_seen_async", (PyCFunction)EmailMailbox_MarkMessageAsSeenAsync, METH_VARARGS, nullptr },
        { "mark_message_read_async", (PyCFunction)EmailMailbox_MarkMessageReadAsync, METH_VARARGS, nullptr },
        { "register_sync_manager_async", (PyCFunction)EmailMailbox_RegisterSyncManagerAsync, METH_VARARGS, nullptr },
        { "resolve_recipients_async", (PyCFunction)EmailMailbox_ResolveRecipientsAsync, METH_VARARGS, nullptr },
        { "save_async", (PyCFunction)EmailMailbox_SaveAsync, METH_VARARGS, nullptr },
        { "save_draft_async", (PyCFunction)EmailMailbox_SaveDraftAsync, METH_VARARGS, nullptr },
        { "send_message_async", (PyCFunction)EmailMailbox_SendMessageAsync, METH_VARARGS, nullptr },
        { "try_create_folder_async", (PyCFunction)EmailMailbox_TryCreateFolderAsync, METH_VARARGS, nullptr },
        { "try_delete_folder_async", (PyCFunction)EmailMailbox_TryDeleteFolderAsync, METH_VARARGS, nullptr },
        { "try_empty_folder_async", (PyCFunction)EmailMailbox_TryEmptyFolderAsync, METH_VARARGS, nullptr },
        { "try_forward_meeting_async", (PyCFunction)EmailMailbox_TryForwardMeetingAsync, METH_VARARGS, nullptr },
        { "try_get_auto_reply_settings_async", (PyCFunction)EmailMailbox_TryGetAutoReplySettingsAsync, METH_VARARGS, nullptr },
        { "try_move_folder_async", (PyCFunction)EmailMailbox_TryMoveFolderAsync, METH_VARARGS, nullptr },
        { "try_move_message_async", (PyCFunction)EmailMailbox_TryMoveMessageAsync, METH_VARARGS, nullptr },
        { "try_propose_new_time_for_meeting_async", (PyCFunction)EmailMailbox_TryProposeNewTimeForMeetingAsync, METH_VARARGS, nullptr },
        { "try_set_auto_reply_settings_async", (PyCFunction)EmailMailbox_TrySetAutoReplySettingsAsync, METH_VARARGS, nullptr },
        { "try_update_meeting_response_async", (PyCFunction)EmailMailbox_TryUpdateMeetingResponseAsync, METH_VARARGS, nullptr },
        { "validate_certificates_async", (PyCFunction)EmailMailbox_ValidateCertificatesAsync, METH_VARARGS, nullptr },
        { "add_mailbox_changed", (PyCFunction)EmailMailbox_add_MailboxChanged, METH_O, nullptr },
        { "remove_mailbox_changed", (PyCFunction)EmailMailbox_remove_MailboxChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_EmailMailbox, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailMailbox[] = {
        { const_cast<char*>("other_app_write_access"), (getter)EmailMailbox_get_OtherAppWriteAccess, (setter)EmailMailbox_put_OtherAppWriteAccess, nullptr, nullptr },
        { const_cast<char*>("mail_address"), (getter)EmailMailbox_get_MailAddress, (setter)EmailMailbox_put_MailAddress, nullptr, nullptr },
        { const_cast<char*>("other_app_read_access"), (getter)EmailMailbox_get_OtherAppReadAccess, (setter)EmailMailbox_put_OtherAppReadAccess, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)EmailMailbox_get_DisplayName, (setter)EmailMailbox_put_DisplayName, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)EmailMailbox_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_data_encrypted_under_lock"), (getter)EmailMailbox_get_IsDataEncryptedUnderLock, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_owned_by_current_app"), (getter)EmailMailbox_get_IsOwnedByCurrentApp, nullptr, nullptr, nullptr },
        { const_cast<char*>("mail_address_aliases"), (getter)EmailMailbox_get_MailAddressAliases, nullptr, nullptr, nullptr },
        { const_cast<char*>("capabilities"), (getter)EmailMailbox_get_Capabilities, nullptr, nullptr, nullptr },
        { const_cast<char*>("change_tracker"), (getter)EmailMailbox_get_ChangeTracker, nullptr, nullptr, nullptr },
        { const_cast<char*>("policies"), (getter)EmailMailbox_get_Policies, nullptr, nullptr, nullptr },
        { const_cast<char*>("source_display_name"), (getter)EmailMailbox_get_SourceDisplayName, nullptr, nullptr, nullptr },
        { const_cast<char*>("sync_manager"), (getter)EmailMailbox_get_SyncManager, nullptr, nullptr, nullptr },
        { const_cast<char*>("user_data_account_id"), (getter)EmailMailbox_get_UserDataAccountId, nullptr, nullptr, nullptr },
        { const_cast<char*>("linked_mailbox_id"), (getter)EmailMailbox_get_LinkedMailboxId, nullptr, nullptr, nullptr },
        { const_cast<char*>("network_account_id"), (getter)EmailMailbox_get_NetworkAccountId, nullptr, nullptr, nullptr },
        { const_cast<char*>("network_id"), (getter)EmailMailbox_get_NetworkId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailMailbox[] = 
    {
        { Py_tp_new, _new_EmailMailbox },
        { Py_tp_dealloc, _dealloc_EmailMailbox },
        { Py_tp_methods, _methods_EmailMailbox },
        { Py_tp_getset, _getset_EmailMailbox },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailMailbox =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailMailbox",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailbox
    };

    // ----- EmailMailboxAction class --------------------
    constexpr const char* const _type_name_EmailMailboxAction = "EmailMailboxAction";

    static PyObject* _new_EmailMailboxAction(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailMailboxAction);
        return nullptr;
    }

    static void _dealloc_EmailMailboxAction(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAction* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailMailboxAction_get_ChangeNumber(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAction* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxAction_get_Kind(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAction* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EmailMailboxAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxAction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxAction[] = {
        { "_from", (PyCFunction)_from_EmailMailboxAction, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailMailboxAction[] = {
        { const_cast<char*>("change_number"), (getter)EmailMailboxAction_get_ChangeNumber, nullptr, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)EmailMailboxAction_get_Kind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailMailboxAction[] = 
    {
        { Py_tp_new, _new_EmailMailboxAction },
        { Py_tp_dealloc, _dealloc_EmailMailboxAction },
        { Py_tp_methods, _methods_EmailMailboxAction },
        { Py_tp_getset, _getset_EmailMailboxAction },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailMailboxAction =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailMailboxAction",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxAction
    };

    // ----- EmailMailboxAutoReply class --------------------
    constexpr const char* const _type_name_EmailMailboxAutoReply = "EmailMailboxAutoReply";

    static PyObject* _new_EmailMailboxAutoReply(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailMailboxAutoReply);
        return nullptr;
    }

    static void _dealloc_EmailMailboxAutoReply(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReply* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailMailboxAutoReply_get_Response(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReply* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Response());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxAutoReply_put_Response(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReply* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Response(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxAutoReply_get_IsEnabled(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReply* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxAutoReply_put_IsEnabled(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReply* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_EmailMailboxAutoReply(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReply>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxAutoReply[] = {
        { "_from", (PyCFunction)_from_EmailMailboxAutoReply, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailMailboxAutoReply[] = {
        { const_cast<char*>("response"), (getter)EmailMailboxAutoReply_get_Response, (setter)EmailMailboxAutoReply_put_Response, nullptr, nullptr },
        { const_cast<char*>("is_enabled"), (getter)EmailMailboxAutoReply_get_IsEnabled, (setter)EmailMailboxAutoReply_put_IsEnabled, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailMailboxAutoReply[] = 
    {
        { Py_tp_new, _new_EmailMailboxAutoReply },
        { Py_tp_dealloc, _dealloc_EmailMailboxAutoReply },
        { Py_tp_methods, _methods_EmailMailboxAutoReply },
        { Py_tp_getset, _getset_EmailMailboxAutoReply },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailMailboxAutoReply =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailMailboxAutoReply",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReply),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxAutoReply
    };

    // ----- EmailMailboxAutoReplySettings class --------------------
    constexpr const char* const _type_name_EmailMailboxAutoReplySettings = "EmailMailboxAutoReplySettings";

    static PyObject* _new_EmailMailboxAutoReplySettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailMailboxAutoReplySettings(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailMailboxAutoReplySettings_get_StartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxAutoReplySettings_put_StartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxAutoReplySettings_get_ResponseKind(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResponseKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxAutoReplySettings_put_ResponseKind(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReplyMessageResponseKind>(arg);

            self->obj.ResponseKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxAutoReplySettings_get_IsEnabled(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxAutoReplySettings_put_IsEnabled(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxAutoReplySettings_get_EndTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxAutoReplySettings_put_EndTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.EndTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxAutoReplySettings_get_InternalReply(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InternalReply());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxAutoReplySettings_get_KnownExternalReply(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KnownExternalReply());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxAutoReplySettings_get_UnknownExternalReply(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UnknownExternalReply());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EmailMailboxAutoReplySettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxAutoReplySettings[] = {
        { "_from", (PyCFunction)_from_EmailMailboxAutoReplySettings, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailMailboxAutoReplySettings[] = {
        { const_cast<char*>("start_time"), (getter)EmailMailboxAutoReplySettings_get_StartTime, (setter)EmailMailboxAutoReplySettings_put_StartTime, nullptr, nullptr },
        { const_cast<char*>("response_kind"), (getter)EmailMailboxAutoReplySettings_get_ResponseKind, (setter)EmailMailboxAutoReplySettings_put_ResponseKind, nullptr, nullptr },
        { const_cast<char*>("is_enabled"), (getter)EmailMailboxAutoReplySettings_get_IsEnabled, (setter)EmailMailboxAutoReplySettings_put_IsEnabled, nullptr, nullptr },
        { const_cast<char*>("end_time"), (getter)EmailMailboxAutoReplySettings_get_EndTime, (setter)EmailMailboxAutoReplySettings_put_EndTime, nullptr, nullptr },
        { const_cast<char*>("internal_reply"), (getter)EmailMailboxAutoReplySettings_get_InternalReply, nullptr, nullptr, nullptr },
        { const_cast<char*>("known_external_reply"), (getter)EmailMailboxAutoReplySettings_get_KnownExternalReply, nullptr, nullptr, nullptr },
        { const_cast<char*>("unknown_external_reply"), (getter)EmailMailboxAutoReplySettings_get_UnknownExternalReply, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailMailboxAutoReplySettings[] = 
    {
        { Py_tp_new, _new_EmailMailboxAutoReplySettings },
        { Py_tp_dealloc, _dealloc_EmailMailboxAutoReplySettings },
        { Py_tp_methods, _methods_EmailMailboxAutoReplySettings },
        { Py_tp_getset, _getset_EmailMailboxAutoReplySettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailMailboxAutoReplySettings =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailMailboxAutoReplySettings",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxAutoReplySettings
    };

    // ----- EmailMailboxCapabilities class --------------------
    constexpr const char* const _type_name_EmailMailboxCapabilities = "EmailMailboxCapabilities";

    static PyObject* _new_EmailMailboxCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailMailboxCapabilities);
        return nullptr;
    }

    static void _dealloc_EmailMailboxCapabilities(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailMailboxCapabilities_get_CanSmartSend(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanSmartSend());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanSmartSend(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanSmartSend(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanUpdateMeetingResponses(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanUpdateMeetingResponses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanUpdateMeetingResponses(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanUpdateMeetingResponses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanServerSearchMailbox(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanServerSearchMailbox());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanServerSearchMailbox(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanServerSearchMailbox(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanServerSearchFolders(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanServerSearchFolders());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanServerSearchFolders(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanServerSearchFolders(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanForwardMeetings(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanForwardMeetings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanForwardMeetings(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanForwardMeetings(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanProposeNewTimeForMeetings(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanProposeNewTimeForMeetings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanProposeNewTimeForMeetings(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanProposeNewTimeForMeetings(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanGetAndSetInternalAutoReplies(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanGetAndSetInternalAutoReplies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanGetAndSetInternalAutoReplies(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanGetAndSetInternalAutoReplies(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanGetAndSetExternalAutoReplies(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanGetAndSetExternalAutoReplies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanGetAndSetExternalAutoReplies(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanGetAndSetExternalAutoReplies(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanValidateCertificates(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanValidateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanValidateCertificates(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanValidateCertificates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanResolveRecipients(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanResolveRecipients());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanResolveRecipients(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanResolveRecipients(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanMoveFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanMoveFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanMoveFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanMoveFolder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanEmptyFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanEmptyFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanEmptyFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanEmptyFolder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanDeleteFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanDeleteFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanDeleteFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanDeleteFolder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanCreateFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanCreateFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanCreateFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanCreateFolder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_EmailMailboxCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxCapabilities[] = {
        { "_from", (PyCFunction)_from_EmailMailboxCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailMailboxCapabilities[] = {
        { const_cast<char*>("can_smart_send"), (getter)EmailMailboxCapabilities_get_CanSmartSend, (setter)EmailMailboxCapabilities_put_CanSmartSend, nullptr, nullptr },
        { const_cast<char*>("can_update_meeting_responses"), (getter)EmailMailboxCapabilities_get_CanUpdateMeetingResponses, (setter)EmailMailboxCapabilities_put_CanUpdateMeetingResponses, nullptr, nullptr },
        { const_cast<char*>("can_server_search_mailbox"), (getter)EmailMailboxCapabilities_get_CanServerSearchMailbox, (setter)EmailMailboxCapabilities_put_CanServerSearchMailbox, nullptr, nullptr },
        { const_cast<char*>("can_server_search_folders"), (getter)EmailMailboxCapabilities_get_CanServerSearchFolders, (setter)EmailMailboxCapabilities_put_CanServerSearchFolders, nullptr, nullptr },
        { const_cast<char*>("can_forward_meetings"), (getter)EmailMailboxCapabilities_get_CanForwardMeetings, (setter)EmailMailboxCapabilities_put_CanForwardMeetings, nullptr, nullptr },
        { const_cast<char*>("can_propose_new_time_for_meetings"), (getter)EmailMailboxCapabilities_get_CanProposeNewTimeForMeetings, (setter)EmailMailboxCapabilities_put_CanProposeNewTimeForMeetings, nullptr, nullptr },
        { const_cast<char*>("can_get_and_set_internal_auto_replies"), (getter)EmailMailboxCapabilities_get_CanGetAndSetInternalAutoReplies, (setter)EmailMailboxCapabilities_put_CanGetAndSetInternalAutoReplies, nullptr, nullptr },
        { const_cast<char*>("can_get_and_set_external_auto_replies"), (getter)EmailMailboxCapabilities_get_CanGetAndSetExternalAutoReplies, (setter)EmailMailboxCapabilities_put_CanGetAndSetExternalAutoReplies, nullptr, nullptr },
        { const_cast<char*>("can_validate_certificates"), (getter)EmailMailboxCapabilities_get_CanValidateCertificates, (setter)EmailMailboxCapabilities_put_CanValidateCertificates, nullptr, nullptr },
        { const_cast<char*>("can_resolve_recipients"), (getter)EmailMailboxCapabilities_get_CanResolveRecipients, (setter)EmailMailboxCapabilities_put_CanResolveRecipients, nullptr, nullptr },
        { const_cast<char*>("can_move_folder"), (getter)EmailMailboxCapabilities_get_CanMoveFolder, (setter)EmailMailboxCapabilities_put_CanMoveFolder, nullptr, nullptr },
        { const_cast<char*>("can_empty_folder"), (getter)EmailMailboxCapabilities_get_CanEmptyFolder, (setter)EmailMailboxCapabilities_put_CanEmptyFolder, nullptr, nullptr },
        { const_cast<char*>("can_delete_folder"), (getter)EmailMailboxCapabilities_get_CanDeleteFolder, (setter)EmailMailboxCapabilities_put_CanDeleteFolder, nullptr, nullptr },
        { const_cast<char*>("can_create_folder"), (getter)EmailMailboxCapabilities_get_CanCreateFolder, (setter)EmailMailboxCapabilities_put_CanCreateFolder, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailMailboxCapabilities[] = 
    {
        { Py_tp_new, _new_EmailMailboxCapabilities },
        { Py_tp_dealloc, _dealloc_EmailMailboxCapabilities },
        { Py_tp_methods, _methods_EmailMailboxCapabilities },
        { Py_tp_getset, _getset_EmailMailboxCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailMailboxCapabilities =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailMailboxCapabilities",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxCapabilities
    };

    // ----- EmailMailboxChange class --------------------
    constexpr const char* const _type_name_EmailMailboxChange = "EmailMailboxChange";

    static PyObject* _new_EmailMailboxChange(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailMailboxChange);
        return nullptr;
    }

    static void _dealloc_EmailMailboxChange(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChange* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailMailboxChange_get_ChangeType(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChange_get_Folder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Folder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChange_get_MailboxActions(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MailboxActions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChange_get_Message(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EmailMailboxChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxChange[] = {
        { "_from", (PyCFunction)_from_EmailMailboxChange, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailMailboxChange[] = {
        { const_cast<char*>("change_type"), (getter)EmailMailboxChange_get_ChangeType, nullptr, nullptr, nullptr },
        { const_cast<char*>("folder"), (getter)EmailMailboxChange_get_Folder, nullptr, nullptr, nullptr },
        { const_cast<char*>("mailbox_actions"), (getter)EmailMailboxChange_get_MailboxActions, nullptr, nullptr, nullptr },
        { const_cast<char*>("message"), (getter)EmailMailboxChange_get_Message, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailMailboxChange[] = 
    {
        { Py_tp_new, _new_EmailMailboxChange },
        { Py_tp_dealloc, _dealloc_EmailMailboxChange },
        { Py_tp_methods, _methods_EmailMailboxChange },
        { Py_tp_getset, _getset_EmailMailboxChange },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailMailboxChange =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailMailboxChange",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxChange
    };

    // ----- EmailMailboxChangeReader class --------------------
    constexpr const char* const _type_name_EmailMailboxChangeReader = "EmailMailboxChangeReader";

    static PyObject* _new_EmailMailboxChangeReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailMailboxChangeReader);
        return nullptr;
    }

    static void _dealloc_EmailMailboxChangeReader(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailMailboxChangeReader_AcceptChanges(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.AcceptChanges();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChangeReader_AcceptChangesThrough(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxChange>(args, 0);

                self->obj.AcceptChangesThrough(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChangeReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_EmailMailboxChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxChangeReader[] = {
        { "accept_changes", (PyCFunction)EmailMailboxChangeReader_AcceptChanges, METH_VARARGS, nullptr },
        { "accept_changes_through", (PyCFunction)EmailMailboxChangeReader_AcceptChangesThrough, METH_VARARGS, nullptr },
        { "read_batch_async", (PyCFunction)EmailMailboxChangeReader_ReadBatchAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_EmailMailboxChangeReader, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailMailboxChangeReader[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailMailboxChangeReader[] = 
    {
        { Py_tp_new, _new_EmailMailboxChangeReader },
        { Py_tp_dealloc, _dealloc_EmailMailboxChangeReader },
        { Py_tp_methods, _methods_EmailMailboxChangeReader },
        { Py_tp_getset, _getset_EmailMailboxChangeReader },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailMailboxChangeReader =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailMailboxChangeReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxChangeReader
    };

    // ----- EmailMailboxChangeTracker class --------------------
    constexpr const char* const _type_name_EmailMailboxChangeTracker = "EmailMailboxChangeTracker";

    static PyObject* _new_EmailMailboxChangeTracker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailMailboxChangeTracker);
        return nullptr;
    }

    static void _dealloc_EmailMailboxChangeTracker(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeTracker* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailMailboxChangeTracker_Enable(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Enable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChangeTracker_GetChangeReader(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetChangeReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChangeTracker_Reset(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChangeTracker_get_IsTracking(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTracking());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EmailMailboxChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeTracker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxChangeTracker[] = {
        { "enable", (PyCFunction)EmailMailboxChangeTracker_Enable, METH_VARARGS, nullptr },
        { "get_change_reader", (PyCFunction)EmailMailboxChangeTracker_GetChangeReader, METH_VARARGS, nullptr },
        { "reset", (PyCFunction)EmailMailboxChangeTracker_Reset, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_EmailMailboxChangeTracker, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailMailboxChangeTracker[] = {
        { const_cast<char*>("is_tracking"), (getter)EmailMailboxChangeTracker_get_IsTracking, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailMailboxChangeTracker[] = 
    {
        { Py_tp_new, _new_EmailMailboxChangeTracker },
        { Py_tp_dealloc, _dealloc_EmailMailboxChangeTracker },
        { Py_tp_methods, _methods_EmailMailboxChangeTracker },
        { Py_tp_getset, _getset_EmailMailboxChangeTracker },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailMailboxChangeTracker =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailMailboxChangeTracker",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeTracker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxChangeTracker
    };

    // ----- EmailMailboxChangedDeferral class --------------------
    constexpr const char* const _type_name_EmailMailboxChangedDeferral = "EmailMailboxChangedDeferral";

    static PyObject* _new_EmailMailboxChangedDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailMailboxChangedDeferral);
        return nullptr;
    }

    static void _dealloc_EmailMailboxChangedDeferral(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangedDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailMailboxChangedDeferral_Complete(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangedDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_EmailMailboxChangedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxChangedDeferral[] = {
        { "complete", (PyCFunction)EmailMailboxChangedDeferral_Complete, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_EmailMailboxChangedDeferral, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailMailboxChangedDeferral[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailMailboxChangedDeferral[] = 
    {
        { Py_tp_new, _new_EmailMailboxChangedDeferral },
        { Py_tp_dealloc, _dealloc_EmailMailboxChangedDeferral },
        { Py_tp_methods, _methods_EmailMailboxChangedDeferral },
        { Py_tp_getset, _getset_EmailMailboxChangedDeferral },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailMailboxChangedDeferral =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailMailboxChangedDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangedDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxChangedDeferral
    };

    // ----- EmailMailboxChangedEventArgs class --------------------
    constexpr const char* const _type_name_EmailMailboxChangedEventArgs = "EmailMailboxChangedEventArgs";

    static PyObject* _new_EmailMailboxChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailMailboxChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_EmailMailboxChangedEventArgs(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailMailboxChangedEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_EmailMailboxChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxChangedEventArgs[] = {
        { "get_deferral", (PyCFunction)EmailMailboxChangedEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_EmailMailboxChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailMailboxChangedEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailMailboxChangedEventArgs[] = 
    {
        { Py_tp_new, _new_EmailMailboxChangedEventArgs },
        { Py_tp_dealloc, _dealloc_EmailMailboxChangedEventArgs },
        { Py_tp_methods, _methods_EmailMailboxChangedEventArgs },
        { Py_tp_getset, _getset_EmailMailboxChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailMailboxChangedEventArgs =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailMailboxChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxChangedEventArgs
    };

    // ----- EmailMailboxCreateFolderResult class --------------------
    constexpr const char* const _type_name_EmailMailboxCreateFolderResult = "EmailMailboxCreateFolderResult";

    static PyObject* _new_EmailMailboxCreateFolderResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailMailboxCreateFolderResult);
        return nullptr;
    }

    static void _dealloc_EmailMailboxCreateFolderResult(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailMailboxCreateFolderResult_get_Folder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Folder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxCreateFolderResult_get_Status(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EmailMailboxCreateFolderResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxCreateFolderResult[] = {
        { "_from", (PyCFunction)_from_EmailMailboxCreateFolderResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailMailboxCreateFolderResult[] = {
        { const_cast<char*>("folder"), (getter)EmailMailboxCreateFolderResult_get_Folder, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)EmailMailboxCreateFolderResult_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailMailboxCreateFolderResult[] = 
    {
        { Py_tp_new, _new_EmailMailboxCreateFolderResult },
        { Py_tp_dealloc, _dealloc_EmailMailboxCreateFolderResult },
        { Py_tp_methods, _methods_EmailMailboxCreateFolderResult },
        { Py_tp_getset, _getset_EmailMailboxCreateFolderResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailMailboxCreateFolderResult =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailMailboxCreateFolderResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxCreateFolderResult
    };

    // ----- EmailMailboxPolicies class --------------------
    constexpr const char* const _type_name_EmailMailboxPolicies = "EmailMailboxPolicies";

    static PyObject* _new_EmailMailboxPolicies(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailMailboxPolicies);
        return nullptr;
    }

    static void _dealloc_EmailMailboxPolicies(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailMailboxPolicies_get_RequiredSmimeSigningAlgorithm(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequiredSmimeSigningAlgorithm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxPolicies_put_RequiredSmimeSigningAlgorithm(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::ApplicationModel::Email::EmailMailboxSmimeSigningAlgorithm>>(arg);

            self->obj.RequiredSmimeSigningAlgorithm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxPolicies_get_RequiredSmimeEncryptionAlgorithm(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequiredSmimeEncryptionAlgorithm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxPolicies_put_RequiredSmimeEncryptionAlgorithm(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::ApplicationModel::Email::EmailMailboxSmimeEncryptionAlgorithm>>(arg);

            self->obj.RequiredSmimeEncryptionAlgorithm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxPolicies_get_AllowedSmimeEncryptionAlgorithmNegotiation(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowedSmimeEncryptionAlgorithmNegotiation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxPolicies_put_AllowedSmimeEncryptionAlgorithmNegotiation(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation>(arg);

            self->obj.AllowedSmimeEncryptionAlgorithmNegotiation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxPolicies_get_AllowSmimeSoftCertificates(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowSmimeSoftCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxPolicies_put_AllowSmimeSoftCertificates(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowSmimeSoftCertificates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxPolicies_get_MustSignSmimeMessages(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MustSignSmimeMessages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxPolicies_put_MustSignSmimeMessages(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.MustSignSmimeMessages(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxPolicies_get_MustEncryptSmimeMessages(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MustEncryptSmimeMessages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxPolicies_put_MustEncryptSmimeMessages(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.MustEncryptSmimeMessages(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_EmailMailboxPolicies(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxPolicies>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxPolicies[] = {
        { "_from", (PyCFunction)_from_EmailMailboxPolicies, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailMailboxPolicies[] = {
        { const_cast<char*>("required_smime_signing_algorithm"), (getter)EmailMailboxPolicies_get_RequiredSmimeSigningAlgorithm, (setter)EmailMailboxPolicies_put_RequiredSmimeSigningAlgorithm, nullptr, nullptr },
        { const_cast<char*>("required_smime_encryption_algorithm"), (getter)EmailMailboxPolicies_get_RequiredSmimeEncryptionAlgorithm, (setter)EmailMailboxPolicies_put_RequiredSmimeEncryptionAlgorithm, nullptr, nullptr },
        { const_cast<char*>("allowed_smime_encryption_algorithm_negotiation"), (getter)EmailMailboxPolicies_get_AllowedSmimeEncryptionAlgorithmNegotiation, (setter)EmailMailboxPolicies_put_AllowedSmimeEncryptionAlgorithmNegotiation, nullptr, nullptr },
        { const_cast<char*>("allow_smime_soft_certificates"), (getter)EmailMailboxPolicies_get_AllowSmimeSoftCertificates, (setter)EmailMailboxPolicies_put_AllowSmimeSoftCertificates, nullptr, nullptr },
        { const_cast<char*>("must_sign_smime_messages"), (getter)EmailMailboxPolicies_get_MustSignSmimeMessages, (setter)EmailMailboxPolicies_put_MustSignSmimeMessages, nullptr, nullptr },
        { const_cast<char*>("must_encrypt_smime_messages"), (getter)EmailMailboxPolicies_get_MustEncryptSmimeMessages, (setter)EmailMailboxPolicies_put_MustEncryptSmimeMessages, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailMailboxPolicies[] = 
    {
        { Py_tp_new, _new_EmailMailboxPolicies },
        { Py_tp_dealloc, _dealloc_EmailMailboxPolicies },
        { Py_tp_methods, _methods_EmailMailboxPolicies },
        { Py_tp_getset, _getset_EmailMailboxPolicies },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailMailboxPolicies =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailMailboxPolicies",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxPolicies
    };

    // ----- EmailMailboxSyncManager class --------------------
    constexpr const char* const _type_name_EmailMailboxSyncManager = "EmailMailboxSyncManager";

    static PyObject* _new_EmailMailboxSyncManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailMailboxSyncManager);
        return nullptr;
    }

    static void _dealloc_EmailMailboxSyncManager(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailMailboxSyncManager_SyncAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.SyncAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxSyncManager_get_Status(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxSyncManager_put_Status(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxSyncStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxSyncManager_get_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastSuccessfulSyncTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxSyncManager_put_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.LastSuccessfulSyncTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxSyncManager_get_LastAttemptedSyncTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastAttemptedSyncTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxSyncManager_put_LastAttemptedSyncTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.LastAttemptedSyncTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxSyncManager_add_SyncStatusChanged(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::EmailMailboxSyncManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SyncStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxSyncManager_remove_SyncStatusChanged(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SyncStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EmailMailboxSyncManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxSyncManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxSyncManager[] = {
        { "sync_async", (PyCFunction)EmailMailboxSyncManager_SyncAsync, METH_VARARGS, nullptr },
        { "add_sync_status_changed", (PyCFunction)EmailMailboxSyncManager_add_SyncStatusChanged, METH_O, nullptr },
        { "remove_sync_status_changed", (PyCFunction)EmailMailboxSyncManager_remove_SyncStatusChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_EmailMailboxSyncManager, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailMailboxSyncManager[] = {
        { const_cast<char*>("status"), (getter)EmailMailboxSyncManager_get_Status, (setter)EmailMailboxSyncManager_put_Status, nullptr, nullptr },
        { const_cast<char*>("last_successful_sync_time"), (getter)EmailMailboxSyncManager_get_LastSuccessfulSyncTime, (setter)EmailMailboxSyncManager_put_LastSuccessfulSyncTime, nullptr, nullptr },
        { const_cast<char*>("last_attempted_sync_time"), (getter)EmailMailboxSyncManager_get_LastAttemptedSyncTime, (setter)EmailMailboxSyncManager_put_LastAttemptedSyncTime, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailMailboxSyncManager[] = 
    {
        { Py_tp_new, _new_EmailMailboxSyncManager },
        { Py_tp_dealloc, _dealloc_EmailMailboxSyncManager },
        { Py_tp_methods, _methods_EmailMailboxSyncManager },
        { Py_tp_getset, _getset_EmailMailboxSyncManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailMailboxSyncManager =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailMailboxSyncManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxSyncManager
    };

    // ----- EmailManager class --------------------
    constexpr const char* const _type_name_EmailManager = "EmailManager";

    static PyObject* _new_EmailManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailManager);
        return nullptr;
    }

    static PyObject* EmailManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Email::EmailManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailStoreAccessType>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Email::EmailManager::RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailManager_ShowComposeNewEmailAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Email::EmailManager::ShowComposeNewEmailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailManager[] = {
        { "get_for_user", (PyCFunction)EmailManager_GetForUser, METH_VARARGS | METH_STATIC, nullptr },
        { "request_store_async", (PyCFunction)EmailManager_RequestStoreAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "show_compose_new_email_async", (PyCFunction)EmailManager_ShowComposeNewEmailAsync, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailManager[] = 
    {
        { Py_tp_new, _new_EmailManager },
        { Py_tp_methods, _methods_EmailManager },
        { Py_tp_getset, _getset_EmailManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailManager =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailManager
    };

    // ----- EmailManagerForUser class --------------------
    constexpr const char* const _type_name_EmailManagerForUser = "EmailManagerForUser";

    static PyObject* _new_EmailManagerForUser(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailManagerForUser);
        return nullptr;
    }

    static void _dealloc_EmailManagerForUser(py::wrapper::Windows::ApplicationModel::Email::EmailManagerForUser* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailManagerForUser_RequestStoreAsync(py::wrapper::Windows::ApplicationModel::Email::EmailManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailStoreAccessType>(args, 0);

                return py::convert(self->obj.RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailManagerForUser_ShowComposeNewEmailAsync(py::wrapper::Windows::ApplicationModel::Email::EmailManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);

                return py::convert(self->obj.ShowComposeNewEmailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailManagerForUser_get_User(py::wrapper::Windows::ApplicationModel::Email::EmailManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EmailManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailManagerForUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailManagerForUser[] = {
        { "request_store_async", (PyCFunction)EmailManagerForUser_RequestStoreAsync, METH_VARARGS, nullptr },
        { "show_compose_new_email_async", (PyCFunction)EmailManagerForUser_ShowComposeNewEmailAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_EmailManagerForUser, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailManagerForUser[] = {
        { const_cast<char*>("user"), (getter)EmailManagerForUser_get_User, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailManagerForUser[] = 
    {
        { Py_tp_new, _new_EmailManagerForUser },
        { Py_tp_dealloc, _dealloc_EmailManagerForUser },
        { Py_tp_methods, _methods_EmailManagerForUser },
        { Py_tp_getset, _getset_EmailManagerForUser },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailManagerForUser =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailManagerForUser",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailManagerForUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailManagerForUser
    };

    // ----- EmailMeetingInfo class --------------------
    constexpr const char* const _type_name_EmailMeetingInfo = "EmailMeetingInfo";

    static PyObject* _new_EmailMeetingInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailMeetingInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailMeetingInfo(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailMeetingInfo_get_Location(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_Location(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Location(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_IsResponseRequested(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsResponseRequested());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_IsResponseRequested(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsResponseRequested(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_IsAllDay(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAllDay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_IsAllDay(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAllDay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_AllowNewTimeProposal(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowNewTimeProposal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_AllowNewTimeProposal(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowNewTimeProposal(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_Duration(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_Duration(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_AppointmentRoamingId(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppointmentRoamingId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_AppointmentRoamingId(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AppointmentRoamingId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_AppointmentOriginalStartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppointmentOriginalStartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_AppointmentOriginalStartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.AppointmentOriginalStartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_ProposedDuration(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProposedDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_ProposedDuration(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.ProposedDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_RemoteChangeNumber(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteChangeNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_RemoteChangeNumber(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.RemoteChangeNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_StartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_StartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_RecurrenceStartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RecurrenceStartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_RecurrenceStartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.RecurrenceStartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_Recurrence(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Recurrence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_Recurrence(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentRecurrence>(arg);

            self->obj.Recurrence(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_ProposedStartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProposedStartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_ProposedStartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ProposedStartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_IsReportedOutOfDateByServer(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReportedOutOfDateByServer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EmailMeetingInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMeetingInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMeetingInfo[] = {
        { "_from", (PyCFunction)_from_EmailMeetingInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailMeetingInfo[] = {
        { const_cast<char*>("location"), (getter)EmailMeetingInfo_get_Location, (setter)EmailMeetingInfo_put_Location, nullptr, nullptr },
        { const_cast<char*>("is_response_requested"), (getter)EmailMeetingInfo_get_IsResponseRequested, (setter)EmailMeetingInfo_put_IsResponseRequested, nullptr, nullptr },
        { const_cast<char*>("is_all_day"), (getter)EmailMeetingInfo_get_IsAllDay, (setter)EmailMeetingInfo_put_IsAllDay, nullptr, nullptr },
        { const_cast<char*>("allow_new_time_proposal"), (getter)EmailMeetingInfo_get_AllowNewTimeProposal, (setter)EmailMeetingInfo_put_AllowNewTimeProposal, nullptr, nullptr },
        { const_cast<char*>("duration"), (getter)EmailMeetingInfo_get_Duration, (setter)EmailMeetingInfo_put_Duration, nullptr, nullptr },
        { const_cast<char*>("appointment_roaming_id"), (getter)EmailMeetingInfo_get_AppointmentRoamingId, (setter)EmailMeetingInfo_put_AppointmentRoamingId, nullptr, nullptr },
        { const_cast<char*>("appointment_original_start_time"), (getter)EmailMeetingInfo_get_AppointmentOriginalStartTime, (setter)EmailMeetingInfo_put_AppointmentOriginalStartTime, nullptr, nullptr },
        { const_cast<char*>("proposed_duration"), (getter)EmailMeetingInfo_get_ProposedDuration, (setter)EmailMeetingInfo_put_ProposedDuration, nullptr, nullptr },
        { const_cast<char*>("remote_change_number"), (getter)EmailMeetingInfo_get_RemoteChangeNumber, (setter)EmailMeetingInfo_put_RemoteChangeNumber, nullptr, nullptr },
        { const_cast<char*>("start_time"), (getter)EmailMeetingInfo_get_StartTime, (setter)EmailMeetingInfo_put_StartTime, nullptr, nullptr },
        { const_cast<char*>("recurrence_start_time"), (getter)EmailMeetingInfo_get_RecurrenceStartTime, (setter)EmailMeetingInfo_put_RecurrenceStartTime, nullptr, nullptr },
        { const_cast<char*>("recurrence"), (getter)EmailMeetingInfo_get_Recurrence, (setter)EmailMeetingInfo_put_Recurrence, nullptr, nullptr },
        { const_cast<char*>("proposed_start_time"), (getter)EmailMeetingInfo_get_ProposedStartTime, (setter)EmailMeetingInfo_put_ProposedStartTime, nullptr, nullptr },
        { const_cast<char*>("is_reported_out_of_date_by_server"), (getter)EmailMeetingInfo_get_IsReportedOutOfDateByServer, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailMeetingInfo[] = 
    {
        { Py_tp_new, _new_EmailMeetingInfo },
        { Py_tp_dealloc, _dealloc_EmailMeetingInfo },
        { Py_tp_methods, _methods_EmailMeetingInfo },
        { Py_tp_getset, _getset_EmailMeetingInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailMeetingInfo =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailMeetingInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMeetingInfo
    };

    // ----- EmailMessage class --------------------
    constexpr const char* const _type_name_EmailMessage = "EmailMessage";

    static PyObject* _new_EmailMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailMessage(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailMessage_GetBodyStream(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageBodyKind>(args, 0);

                return py::convert(self->obj.GetBodyStream(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMessage_SetBodyStream(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageBodyKind>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 1);

                self->obj.SetBodyStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_Subject(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_Subject(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subject(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_Body(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_Body(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Body(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_Bcc(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bcc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_CC(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CC());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_Attachments(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Attachments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_To(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_AllowInternetImages(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowInternetImages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_AllowInternetImages(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowInternetImages(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_FlagState(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FlagState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_FlagState(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailFlagState>(arg);

            self->obj.FlagState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_EstimatedDownloadSizeInBytes(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EstimatedDownloadSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_EstimatedDownloadSizeInBytes(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.EstimatedDownloadSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_DownloadState(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DownloadState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_DownloadState(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageDownloadState>(arg);

            self->obj.DownloadState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_Importance(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Importance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_Importance(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailImportance>(arg);

            self->obj.Importance(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_IrmInfo(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IrmInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_IrmInfo(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailIrmInfo>(arg);

            self->obj.IrmInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_OriginalCodePage(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OriginalCodePage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_OriginalCodePage(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.OriginalCodePage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_SentTime(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SentTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_SentTime(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.SentTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_Sender(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Sender());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_Sender(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailRecipient>(arg);

            self->obj.Sender(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_RemoteId(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_RemoteId(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_Preview(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Preview());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_Preview(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Preview(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_MessageClass(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_MessageClass(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MessageClass(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_MeetingInfo(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MeetingInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_MeetingInfo(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMeetingInfo>(arg);

            self->obj.MeetingInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_LastResponseKind(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastResponseKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_LastResponseKind(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageResponseKind>(arg);

            self->obj.LastResponseKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_IsSeen(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSeen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_IsSeen(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSeen(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_IsRead(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_IsRead(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRead(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_IsServerSearchMessage(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsServerSearchMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_IsSmartSendable(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSmartSendable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_MailboxId(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_ChangeNumber(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_ConversationId(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConversationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_NormalizedSubject(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NormalizedSubject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_FolderId(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FolderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_HasPartialBodies(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasPartialBodies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_Id(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_InResponseToMessageId(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InResponseToMessageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_IsDraftMessage(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDraftMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_SmimeKind(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SmimeKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_SmimeKind(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageSmimeKind>(arg);

            self->obj.SmimeKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_SmimeData(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SmimeData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_SmimeData(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.SmimeData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_SentRepresenting(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SentRepresenting());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_SentRepresenting(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailRecipient>(arg);

            self->obj.SentRepresenting(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_ReplyTo(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReplyTo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EmailMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMessage[] = {
        { "get_body_stream", (PyCFunction)EmailMessage_GetBodyStream, METH_VARARGS, nullptr },
        { "set_body_stream", (PyCFunction)EmailMessage_SetBodyStream, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_EmailMessage, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailMessage[] = {
        { const_cast<char*>("subject"), (getter)EmailMessage_get_Subject, (setter)EmailMessage_put_Subject, nullptr, nullptr },
        { const_cast<char*>("body"), (getter)EmailMessage_get_Body, (setter)EmailMessage_put_Body, nullptr, nullptr },
        { const_cast<char*>("bcc"), (getter)EmailMessage_get_Bcc, nullptr, nullptr, nullptr },
        { const_cast<char*>("c_c"), (getter)EmailMessage_get_CC, nullptr, nullptr, nullptr },
        { const_cast<char*>("attachments"), (getter)EmailMessage_get_Attachments, nullptr, nullptr, nullptr },
        { const_cast<char*>("to"), (getter)EmailMessage_get_To, nullptr, nullptr, nullptr },
        { const_cast<char*>("allow_internet_images"), (getter)EmailMessage_get_AllowInternetImages, (setter)EmailMessage_put_AllowInternetImages, nullptr, nullptr },
        { const_cast<char*>("flag_state"), (getter)EmailMessage_get_FlagState, (setter)EmailMessage_put_FlagState, nullptr, nullptr },
        { const_cast<char*>("estimated_download_size_in_bytes"), (getter)EmailMessage_get_EstimatedDownloadSizeInBytes, (setter)EmailMessage_put_EstimatedDownloadSizeInBytes, nullptr, nullptr },
        { const_cast<char*>("download_state"), (getter)EmailMessage_get_DownloadState, (setter)EmailMessage_put_DownloadState, nullptr, nullptr },
        { const_cast<char*>("importance"), (getter)EmailMessage_get_Importance, (setter)EmailMessage_put_Importance, nullptr, nullptr },
        { const_cast<char*>("irm_info"), (getter)EmailMessage_get_IrmInfo, (setter)EmailMessage_put_IrmInfo, nullptr, nullptr },
        { const_cast<char*>("original_code_page"), (getter)EmailMessage_get_OriginalCodePage, (setter)EmailMessage_put_OriginalCodePage, nullptr, nullptr },
        { const_cast<char*>("sent_time"), (getter)EmailMessage_get_SentTime, (setter)EmailMessage_put_SentTime, nullptr, nullptr },
        { const_cast<char*>("sender"), (getter)EmailMessage_get_Sender, (setter)EmailMessage_put_Sender, nullptr, nullptr },
        { const_cast<char*>("remote_id"), (getter)EmailMessage_get_RemoteId, (setter)EmailMessage_put_RemoteId, nullptr, nullptr },
        { const_cast<char*>("preview"), (getter)EmailMessage_get_Preview, (setter)EmailMessage_put_Preview, nullptr, nullptr },
        { const_cast<char*>("message_class"), (getter)EmailMessage_get_MessageClass, (setter)EmailMessage_put_MessageClass, nullptr, nullptr },
        { const_cast<char*>("meeting_info"), (getter)EmailMessage_get_MeetingInfo, (setter)EmailMessage_put_MeetingInfo, nullptr, nullptr },
        { const_cast<char*>("last_response_kind"), (getter)EmailMessage_get_LastResponseKind, (setter)EmailMessage_put_LastResponseKind, nullptr, nullptr },
        { const_cast<char*>("is_seen"), (getter)EmailMessage_get_IsSeen, (setter)EmailMessage_put_IsSeen, nullptr, nullptr },
        { const_cast<char*>("is_read"), (getter)EmailMessage_get_IsRead, (setter)EmailMessage_put_IsRead, nullptr, nullptr },
        { const_cast<char*>("is_server_search_message"), (getter)EmailMessage_get_IsServerSearchMessage, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_smart_sendable"), (getter)EmailMessage_get_IsSmartSendable, nullptr, nullptr, nullptr },
        { const_cast<char*>("mailbox_id"), (getter)EmailMessage_get_MailboxId, nullptr, nullptr, nullptr },
        { const_cast<char*>("change_number"), (getter)EmailMessage_get_ChangeNumber, nullptr, nullptr, nullptr },
        { const_cast<char*>("conversation_id"), (getter)EmailMessage_get_ConversationId, nullptr, nullptr, nullptr },
        { const_cast<char*>("normalized_subject"), (getter)EmailMessage_get_NormalizedSubject, nullptr, nullptr, nullptr },
        { const_cast<char*>("folder_id"), (getter)EmailMessage_get_FolderId, nullptr, nullptr, nullptr },
        { const_cast<char*>("has_partial_bodies"), (getter)EmailMessage_get_HasPartialBodies, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)EmailMessage_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("in_response_to_message_id"), (getter)EmailMessage_get_InResponseToMessageId, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_draft_message"), (getter)EmailMessage_get_IsDraftMessage, nullptr, nullptr, nullptr },
        { const_cast<char*>("smime_kind"), (getter)EmailMessage_get_SmimeKind, (setter)EmailMessage_put_SmimeKind, nullptr, nullptr },
        { const_cast<char*>("smime_data"), (getter)EmailMessage_get_SmimeData, (setter)EmailMessage_put_SmimeData, nullptr, nullptr },
        { const_cast<char*>("sent_representing"), (getter)EmailMessage_get_SentRepresenting, (setter)EmailMessage_put_SentRepresenting, nullptr, nullptr },
        { const_cast<char*>("reply_to"), (getter)EmailMessage_get_ReplyTo, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailMessage[] = 
    {
        { Py_tp_new, _new_EmailMessage },
        { Py_tp_dealloc, _dealloc_EmailMessage },
        { Py_tp_methods, _methods_EmailMessage },
        { Py_tp_getset, _getset_EmailMessage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailMessage =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailMessage",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMessage
    };

    // ----- EmailMessageBatch class --------------------
    constexpr const char* const _type_name_EmailMessageBatch = "EmailMessageBatch";

    static PyObject* _new_EmailMessageBatch(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailMessageBatch);
        return nullptr;
    }

    static void _dealloc_EmailMessageBatch(py::wrapper::Windows::ApplicationModel::Email::EmailMessageBatch* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailMessageBatch_get_Messages(py::wrapper::Windows::ApplicationModel::Email::EmailMessageBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Messages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessageBatch_get_Status(py::wrapper::Windows::ApplicationModel::Email::EmailMessageBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EmailMessageBatch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMessageBatch>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMessageBatch[] = {
        { "_from", (PyCFunction)_from_EmailMessageBatch, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailMessageBatch[] = {
        { const_cast<char*>("messages"), (getter)EmailMessageBatch_get_Messages, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)EmailMessageBatch_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailMessageBatch[] = 
    {
        { Py_tp_new, _new_EmailMessageBatch },
        { Py_tp_dealloc, _dealloc_EmailMessageBatch },
        { Py_tp_methods, _methods_EmailMessageBatch },
        { Py_tp_getset, _getset_EmailMessageBatch },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailMessageBatch =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailMessageBatch",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMessageBatch),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMessageBatch
    };

    // ----- EmailMessageReader class --------------------
    constexpr const char* const _type_name_EmailMessageReader = "EmailMessageReader";

    static PyObject* _new_EmailMessageReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailMessageReader);
        return nullptr;
    }

    static void _dealloc_EmailMessageReader(py::wrapper::Windows::ApplicationModel::Email::EmailMessageReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailMessageReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMessageReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_EmailMessageReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMessageReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMessageReader[] = {
        { "read_batch_async", (PyCFunction)EmailMessageReader_ReadBatchAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_EmailMessageReader, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailMessageReader[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailMessageReader[] = 
    {
        { Py_tp_new, _new_EmailMessageReader },
        { Py_tp_dealloc, _dealloc_EmailMessageReader },
        { Py_tp_methods, _methods_EmailMessageReader },
        { Py_tp_getset, _getset_EmailMessageReader },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailMessageReader =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailMessageReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMessageReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMessageReader
    };

    // ----- EmailQueryOptions class --------------------
    constexpr const char* const _type_name_EmailQueryOptions = "EmailQueryOptions";

    static PyObject* _new_EmailQueryOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Email::EmailQueryOptions instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQuerySearchFields>(args, 1);

                winrt::Windows::ApplicationModel::Email::EmailQueryOptions instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailQueryOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailQueryOptions(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailQueryOptions_get_SortProperty(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SortProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailQueryOptions_put_SortProperty(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQuerySortProperty>(arg);

            self->obj.SortProperty(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailQueryOptions_get_SortDirection(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SortDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailQueryOptions_put_SortDirection(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQuerySortDirection>(arg);

            self->obj.SortDirection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailQueryOptions_get_Kind(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailQueryOptions_put_Kind(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQueryKind>(arg);

            self->obj.Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailQueryOptions_get_FolderIds(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FolderIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailQueryOptions_get_TextSearch(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TextSearch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EmailQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailQueryOptions[] = {
        { "_from", (PyCFunction)_from_EmailQueryOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailQueryOptions[] = {
        { const_cast<char*>("sort_property"), (getter)EmailQueryOptions_get_SortProperty, (setter)EmailQueryOptions_put_SortProperty, nullptr, nullptr },
        { const_cast<char*>("sort_direction"), (getter)EmailQueryOptions_get_SortDirection, (setter)EmailQueryOptions_put_SortDirection, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)EmailQueryOptions_get_Kind, (setter)EmailQueryOptions_put_Kind, nullptr, nullptr },
        { const_cast<char*>("folder_ids"), (getter)EmailQueryOptions_get_FolderIds, nullptr, nullptr, nullptr },
        { const_cast<char*>("text_search"), (getter)EmailQueryOptions_get_TextSearch, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailQueryOptions[] = 
    {
        { Py_tp_new, _new_EmailQueryOptions },
        { Py_tp_dealloc, _dealloc_EmailQueryOptions },
        { Py_tp_methods, _methods_EmailQueryOptions },
        { Py_tp_getset, _getset_EmailQueryOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailQueryOptions =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailQueryOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailQueryOptions
    };

    // ----- EmailQueryTextSearch class --------------------
    constexpr const char* const _type_name_EmailQueryTextSearch = "EmailQueryTextSearch";

    static PyObject* _new_EmailQueryTextSearch(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailQueryTextSearch);
        return nullptr;
    }

    static void _dealloc_EmailQueryTextSearch(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailQueryTextSearch_get_Text(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailQueryTextSearch_put_Text(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailQueryTextSearch_get_SearchScope(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SearchScope());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailQueryTextSearch_put_SearchScope(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQuerySearchScope>(arg);

            self->obj.SearchScope(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailQueryTextSearch_get_Fields(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Fields());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailQueryTextSearch_put_Fields(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQuerySearchFields>(arg);

            self->obj.Fields(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_EmailQueryTextSearch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailQueryTextSearch>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailQueryTextSearch[] = {
        { "_from", (PyCFunction)_from_EmailQueryTextSearch, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailQueryTextSearch[] = {
        { const_cast<char*>("text"), (getter)EmailQueryTextSearch_get_Text, (setter)EmailQueryTextSearch_put_Text, nullptr, nullptr },
        { const_cast<char*>("search_scope"), (getter)EmailQueryTextSearch_get_SearchScope, (setter)EmailQueryTextSearch_put_SearchScope, nullptr, nullptr },
        { const_cast<char*>("fields"), (getter)EmailQueryTextSearch_get_Fields, (setter)EmailQueryTextSearch_put_Fields, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailQueryTextSearch[] = 
    {
        { Py_tp_new, _new_EmailQueryTextSearch },
        { Py_tp_dealloc, _dealloc_EmailQueryTextSearch },
        { Py_tp_methods, _methods_EmailQueryTextSearch },
        { Py_tp_getset, _getset_EmailQueryTextSearch },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailQueryTextSearch =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailQueryTextSearch",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailQueryTextSearch
    };

    // ----- EmailRecipient class --------------------
    constexpr const char* const _type_name_EmailRecipient = "EmailRecipient";

    static PyObject* _new_EmailRecipient(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Email::EmailRecipient instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Email::EmailRecipient instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailRecipient instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailRecipient(py::wrapper::Windows::ApplicationModel::Email::EmailRecipient* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailRecipient_get_Name(py::wrapper::Windows::ApplicationModel::Email::EmailRecipient* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailRecipient_put_Name(py::wrapper::Windows::ApplicationModel::Email::EmailRecipient* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailRecipient_get_Address(py::wrapper::Windows::ApplicationModel::Email::EmailRecipient* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailRecipient_put_Address(py::wrapper::Windows::ApplicationModel::Email::EmailRecipient* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Address(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_EmailRecipient(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailRecipient>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailRecipient[] = {
        { "_from", (PyCFunction)_from_EmailRecipient, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailRecipient[] = {
        { const_cast<char*>("name"), (getter)EmailRecipient_get_Name, (setter)EmailRecipient_put_Name, nullptr, nullptr },
        { const_cast<char*>("address"), (getter)EmailRecipient_get_Address, (setter)EmailRecipient_put_Address, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailRecipient[] = 
    {
        { Py_tp_new, _new_EmailRecipient },
        { Py_tp_dealloc, _dealloc_EmailRecipient },
        { Py_tp_methods, _methods_EmailRecipient },
        { Py_tp_getset, _getset_EmailRecipient },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailRecipient =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailRecipient",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailRecipient),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailRecipient
    };

    // ----- EmailRecipientResolutionResult class --------------------
    constexpr const char* const _type_name_EmailRecipientResolutionResult = "EmailRecipientResolutionResult";

    static PyObject* _new_EmailRecipientResolutionResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailRecipientResolutionResult instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailRecipientResolutionResult(py::wrapper::Windows::ApplicationModel::Email::EmailRecipientResolutionResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailRecipientResolutionResult_SetPublicKeys(py::wrapper::Windows::ApplicationModel::Email::EmailRecipientResolutionResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 0);

                self->obj.SetPublicKeys(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailRecipientResolutionResult_get_Status(py::wrapper::Windows::ApplicationModel::Email::EmailRecipientResolutionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailRecipientResolutionResult_put_Status(py::wrapper::Windows::ApplicationModel::Email::EmailRecipientResolutionResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailRecipientResolutionStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailRecipientResolutionResult_get_PublicKeys(py::wrapper::Windows::ApplicationModel::Email::EmailRecipientResolutionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PublicKeys());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EmailRecipientResolutionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailRecipientResolutionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailRecipientResolutionResult[] = {
        { "set_public_keys", (PyCFunction)EmailRecipientResolutionResult_SetPublicKeys, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_EmailRecipientResolutionResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailRecipientResolutionResult[] = {
        { const_cast<char*>("status"), (getter)EmailRecipientResolutionResult_get_Status, (setter)EmailRecipientResolutionResult_put_Status, nullptr, nullptr },
        { const_cast<char*>("public_keys"), (getter)EmailRecipientResolutionResult_get_PublicKeys, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailRecipientResolutionResult[] = 
    {
        { Py_tp_new, _new_EmailRecipientResolutionResult },
        { Py_tp_dealloc, _dealloc_EmailRecipientResolutionResult },
        { Py_tp_methods, _methods_EmailRecipientResolutionResult },
        { Py_tp_getset, _getset_EmailRecipientResolutionResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailRecipientResolutionResult =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailRecipientResolutionResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailRecipientResolutionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailRecipientResolutionResult
    };

    // ----- EmailStore class --------------------
    constexpr const char* const _type_name_EmailStore = "EmailStore";

    static PyObject* _new_EmailStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailStore);
        return nullptr;
    }

    static void _dealloc_EmailStore(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EmailStore_CreateMailboxAsync(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CreateMailboxAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.CreateMailboxAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_FindMailboxesAsync(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindMailboxesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_GetConversationAsync(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetConversationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_GetConversationReader(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConversationReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>(args, 0);

                return py::convert(self->obj.GetConversationReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_GetFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_GetMailboxAsync(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetMailboxAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_GetMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_GetMessageReader(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetMessageReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>(args, 0);

                return py::convert(self->obj.GetMessageReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_EmailStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailStore[] = {
        { "create_mailbox_async", (PyCFunction)EmailStore_CreateMailboxAsync, METH_VARARGS, nullptr },
        { "find_mailboxes_async", (PyCFunction)EmailStore_FindMailboxesAsync, METH_VARARGS, nullptr },
        { "get_conversation_async", (PyCFunction)EmailStore_GetConversationAsync, METH_VARARGS, nullptr },
        { "get_conversation_reader", (PyCFunction)EmailStore_GetConversationReader, METH_VARARGS, nullptr },
        { "get_folder_async", (PyCFunction)EmailStore_GetFolderAsync, METH_VARARGS, nullptr },
        { "get_mailbox_async", (PyCFunction)EmailStore_GetMailboxAsync, METH_VARARGS, nullptr },
        { "get_message_async", (PyCFunction)EmailStore_GetMessageAsync, METH_VARARGS, nullptr },
        { "get_message_reader", (PyCFunction)EmailStore_GetMessageReader, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_EmailStore, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailStore[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailStore[] = 
    {
        { Py_tp_new, _new_EmailStore },
        { Py_tp_dealloc, _dealloc_EmailStore },
        { Py_tp_methods, _methods_EmailStore },
        { Py_tp_getset, _getset_EmailStore },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailStore =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailStore
    };

    // ----- EmailStoreNotificationTriggerDetails class --------------------
    constexpr const char* const _type_name_EmailStoreNotificationTriggerDetails = "EmailStoreNotificationTriggerDetails";

    static PyObject* _new_EmailStoreNotificationTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EmailStoreNotificationTriggerDetails);
        return nullptr;
    }

    static void _dealloc_EmailStoreNotificationTriggerDetails(py::wrapper::Windows::ApplicationModel::Email::EmailStoreNotificationTriggerDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_EmailStoreNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailStoreNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailStoreNotificationTriggerDetails[] = {
        { "_from", (PyCFunction)_from_EmailStoreNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailStoreNotificationTriggerDetails[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailStoreNotificationTriggerDetails[] = 
    {
        { Py_tp_new, _new_EmailStoreNotificationTriggerDetails },
        { Py_tp_dealloc, _dealloc_EmailStoreNotificationTriggerDetails },
        { Py_tp_methods, _methods_EmailStoreNotificationTriggerDetails },
        { Py_tp_getset, _getset_EmailStoreNotificationTriggerDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailStoreNotificationTriggerDetails =
    {
        "_winrt_Windows_ApplicationModel_Email.EmailStoreNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailStoreNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailStoreNotificationTriggerDetails
    };

    // ----- Windows.ApplicationModel.Email Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailAttachment>::python_type = py::register_python_type(module, _type_name_EmailAttachment, &_type_spec_EmailAttachment, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailConversation>::python_type = py::register_python_type(module, _type_name_EmailConversation, &_type_spec_EmailConversation, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailConversationBatch>::python_type = py::register_python_type(module, _type_name_EmailConversationBatch, &_type_spec_EmailConversationBatch, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailConversationReader>::python_type = py::register_python_type(module, _type_name_EmailConversationReader, &_type_spec_EmailConversationReader, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailFolder>::python_type = py::register_python_type(module, _type_name_EmailFolder, &_type_spec_EmailFolder, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailIrmInfo>::python_type = py::register_python_type(module, _type_name_EmailIrmInfo, &_type_spec_EmailIrmInfo, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailIrmTemplate>::python_type = py::register_python_type(module, _type_name_EmailIrmTemplate, &_type_spec_EmailIrmTemplate, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailItemCounts>::python_type = py::register_python_type(module, _type_name_EmailItemCounts, &_type_spec_EmailItemCounts, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailbox>::python_type = py::register_python_type(module, _type_name_EmailMailbox, &_type_spec_EmailMailbox, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxAction>::python_type = py::register_python_type(module, _type_name_EmailMailboxAction, &_type_spec_EmailMailboxAction, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReply>::python_type = py::register_python_type(module, _type_name_EmailMailboxAutoReply, &_type_spec_EmailMailboxAutoReply, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings>::python_type = py::register_python_type(module, _type_name_EmailMailboxAutoReplySettings, &_type_spec_EmailMailboxAutoReplySettings, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxCapabilities>::python_type = py::register_python_type(module, _type_name_EmailMailboxCapabilities, &_type_spec_EmailMailboxCapabilities, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChange>::python_type = py::register_python_type(module, _type_name_EmailMailboxChange, &_type_spec_EmailMailboxChange, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeReader>::python_type = py::register_python_type(module, _type_name_EmailMailboxChangeReader, &_type_spec_EmailMailboxChangeReader, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeTracker>::python_type = py::register_python_type(module, _type_name_EmailMailboxChangeTracker, &_type_spec_EmailMailboxChangeTracker, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedDeferral>::python_type = py::register_python_type(module, _type_name_EmailMailboxChangedDeferral, &_type_spec_EmailMailboxChangedDeferral, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs>::python_type = py::register_python_type(module, _type_name_EmailMailboxChangedEventArgs, &_type_spec_EmailMailboxChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult>::python_type = py::register_python_type(module, _type_name_EmailMailboxCreateFolderResult, &_type_spec_EmailMailboxCreateFolderResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxPolicies>::python_type = py::register_python_type(module, _type_name_EmailMailboxPolicies, &_type_spec_EmailMailboxPolicies, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMailboxSyncManager>::python_type = py::register_python_type(module, _type_name_EmailMailboxSyncManager, &_type_spec_EmailMailboxSyncManager, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailManager>::python_type = py::register_python_type(module, _type_name_EmailManager, &_type_spec_EmailManager, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailManagerForUser>::python_type = py::register_python_type(module, _type_name_EmailManagerForUser, &_type_spec_EmailManagerForUser, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMeetingInfo>::python_type = py::register_python_type(module, _type_name_EmailMeetingInfo, &_type_spec_EmailMeetingInfo, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMessage>::python_type = py::register_python_type(module, _type_name_EmailMessage, &_type_spec_EmailMessage, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMessageBatch>::python_type = py::register_python_type(module, _type_name_EmailMessageBatch, &_type_spec_EmailMessageBatch, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailMessageReader>::python_type = py::register_python_type(module, _type_name_EmailMessageReader, &_type_spec_EmailMessageReader, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>::python_type = py::register_python_type(module, _type_name_EmailQueryOptions, &_type_spec_EmailQueryOptions, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailQueryTextSearch>::python_type = py::register_python_type(module, _type_name_EmailQueryTextSearch, &_type_spec_EmailQueryTextSearch, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailRecipient>::python_type = py::register_python_type(module, _type_name_EmailRecipient, &_type_spec_EmailRecipient, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailRecipientResolutionResult>::python_type = py::register_python_type(module, _type_name_EmailRecipientResolutionResult, &_type_spec_EmailRecipientResolutionResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailStore>::python_type = py::register_python_type(module, _type_name_EmailStore, &_type_spec_EmailStore, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Email::EmailStoreNotificationTriggerDetails>::python_type = py::register_python_type(module, _type_name_EmailStoreNotificationTriggerDetails, &_type_spec_EmailStoreNotificationTriggerDetails, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.Email");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_ApplicationModel_Email",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::ApplicationModel::Email

PyMODINIT_FUNC
PyInit__winrt_Windows_ApplicationModel_Email (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::ApplicationModel::Email::module_def);
}
