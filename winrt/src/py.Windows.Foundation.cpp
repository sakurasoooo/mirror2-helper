// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Foundation.h"

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Deferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::GuidHelper>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::MemoryBuffer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::PropertyValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Uri>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoder>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IAsyncAction>::python_type;
PyTypeObject* py::winrt_type<py::proj::Windows::Foundation::IAsyncActionWithProgress>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IAsyncInfo>::python_type;
PyTypeObject* py::winrt_type<py::proj::Windows::Foundation::IAsyncOperationWithProgress>::python_type;
PyTypeObject* py::winrt_type<py::proj::Windows::Foundation::IAsyncOperation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IClosable>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IGetActivationFactory>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IMemoryBuffer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IMemoryBufferReference>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IPropertyValue>::python_type;
PyTypeObject* py::winrt_type<py::proj::Windows::Foundation::IReferenceArray>::python_type;
PyTypeObject* py::winrt_type<py::proj::Windows::Foundation::IReference>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IStringable>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::DateTime>::python_type;
PyTypeObject* py::winrt_type<winrt::event_token>::python_type;
PyTypeObject* py::winrt_type<winrt::hresult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Point>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Rect>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Size>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::TimeSpan>::python_type;

static int64_t custom_get(winrt::Windows::Foundation::DateTime const& instance) 
{
    return instance.time_since_epoch().count();
}

static void custom_set(winrt::Windows::Foundation::DateTime& instance, int64_t value) 
{
    instance = winrt::Windows::Foundation::DateTime{ winrt::Windows::Foundation::TimeSpan{ value } };
}

static int64_t custom_get(winrt::Windows::Foundation::TimeSpan const& instance) 
{
    return instance.count();
}

static void custom_set(winrt::Windows::Foundation::TimeSpan& instance, int64_t value) 
{
    instance = winrt::Windows::Foundation::TimeSpan{ value };
}

static int64_t custom_get(winrt::event_token const& instance) 
{
    return instance.value;
}

static void custom_set(winrt::event_token& instance, int64_t value) 
{
    instance.value = value;
}

static int32_t custom_get(winrt::hresult const& instance) 
{
    return instance;
}

static void custom_set(winrt::hresult& instance, int32_t value) 
{
    instance = value;
}

PyObject* py::converter<winrt::Windows::Foundation::DateTime>::convert(winrt::Windows::Foundation::DateTime instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Foundation::DateTime>());
}
winrt::Windows::Foundation::DateTime py::converter<winrt::Windows::Foundation::DateTime>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::DateTime>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::DateTime>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Foundation::DateTime return_value{};

    PyObject* py_UniversalTime = PyDict_GetItemString(obj, "universal_time");
    if (!py_UniversalTime) { throw winrt::hresult_invalid_argument(); }
    custom_set(return_value, converter<int64_t>::convert_to(py_UniversalTime));

    return return_value;
}

PyObject* py::converter<winrt::event_token>::convert(winrt::event_token instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::event_token>());
}
winrt::event_token py::converter<winrt::event_token>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::event_token>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::event_token>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::event_token return_value{};

    PyObject* py_Value = PyDict_GetItemString(obj, "value");
    if (!py_Value) { throw winrt::hresult_invalid_argument(); }
    custom_set(return_value, converter<int64_t>::convert_to(py_Value));

    return return_value;
}

PyObject* py::converter<winrt::hresult>::convert(winrt::hresult instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::hresult>());
}
winrt::hresult py::converter<winrt::hresult>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::hresult>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::hresult>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::hresult return_value{};

    PyObject* py_Value = PyDict_GetItemString(obj, "value");
    if (!py_Value) { throw winrt::hresult_invalid_argument(); }
    custom_set(return_value, converter<int32_t>::convert_to(py_Value));

    return return_value;
}

PyObject* py::converter<winrt::Windows::Foundation::Point>::convert(winrt::Windows::Foundation::Point instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Foundation::Point>());
}
winrt::Windows::Foundation::Point py::converter<winrt::Windows::Foundation::Point>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Point>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Point>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Foundation::Point return_value{};

    PyObject* py_X = PyDict_GetItemString(obj, "x");
    if (!py_X) { throw winrt::hresult_invalid_argument(); }
    return_value.X = converter<float>::convert_to(py_X);

    PyObject* py_Y = PyDict_GetItemString(obj, "y");
    if (!py_Y) { throw winrt::hresult_invalid_argument(); }
    return_value.Y = converter<float>::convert_to(py_Y);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Foundation::Rect>::convert(winrt::Windows::Foundation::Rect instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Foundation::Rect>());
}
winrt::Windows::Foundation::Rect py::converter<winrt::Windows::Foundation::Rect>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Rect>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Rect>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Foundation::Rect return_value{};

    PyObject* py_X = PyDict_GetItemString(obj, "x");
    if (!py_X) { throw winrt::hresult_invalid_argument(); }
    return_value.X = converter<float>::convert_to(py_X);

    PyObject* py_Y = PyDict_GetItemString(obj, "y");
    if (!py_Y) { throw winrt::hresult_invalid_argument(); }
    return_value.Y = converter<float>::convert_to(py_Y);

    PyObject* py_Width = PyDict_GetItemString(obj, "width");
    if (!py_Width) { throw winrt::hresult_invalid_argument(); }
    return_value.Width = converter<float>::convert_to(py_Width);

    PyObject* py_Height = PyDict_GetItemString(obj, "height");
    if (!py_Height) { throw winrt::hresult_invalid_argument(); }
    return_value.Height = converter<float>::convert_to(py_Height);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Foundation::Size>::convert(winrt::Windows::Foundation::Size instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Foundation::Size>());
}
winrt::Windows::Foundation::Size py::converter<winrt::Windows::Foundation::Size>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Size>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Size>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Foundation::Size return_value{};

    PyObject* py_Width = PyDict_GetItemString(obj, "width");
    if (!py_Width) { throw winrt::hresult_invalid_argument(); }
    return_value.Width = converter<float>::convert_to(py_Width);

    PyObject* py_Height = PyDict_GetItemString(obj, "height");
    if (!py_Height) { throw winrt::hresult_invalid_argument(); }
    return_value.Height = converter<float>::convert_to(py_Height);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Foundation::TimeSpan>::convert(winrt::Windows::Foundation::TimeSpan instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Foundation::TimeSpan>());
}
winrt::Windows::Foundation::TimeSpan py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::TimeSpan>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::TimeSpan>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Foundation::TimeSpan return_value{};

    PyObject* py_Duration = PyDict_GetItemString(obj, "duration");
    if (!py_Duration) { throw winrt::hresult_invalid_argument(); }
    custom_set(return_value, converter<int64_t>::convert_to(py_Duration));

    return return_value;
}

namespace py::cpp::Windows::Foundation
{
    // ----- Deferral class --------------------
    constexpr const char* const _type_name_Deferral = "Deferral";

    static PyObject* _new_Deferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DeferralCompletedHandler>(args, 0);

                winrt::Windows::Foundation::Deferral instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Deferral(py::wrapper::Windows::Foundation::Deferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Deferral_Close(py::wrapper::Windows::Foundation::Deferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Deferral_Complete(py::wrapper::Windows::Foundation::Deferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_Deferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Deferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_Deferral(py::wrapper::Windows::Foundation::Deferral* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_Deferral(py::wrapper::Windows::Foundation::Deferral* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Deferral[] = {
        { "close", (PyCFunction)Deferral_Close, METH_VARARGS, nullptr },
        { "complete", (PyCFunction)Deferral_Complete, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_Deferral, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_Deferral, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_Deferral, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_Deferral[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_Deferral[] = 
    {
        { Py_tp_new, _new_Deferral },
        { Py_tp_dealloc, _dealloc_Deferral },
        { Py_tp_methods, _methods_Deferral },
        { Py_tp_getset, _getset_Deferral },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Deferral =
    {
        "_winrt_Windows_Foundation.Deferral",
        sizeof(py::wrapper::Windows::Foundation::Deferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Deferral
    };

    // ----- GuidHelper class --------------------
    constexpr const char* const _type_name_GuidHelper = "GuidHelper";

    static PyObject* _new_GuidHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GuidHelper);
        return nullptr;
    }

    static PyObject* GuidHelper_CreateNewGuid(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Foundation::GuidHelper::CreateNewGuid());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidHelper_Equals(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                return py::convert(winrt::Windows::Foundation::GuidHelper::Equals(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidHelper_get_Empty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Foundation::GuidHelper::Empty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GuidHelper[] = {
        { "create_new_guid", (PyCFunction)GuidHelper_CreateNewGuid, METH_VARARGS | METH_STATIC, nullptr },
        { "equals", (PyCFunction)GuidHelper_Equals, METH_VARARGS | METH_STATIC, nullptr },
        { "get_empty", (PyCFunction)GuidHelper_get_Empty, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GuidHelper[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_GuidHelper[] = 
    {
        { Py_tp_new, _new_GuidHelper },
        { Py_tp_methods, _methods_GuidHelper },
        { Py_tp_getset, _getset_GuidHelper },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GuidHelper =
    {
        "_winrt_Windows_Foundation.GuidHelper",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GuidHelper
    };

    // ----- MemoryBuffer class --------------------
    constexpr const char* const _type_name_MemoryBuffer = "MemoryBuffer";

    static PyObject* _new_MemoryBuffer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Foundation::MemoryBuffer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MemoryBuffer(py::wrapper::Windows::Foundation::MemoryBuffer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MemoryBuffer_Close(py::wrapper::Windows::Foundation::MemoryBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MemoryBuffer_CreateReference(py::wrapper::Windows::Foundation::MemoryBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_MemoryBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::MemoryBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MemoryBuffer(py::wrapper::Windows::Foundation::MemoryBuffer* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_MemoryBuffer(py::wrapper::Windows::Foundation::MemoryBuffer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MemoryBuffer[] = {
        { "close", (PyCFunction)MemoryBuffer_Close, METH_VARARGS, nullptr },
        { "create_reference", (PyCFunction)MemoryBuffer_CreateReference, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MemoryBuffer, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_MemoryBuffer, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_MemoryBuffer, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MemoryBuffer[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_MemoryBuffer[] = 
    {
        { Py_tp_new, _new_MemoryBuffer },
        { Py_tp_dealloc, _dealloc_MemoryBuffer },
        { Py_tp_methods, _methods_MemoryBuffer },
        { Py_tp_getset, _getset_MemoryBuffer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MemoryBuffer =
    {
        "_winrt_Windows_Foundation.MemoryBuffer",
        sizeof(py::wrapper::Windows::Foundation::MemoryBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MemoryBuffer
    };

    // ----- PropertyValue class --------------------
    constexpr const char* const _type_name_PropertyValue = "PropertyValue";

    static PyObject* _new_PropertyValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PropertyValue);
        return nullptr;
    }

    static PyObject* PropertyValue_CreateBoolean(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateBoolean(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateBooleanArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<bool>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateBooleanArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateChar16(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<char16_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateChar16(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateChar16Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<char16_t>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateChar16Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateDateTime(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateDateTime(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateDateTimeArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::DateTime>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateDateTimeArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateDouble(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateDouble(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateDoubleArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<double>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateDoubleArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateEmpty(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateEmpty());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateGuid(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateGuid(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateGuidArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::guid>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateGuidArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInspectable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInspectable(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInspectableArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::IInspectable>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInspectableArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt16(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int16_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInt16(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt16Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int16_t>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInt16Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt32(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInt32(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt32Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int32_t>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInt32Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt64(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int64_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInt64(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateInt64Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateInt64Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreatePoint(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreatePoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreatePointArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Point>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreatePointArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateRect(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateRect(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateRectArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Rect>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateRectArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateSingle(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<float>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateSingle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateSingleArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<float>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateSingleArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateSize(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateSize(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateSizeArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Size>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateSizeArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateString(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateStringArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::hstring>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateStringArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateTimeSpan(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateTimeSpan(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateTimeSpanArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::TimeSpan>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateTimeSpanArray(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt16(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt16(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt16Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint16_t>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt16Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt32(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt32(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt32Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint32_t>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt32Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt64(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt64(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt64Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint64_t>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt64Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt8(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt8(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PropertyValue_CreateUInt8Array(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(winrt::Windows::Foundation::PropertyValue::CreateUInt8Array(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PropertyValue[] = {
        { "create_boolean", (PyCFunction)PropertyValue_CreateBoolean, METH_VARARGS | METH_STATIC, nullptr },
        { "create_boolean_array", (PyCFunction)PropertyValue_CreateBooleanArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_char16", (PyCFunction)PropertyValue_CreateChar16, METH_VARARGS | METH_STATIC, nullptr },
        { "create_char16_array", (PyCFunction)PropertyValue_CreateChar16Array, METH_VARARGS | METH_STATIC, nullptr },
        { "create_date_time", (PyCFunction)PropertyValue_CreateDateTime, METH_VARARGS | METH_STATIC, nullptr },
        { "create_date_time_array", (PyCFunction)PropertyValue_CreateDateTimeArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_double", (PyCFunction)PropertyValue_CreateDouble, METH_VARARGS | METH_STATIC, nullptr },
        { "create_double_array", (PyCFunction)PropertyValue_CreateDoubleArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_empty", (PyCFunction)PropertyValue_CreateEmpty, METH_VARARGS | METH_STATIC, nullptr },
        { "create_guid", (PyCFunction)PropertyValue_CreateGuid, METH_VARARGS | METH_STATIC, nullptr },
        { "create_guid_array", (PyCFunction)PropertyValue_CreateGuidArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_inspectable", (PyCFunction)PropertyValue_CreateInspectable, METH_VARARGS | METH_STATIC, nullptr },
        { "create_inspectable_array", (PyCFunction)PropertyValue_CreateInspectableArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_int16", (PyCFunction)PropertyValue_CreateInt16, METH_VARARGS | METH_STATIC, nullptr },
        { "create_int16_array", (PyCFunction)PropertyValue_CreateInt16Array, METH_VARARGS | METH_STATIC, nullptr },
        { "create_int32", (PyCFunction)PropertyValue_CreateInt32, METH_VARARGS | METH_STATIC, nullptr },
        { "create_int32_array", (PyCFunction)PropertyValue_CreateInt32Array, METH_VARARGS | METH_STATIC, nullptr },
        { "create_int64", (PyCFunction)PropertyValue_CreateInt64, METH_VARARGS | METH_STATIC, nullptr },
        { "create_int64_array", (PyCFunction)PropertyValue_CreateInt64Array, METH_VARARGS | METH_STATIC, nullptr },
        { "create_point", (PyCFunction)PropertyValue_CreatePoint, METH_VARARGS | METH_STATIC, nullptr },
        { "create_point_array", (PyCFunction)PropertyValue_CreatePointArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_rect", (PyCFunction)PropertyValue_CreateRect, METH_VARARGS | METH_STATIC, nullptr },
        { "create_rect_array", (PyCFunction)PropertyValue_CreateRectArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_single", (PyCFunction)PropertyValue_CreateSingle, METH_VARARGS | METH_STATIC, nullptr },
        { "create_single_array", (PyCFunction)PropertyValue_CreateSingleArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_size", (PyCFunction)PropertyValue_CreateSize, METH_VARARGS | METH_STATIC, nullptr },
        { "create_size_array", (PyCFunction)PropertyValue_CreateSizeArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_string", (PyCFunction)PropertyValue_CreateString, METH_VARARGS | METH_STATIC, nullptr },
        { "create_string_array", (PyCFunction)PropertyValue_CreateStringArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_time_span", (PyCFunction)PropertyValue_CreateTimeSpan, METH_VARARGS | METH_STATIC, nullptr },
        { "create_time_span_array", (PyCFunction)PropertyValue_CreateTimeSpanArray, METH_VARARGS | METH_STATIC, nullptr },
        { "create_uint16", (PyCFunction)PropertyValue_CreateUInt16, METH_VARARGS | METH_STATIC, nullptr },
        { "create_uint16_array", (PyCFunction)PropertyValue_CreateUInt16Array, METH_VARARGS | METH_STATIC, nullptr },
        { "create_uint32", (PyCFunction)PropertyValue_CreateUInt32, METH_VARARGS | METH_STATIC, nullptr },
        { "create_uint32_array", (PyCFunction)PropertyValue_CreateUInt32Array, METH_VARARGS | METH_STATIC, nullptr },
        { "create_uint64", (PyCFunction)PropertyValue_CreateUInt64, METH_VARARGS | METH_STATIC, nullptr },
        { "create_uint64_array", (PyCFunction)PropertyValue_CreateUInt64Array, METH_VARARGS | METH_STATIC, nullptr },
        { "create_uint8", (PyCFunction)PropertyValue_CreateUInt8, METH_VARARGS | METH_STATIC, nullptr },
        { "create_uint8_array", (PyCFunction)PropertyValue_CreateUInt8Array, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PropertyValue[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PropertyValue[] = 
    {
        { Py_tp_new, _new_PropertyValue },
        { Py_tp_methods, _methods_PropertyValue },
        { Py_tp_getset, _getset_PropertyValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PropertyValue =
    {
        "_winrt_Windows_Foundation.PropertyValue",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PropertyValue
    };

    // ----- Uri class --------------------
    constexpr const char* const _type_name_Uri = "Uri";

    static PyObject* _new_Uri(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Foundation::Uri instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Foundation::Uri instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Uri(py::wrapper::Windows::Foundation::Uri* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Uri_CombineUri(py::wrapper::Windows::Foundation::Uri* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CombineUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Uri_Equals(py::wrapper::Windows::Foundation::Uri* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.Equals(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Uri_EscapeComponent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Foundation::Uri::EscapeComponent(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Uri_ToString(py::wrapper::Windows::Foundation::Uri* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Uri_UnescapeComponent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Foundation::Uri::UnescapeComponent(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Uri_get_AbsoluteUri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AbsoluteUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_DisplayUri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Domain(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Domain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Extension(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Extension());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Fragment(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Fragment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Host(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Host());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Password(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Password());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Path(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Port(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Port());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Query(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Query());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_QueryParsed(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.QueryParsed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_RawUri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_SchemeName(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SchemeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_Suspicious(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Suspicious());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_UserName(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_AbsoluteCanonicalUri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AbsoluteCanonicalUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Uri_get_DisplayIri(py::wrapper::Windows::Foundation::Uri* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayIri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Uri(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Uri>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_Uri(py::wrapper::Windows::Foundation::Uri* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Uri[] = {
        { "combine_uri", (PyCFunction)Uri_CombineUri, METH_VARARGS, nullptr },
        { "equals", (PyCFunction)Uri_Equals, METH_VARARGS, nullptr },
        { "escape_component", (PyCFunction)Uri_EscapeComponent, METH_VARARGS | METH_STATIC, nullptr },
        { "to_string", (PyCFunction)Uri_ToString, METH_VARARGS, nullptr },
        { "unescape_component", (PyCFunction)Uri_UnescapeComponent, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_Uri, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_Uri[] = {
        { const_cast<char*>("absolute_uri"), (getter)Uri_get_AbsoluteUri, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_uri"), (getter)Uri_get_DisplayUri, nullptr, nullptr, nullptr },
        { const_cast<char*>("domain"), (getter)Uri_get_Domain, nullptr, nullptr, nullptr },
        { const_cast<char*>("extension"), (getter)Uri_get_Extension, nullptr, nullptr, nullptr },
        { const_cast<char*>("fragment"), (getter)Uri_get_Fragment, nullptr, nullptr, nullptr },
        { const_cast<char*>("host"), (getter)Uri_get_Host, nullptr, nullptr, nullptr },
        { const_cast<char*>("password"), (getter)Uri_get_Password, nullptr, nullptr, nullptr },
        { const_cast<char*>("path"), (getter)Uri_get_Path, nullptr, nullptr, nullptr },
        { const_cast<char*>("port"), (getter)Uri_get_Port, nullptr, nullptr, nullptr },
        { const_cast<char*>("query"), (getter)Uri_get_Query, nullptr, nullptr, nullptr },
        { const_cast<char*>("query_parsed"), (getter)Uri_get_QueryParsed, nullptr, nullptr, nullptr },
        { const_cast<char*>("raw_uri"), (getter)Uri_get_RawUri, nullptr, nullptr, nullptr },
        { const_cast<char*>("scheme_name"), (getter)Uri_get_SchemeName, nullptr, nullptr, nullptr },
        { const_cast<char*>("suspicious"), (getter)Uri_get_Suspicious, nullptr, nullptr, nullptr },
        { const_cast<char*>("user_name"), (getter)Uri_get_UserName, nullptr, nullptr, nullptr },
        { const_cast<char*>("absolute_canonical_uri"), (getter)Uri_get_AbsoluteCanonicalUri, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_iri"), (getter)Uri_get_DisplayIri, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Uri[] = 
    {
        { Py_tp_new, _new_Uri },
        { Py_tp_dealloc, _dealloc_Uri },
        { Py_tp_methods, _methods_Uri },
        { Py_tp_getset, _getset_Uri },
        { Py_tp_str, _str_Uri },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Uri =
    {
        "_winrt_Windows_Foundation.Uri",
        sizeof(py::wrapper::Windows::Foundation::Uri),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Uri
    };

    // ----- WwwFormUrlDecoder class --------------------
    constexpr const char* const _type_name_WwwFormUrlDecoder = "WwwFormUrlDecoder";

    static PyObject* _new_WwwFormUrlDecoder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Foundation::WwwFormUrlDecoder instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* WwwFormUrlDecoder_First(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoder_GetAt(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoder_GetFirstValueByName(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFirstValueByName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoder_GetMany(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry> param1 ( param1_count, py::empty_instance<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::get() );

                auto return_value = self->obj.GetMany(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoder_IndexOf(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoder_get_Size(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_WwwFormUrlDecoder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::WwwFormUrlDecoder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_WwwFormUrlDecoder(py::wrapper::Windows::Foundation::WwwFormUrlDecoder* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WwwFormUrlDecoder[] = {
        { "first", (PyCFunction)WwwFormUrlDecoder_First, METH_VARARGS, nullptr },
        { "get_at", (PyCFunction)WwwFormUrlDecoder_GetAt, METH_VARARGS, nullptr },
        { "get_first_value_by_name", (PyCFunction)WwwFormUrlDecoder_GetFirstValueByName, METH_VARARGS, nullptr },
        { "get_many", (PyCFunction)WwwFormUrlDecoder_GetMany, METH_VARARGS, nullptr },
        { "index_of", (PyCFunction)WwwFormUrlDecoder_IndexOf, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_WwwFormUrlDecoder, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_WwwFormUrlDecoder[] = {
        { const_cast<char*>("size"), (getter)WwwFormUrlDecoder_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_WwwFormUrlDecoder[] = 
    {
        { Py_tp_new, _new_WwwFormUrlDecoder },
        { Py_tp_dealloc, _dealloc_WwwFormUrlDecoder },
        { Py_tp_methods, _methods_WwwFormUrlDecoder },
        { Py_tp_getset, _getset_WwwFormUrlDecoder },
        { Py_tp_iter, _iterator_WwwFormUrlDecoder },
        { Py_sq_length, _seq_length_WwwFormUrlDecoder },
        { Py_sq_item, _seq_item_WwwFormUrlDecoder },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_WwwFormUrlDecoder =
    {
        "_winrt_Windows_Foundation.WwwFormUrlDecoder",
        sizeof(py::wrapper::Windows::Foundation::WwwFormUrlDecoder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WwwFormUrlDecoder
    };

    // ----- WwwFormUrlDecoderEntry class --------------------
    constexpr const char* const _type_name_WwwFormUrlDecoderEntry = "WwwFormUrlDecoderEntry";

    static PyObject* _new_WwwFormUrlDecoderEntry(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_WwwFormUrlDecoderEntry);
        return nullptr;
    }

    static void _dealloc_WwwFormUrlDecoderEntry(py::wrapper::Windows::Foundation::WwwFormUrlDecoderEntry* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* WwwFormUrlDecoderEntry_get_Name(py::wrapper::Windows::Foundation::WwwFormUrlDecoderEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WwwFormUrlDecoderEntry_get_Value(py::wrapper::Windows::Foundation::WwwFormUrlDecoderEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_WwwFormUrlDecoderEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WwwFormUrlDecoderEntry[] = {
        { "_from", (PyCFunction)_from_WwwFormUrlDecoderEntry, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_WwwFormUrlDecoderEntry[] = {
        { const_cast<char*>("name"), (getter)WwwFormUrlDecoderEntry_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("value"), (getter)WwwFormUrlDecoderEntry_get_Value, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_WwwFormUrlDecoderEntry[] = 
    {
        { Py_tp_new, _new_WwwFormUrlDecoderEntry },
        { Py_tp_dealloc, _dealloc_WwwFormUrlDecoderEntry },
        { Py_tp_methods, _methods_WwwFormUrlDecoderEntry },
        { Py_tp_getset, _getset_WwwFormUrlDecoderEntry },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_WwwFormUrlDecoderEntry =
    {
        "_winrt_Windows_Foundation.WwwFormUrlDecoderEntry",
        sizeof(py::wrapper::Windows::Foundation::WwwFormUrlDecoderEntry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WwwFormUrlDecoderEntry
    };

    // ----- IAsyncAction interface --------------------
    constexpr const char* const _type_name_IAsyncAction = "IAsyncAction";

    static PyObject* _new_IAsyncAction(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IAsyncAction);
        return nullptr;
    }

    static void _dealloc_IAsyncAction(py::wrapper::Windows::Foundation::IAsyncAction* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IAsyncAction_Cancel(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Cancel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAsyncAction_Close(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAsyncAction_GetResults(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.GetResults();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAsyncAction_get_Completed(py::wrapper::Windows::Foundation::IAsyncAction* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Completed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAsyncAction_put_Completed(py::wrapper::Windows::Foundation::IAsyncAction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncActionCompletedHandler>(arg);

            self->obj.Completed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAsyncAction_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncAction* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncAction_get_Id(py::wrapper::Windows::Foundation::IAsyncAction* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncAction_get_Status(py::wrapper::Windows::Foundation::IAsyncAction* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IAsyncAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IAsyncAction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_IAsyncAction(py::wrapper::Windows::Foundation::IAsyncAction* self) noexcept
    {
        return py::dunder_await(self->obj);
    }

    static PyMethodDef _methods_IAsyncAction[] = {
        { "get_results", (PyCFunction)IAsyncAction_GetResults, METH_VARARGS, nullptr },
        { "cancel", (PyCFunction)IAsyncAction_Cancel, METH_VARARGS, nullptr },
        { "close", (PyCFunction)IAsyncAction_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IAsyncAction, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IAsyncAction[] = {
        { const_cast<char*>("completed"), (getter)IAsyncAction_get_Completed, (setter)IAsyncAction_put_Completed, nullptr, nullptr },
        { const_cast<char*>("error_code"), (getter)IAsyncAction_get_ErrorCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)IAsyncAction_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)IAsyncAction_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IAsyncAction[] = 
    {
        { Py_tp_new, _new_IAsyncAction },
        { Py_tp_dealloc, _dealloc_IAsyncAction },
        { Py_tp_methods, _methods_IAsyncAction },
        { Py_tp_getset, _getset_IAsyncAction },
        { Py_am_await, (unaryfunc)_await_IAsyncAction },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IAsyncAction =
    {
        "_winrt_Windows_Foundation.IAsyncAction",
        sizeof(py::wrapper::Windows::Foundation::IAsyncAction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAsyncAction
    };

    // ----- IAsyncActionWithProgress interface --------------------
    constexpr const char* const _type_name_IAsyncActionWithProgress = "IAsyncActionWithProgress";

    static PyObject* _new_IAsyncActionWithProgress(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IAsyncActionWithProgress);
        return nullptr;
    }

    static void _dealloc_IAsyncActionWithProgress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self)
    {
        auto hash_value = self->obj->hash();
        py::wrapped_instance(hash_value, nullptr);
        self->obj.reset();
    }

    static PyObject* IAsyncActionWithProgress_Cancel(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* args) noexcept
    {
        return self->obj->Cancel(args);
    }

    static PyObject* IAsyncActionWithProgress_Close(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* args) noexcept
    {
        return self->obj->Close(args);
    }

    static PyObject* IAsyncActionWithProgress_GetResults(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* args) noexcept
    {
        return self->obj->GetResults(args);
    }

    static PyObject* IAsyncActionWithProgress_get_Progress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/) noexcept
    {
        return self->obj->get_Progress();
    }

    static int IAsyncActionWithProgress_put_Progress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        return self->obj->put_Progress(arg);
    }

    static PyObject* IAsyncActionWithProgress_get_Completed(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/) noexcept
    {
        return self->obj->get_Completed();
    }

    static int IAsyncActionWithProgress_put_Completed(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        return self->obj->put_Completed(arg);
    }

    static PyObject* IAsyncActionWithProgress_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/) noexcept
    {
        return self->obj->get_ErrorCode();
    }

    static PyObject* IAsyncActionWithProgress_get_Id(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/) noexcept
    {
        return self->obj->get_Id();
    }

    static PyObject* IAsyncActionWithProgress_get_Status(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self, void* /*unused*/) noexcept
    {
        return self->obj->get_Status();
    }

    static PyObject* _await_IAsyncActionWithProgress(py::wrapper::Windows::Foundation::IAsyncActionWithProgress* self) noexcept
    {
        return self->obj->dunder_await();
    }

    static PyMethodDef _methods_IAsyncActionWithProgress[] = {
        { "get_results", (PyCFunction)IAsyncActionWithProgress_GetResults, METH_VARARGS, nullptr },
        { "cancel", (PyCFunction)IAsyncActionWithProgress_Cancel, METH_VARARGS, nullptr },
        { "close", (PyCFunction)IAsyncActionWithProgress_Close, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IAsyncActionWithProgress[] = {
        { const_cast<char*>("progress"), (getter)IAsyncActionWithProgress_get_Progress, (setter)IAsyncActionWithProgress_put_Progress, nullptr, nullptr },
        { const_cast<char*>("completed"), (getter)IAsyncActionWithProgress_get_Completed, (setter)IAsyncActionWithProgress_put_Completed, nullptr, nullptr },
        { const_cast<char*>("error_code"), (getter)IAsyncActionWithProgress_get_ErrorCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)IAsyncActionWithProgress_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)IAsyncActionWithProgress_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IAsyncActionWithProgress[] = 
    {
        { Py_tp_new, _new_IAsyncActionWithProgress },
        { Py_tp_dealloc, _dealloc_IAsyncActionWithProgress },
        { Py_tp_methods, _methods_IAsyncActionWithProgress },
        { Py_tp_getset, _getset_IAsyncActionWithProgress },
        { Py_am_await, (unaryfunc)_await_IAsyncActionWithProgress },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IAsyncActionWithProgress =
    {
        "_winrt_Windows_Foundation.IAsyncActionWithProgress",
        sizeof(py::wrapper::Windows::Foundation::IAsyncActionWithProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAsyncActionWithProgress
    };

    // ----- IAsyncInfo interface --------------------
    constexpr const char* const _type_name_IAsyncInfo = "IAsyncInfo";

    static PyObject* _new_IAsyncInfo(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IAsyncInfo);
        return nullptr;
    }

    static void _dealloc_IAsyncInfo(py::wrapper::Windows::Foundation::IAsyncInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IAsyncInfo_Cancel(py::wrapper::Windows::Foundation::IAsyncInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Cancel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAsyncInfo_Close(py::wrapper::Windows::Foundation::IAsyncInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAsyncInfo_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncInfo_get_Id(py::wrapper::Windows::Foundation::IAsyncInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAsyncInfo_get_Status(py::wrapper::Windows::Foundation::IAsyncInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IAsyncInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IAsyncInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAsyncInfo[] = {
        { "cancel", (PyCFunction)IAsyncInfo_Cancel, METH_VARARGS, nullptr },
        { "close", (PyCFunction)IAsyncInfo_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IAsyncInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IAsyncInfo[] = {
        { const_cast<char*>("error_code"), (getter)IAsyncInfo_get_ErrorCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)IAsyncInfo_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)IAsyncInfo_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IAsyncInfo[] = 
    {
        { Py_tp_new, _new_IAsyncInfo },
        { Py_tp_dealloc, _dealloc_IAsyncInfo },
        { Py_tp_methods, _methods_IAsyncInfo },
        { Py_tp_getset, _getset_IAsyncInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IAsyncInfo =
    {
        "_winrt_Windows_Foundation.IAsyncInfo",
        sizeof(py::wrapper::Windows::Foundation::IAsyncInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAsyncInfo
    };

    // ----- IAsyncOperationWithProgress interface --------------------
    constexpr const char* const _type_name_IAsyncOperationWithProgress = "IAsyncOperationWithProgress";

    static PyObject* _new_IAsyncOperationWithProgress(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IAsyncOperationWithProgress);
        return nullptr;
    }

    static void _dealloc_IAsyncOperationWithProgress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self)
    {
        auto hash_value = self->obj->hash();
        py::wrapped_instance(hash_value, nullptr);
        self->obj.reset();
    }

    static PyObject* IAsyncOperationWithProgress_Cancel(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* args) noexcept
    {
        return self->obj->Cancel(args);
    }

    static PyObject* IAsyncOperationWithProgress_Close(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* args) noexcept
    {
        return self->obj->Close(args);
    }

    static PyObject* IAsyncOperationWithProgress_GetResults(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* args) noexcept
    {
        return self->obj->GetResults(args);
    }

    static PyObject* IAsyncOperationWithProgress_get_Progress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/) noexcept
    {
        return self->obj->get_Progress();
    }

    static int IAsyncOperationWithProgress_put_Progress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        return self->obj->put_Progress(arg);
    }

    static PyObject* IAsyncOperationWithProgress_get_Completed(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/) noexcept
    {
        return self->obj->get_Completed();
    }

    static int IAsyncOperationWithProgress_put_Completed(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        return self->obj->put_Completed(arg);
    }

    static PyObject* IAsyncOperationWithProgress_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/) noexcept
    {
        return self->obj->get_ErrorCode();
    }

    static PyObject* IAsyncOperationWithProgress_get_Id(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/) noexcept
    {
        return self->obj->get_Id();
    }

    static PyObject* IAsyncOperationWithProgress_get_Status(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self, void* /*unused*/) noexcept
    {
        return self->obj->get_Status();
    }

    static PyObject* _await_IAsyncOperationWithProgress(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress* self) noexcept
    {
        return self->obj->dunder_await();
    }

    static PyMethodDef _methods_IAsyncOperationWithProgress[] = {
        { "get_results", (PyCFunction)IAsyncOperationWithProgress_GetResults, METH_VARARGS, nullptr },
        { "cancel", (PyCFunction)IAsyncOperationWithProgress_Cancel, METH_VARARGS, nullptr },
        { "close", (PyCFunction)IAsyncOperationWithProgress_Close, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IAsyncOperationWithProgress[] = {
        { const_cast<char*>("progress"), (getter)IAsyncOperationWithProgress_get_Progress, (setter)IAsyncOperationWithProgress_put_Progress, nullptr, nullptr },
        { const_cast<char*>("completed"), (getter)IAsyncOperationWithProgress_get_Completed, (setter)IAsyncOperationWithProgress_put_Completed, nullptr, nullptr },
        { const_cast<char*>("error_code"), (getter)IAsyncOperationWithProgress_get_ErrorCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)IAsyncOperationWithProgress_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)IAsyncOperationWithProgress_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IAsyncOperationWithProgress[] = 
    {
        { Py_tp_new, _new_IAsyncOperationWithProgress },
        { Py_tp_dealloc, _dealloc_IAsyncOperationWithProgress },
        { Py_tp_methods, _methods_IAsyncOperationWithProgress },
        { Py_tp_getset, _getset_IAsyncOperationWithProgress },
        { Py_am_await, (unaryfunc)_await_IAsyncOperationWithProgress },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IAsyncOperationWithProgress =
    {
        "_winrt_Windows_Foundation.IAsyncOperationWithProgress",
        sizeof(py::wrapper::Windows::Foundation::IAsyncOperationWithProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAsyncOperationWithProgress
    };

    // ----- IAsyncOperation interface --------------------
    constexpr const char* const _type_name_IAsyncOperation = "IAsyncOperation";

    static PyObject* _new_IAsyncOperation(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IAsyncOperation);
        return nullptr;
    }

    static void _dealloc_IAsyncOperation(py::wrapper::Windows::Foundation::IAsyncOperation* self)
    {
        auto hash_value = self->obj->hash();
        py::wrapped_instance(hash_value, nullptr);
        self->obj.reset();
    }

    static PyObject* IAsyncOperation_Cancel(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* args) noexcept
    {
        return self->obj->Cancel(args);
    }

    static PyObject* IAsyncOperation_Close(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* args) noexcept
    {
        return self->obj->Close(args);
    }

    static PyObject* IAsyncOperation_GetResults(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* args) noexcept
    {
        return self->obj->GetResults(args);
    }

    static PyObject* IAsyncOperation_get_Completed(py::wrapper::Windows::Foundation::IAsyncOperation* self, void* /*unused*/) noexcept
    {
        return self->obj->get_Completed();
    }

    static int IAsyncOperation_put_Completed(py::wrapper::Windows::Foundation::IAsyncOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        return self->obj->put_Completed(arg);
    }

    static PyObject* IAsyncOperation_get_ErrorCode(py::wrapper::Windows::Foundation::IAsyncOperation* self, void* /*unused*/) noexcept
    {
        return self->obj->get_ErrorCode();
    }

    static PyObject* IAsyncOperation_get_Id(py::wrapper::Windows::Foundation::IAsyncOperation* self, void* /*unused*/) noexcept
    {
        return self->obj->get_Id();
    }

    static PyObject* IAsyncOperation_get_Status(py::wrapper::Windows::Foundation::IAsyncOperation* self, void* /*unused*/) noexcept
    {
        return self->obj->get_Status();
    }

    static PyObject* _await_IAsyncOperation(py::wrapper::Windows::Foundation::IAsyncOperation* self) noexcept
    {
        return self->obj->dunder_await();
    }

    static PyMethodDef _methods_IAsyncOperation[] = {
        { "get_results", (PyCFunction)IAsyncOperation_GetResults, METH_VARARGS, nullptr },
        { "cancel", (PyCFunction)IAsyncOperation_Cancel, METH_VARARGS, nullptr },
        { "close", (PyCFunction)IAsyncOperation_Close, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IAsyncOperation[] = {
        { const_cast<char*>("completed"), (getter)IAsyncOperation_get_Completed, (setter)IAsyncOperation_put_Completed, nullptr, nullptr },
        { const_cast<char*>("error_code"), (getter)IAsyncOperation_get_ErrorCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)IAsyncOperation_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)IAsyncOperation_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IAsyncOperation[] = 
    {
        { Py_tp_new, _new_IAsyncOperation },
        { Py_tp_dealloc, _dealloc_IAsyncOperation },
        { Py_tp_methods, _methods_IAsyncOperation },
        { Py_tp_getset, _getset_IAsyncOperation },
        { Py_am_await, (unaryfunc)_await_IAsyncOperation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IAsyncOperation =
    {
        "_winrt_Windows_Foundation.IAsyncOperation",
        sizeof(py::wrapper::Windows::Foundation::IAsyncOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAsyncOperation
    };

    // ----- IClosable interface --------------------
    constexpr const char* const _type_name_IClosable = "IClosable";

    static PyObject* _new_IClosable(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IClosable);
        return nullptr;
    }

    static void _dealloc_IClosable(py::wrapper::Windows::Foundation::IClosable* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IClosable_Close(py::wrapper::Windows::Foundation::IClosable* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IClosable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IClosable>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IClosable(py::wrapper::Windows::Foundation::IClosable* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_IClosable(py::wrapper::Windows::Foundation::IClosable* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IClosable[] = {
        { "close", (PyCFunction)IClosable_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IClosable, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_IClosable, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_IClosable, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IClosable[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IClosable[] = 
    {
        { Py_tp_new, _new_IClosable },
        { Py_tp_dealloc, _dealloc_IClosable },
        { Py_tp_methods, _methods_IClosable },
        { Py_tp_getset, _getset_IClosable },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IClosable =
    {
        "_winrt_Windows_Foundation.IClosable",
        sizeof(py::wrapper::Windows::Foundation::IClosable),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IClosable
    };

    // ----- IGetActivationFactory interface --------------------
    constexpr const char* const _type_name_IGetActivationFactory = "IGetActivationFactory";

    static PyObject* _new_IGetActivationFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IGetActivationFactory);
        return nullptr;
    }

    static void _dealloc_IGetActivationFactory(py::wrapper::Windows::Foundation::IGetActivationFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IGetActivationFactory_GetActivationFactory(py::wrapper::Windows::Foundation::IGetActivationFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetActivationFactory(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IGetActivationFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IGetActivationFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGetActivationFactory[] = {
        { "get_activation_factory", (PyCFunction)IGetActivationFactory_GetActivationFactory, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IGetActivationFactory, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IGetActivationFactory[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IGetActivationFactory[] = 
    {
        { Py_tp_new, _new_IGetActivationFactory },
        { Py_tp_dealloc, _dealloc_IGetActivationFactory },
        { Py_tp_methods, _methods_IGetActivationFactory },
        { Py_tp_getset, _getset_IGetActivationFactory },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IGetActivationFactory =
    {
        "_winrt_Windows_Foundation.IGetActivationFactory",
        sizeof(py::wrapper::Windows::Foundation::IGetActivationFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGetActivationFactory
    };

    // ----- IMemoryBuffer interface --------------------
    constexpr const char* const _type_name_IMemoryBuffer = "IMemoryBuffer";

    static PyObject* _new_IMemoryBuffer(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IMemoryBuffer);
        return nullptr;
    }

    static void _dealloc_IMemoryBuffer(py::wrapper::Windows::Foundation::IMemoryBuffer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IMemoryBuffer_Close(py::wrapper::Windows::Foundation::IMemoryBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMemoryBuffer_CreateReference(py::wrapper::Windows::Foundation::IMemoryBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IMemoryBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IMemoryBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IMemoryBuffer(py::wrapper::Windows::Foundation::IMemoryBuffer* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_IMemoryBuffer(py::wrapper::Windows::Foundation::IMemoryBuffer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMemoryBuffer[] = {
        { "create_reference", (PyCFunction)IMemoryBuffer_CreateReference, METH_VARARGS, nullptr },
        { "close", (PyCFunction)IMemoryBuffer_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IMemoryBuffer, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_IMemoryBuffer, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_IMemoryBuffer, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IMemoryBuffer[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IMemoryBuffer[] = 
    {
        { Py_tp_new, _new_IMemoryBuffer },
        { Py_tp_dealloc, _dealloc_IMemoryBuffer },
        { Py_tp_methods, _methods_IMemoryBuffer },
        { Py_tp_getset, _getset_IMemoryBuffer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IMemoryBuffer =
    {
        "_winrt_Windows_Foundation.IMemoryBuffer",
        sizeof(py::wrapper::Windows::Foundation::IMemoryBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMemoryBuffer
    };

    // ----- IMemoryBufferReference interface --------------------
    constexpr const char* const _type_name_IMemoryBufferReference = "IMemoryBufferReference";

    static PyObject* _new_IMemoryBufferReference(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IMemoryBufferReference);
        return nullptr;
    }

    static void _dealloc_IMemoryBufferReference(py::wrapper::Windows::Foundation::IMemoryBufferReference* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IMemoryBufferReference_Close(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMemoryBufferReference_get_Capacity(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMemoryBufferReference_add_Closed(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IMemoryBufferReference, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMemoryBufferReference_remove_Closed(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IMemoryBufferReference(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IMemoryBufferReference>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IMemoryBufferReference(py::wrapper::Windows::Foundation::IMemoryBufferReference* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_IMemoryBufferReference(py::wrapper::Windows::Foundation::IMemoryBufferReference* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _get_buffer_IMemoryBufferReference(py::wrapper::Windows::Foundation::IMemoryBufferReference* self, Py_buffer* view, int flags) noexcept
    {
        try
        {
            return PyBuffer_FillInfo(view, (PyObject*)self, (void*)self->obj.data(), (Py_ssize_t)self->obj.Capacity(), 0, flags);
        }
        catch (...)
        {
            view->obj = nullptr;
            PyErr_SetNone(PyExc_BufferError);
            return -1;
        }
    }

    #if PY_VERSION_HEX < 0x03090000
    static PyBufferProcs _PyBufferProcs_IMemoryBufferReference = { (getbufferproc)_get_buffer_IMemoryBufferReference, (releasebufferproc)NULL };
    #endif

    static PyMethodDef _methods_IMemoryBufferReference[] = {
        { "close", (PyCFunction)IMemoryBufferReference_Close, METH_VARARGS, nullptr },
        { "add_closed", (PyCFunction)IMemoryBufferReference_add_Closed, METH_O, nullptr },
        { "remove_closed", (PyCFunction)IMemoryBufferReference_remove_Closed, METH_O, nullptr },
        { "_from", (PyCFunction)_from_IMemoryBufferReference, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_IMemoryBufferReference, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_IMemoryBufferReference, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IMemoryBufferReference[] = {
        { const_cast<char*>("capacity"), (getter)IMemoryBufferReference_get_Capacity, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IMemoryBufferReference[] = 
    {
        { Py_tp_new, _new_IMemoryBufferReference },
        { Py_tp_dealloc, _dealloc_IMemoryBufferReference },
        { Py_tp_methods, _methods_IMemoryBufferReference },
        { Py_tp_getset, _getset_IMemoryBufferReference },
        #if PY_VERSION_HEX >= 0x03090000
        { Py_bf_getbuffer, _get_buffer_IMemoryBufferReference },
        #endif
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IMemoryBufferReference =
    {
        "_winrt_Windows_Foundation.IMemoryBufferReference",
        sizeof(py::wrapper::Windows::Foundation::IMemoryBufferReference),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMemoryBufferReference
    };

    // ----- IPropertyValue interface --------------------
    constexpr const char* const _type_name_IPropertyValue = "IPropertyValue";

    static PyObject* _new_IPropertyValue(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IPropertyValue);
        return nullptr;
    }

    static void _dealloc_IPropertyValue(py::wrapper::Windows::Foundation::IPropertyValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IPropertyValue_GetBoolean(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetBoolean());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetBooleanArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<bool> param0 { };

                self->obj.GetBooleanArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetChar16(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetChar16());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetChar16Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<char16_t> param0 { };

                self->obj.GetChar16Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetDateTime(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDateTime());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetDateTimeArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::Windows::Foundation::DateTime> param0 { };

                self->obj.GetDateTimeArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetDouble(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDouble());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetDoubleArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<double> param0 { };

                self->obj.GetDoubleArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetGuid(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetGuid());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetGuidArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::guid> param0 { };

                self->obj.GetGuidArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInspectableArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::Windows::Foundation::IInspectable> param0 { };

                self->obj.GetInspectableArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt16(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetInt16());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt16Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<int16_t> param0 { };

                self->obj.GetInt16Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt32(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetInt32());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt32Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<int32_t> param0 { };

                self->obj.GetInt32Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt64(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetInt64());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetInt64Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<int64_t> param0 { };

                self->obj.GetInt64Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetPoint(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPoint());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetPointArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::Windows::Foundation::Point> param0 { };

                self->obj.GetPointArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetRect(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRect());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetRectArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::Windows::Foundation::Rect> param0 { };

                self->obj.GetRectArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetSingle(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSingle());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetSingleArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<float> param0 { };

                self->obj.GetSingleArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetSize(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSize());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetSizeArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::Windows::Foundation::Size> param0 { };

                self->obj.GetSizeArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetString(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetStringArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::hstring> param0 { };

                self->obj.GetStringArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetTimeSpan(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetTimeSpan());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetTimeSpanArray(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<winrt::Windows::Foundation::TimeSpan> param0 { };

                self->obj.GetTimeSpanArray(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt16(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetUInt16());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt16Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint16_t> param0 { };

                self->obj.GetUInt16Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt32(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetUInt32());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt32Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint32_t> param0 { };

                self->obj.GetUInt32Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt64(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetUInt64());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt64Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint64_t> param0 { };

                self->obj.GetUInt64Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt8(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetUInt8());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_GetUInt8Array(py::wrapper::Windows::Foundation::IPropertyValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetUInt8Array(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_get_IsNumericScalar(py::wrapper::Windows::Foundation::IPropertyValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsNumericScalar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPropertyValue_get_Type(py::wrapper::Windows::Foundation::IPropertyValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IPropertyValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IPropertyValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPropertyValue[] = {
        { "get_boolean", (PyCFunction)IPropertyValue_GetBoolean, METH_VARARGS, nullptr },
        { "get_boolean_array", (PyCFunction)IPropertyValue_GetBooleanArray, METH_VARARGS, nullptr },
        { "get_char16", (PyCFunction)IPropertyValue_GetChar16, METH_VARARGS, nullptr },
        { "get_char16_array", (PyCFunction)IPropertyValue_GetChar16Array, METH_VARARGS, nullptr },
        { "get_date_time", (PyCFunction)IPropertyValue_GetDateTime, METH_VARARGS, nullptr },
        { "get_date_time_array", (PyCFunction)IPropertyValue_GetDateTimeArray, METH_VARARGS, nullptr },
        { "get_double", (PyCFunction)IPropertyValue_GetDouble, METH_VARARGS, nullptr },
        { "get_double_array", (PyCFunction)IPropertyValue_GetDoubleArray, METH_VARARGS, nullptr },
        { "get_guid", (PyCFunction)IPropertyValue_GetGuid, METH_VARARGS, nullptr },
        { "get_guid_array", (PyCFunction)IPropertyValue_GetGuidArray, METH_VARARGS, nullptr },
        { "get_inspectable_array", (PyCFunction)IPropertyValue_GetInspectableArray, METH_VARARGS, nullptr },
        { "get_int16", (PyCFunction)IPropertyValue_GetInt16, METH_VARARGS, nullptr },
        { "get_int16_array", (PyCFunction)IPropertyValue_GetInt16Array, METH_VARARGS, nullptr },
        { "get_int32", (PyCFunction)IPropertyValue_GetInt32, METH_VARARGS, nullptr },
        { "get_int32_array", (PyCFunction)IPropertyValue_GetInt32Array, METH_VARARGS, nullptr },
        { "get_int64", (PyCFunction)IPropertyValue_GetInt64, METH_VARARGS, nullptr },
        { "get_int64_array", (PyCFunction)IPropertyValue_GetInt64Array, METH_VARARGS, nullptr },
        { "get_point", (PyCFunction)IPropertyValue_GetPoint, METH_VARARGS, nullptr },
        { "get_point_array", (PyCFunction)IPropertyValue_GetPointArray, METH_VARARGS, nullptr },
        { "get_rect", (PyCFunction)IPropertyValue_GetRect, METH_VARARGS, nullptr },
        { "get_rect_array", (PyCFunction)IPropertyValue_GetRectArray, METH_VARARGS, nullptr },
        { "get_single", (PyCFunction)IPropertyValue_GetSingle, METH_VARARGS, nullptr },
        { "get_single_array", (PyCFunction)IPropertyValue_GetSingleArray, METH_VARARGS, nullptr },
        { "get_size", (PyCFunction)IPropertyValue_GetSize, METH_VARARGS, nullptr },
        { "get_size_array", (PyCFunction)IPropertyValue_GetSizeArray, METH_VARARGS, nullptr },
        { "get_string", (PyCFunction)IPropertyValue_GetString, METH_VARARGS, nullptr },
        { "get_string_array", (PyCFunction)IPropertyValue_GetStringArray, METH_VARARGS, nullptr },
        { "get_time_span", (PyCFunction)IPropertyValue_GetTimeSpan, METH_VARARGS, nullptr },
        { "get_time_span_array", (PyCFunction)IPropertyValue_GetTimeSpanArray, METH_VARARGS, nullptr },
        { "get_uint16", (PyCFunction)IPropertyValue_GetUInt16, METH_VARARGS, nullptr },
        { "get_uint16_array", (PyCFunction)IPropertyValue_GetUInt16Array, METH_VARARGS, nullptr },
        { "get_uint32", (PyCFunction)IPropertyValue_GetUInt32, METH_VARARGS, nullptr },
        { "get_uint32_array", (PyCFunction)IPropertyValue_GetUInt32Array, METH_VARARGS, nullptr },
        { "get_uint64", (PyCFunction)IPropertyValue_GetUInt64, METH_VARARGS, nullptr },
        { "get_uint64_array", (PyCFunction)IPropertyValue_GetUInt64Array, METH_VARARGS, nullptr },
        { "get_uint8", (PyCFunction)IPropertyValue_GetUInt8, METH_VARARGS, nullptr },
        { "get_uint8_array", (PyCFunction)IPropertyValue_GetUInt8Array, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IPropertyValue, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IPropertyValue[] = {
        { const_cast<char*>("is_numeric_scalar"), (getter)IPropertyValue_get_IsNumericScalar, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)IPropertyValue_get_Type, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IPropertyValue[] = 
    {
        { Py_tp_new, _new_IPropertyValue },
        { Py_tp_dealloc, _dealloc_IPropertyValue },
        { Py_tp_methods, _methods_IPropertyValue },
        { Py_tp_getset, _getset_IPropertyValue },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IPropertyValue =
    {
        "_winrt_Windows_Foundation.IPropertyValue",
        sizeof(py::wrapper::Windows::Foundation::IPropertyValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPropertyValue
    };

    // ----- IReferenceArray interface --------------------
    constexpr const char* const _type_name_IReferenceArray = "IReferenceArray";

    static PyObject* _new_IReferenceArray(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IReferenceArray);
        return nullptr;
    }

    static void _dealloc_IReferenceArray(py::wrapper::Windows::Foundation::IReferenceArray* self)
    {
        auto hash_value = self->obj->hash();
        py::wrapped_instance(hash_value, nullptr);
        self->obj.reset();
    }

    static PyObject* IReferenceArray_GetBoolean(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetBoolean(args);
    }

    static PyObject* IReferenceArray_GetBooleanArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetBooleanArray(args);
    }

    static PyObject* IReferenceArray_GetChar16(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetChar16(args);
    }

    static PyObject* IReferenceArray_GetChar16Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetChar16Array(args);
    }

    static PyObject* IReferenceArray_GetDateTime(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetDateTime(args);
    }

    static PyObject* IReferenceArray_GetDateTimeArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetDateTimeArray(args);
    }

    static PyObject* IReferenceArray_GetDouble(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetDouble(args);
    }

    static PyObject* IReferenceArray_GetDoubleArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetDoubleArray(args);
    }

    static PyObject* IReferenceArray_GetGuid(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetGuid(args);
    }

    static PyObject* IReferenceArray_GetGuidArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetGuidArray(args);
    }

    static PyObject* IReferenceArray_GetInspectableArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetInspectableArray(args);
    }

    static PyObject* IReferenceArray_GetInt16(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetInt16(args);
    }

    static PyObject* IReferenceArray_GetInt16Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetInt16Array(args);
    }

    static PyObject* IReferenceArray_GetInt32(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetInt32(args);
    }

    static PyObject* IReferenceArray_GetInt32Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetInt32Array(args);
    }

    static PyObject* IReferenceArray_GetInt64(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetInt64(args);
    }

    static PyObject* IReferenceArray_GetInt64Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetInt64Array(args);
    }

    static PyObject* IReferenceArray_GetPoint(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetPoint(args);
    }

    static PyObject* IReferenceArray_GetPointArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetPointArray(args);
    }

    static PyObject* IReferenceArray_GetRect(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetRect(args);
    }

    static PyObject* IReferenceArray_GetRectArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetRectArray(args);
    }

    static PyObject* IReferenceArray_GetSingle(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetSingle(args);
    }

    static PyObject* IReferenceArray_GetSingleArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetSingleArray(args);
    }

    static PyObject* IReferenceArray_GetSize(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetSize(args);
    }

    static PyObject* IReferenceArray_GetSizeArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetSizeArray(args);
    }

    static PyObject* IReferenceArray_GetString(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetString(args);
    }

    static PyObject* IReferenceArray_GetStringArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetStringArray(args);
    }

    static PyObject* IReferenceArray_GetTimeSpan(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetTimeSpan(args);
    }

    static PyObject* IReferenceArray_GetTimeSpanArray(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetTimeSpanArray(args);
    }

    static PyObject* IReferenceArray_GetUInt16(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt16(args);
    }

    static PyObject* IReferenceArray_GetUInt16Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt16Array(args);
    }

    static PyObject* IReferenceArray_GetUInt32(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt32(args);
    }

    static PyObject* IReferenceArray_GetUInt32Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt32Array(args);
    }

    static PyObject* IReferenceArray_GetUInt64(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt64(args);
    }

    static PyObject* IReferenceArray_GetUInt64Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt64Array(args);
    }

    static PyObject* IReferenceArray_GetUInt8(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt8(args);
    }

    static PyObject* IReferenceArray_GetUInt8Array(py::wrapper::Windows::Foundation::IReferenceArray* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt8Array(args);
    }

    static PyObject* IReferenceArray_get_Value(py::wrapper::Windows::Foundation::IReferenceArray* self, void* /*unused*/) noexcept
    {
        return self->obj->get_Value();
    }

    static PyObject* IReferenceArray_get_IsNumericScalar(py::wrapper::Windows::Foundation::IReferenceArray* self, void* /*unused*/) noexcept
    {
        return self->obj->get_IsNumericScalar();
    }

    static PyObject* IReferenceArray_get_Type(py::wrapper::Windows::Foundation::IReferenceArray* self, void* /*unused*/) noexcept
    {
        return self->obj->get_Type();
    }

    static PyMethodDef _methods_IReferenceArray[] = {
        { "get_boolean", (PyCFunction)IReferenceArray_GetBoolean, METH_VARARGS, nullptr },
        { "get_boolean_array", (PyCFunction)IReferenceArray_GetBooleanArray, METH_VARARGS, nullptr },
        { "get_char16", (PyCFunction)IReferenceArray_GetChar16, METH_VARARGS, nullptr },
        { "get_char16_array", (PyCFunction)IReferenceArray_GetChar16Array, METH_VARARGS, nullptr },
        { "get_date_time", (PyCFunction)IReferenceArray_GetDateTime, METH_VARARGS, nullptr },
        { "get_date_time_array", (PyCFunction)IReferenceArray_GetDateTimeArray, METH_VARARGS, nullptr },
        { "get_double", (PyCFunction)IReferenceArray_GetDouble, METH_VARARGS, nullptr },
        { "get_double_array", (PyCFunction)IReferenceArray_GetDoubleArray, METH_VARARGS, nullptr },
        { "get_guid", (PyCFunction)IReferenceArray_GetGuid, METH_VARARGS, nullptr },
        { "get_guid_array", (PyCFunction)IReferenceArray_GetGuidArray, METH_VARARGS, nullptr },
        { "get_inspectable_array", (PyCFunction)IReferenceArray_GetInspectableArray, METH_VARARGS, nullptr },
        { "get_int16", (PyCFunction)IReferenceArray_GetInt16, METH_VARARGS, nullptr },
        { "get_int16_array", (PyCFunction)IReferenceArray_GetInt16Array, METH_VARARGS, nullptr },
        { "get_int32", (PyCFunction)IReferenceArray_GetInt32, METH_VARARGS, nullptr },
        { "get_int32_array", (PyCFunction)IReferenceArray_GetInt32Array, METH_VARARGS, nullptr },
        { "get_int64", (PyCFunction)IReferenceArray_GetInt64, METH_VARARGS, nullptr },
        { "get_int64_array", (PyCFunction)IReferenceArray_GetInt64Array, METH_VARARGS, nullptr },
        { "get_point", (PyCFunction)IReferenceArray_GetPoint, METH_VARARGS, nullptr },
        { "get_point_array", (PyCFunction)IReferenceArray_GetPointArray, METH_VARARGS, nullptr },
        { "get_rect", (PyCFunction)IReferenceArray_GetRect, METH_VARARGS, nullptr },
        { "get_rect_array", (PyCFunction)IReferenceArray_GetRectArray, METH_VARARGS, nullptr },
        { "get_single", (PyCFunction)IReferenceArray_GetSingle, METH_VARARGS, nullptr },
        { "get_single_array", (PyCFunction)IReferenceArray_GetSingleArray, METH_VARARGS, nullptr },
        { "get_size", (PyCFunction)IReferenceArray_GetSize, METH_VARARGS, nullptr },
        { "get_size_array", (PyCFunction)IReferenceArray_GetSizeArray, METH_VARARGS, nullptr },
        { "get_string", (PyCFunction)IReferenceArray_GetString, METH_VARARGS, nullptr },
        { "get_string_array", (PyCFunction)IReferenceArray_GetStringArray, METH_VARARGS, nullptr },
        { "get_time_span", (PyCFunction)IReferenceArray_GetTimeSpan, METH_VARARGS, nullptr },
        { "get_time_span_array", (PyCFunction)IReferenceArray_GetTimeSpanArray, METH_VARARGS, nullptr },
        { "get_uint16", (PyCFunction)IReferenceArray_GetUInt16, METH_VARARGS, nullptr },
        { "get_uint16_array", (PyCFunction)IReferenceArray_GetUInt16Array, METH_VARARGS, nullptr },
        { "get_uint32", (PyCFunction)IReferenceArray_GetUInt32, METH_VARARGS, nullptr },
        { "get_uint32_array", (PyCFunction)IReferenceArray_GetUInt32Array, METH_VARARGS, nullptr },
        { "get_uint64", (PyCFunction)IReferenceArray_GetUInt64, METH_VARARGS, nullptr },
        { "get_uint64_array", (PyCFunction)IReferenceArray_GetUInt64Array, METH_VARARGS, nullptr },
        { "get_uint8", (PyCFunction)IReferenceArray_GetUInt8, METH_VARARGS, nullptr },
        { "get_uint8_array", (PyCFunction)IReferenceArray_GetUInt8Array, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IReferenceArray[] = {
        { const_cast<char*>("value"), (getter)IReferenceArray_get_Value, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_numeric_scalar"), (getter)IReferenceArray_get_IsNumericScalar, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)IReferenceArray_get_Type, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IReferenceArray[] = 
    {
        { Py_tp_new, _new_IReferenceArray },
        { Py_tp_dealloc, _dealloc_IReferenceArray },
        { Py_tp_methods, _methods_IReferenceArray },
        { Py_tp_getset, _getset_IReferenceArray },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IReferenceArray =
    {
        "_winrt_Windows_Foundation.IReferenceArray",
        sizeof(py::wrapper::Windows::Foundation::IReferenceArray),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IReferenceArray
    };

    // ----- IReference interface --------------------
    constexpr const char* const _type_name_IReference = "IReference";

    static PyObject* _new_IReference(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IReference);
        return nullptr;
    }

    static void _dealloc_IReference(py::wrapper::Windows::Foundation::IReference* self)
    {
        auto hash_value = self->obj->hash();
        py::wrapped_instance(hash_value, nullptr);
        self->obj.reset();
    }

    static PyObject* IReference_GetBoolean(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetBoolean(args);
    }

    static PyObject* IReference_GetBooleanArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetBooleanArray(args);
    }

    static PyObject* IReference_GetChar16(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetChar16(args);
    }

    static PyObject* IReference_GetChar16Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetChar16Array(args);
    }

    static PyObject* IReference_GetDateTime(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetDateTime(args);
    }

    static PyObject* IReference_GetDateTimeArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetDateTimeArray(args);
    }

    static PyObject* IReference_GetDouble(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetDouble(args);
    }

    static PyObject* IReference_GetDoubleArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetDoubleArray(args);
    }

    static PyObject* IReference_GetGuid(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetGuid(args);
    }

    static PyObject* IReference_GetGuidArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetGuidArray(args);
    }

    static PyObject* IReference_GetInspectableArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetInspectableArray(args);
    }

    static PyObject* IReference_GetInt16(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetInt16(args);
    }

    static PyObject* IReference_GetInt16Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetInt16Array(args);
    }

    static PyObject* IReference_GetInt32(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetInt32(args);
    }

    static PyObject* IReference_GetInt32Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetInt32Array(args);
    }

    static PyObject* IReference_GetInt64(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetInt64(args);
    }

    static PyObject* IReference_GetInt64Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetInt64Array(args);
    }

    static PyObject* IReference_GetPoint(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetPoint(args);
    }

    static PyObject* IReference_GetPointArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetPointArray(args);
    }

    static PyObject* IReference_GetRect(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetRect(args);
    }

    static PyObject* IReference_GetRectArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetRectArray(args);
    }

    static PyObject* IReference_GetSingle(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetSingle(args);
    }

    static PyObject* IReference_GetSingleArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetSingleArray(args);
    }

    static PyObject* IReference_GetSize(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetSize(args);
    }

    static PyObject* IReference_GetSizeArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetSizeArray(args);
    }

    static PyObject* IReference_GetString(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetString(args);
    }

    static PyObject* IReference_GetStringArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetStringArray(args);
    }

    static PyObject* IReference_GetTimeSpan(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetTimeSpan(args);
    }

    static PyObject* IReference_GetTimeSpanArray(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetTimeSpanArray(args);
    }

    static PyObject* IReference_GetUInt16(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt16(args);
    }

    static PyObject* IReference_GetUInt16Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt16Array(args);
    }

    static PyObject* IReference_GetUInt32(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt32(args);
    }

    static PyObject* IReference_GetUInt32Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt32Array(args);
    }

    static PyObject* IReference_GetUInt64(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt64(args);
    }

    static PyObject* IReference_GetUInt64Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt64Array(args);
    }

    static PyObject* IReference_GetUInt8(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt8(args);
    }

    static PyObject* IReference_GetUInt8Array(py::wrapper::Windows::Foundation::IReference* self, PyObject* args) noexcept
    {
        return self->obj->GetUInt8Array(args);
    }

    static PyObject* IReference_get_Value(py::wrapper::Windows::Foundation::IReference* self, void* /*unused*/) noexcept
    {
        return self->obj->get_Value();
    }

    static PyObject* IReference_get_IsNumericScalar(py::wrapper::Windows::Foundation::IReference* self, void* /*unused*/) noexcept
    {
        return self->obj->get_IsNumericScalar();
    }

    static PyObject* IReference_get_Type(py::wrapper::Windows::Foundation::IReference* self, void* /*unused*/) noexcept
    {
        return self->obj->get_Type();
    }

    static PyMethodDef _methods_IReference[] = {
        { "get_boolean", (PyCFunction)IReference_GetBoolean, METH_VARARGS, nullptr },
        { "get_boolean_array", (PyCFunction)IReference_GetBooleanArray, METH_VARARGS, nullptr },
        { "get_char16", (PyCFunction)IReference_GetChar16, METH_VARARGS, nullptr },
        { "get_char16_array", (PyCFunction)IReference_GetChar16Array, METH_VARARGS, nullptr },
        { "get_date_time", (PyCFunction)IReference_GetDateTime, METH_VARARGS, nullptr },
        { "get_date_time_array", (PyCFunction)IReference_GetDateTimeArray, METH_VARARGS, nullptr },
        { "get_double", (PyCFunction)IReference_GetDouble, METH_VARARGS, nullptr },
        { "get_double_array", (PyCFunction)IReference_GetDoubleArray, METH_VARARGS, nullptr },
        { "get_guid", (PyCFunction)IReference_GetGuid, METH_VARARGS, nullptr },
        { "get_guid_array", (PyCFunction)IReference_GetGuidArray, METH_VARARGS, nullptr },
        { "get_inspectable_array", (PyCFunction)IReference_GetInspectableArray, METH_VARARGS, nullptr },
        { "get_int16", (PyCFunction)IReference_GetInt16, METH_VARARGS, nullptr },
        { "get_int16_array", (PyCFunction)IReference_GetInt16Array, METH_VARARGS, nullptr },
        { "get_int32", (PyCFunction)IReference_GetInt32, METH_VARARGS, nullptr },
        { "get_int32_array", (PyCFunction)IReference_GetInt32Array, METH_VARARGS, nullptr },
        { "get_int64", (PyCFunction)IReference_GetInt64, METH_VARARGS, nullptr },
        { "get_int64_array", (PyCFunction)IReference_GetInt64Array, METH_VARARGS, nullptr },
        { "get_point", (PyCFunction)IReference_GetPoint, METH_VARARGS, nullptr },
        { "get_point_array", (PyCFunction)IReference_GetPointArray, METH_VARARGS, nullptr },
        { "get_rect", (PyCFunction)IReference_GetRect, METH_VARARGS, nullptr },
        { "get_rect_array", (PyCFunction)IReference_GetRectArray, METH_VARARGS, nullptr },
        { "get_single", (PyCFunction)IReference_GetSingle, METH_VARARGS, nullptr },
        { "get_single_array", (PyCFunction)IReference_GetSingleArray, METH_VARARGS, nullptr },
        { "get_size", (PyCFunction)IReference_GetSize, METH_VARARGS, nullptr },
        { "get_size_array", (PyCFunction)IReference_GetSizeArray, METH_VARARGS, nullptr },
        { "get_string", (PyCFunction)IReference_GetString, METH_VARARGS, nullptr },
        { "get_string_array", (PyCFunction)IReference_GetStringArray, METH_VARARGS, nullptr },
        { "get_time_span", (PyCFunction)IReference_GetTimeSpan, METH_VARARGS, nullptr },
        { "get_time_span_array", (PyCFunction)IReference_GetTimeSpanArray, METH_VARARGS, nullptr },
        { "get_uint16", (PyCFunction)IReference_GetUInt16, METH_VARARGS, nullptr },
        { "get_uint16_array", (PyCFunction)IReference_GetUInt16Array, METH_VARARGS, nullptr },
        { "get_uint32", (PyCFunction)IReference_GetUInt32, METH_VARARGS, nullptr },
        { "get_uint32_array", (PyCFunction)IReference_GetUInt32Array, METH_VARARGS, nullptr },
        { "get_uint64", (PyCFunction)IReference_GetUInt64, METH_VARARGS, nullptr },
        { "get_uint64_array", (PyCFunction)IReference_GetUInt64Array, METH_VARARGS, nullptr },
        { "get_uint8", (PyCFunction)IReference_GetUInt8, METH_VARARGS, nullptr },
        { "get_uint8_array", (PyCFunction)IReference_GetUInt8Array, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IReference[] = {
        { const_cast<char*>("value"), (getter)IReference_get_Value, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_numeric_scalar"), (getter)IReference_get_IsNumericScalar, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)IReference_get_Type, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IReference[] = 
    {
        { Py_tp_new, _new_IReference },
        { Py_tp_dealloc, _dealloc_IReference },
        { Py_tp_methods, _methods_IReference },
        { Py_tp_getset, _getset_IReference },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IReference =
    {
        "_winrt_Windows_Foundation.IReference",
        sizeof(py::wrapper::Windows::Foundation::IReference),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IReference
    };

    // ----- IStringable interface --------------------
    constexpr const char* const _type_name_IStringable = "IStringable";

    static PyObject* _new_IStringable(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStringable);
        return nullptr;
    }

    static void _dealloc_IStringable(py::wrapper::Windows::Foundation::IStringable* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStringable_ToString(py::wrapper::Windows::Foundation::IStringable* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IStringable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IStringable>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _str_IStringable(py::wrapper::Windows::Foundation::IStringable* self) noexcept
    {
        try
        {
            return py::convert(self->obj.ToString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStringable[] = {
        { "to_string", (PyCFunction)IStringable_ToString, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IStringable, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IStringable[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IStringable[] = 
    {
        { Py_tp_new, _new_IStringable },
        { Py_tp_dealloc, _dealloc_IStringable },
        { Py_tp_methods, _methods_IStringable },
        { Py_tp_getset, _getset_IStringable },
        { Py_tp_str, _str_IStringable },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStringable =
    {
        "_winrt_Windows_Foundation.IStringable",
        sizeof(py::wrapper::Windows::Foundation::IStringable),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStringable
    };

    // ----- IWwwFormUrlDecoderEntry interface --------------------
    constexpr const char* const _type_name_IWwwFormUrlDecoderEntry = "IWwwFormUrlDecoderEntry";

    static PyObject* _new_IWwwFormUrlDecoderEntry(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IWwwFormUrlDecoderEntry);
        return nullptr;
    }

    static void _dealloc_IWwwFormUrlDecoderEntry(py::wrapper::Windows::Foundation::IWwwFormUrlDecoderEntry* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IWwwFormUrlDecoderEntry_get_Name(py::wrapper::Windows::Foundation::IWwwFormUrlDecoderEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWwwFormUrlDecoderEntry_get_Value(py::wrapper::Windows::Foundation::IWwwFormUrlDecoderEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IWwwFormUrlDecoderEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWwwFormUrlDecoderEntry[] = {
        { "_from", (PyCFunction)_from_IWwwFormUrlDecoderEntry, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IWwwFormUrlDecoderEntry[] = {
        { const_cast<char*>("name"), (getter)IWwwFormUrlDecoderEntry_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("value"), (getter)IWwwFormUrlDecoderEntry_get_Value, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IWwwFormUrlDecoderEntry[] = 
    {
        { Py_tp_new, _new_IWwwFormUrlDecoderEntry },
        { Py_tp_dealloc, _dealloc_IWwwFormUrlDecoderEntry },
        { Py_tp_methods, _methods_IWwwFormUrlDecoderEntry },
        { Py_tp_getset, _getset_IWwwFormUrlDecoderEntry },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IWwwFormUrlDecoderEntry =
    {
        "_winrt_Windows_Foundation.IWwwFormUrlDecoderEntry",
        sizeof(py::wrapper::Windows::Foundation::IWwwFormUrlDecoderEntry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWwwFormUrlDecoderEntry
    };

    // ----- DateTime struct --------------------
    constexpr const char* const _type_name_DateTime = "DateTime";

    PyObject* _new_DateTime(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Foundation::DateTime return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        int64_t _UniversalTime{};

        static const char* kwlist[] = {"universal_time", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "L", const_cast<char**>(kwlist), &_UniversalTime))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Foundation::DateTime return_value{ };
            custom_set(return_value, _UniversalTime);
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_DateTime(py::wrapper::Windows::Foundation::DateTime* self)
    {
    }

    static PyObject* DateTime_get_UniversalTime(py::wrapper::Windows::Foundation::DateTime* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(custom_get(self->obj));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DateTime_set_UniversalTime(py::wrapper::Windows::Foundation::DateTime* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            custom_set(self->obj, py::converter<int64_t>::convert_to(arg));
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_DateTime[] = {
        { const_cast<char*>("universal_time"), (getter)DateTime_get_UniversalTime, (setter)DateTime_set_UniversalTime, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DateTime[] = 
    {
        { Py_tp_new, _new_DateTime },
        { Py_tp_dealloc, _dealloc_DateTime },
        { Py_tp_getset, _getset_DateTime },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DateTime =
    {
        "_winrt_Windows_Foundation.DateTime",
        sizeof(py::wrapper::Windows::Foundation::DateTime),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DateTime
    };

    // ----- EventRegistrationToken struct --------------------
    constexpr const char* const _type_name_EventRegistrationToken = "EventRegistrationToken";

    PyObject* _new_EventRegistrationToken(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::event_token return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::event_token>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        int64_t _Value{};

        static const char* kwlist[] = {"value", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "L", const_cast<char**>(kwlist), &_Value))
        {
            return nullptr;
        }

        try
        {
            winrt::event_token return_value{ };
            custom_set(return_value, _Value);
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_EventRegistrationToken(py::wrapper::Windows::Foundation::EventRegistrationToken* self)
    {
    }

    static PyObject* EventRegistrationToken_get_Value(py::wrapper::Windows::Foundation::EventRegistrationToken* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(custom_get(self->obj));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EventRegistrationToken_set_Value(py::wrapper::Windows::Foundation::EventRegistrationToken* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            custom_set(self->obj, py::converter<int64_t>::convert_to(arg));
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_EventRegistrationToken[] = {
        { const_cast<char*>("value"), (getter)EventRegistrationToken_get_Value, (setter)EventRegistrationToken_set_Value, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EventRegistrationToken[] = 
    {
        { Py_tp_new, _new_EventRegistrationToken },
        { Py_tp_dealloc, _dealloc_EventRegistrationToken },
        { Py_tp_getset, _getset_EventRegistrationToken },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EventRegistrationToken =
    {
        "_winrt_Windows_Foundation.EventRegistrationToken",
        sizeof(py::wrapper::Windows::Foundation::EventRegistrationToken),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EventRegistrationToken
    };

    // ----- HResult struct --------------------
    constexpr const char* const _type_name_HResult = "HResult";

    PyObject* _new_HResult(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::hresult return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::hresult>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        int32_t _Value{};

        static const char* kwlist[] = {"value", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "i", const_cast<char**>(kwlist), &_Value))
        {
            return nullptr;
        }

        try
        {
            winrt::hresult return_value{ };
            custom_set(return_value, _Value);
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_HResult(py::wrapper::Windows::Foundation::HResult* self)
    {
    }

    static PyObject* HResult_get_Value(py::wrapper::Windows::Foundation::HResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(custom_get(self->obj));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HResult_set_Value(py::wrapper::Windows::Foundation::HResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            custom_set(self->obj, py::converter<int32_t>::convert_to(arg));
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_HResult[] = {
        { const_cast<char*>("value"), (getter)HResult_get_Value, (setter)HResult_set_Value, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HResult[] = 
    {
        { Py_tp_new, _new_HResult },
        { Py_tp_dealloc, _dealloc_HResult },
        { Py_tp_getset, _getset_HResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HResult =
    {
        "_winrt_Windows_Foundation.HResult",
        sizeof(py::wrapper::Windows::Foundation::HResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HResult
    };

    // ----- Point struct --------------------
    constexpr const char* const _type_name_Point = "Point";

    PyObject* _new_Point(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Foundation::Point return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Foundation::Point>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        float _X{};
        float _Y{};

        static const char* kwlist[] = {"x", "y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ff", const_cast<char**>(kwlist), &_X, &_Y))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Foundation::Point return_value{ _X, _Y };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Point(py::wrapper::Windows::Foundation::Point* self)
    {
    }

    static PyObject* Point_get_X(py::wrapper::Windows::Foundation::Point* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Point_set_X(py::wrapper::Windows::Foundation::Point* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.X = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Point_get_Y(py::wrapper::Windows::Foundation::Point* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Point_set_Y(py::wrapper::Windows::Foundation::Point* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Y = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Point[] = {
        { const_cast<char*>("x"), (getter)Point_get_X, (setter)Point_set_X, nullptr, nullptr },
        { const_cast<char*>("y"), (getter)Point_get_Y, (setter)Point_set_Y, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Point[] = 
    {
        { Py_tp_new, _new_Point },
        { Py_tp_dealloc, _dealloc_Point },
        { Py_tp_getset, _getset_Point },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Point =
    {
        "_winrt_Windows_Foundation.Point",
        sizeof(py::wrapper::Windows::Foundation::Point),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Point
    };

    // ----- Rect struct --------------------
    constexpr const char* const _type_name_Rect = "Rect";

    PyObject* _new_Rect(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Foundation::Rect return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Foundation::Rect>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        float _X{};
        float _Y{};
        float _Width{};
        float _Height{};

        static const char* kwlist[] = {"x", "y", "width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ffff", const_cast<char**>(kwlist), &_X, &_Y, &_Width, &_Height))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Foundation::Rect return_value{ _X, _Y, _Width, _Height };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Rect(py::wrapper::Windows::Foundation::Rect* self)
    {
    }

    static PyObject* Rect_get_X(py::wrapper::Windows::Foundation::Rect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Rect_set_X(py::wrapper::Windows::Foundation::Rect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.X = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Rect_get_Y(py::wrapper::Windows::Foundation::Rect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Rect_set_Y(py::wrapper::Windows::Foundation::Rect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Y = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Rect_get_Width(py::wrapper::Windows::Foundation::Rect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Rect_set_Width(py::wrapper::Windows::Foundation::Rect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Rect_get_Height(py::wrapper::Windows::Foundation::Rect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Rect_set_Height(py::wrapper::Windows::Foundation::Rect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Rect[] = {
        { const_cast<char*>("x"), (getter)Rect_get_X, (setter)Rect_set_X, nullptr, nullptr },
        { const_cast<char*>("y"), (getter)Rect_get_Y, (setter)Rect_set_Y, nullptr, nullptr },
        { const_cast<char*>("width"), (getter)Rect_get_Width, (setter)Rect_set_Width, nullptr, nullptr },
        { const_cast<char*>("height"), (getter)Rect_get_Height, (setter)Rect_set_Height, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Rect[] = 
    {
        { Py_tp_new, _new_Rect },
        { Py_tp_dealloc, _dealloc_Rect },
        { Py_tp_getset, _getset_Rect },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Rect =
    {
        "_winrt_Windows_Foundation.Rect",
        sizeof(py::wrapper::Windows::Foundation::Rect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Rect
    };

    // ----- Size struct --------------------
    constexpr const char* const _type_name_Size = "Size";

    PyObject* _new_Size(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Foundation::Size return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Foundation::Size>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        float _Width{};
        float _Height{};

        static const char* kwlist[] = {"width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ff", const_cast<char**>(kwlist), &_Width, &_Height))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Foundation::Size return_value{ _Width, _Height };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Size(py::wrapper::Windows::Foundation::Size* self)
    {
    }

    static PyObject* Size_get_Width(py::wrapper::Windows::Foundation::Size* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Size_set_Width(py::wrapper::Windows::Foundation::Size* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Size_get_Height(py::wrapper::Windows::Foundation::Size* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Size_set_Height(py::wrapper::Windows::Foundation::Size* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Size[] = {
        { const_cast<char*>("width"), (getter)Size_get_Width, (setter)Size_set_Width, nullptr, nullptr },
        { const_cast<char*>("height"), (getter)Size_get_Height, (setter)Size_set_Height, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Size[] = 
    {
        { Py_tp_new, _new_Size },
        { Py_tp_dealloc, _dealloc_Size },
        { Py_tp_getset, _getset_Size },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Size =
    {
        "_winrt_Windows_Foundation.Size",
        sizeof(py::wrapper::Windows::Foundation::Size),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Size
    };

    // ----- TimeSpan struct --------------------
    constexpr const char* const _type_name_TimeSpan = "TimeSpan";

    PyObject* _new_TimeSpan(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Foundation::TimeSpan return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        int64_t _Duration{};

        static const char* kwlist[] = {"duration", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "L", const_cast<char**>(kwlist), &_Duration))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Foundation::TimeSpan return_value{ };
            custom_set(return_value, _Duration);
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_TimeSpan(py::wrapper::Windows::Foundation::TimeSpan* self)
    {
    }

    static PyObject* TimeSpan_get_Duration(py::wrapper::Windows::Foundation::TimeSpan* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(custom_get(self->obj));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimeSpan_set_Duration(py::wrapper::Windows::Foundation::TimeSpan* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            custom_set(self->obj, py::converter<int64_t>::convert_to(arg));
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TimeSpan[] = {
        { const_cast<char*>("duration"), (getter)TimeSpan_get_Duration, (setter)TimeSpan_set_Duration, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TimeSpan[] = 
    {
        { Py_tp_new, _new_TimeSpan },
        { Py_tp_dealloc, _dealloc_TimeSpan },
        { Py_tp_getset, _getset_TimeSpan },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimeSpan =
    {
        "_winrt_Windows_Foundation.TimeSpan",
        sizeof(py::wrapper::Windows::Foundation::TimeSpan),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimeSpan
    };

    // ----- Windows.Foundation Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Foundation::Deferral>::python_type = py::register_python_type(module, _type_name_Deferral, &_type_spec_Deferral, bases.get());
            py::winrt_type<winrt::Windows::Foundation::GuidHelper>::python_type = py::register_python_type(module, _type_name_GuidHelper, &_type_spec_GuidHelper, nullptr);
            py::winrt_type<winrt::Windows::Foundation::MemoryBuffer>::python_type = py::register_python_type(module, _type_name_MemoryBuffer, &_type_spec_MemoryBuffer, bases.get());
            py::winrt_type<winrt::Windows::Foundation::PropertyValue>::python_type = py::register_python_type(module, _type_name_PropertyValue, &_type_spec_PropertyValue, nullptr);
            py::winrt_type<winrt::Windows::Foundation::Uri>::python_type = py::register_python_type(module, _type_name_Uri, &_type_spec_Uri, bases.get());
            py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoder>::python_type = py::register_python_type(module, _type_name_WwwFormUrlDecoder, &_type_spec_WwwFormUrlDecoder, bases.get());
            py::winrt_type<winrt::Windows::Foundation::WwwFormUrlDecoderEntry>::python_type = py::register_python_type(module, _type_name_WwwFormUrlDecoderEntry, &_type_spec_WwwFormUrlDecoderEntry, bases.get());
            py::winrt_type<winrt::Windows::Foundation::IAsyncAction>::python_type = py::register_python_type(module, _type_name_IAsyncAction, &_type_spec_IAsyncAction, bases.get());
            py::winrt_type<py::proj::Windows::Foundation::IAsyncActionWithProgress>::python_type = py::register_python_type(module, _type_name_IAsyncActionWithProgress, &_type_spec_IAsyncActionWithProgress, bases.get());
            py::winrt_type<winrt::Windows::Foundation::IAsyncInfo>::python_type = py::register_python_type(module, _type_name_IAsyncInfo, &_type_spec_IAsyncInfo, bases.get());
            py::winrt_type<py::proj::Windows::Foundation::IAsyncOperationWithProgress>::python_type = py::register_python_type(module, _type_name_IAsyncOperationWithProgress, &_type_spec_IAsyncOperationWithProgress, bases.get());
            py::winrt_type<py::proj::Windows::Foundation::IAsyncOperation>::python_type = py::register_python_type(module, _type_name_IAsyncOperation, &_type_spec_IAsyncOperation, bases.get());
            py::winrt_type<winrt::Windows::Foundation::IClosable>::python_type = py::register_python_type(module, _type_name_IClosable, &_type_spec_IClosable, bases.get());
            py::winrt_type<winrt::Windows::Foundation::IGetActivationFactory>::python_type = py::register_python_type(module, _type_name_IGetActivationFactory, &_type_spec_IGetActivationFactory, bases.get());
            py::winrt_type<winrt::Windows::Foundation::IMemoryBuffer>::python_type = py::register_python_type(module, _type_name_IMemoryBuffer, &_type_spec_IMemoryBuffer, bases.get());
            py::winrt_type<winrt::Windows::Foundation::IMemoryBufferReference>::python_type = py::register_python_type(module, _type_name_IMemoryBufferReference, &_type_spec_IMemoryBufferReference, bases.get());
            #if PY_VERSION_HEX < 0x03090000
            py::winrt_type<winrt::Windows::Foundation::IMemoryBufferReference>::python_type->tp_as_buffer = &_PyBufferProcs_IMemoryBufferReference;
            #endif
            py::winrt_type<winrt::Windows::Foundation::IPropertyValue>::python_type = py::register_python_type(module, _type_name_IPropertyValue, &_type_spec_IPropertyValue, bases.get());
            py::winrt_type<py::proj::Windows::Foundation::IReferenceArray>::python_type = py::register_python_type(module, _type_name_IReferenceArray, &_type_spec_IReferenceArray, bases.get());
            py::winrt_type<py::proj::Windows::Foundation::IReference>::python_type = py::register_python_type(module, _type_name_IReference, &_type_spec_IReference, bases.get());
            py::winrt_type<winrt::Windows::Foundation::IStringable>::python_type = py::register_python_type(module, _type_name_IStringable, &_type_spec_IStringable, bases.get());
            py::winrt_type<winrt::Windows::Foundation::IWwwFormUrlDecoderEntry>::python_type = py::register_python_type(module, _type_name_IWwwFormUrlDecoderEntry, &_type_spec_IWwwFormUrlDecoderEntry, bases.get());
            py::winrt_type<winrt::Windows::Foundation::DateTime>::python_type = py::register_python_type(module, _type_name_DateTime, &_type_spec_DateTime, bases.get());
            py::winrt_type<winrt::event_token>::python_type = py::register_python_type(module, _type_name_EventRegistrationToken, &_type_spec_EventRegistrationToken, bases.get());
            py::winrt_type<winrt::hresult>::python_type = py::register_python_type(module, _type_name_HResult, &_type_spec_HResult, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Point>::python_type = py::register_python_type(module, _type_name_Point, &_type_spec_Point, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Rect>::python_type = py::register_python_type(module, _type_name_Rect, &_type_spec_Rect, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Size>::python_type = py::register_python_type(module, _type_name_Size, &_type_spec_Size, bases.get());
            py::winrt_type<winrt::Windows::Foundation::TimeSpan>::python_type = py::register_python_type(module, _type_name_TimeSpan, &_type_spec_TimeSpan, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Foundation");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Foundation",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Foundation

PyMODINIT_FUNC
PyInit__winrt_Windows_Foundation (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Foundation::module_def);
}
