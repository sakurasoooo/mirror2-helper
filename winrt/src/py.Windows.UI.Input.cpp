// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.UI.Input.h"

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::AttachableInputObject>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::CrossSlidingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::DraggingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::EdgeGesture>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::EdgeGestureEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::GestureRecognizer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::HoldingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::InputActivationListener>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::InputActivationListenerActivationChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::KeyboardDeliveryInterceptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::ManipulationCompletedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::ManipulationInertiaStartingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::ManipulationStartedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::ManipulationUpdatedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::MouseWheelParameters>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::PointerPoint>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::PointerPointProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::PointerVisualizationSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::RadialController>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::RadialControllerButtonClickedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::RadialControllerButtonHoldingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::RadialControllerButtonPressedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::RadialControllerButtonReleasedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::RadialControllerConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::RadialControllerControlAcquiredEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::RadialControllerMenu>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::RadialControllerMenuItem>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::RadialControllerRotationChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::RadialControllerScreenContact>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::RadialControllerScreenContactContinuedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::RadialControllerScreenContactEndedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::RadialControllerScreenContactStartedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::RightTappedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::SystemButtonEventController>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::SystemFunctionButtonEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::SystemFunctionLockChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::SystemFunctionLockIndicatorChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::TappedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::IPointerPointTransform>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::CrossSlideThresholds>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::ManipulationDelta>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::ManipulationVelocities>::python_type;

PyObject* py::converter<winrt::Windows::UI::Input::CrossSlideThresholds>::convert(winrt::Windows::UI::Input::CrossSlideThresholds instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::UI::Input::CrossSlideThresholds>());
}
winrt::Windows::UI::Input::CrossSlideThresholds py::converter<winrt::Windows::UI::Input::CrossSlideThresholds>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::UI::Input::CrossSlideThresholds>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::UI::Input::CrossSlideThresholds>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::UI::Input::CrossSlideThresholds return_value{};

    PyObject* py_SelectionStart = PyDict_GetItemString(obj, "selection_start");
    if (!py_SelectionStart) { throw winrt::hresult_invalid_argument(); }
    return_value.SelectionStart = converter<float>::convert_to(py_SelectionStart);

    PyObject* py_SpeedBumpStart = PyDict_GetItemString(obj, "speed_bump_start");
    if (!py_SpeedBumpStart) { throw winrt::hresult_invalid_argument(); }
    return_value.SpeedBumpStart = converter<float>::convert_to(py_SpeedBumpStart);

    PyObject* py_SpeedBumpEnd = PyDict_GetItemString(obj, "speed_bump_end");
    if (!py_SpeedBumpEnd) { throw winrt::hresult_invalid_argument(); }
    return_value.SpeedBumpEnd = converter<float>::convert_to(py_SpeedBumpEnd);

    PyObject* py_RearrangeStart = PyDict_GetItemString(obj, "rearrange_start");
    if (!py_RearrangeStart) { throw winrt::hresult_invalid_argument(); }
    return_value.RearrangeStart = converter<float>::convert_to(py_RearrangeStart);

    return return_value;
}

PyObject* py::converter<winrt::Windows::UI::Input::ManipulationDelta>::convert(winrt::Windows::UI::Input::ManipulationDelta instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::UI::Input::ManipulationDelta>());
}
winrt::Windows::UI::Input::ManipulationDelta py::converter<winrt::Windows::UI::Input::ManipulationDelta>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::UI::Input::ManipulationDelta>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::UI::Input::ManipulationDelta>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::UI::Input::ManipulationDelta return_value{};

    PyObject* py_Translation = PyDict_GetItemString(obj, "translation");
    if (!py_Translation) { throw winrt::hresult_invalid_argument(); }
    return_value.Translation = converter<winrt::Windows::Foundation::Point>::convert_to(py_Translation);

    PyObject* py_Scale = PyDict_GetItemString(obj, "scale");
    if (!py_Scale) { throw winrt::hresult_invalid_argument(); }
    return_value.Scale = converter<float>::convert_to(py_Scale);

    PyObject* py_Rotation = PyDict_GetItemString(obj, "rotation");
    if (!py_Rotation) { throw winrt::hresult_invalid_argument(); }
    return_value.Rotation = converter<float>::convert_to(py_Rotation);

    PyObject* py_Expansion = PyDict_GetItemString(obj, "expansion");
    if (!py_Expansion) { throw winrt::hresult_invalid_argument(); }
    return_value.Expansion = converter<float>::convert_to(py_Expansion);

    return return_value;
}

PyObject* py::converter<winrt::Windows::UI::Input::ManipulationVelocities>::convert(winrt::Windows::UI::Input::ManipulationVelocities instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::UI::Input::ManipulationVelocities>());
}
winrt::Windows::UI::Input::ManipulationVelocities py::converter<winrt::Windows::UI::Input::ManipulationVelocities>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::UI::Input::ManipulationVelocities>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::UI::Input::ManipulationVelocities>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::UI::Input::ManipulationVelocities return_value{};

    PyObject* py_Linear = PyDict_GetItemString(obj, "linear");
    if (!py_Linear) { throw winrt::hresult_invalid_argument(); }
    return_value.Linear = converter<winrt::Windows::Foundation::Point>::convert_to(py_Linear);

    PyObject* py_Angular = PyDict_GetItemString(obj, "angular");
    if (!py_Angular) { throw winrt::hresult_invalid_argument(); }
    return_value.Angular = converter<float>::convert_to(py_Angular);

    PyObject* py_Expansion = PyDict_GetItemString(obj, "expansion");
    if (!py_Expansion) { throw winrt::hresult_invalid_argument(); }
    return_value.Expansion = converter<float>::convert_to(py_Expansion);

    return return_value;
}

namespace py::cpp::Windows::UI::Input
{
    // ----- AttachableInputObject class --------------------
    constexpr const char* const _type_name_AttachableInputObject = "AttachableInputObject";

    static PyObject* _new_AttachableInputObject(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AttachableInputObject);
        return nullptr;
    }

    static void _dealloc_AttachableInputObject(py::wrapper::Windows::UI::Input::AttachableInputObject* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AttachableInputObject_Close(py::wrapper::Windows::UI::Input::AttachableInputObject* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_AttachableInputObject(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::AttachableInputObject>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AttachableInputObject(py::wrapper::Windows::UI::Input::AttachableInputObject* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_AttachableInputObject(py::wrapper::Windows::UI::Input::AttachableInputObject* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AttachableInputObject[] = {
        { "close", (PyCFunction)AttachableInputObject_Close, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AttachableInputObject, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_AttachableInputObject, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_AttachableInputObject, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AttachableInputObject[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_AttachableInputObject[] = 
    {
        { Py_tp_new, _new_AttachableInputObject },
        { Py_tp_dealloc, _dealloc_AttachableInputObject },
        { Py_tp_methods, _methods_AttachableInputObject },
        { Py_tp_getset, _getset_AttachableInputObject },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AttachableInputObject =
    {
        "_winrt_Windows_UI_Input.AttachableInputObject",
        sizeof(py::wrapper::Windows::UI::Input::AttachableInputObject),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AttachableInputObject
    };

    // ----- CrossSlidingEventArgs class --------------------
    constexpr const char* const _type_name_CrossSlidingEventArgs = "CrossSlidingEventArgs";

    static PyObject* _new_CrossSlidingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CrossSlidingEventArgs);
        return nullptr;
    }

    static void _dealloc_CrossSlidingEventArgs(py::wrapper::Windows::UI::Input::CrossSlidingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CrossSlidingEventArgs_get_CrossSlidingState(py::wrapper::Windows::UI::Input::CrossSlidingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CrossSlidingState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CrossSlidingEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Input::CrossSlidingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CrossSlidingEventArgs_get_Position(py::wrapper::Windows::UI::Input::CrossSlidingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CrossSlidingEventArgs_get_ContactCount(py::wrapper::Windows::UI::Input::CrossSlidingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CrossSlidingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::CrossSlidingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CrossSlidingEventArgs[] = {
        { "_from", (PyCFunction)_from_CrossSlidingEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CrossSlidingEventArgs[] = {
        { const_cast<char*>("cross_sliding_state"), (getter)CrossSlidingEventArgs_get_CrossSlidingState, nullptr, nullptr, nullptr },
        { const_cast<char*>("pointer_device_type"), (getter)CrossSlidingEventArgs_get_PointerDeviceType, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)CrossSlidingEventArgs_get_Position, nullptr, nullptr, nullptr },
        { const_cast<char*>("contact_count"), (getter)CrossSlidingEventArgs_get_ContactCount, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CrossSlidingEventArgs[] = 
    {
        { Py_tp_new, _new_CrossSlidingEventArgs },
        { Py_tp_dealloc, _dealloc_CrossSlidingEventArgs },
        { Py_tp_methods, _methods_CrossSlidingEventArgs },
        { Py_tp_getset, _getset_CrossSlidingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CrossSlidingEventArgs =
    {
        "_winrt_Windows_UI_Input.CrossSlidingEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::CrossSlidingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CrossSlidingEventArgs
    };

    // ----- DraggingEventArgs class --------------------
    constexpr const char* const _type_name_DraggingEventArgs = "DraggingEventArgs";

    static PyObject* _new_DraggingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DraggingEventArgs);
        return nullptr;
    }

    static void _dealloc_DraggingEventArgs(py::wrapper::Windows::UI::Input::DraggingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DraggingEventArgs_get_DraggingState(py::wrapper::Windows::UI::Input::DraggingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DraggingState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DraggingEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Input::DraggingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DraggingEventArgs_get_Position(py::wrapper::Windows::UI::Input::DraggingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DraggingEventArgs_get_ContactCount(py::wrapper::Windows::UI::Input::DraggingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DraggingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::DraggingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DraggingEventArgs[] = {
        { "_from", (PyCFunction)_from_DraggingEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DraggingEventArgs[] = {
        { const_cast<char*>("dragging_state"), (getter)DraggingEventArgs_get_DraggingState, nullptr, nullptr, nullptr },
        { const_cast<char*>("pointer_device_type"), (getter)DraggingEventArgs_get_PointerDeviceType, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)DraggingEventArgs_get_Position, nullptr, nullptr, nullptr },
        { const_cast<char*>("contact_count"), (getter)DraggingEventArgs_get_ContactCount, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DraggingEventArgs[] = 
    {
        { Py_tp_new, _new_DraggingEventArgs },
        { Py_tp_dealloc, _dealloc_DraggingEventArgs },
        { Py_tp_methods, _methods_DraggingEventArgs },
        { Py_tp_getset, _getset_DraggingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DraggingEventArgs =
    {
        "_winrt_Windows_UI_Input.DraggingEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::DraggingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DraggingEventArgs
    };

    // ----- EdgeGesture class --------------------
    constexpr const char* const _type_name_EdgeGesture = "EdgeGesture";

    static PyObject* _new_EdgeGesture(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EdgeGesture);
        return nullptr;
    }

    static void _dealloc_EdgeGesture(py::wrapper::Windows::UI::Input::EdgeGesture* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EdgeGesture_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::Input::EdgeGesture::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EdgeGesture_add_Canceled(py::wrapper::Windows::UI::Input::EdgeGesture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::EdgeGesture, winrt::Windows::UI::Input::EdgeGestureEventArgs>>(arg);

            return py::convert(self->obj.Canceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EdgeGesture_remove_Canceled(py::wrapper::Windows::UI::Input::EdgeGesture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Canceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EdgeGesture_add_Completed(py::wrapper::Windows::UI::Input::EdgeGesture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::EdgeGesture, winrt::Windows::UI::Input::EdgeGestureEventArgs>>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EdgeGesture_remove_Completed(py::wrapper::Windows::UI::Input::EdgeGesture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EdgeGesture_add_Starting(py::wrapper::Windows::UI::Input::EdgeGesture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::EdgeGesture, winrt::Windows::UI::Input::EdgeGestureEventArgs>>(arg);

            return py::convert(self->obj.Starting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EdgeGesture_remove_Starting(py::wrapper::Windows::UI::Input::EdgeGesture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Starting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EdgeGesture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::EdgeGesture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EdgeGesture[] = {
        { "get_for_current_view", (PyCFunction)EdgeGesture_GetForCurrentView, METH_VARARGS | METH_STATIC, nullptr },
        { "add_canceled", (PyCFunction)EdgeGesture_add_Canceled, METH_O, nullptr },
        { "remove_canceled", (PyCFunction)EdgeGesture_remove_Canceled, METH_O, nullptr },
        { "add_completed", (PyCFunction)EdgeGesture_add_Completed, METH_O, nullptr },
        { "remove_completed", (PyCFunction)EdgeGesture_remove_Completed, METH_O, nullptr },
        { "add_starting", (PyCFunction)EdgeGesture_add_Starting, METH_O, nullptr },
        { "remove_starting", (PyCFunction)EdgeGesture_remove_Starting, METH_O, nullptr },
        { "_from", (PyCFunction)_from_EdgeGesture, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EdgeGesture[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_EdgeGesture[] = 
    {
        { Py_tp_new, _new_EdgeGesture },
        { Py_tp_dealloc, _dealloc_EdgeGesture },
        { Py_tp_methods, _methods_EdgeGesture },
        { Py_tp_getset, _getset_EdgeGesture },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EdgeGesture =
    {
        "_winrt_Windows_UI_Input.EdgeGesture",
        sizeof(py::wrapper::Windows::UI::Input::EdgeGesture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EdgeGesture
    };

    // ----- EdgeGestureEventArgs class --------------------
    constexpr const char* const _type_name_EdgeGestureEventArgs = "EdgeGestureEventArgs";

    static PyObject* _new_EdgeGestureEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EdgeGestureEventArgs);
        return nullptr;
    }

    static void _dealloc_EdgeGestureEventArgs(py::wrapper::Windows::UI::Input::EdgeGestureEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EdgeGestureEventArgs_get_Kind(py::wrapper::Windows::UI::Input::EdgeGestureEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EdgeGestureEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::EdgeGestureEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EdgeGestureEventArgs[] = {
        { "_from", (PyCFunction)_from_EdgeGestureEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EdgeGestureEventArgs[] = {
        { const_cast<char*>("kind"), (getter)EdgeGestureEventArgs_get_Kind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EdgeGestureEventArgs[] = 
    {
        { Py_tp_new, _new_EdgeGestureEventArgs },
        { Py_tp_dealloc, _dealloc_EdgeGestureEventArgs },
        { Py_tp_methods, _methods_EdgeGestureEventArgs },
        { Py_tp_getset, _getset_EdgeGestureEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EdgeGestureEventArgs =
    {
        "_winrt_Windows_UI_Input.EdgeGestureEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::EdgeGestureEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EdgeGestureEventArgs
    };

    // ----- GestureRecognizer class --------------------
    constexpr const char* const _type_name_GestureRecognizer = "GestureRecognizer";

    static PyObject* _new_GestureRecognizer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::GestureRecognizer instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GestureRecognizer(py::wrapper::Windows::UI::Input::GestureRecognizer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GestureRecognizer_CanBeDoubleTap(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                return py::convert(self->obj.CanBeDoubleTap(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_CompleteGesture(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.CompleteGesture();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_ProcessDownEvent(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                self->obj.ProcessDownEvent(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_ProcessInertia(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ProcessInertia();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_ProcessMouseWheelEvent(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.ProcessMouseWheelEvent(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_ProcessMoveEvents(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::UI::Input::PointerPoint>>(args, 0);

                self->obj.ProcessMoveEvents(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_ProcessUpEvent(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                self->obj.ProcessUpEvent(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_get_ShowGestureFeedback(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShowGestureFeedback());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_ShowGestureFeedback(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowGestureFeedback(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_PivotRadius(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PivotRadius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_PivotRadius(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.PivotRadius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_PivotCenter(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PivotCenter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_PivotCenter(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.PivotCenter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_ManipulationExact(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ManipulationExact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_ManipulationExact(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ManipulationExact(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_InertiaTranslationDisplacement(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InertiaTranslationDisplacement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_InertiaTranslationDisplacement(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.InertiaTranslationDisplacement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_InertiaTranslationDeceleration(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InertiaTranslationDeceleration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_InertiaTranslationDeceleration(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.InertiaTranslationDeceleration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_InertiaRotationDeceleration(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InertiaRotationDeceleration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_InertiaRotationDeceleration(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.InertiaRotationDeceleration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_InertiaRotationAngle(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InertiaRotationAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_InertiaRotationAngle(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.InertiaRotationAngle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_InertiaExpansionDeceleration(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InertiaExpansionDeceleration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_InertiaExpansionDeceleration(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.InertiaExpansionDeceleration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_InertiaExpansion(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InertiaExpansion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_InertiaExpansion(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.InertiaExpansion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_GestureSettings(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.GestureSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_GestureSettings(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::GestureSettings>(arg);

            self->obj.GestureSettings(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_CrossSlideThresholds(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CrossSlideThresholds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_CrossSlideThresholds(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::CrossSlideThresholds>(arg);

            self->obj.CrossSlideThresholds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_CrossSlideHorizontally(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CrossSlideHorizontally());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_CrossSlideHorizontally(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CrossSlideHorizontally(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_CrossSlideExact(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CrossSlideExact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_CrossSlideExact(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CrossSlideExact(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_AutoProcessInertia(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoProcessInertia());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_AutoProcessInertia(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoProcessInertia(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_IsActive(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_get_IsInertial(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInertial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_get_MouseWheelParameters(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MouseWheelParameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_get_TranslationMinContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TranslationMinContactCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_TranslationMinContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.TranslationMinContactCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_TranslationMaxContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TranslationMaxContactCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_TranslationMaxContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.TranslationMaxContactCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_TapMinContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TapMinContactCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_TapMinContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.TapMinContactCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_TapMaxContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TapMaxContactCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_TapMaxContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.TapMaxContactCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_HoldStartDelay(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HoldStartDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_HoldStartDelay(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.HoldStartDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_HoldRadius(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HoldRadius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_HoldRadius(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.HoldRadius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_HoldMinContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HoldMinContactCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_HoldMinContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.HoldMinContactCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_HoldMaxContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HoldMaxContactCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_HoldMaxContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.HoldMaxContactCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_add_CrossSliding(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::GestureRecognizer, winrt::Windows::UI::Input::CrossSlidingEventArgs>>(arg);

            return py::convert(self->obj.CrossSliding(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_CrossSliding(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CrossSliding(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_Dragging(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::GestureRecognizer, winrt::Windows::UI::Input::DraggingEventArgs>>(arg);

            return py::convert(self->obj.Dragging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_Dragging(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Dragging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_Holding(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::GestureRecognizer, winrt::Windows::UI::Input::HoldingEventArgs>>(arg);

            return py::convert(self->obj.Holding(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_Holding(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Holding(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_ManipulationCompleted(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::GestureRecognizer, winrt::Windows::UI::Input::ManipulationCompletedEventArgs>>(arg);

            return py::convert(self->obj.ManipulationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_ManipulationCompleted(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_ManipulationInertiaStarting(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::GestureRecognizer, winrt::Windows::UI::Input::ManipulationInertiaStartingEventArgs>>(arg);

            return py::convert(self->obj.ManipulationInertiaStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_ManipulationInertiaStarting(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationInertiaStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_ManipulationStarted(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::GestureRecognizer, winrt::Windows::UI::Input::ManipulationStartedEventArgs>>(arg);

            return py::convert(self->obj.ManipulationStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_ManipulationStarted(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_ManipulationUpdated(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::GestureRecognizer, winrt::Windows::UI::Input::ManipulationUpdatedEventArgs>>(arg);

            return py::convert(self->obj.ManipulationUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_ManipulationUpdated(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_RightTapped(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::GestureRecognizer, winrt::Windows::UI::Input::RightTappedEventArgs>>(arg);

            return py::convert(self->obj.RightTapped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_RightTapped(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RightTapped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_Tapped(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::GestureRecognizer, winrt::Windows::UI::Input::TappedEventArgs>>(arg);

            return py::convert(self->obj.Tapped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_Tapped(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Tapped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GestureRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::GestureRecognizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GestureRecognizer[] = {
        { "can_be_double_tap", (PyCFunction)GestureRecognizer_CanBeDoubleTap, METH_VARARGS, nullptr },
        { "complete_gesture", (PyCFunction)GestureRecognizer_CompleteGesture, METH_VARARGS, nullptr },
        { "process_down_event", (PyCFunction)GestureRecognizer_ProcessDownEvent, METH_VARARGS, nullptr },
        { "process_inertia", (PyCFunction)GestureRecognizer_ProcessInertia, METH_VARARGS, nullptr },
        { "process_mouse_wheel_event", (PyCFunction)GestureRecognizer_ProcessMouseWheelEvent, METH_VARARGS, nullptr },
        { "process_move_events", (PyCFunction)GestureRecognizer_ProcessMoveEvents, METH_VARARGS, nullptr },
        { "process_up_event", (PyCFunction)GestureRecognizer_ProcessUpEvent, METH_VARARGS, nullptr },
        { "add_cross_sliding", (PyCFunction)GestureRecognizer_add_CrossSliding, METH_O, nullptr },
        { "remove_cross_sliding", (PyCFunction)GestureRecognizer_remove_CrossSliding, METH_O, nullptr },
        { "add_dragging", (PyCFunction)GestureRecognizer_add_Dragging, METH_O, nullptr },
        { "remove_dragging", (PyCFunction)GestureRecognizer_remove_Dragging, METH_O, nullptr },
        { "add_holding", (PyCFunction)GestureRecognizer_add_Holding, METH_O, nullptr },
        { "remove_holding", (PyCFunction)GestureRecognizer_remove_Holding, METH_O, nullptr },
        { "add_manipulation_completed", (PyCFunction)GestureRecognizer_add_ManipulationCompleted, METH_O, nullptr },
        { "remove_manipulation_completed", (PyCFunction)GestureRecognizer_remove_ManipulationCompleted, METH_O, nullptr },
        { "add_manipulation_inertia_starting", (PyCFunction)GestureRecognizer_add_ManipulationInertiaStarting, METH_O, nullptr },
        { "remove_manipulation_inertia_starting", (PyCFunction)GestureRecognizer_remove_ManipulationInertiaStarting, METH_O, nullptr },
        { "add_manipulation_started", (PyCFunction)GestureRecognizer_add_ManipulationStarted, METH_O, nullptr },
        { "remove_manipulation_started", (PyCFunction)GestureRecognizer_remove_ManipulationStarted, METH_O, nullptr },
        { "add_manipulation_updated", (PyCFunction)GestureRecognizer_add_ManipulationUpdated, METH_O, nullptr },
        { "remove_manipulation_updated", (PyCFunction)GestureRecognizer_remove_ManipulationUpdated, METH_O, nullptr },
        { "add_right_tapped", (PyCFunction)GestureRecognizer_add_RightTapped, METH_O, nullptr },
        { "remove_right_tapped", (PyCFunction)GestureRecognizer_remove_RightTapped, METH_O, nullptr },
        { "add_tapped", (PyCFunction)GestureRecognizer_add_Tapped, METH_O, nullptr },
        { "remove_tapped", (PyCFunction)GestureRecognizer_remove_Tapped, METH_O, nullptr },
        { "_from", (PyCFunction)_from_GestureRecognizer, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GestureRecognizer[] = {
        { const_cast<char*>("show_gesture_feedback"), (getter)GestureRecognizer_get_ShowGestureFeedback, (setter)GestureRecognizer_put_ShowGestureFeedback, nullptr, nullptr },
        { const_cast<char*>("pivot_radius"), (getter)GestureRecognizer_get_PivotRadius, (setter)GestureRecognizer_put_PivotRadius, nullptr, nullptr },
        { const_cast<char*>("pivot_center"), (getter)GestureRecognizer_get_PivotCenter, (setter)GestureRecognizer_put_PivotCenter, nullptr, nullptr },
        { const_cast<char*>("manipulation_exact"), (getter)GestureRecognizer_get_ManipulationExact, (setter)GestureRecognizer_put_ManipulationExact, nullptr, nullptr },
        { const_cast<char*>("inertia_translation_displacement"), (getter)GestureRecognizer_get_InertiaTranslationDisplacement, (setter)GestureRecognizer_put_InertiaTranslationDisplacement, nullptr, nullptr },
        { const_cast<char*>("inertia_translation_deceleration"), (getter)GestureRecognizer_get_InertiaTranslationDeceleration, (setter)GestureRecognizer_put_InertiaTranslationDeceleration, nullptr, nullptr },
        { const_cast<char*>("inertia_rotation_deceleration"), (getter)GestureRecognizer_get_InertiaRotationDeceleration, (setter)GestureRecognizer_put_InertiaRotationDeceleration, nullptr, nullptr },
        { const_cast<char*>("inertia_rotation_angle"), (getter)GestureRecognizer_get_InertiaRotationAngle, (setter)GestureRecognizer_put_InertiaRotationAngle, nullptr, nullptr },
        { const_cast<char*>("inertia_expansion_deceleration"), (getter)GestureRecognizer_get_InertiaExpansionDeceleration, (setter)GestureRecognizer_put_InertiaExpansionDeceleration, nullptr, nullptr },
        { const_cast<char*>("inertia_expansion"), (getter)GestureRecognizer_get_InertiaExpansion, (setter)GestureRecognizer_put_InertiaExpansion, nullptr, nullptr },
        { const_cast<char*>("gesture_settings"), (getter)GestureRecognizer_get_GestureSettings, (setter)GestureRecognizer_put_GestureSettings, nullptr, nullptr },
        { const_cast<char*>("cross_slide_thresholds"), (getter)GestureRecognizer_get_CrossSlideThresholds, (setter)GestureRecognizer_put_CrossSlideThresholds, nullptr, nullptr },
        { const_cast<char*>("cross_slide_horizontally"), (getter)GestureRecognizer_get_CrossSlideHorizontally, (setter)GestureRecognizer_put_CrossSlideHorizontally, nullptr, nullptr },
        { const_cast<char*>("cross_slide_exact"), (getter)GestureRecognizer_get_CrossSlideExact, (setter)GestureRecognizer_put_CrossSlideExact, nullptr, nullptr },
        { const_cast<char*>("auto_process_inertia"), (getter)GestureRecognizer_get_AutoProcessInertia, (setter)GestureRecognizer_put_AutoProcessInertia, nullptr, nullptr },
        { const_cast<char*>("is_active"), (getter)GestureRecognizer_get_IsActive, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_inertial"), (getter)GestureRecognizer_get_IsInertial, nullptr, nullptr, nullptr },
        { const_cast<char*>("mouse_wheel_parameters"), (getter)GestureRecognizer_get_MouseWheelParameters, nullptr, nullptr, nullptr },
        { const_cast<char*>("translation_min_contact_count"), (getter)GestureRecognizer_get_TranslationMinContactCount, (setter)GestureRecognizer_put_TranslationMinContactCount, nullptr, nullptr },
        { const_cast<char*>("translation_max_contact_count"), (getter)GestureRecognizer_get_TranslationMaxContactCount, (setter)GestureRecognizer_put_TranslationMaxContactCount, nullptr, nullptr },
        { const_cast<char*>("tap_min_contact_count"), (getter)GestureRecognizer_get_TapMinContactCount, (setter)GestureRecognizer_put_TapMinContactCount, nullptr, nullptr },
        { const_cast<char*>("tap_max_contact_count"), (getter)GestureRecognizer_get_TapMaxContactCount, (setter)GestureRecognizer_put_TapMaxContactCount, nullptr, nullptr },
        { const_cast<char*>("hold_start_delay"), (getter)GestureRecognizer_get_HoldStartDelay, (setter)GestureRecognizer_put_HoldStartDelay, nullptr, nullptr },
        { const_cast<char*>("hold_radius"), (getter)GestureRecognizer_get_HoldRadius, (setter)GestureRecognizer_put_HoldRadius, nullptr, nullptr },
        { const_cast<char*>("hold_min_contact_count"), (getter)GestureRecognizer_get_HoldMinContactCount, (setter)GestureRecognizer_put_HoldMinContactCount, nullptr, nullptr },
        { const_cast<char*>("hold_max_contact_count"), (getter)GestureRecognizer_get_HoldMaxContactCount, (setter)GestureRecognizer_put_HoldMaxContactCount, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GestureRecognizer[] = 
    {
        { Py_tp_new, _new_GestureRecognizer },
        { Py_tp_dealloc, _dealloc_GestureRecognizer },
        { Py_tp_methods, _methods_GestureRecognizer },
        { Py_tp_getset, _getset_GestureRecognizer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GestureRecognizer =
    {
        "_winrt_Windows_UI_Input.GestureRecognizer",
        sizeof(py::wrapper::Windows::UI::Input::GestureRecognizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GestureRecognizer
    };

    // ----- HoldingEventArgs class --------------------
    constexpr const char* const _type_name_HoldingEventArgs = "HoldingEventArgs";

    static PyObject* _new_HoldingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HoldingEventArgs);
        return nullptr;
    }

    static void _dealloc_HoldingEventArgs(py::wrapper::Windows::UI::Input::HoldingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HoldingEventArgs_get_HoldingState(py::wrapper::Windows::UI::Input::HoldingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HoldingState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HoldingEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Input::HoldingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HoldingEventArgs_get_Position(py::wrapper::Windows::UI::Input::HoldingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HoldingEventArgs_get_ContactCount(py::wrapper::Windows::UI::Input::HoldingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HoldingEventArgs_get_CurrentContactCount(py::wrapper::Windows::UI::Input::HoldingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentContactCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HoldingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::HoldingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HoldingEventArgs[] = {
        { "_from", (PyCFunction)_from_HoldingEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HoldingEventArgs[] = {
        { const_cast<char*>("holding_state"), (getter)HoldingEventArgs_get_HoldingState, nullptr, nullptr, nullptr },
        { const_cast<char*>("pointer_device_type"), (getter)HoldingEventArgs_get_PointerDeviceType, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)HoldingEventArgs_get_Position, nullptr, nullptr, nullptr },
        { const_cast<char*>("contact_count"), (getter)HoldingEventArgs_get_ContactCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("current_contact_count"), (getter)HoldingEventArgs_get_CurrentContactCount, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HoldingEventArgs[] = 
    {
        { Py_tp_new, _new_HoldingEventArgs },
        { Py_tp_dealloc, _dealloc_HoldingEventArgs },
        { Py_tp_methods, _methods_HoldingEventArgs },
        { Py_tp_getset, _getset_HoldingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HoldingEventArgs =
    {
        "_winrt_Windows_UI_Input.HoldingEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::HoldingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HoldingEventArgs
    };

    // ----- InputActivationListener class --------------------
    constexpr const char* const _type_name_InputActivationListener = "InputActivationListener";

    static PyObject* _new_InputActivationListener(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InputActivationListener);
        return nullptr;
    }

    static void _dealloc_InputActivationListener(py::wrapper::Windows::UI::Input::InputActivationListener* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InputActivationListener_get_State(py::wrapper::Windows::UI::Input::InputActivationListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputActivationListener_add_InputActivationChanged(py::wrapper::Windows::UI::Input::InputActivationListener* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::InputActivationListener, winrt::Windows::UI::Input::InputActivationListenerActivationChangedEventArgs>>(arg);

            return py::convert(self->obj.InputActivationChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputActivationListener_remove_InputActivationChanged(py::wrapper::Windows::UI::Input::InputActivationListener* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InputActivationChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InputActivationListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::InputActivationListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputActivationListener[] = {
        { "add_input_activation_changed", (PyCFunction)InputActivationListener_add_InputActivationChanged, METH_O, nullptr },
        { "remove_input_activation_changed", (PyCFunction)InputActivationListener_remove_InputActivationChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_InputActivationListener, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InputActivationListener[] = {
        { const_cast<char*>("state"), (getter)InputActivationListener_get_State, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InputActivationListener[] = 
    {
        { Py_tp_new, _new_InputActivationListener },
        { Py_tp_dealloc, _dealloc_InputActivationListener },
        { Py_tp_methods, _methods_InputActivationListener },
        { Py_tp_getset, _getset_InputActivationListener },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InputActivationListener =
    {
        "_winrt_Windows_UI_Input.InputActivationListener",
        sizeof(py::wrapper::Windows::UI::Input::InputActivationListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputActivationListener
    };

    // ----- InputActivationListenerActivationChangedEventArgs class --------------------
    constexpr const char* const _type_name_InputActivationListenerActivationChangedEventArgs = "InputActivationListenerActivationChangedEventArgs";

    static PyObject* _new_InputActivationListenerActivationChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InputActivationListenerActivationChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_InputActivationListenerActivationChangedEventArgs(py::wrapper::Windows::UI::Input::InputActivationListenerActivationChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InputActivationListenerActivationChangedEventArgs_get_State(py::wrapper::Windows::UI::Input::InputActivationListenerActivationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InputActivationListenerActivationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::InputActivationListenerActivationChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputActivationListenerActivationChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_InputActivationListenerActivationChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InputActivationListenerActivationChangedEventArgs[] = {
        { const_cast<char*>("state"), (getter)InputActivationListenerActivationChangedEventArgs_get_State, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InputActivationListenerActivationChangedEventArgs[] = 
    {
        { Py_tp_new, _new_InputActivationListenerActivationChangedEventArgs },
        { Py_tp_dealloc, _dealloc_InputActivationListenerActivationChangedEventArgs },
        { Py_tp_methods, _methods_InputActivationListenerActivationChangedEventArgs },
        { Py_tp_getset, _getset_InputActivationListenerActivationChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InputActivationListenerActivationChangedEventArgs =
    {
        "_winrt_Windows_UI_Input.InputActivationListenerActivationChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::InputActivationListenerActivationChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputActivationListenerActivationChangedEventArgs
    };

    // ----- KeyboardDeliveryInterceptor class --------------------
    constexpr const char* const _type_name_KeyboardDeliveryInterceptor = "KeyboardDeliveryInterceptor";

    static PyObject* _new_KeyboardDeliveryInterceptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KeyboardDeliveryInterceptor);
        return nullptr;
    }

    static void _dealloc_KeyboardDeliveryInterceptor(py::wrapper::Windows::UI::Input::KeyboardDeliveryInterceptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* KeyboardDeliveryInterceptor_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::Input::KeyboardDeliveryInterceptor::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyboardDeliveryInterceptor_get_IsInterceptionEnabledWhenInForeground(py::wrapper::Windows::UI::Input::KeyboardDeliveryInterceptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInterceptionEnabledWhenInForeground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyboardDeliveryInterceptor_put_IsInterceptionEnabledWhenInForeground(py::wrapper::Windows::UI::Input::KeyboardDeliveryInterceptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsInterceptionEnabledWhenInForeground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyboardDeliveryInterceptor_add_KeyDown(py::wrapper::Windows::UI::Input::KeyboardDeliveryInterceptor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::KeyboardDeliveryInterceptor, winrt::Windows::UI::Core::KeyEventArgs>>(arg);

            return py::convert(self->obj.KeyDown(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyboardDeliveryInterceptor_remove_KeyDown(py::wrapper::Windows::UI::Input::KeyboardDeliveryInterceptor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.KeyDown(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyboardDeliveryInterceptor_add_KeyUp(py::wrapper::Windows::UI::Input::KeyboardDeliveryInterceptor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::KeyboardDeliveryInterceptor, winrt::Windows::UI::Core::KeyEventArgs>>(arg);

            return py::convert(self->obj.KeyUp(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyboardDeliveryInterceptor_remove_KeyUp(py::wrapper::Windows::UI::Input::KeyboardDeliveryInterceptor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.KeyUp(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_KeyboardDeliveryInterceptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::KeyboardDeliveryInterceptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyboardDeliveryInterceptor[] = {
        { "get_for_current_view", (PyCFunction)KeyboardDeliveryInterceptor_GetForCurrentView, METH_VARARGS | METH_STATIC, nullptr },
        { "add_key_down", (PyCFunction)KeyboardDeliveryInterceptor_add_KeyDown, METH_O, nullptr },
        { "remove_key_down", (PyCFunction)KeyboardDeliveryInterceptor_remove_KeyDown, METH_O, nullptr },
        { "add_key_up", (PyCFunction)KeyboardDeliveryInterceptor_add_KeyUp, METH_O, nullptr },
        { "remove_key_up", (PyCFunction)KeyboardDeliveryInterceptor_remove_KeyUp, METH_O, nullptr },
        { "_from", (PyCFunction)_from_KeyboardDeliveryInterceptor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_KeyboardDeliveryInterceptor[] = {
        { const_cast<char*>("is_interception_enabled_when_in_foreground"), (getter)KeyboardDeliveryInterceptor_get_IsInterceptionEnabledWhenInForeground, (setter)KeyboardDeliveryInterceptor_put_IsInterceptionEnabledWhenInForeground, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_KeyboardDeliveryInterceptor[] = 
    {
        { Py_tp_new, _new_KeyboardDeliveryInterceptor },
        { Py_tp_dealloc, _dealloc_KeyboardDeliveryInterceptor },
        { Py_tp_methods, _methods_KeyboardDeliveryInterceptor },
        { Py_tp_getset, _getset_KeyboardDeliveryInterceptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_KeyboardDeliveryInterceptor =
    {
        "_winrt_Windows_UI_Input.KeyboardDeliveryInterceptor",
        sizeof(py::wrapper::Windows::UI::Input::KeyboardDeliveryInterceptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyboardDeliveryInterceptor
    };

    // ----- ManipulationCompletedEventArgs class --------------------
    constexpr const char* const _type_name_ManipulationCompletedEventArgs = "ManipulationCompletedEventArgs";

    static PyObject* _new_ManipulationCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ManipulationCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_ManipulationCompletedEventArgs(py::wrapper::Windows::UI::Input::ManipulationCompletedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ManipulationCompletedEventArgs_get_Cumulative(py::wrapper::Windows::UI::Input::ManipulationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Cumulative());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Input::ManipulationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedEventArgs_get_Position(py::wrapper::Windows::UI::Input::ManipulationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedEventArgs_get_Velocities(py::wrapper::Windows::UI::Input::ManipulationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Velocities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedEventArgs_get_ContactCount(py::wrapper::Windows::UI::Input::ManipulationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedEventArgs_get_CurrentContactCount(py::wrapper::Windows::UI::Input::ManipulationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentContactCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ManipulationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::ManipulationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationCompletedEventArgs[] = {
        { "_from", (PyCFunction)_from_ManipulationCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ManipulationCompletedEventArgs[] = {
        { const_cast<char*>("cumulative"), (getter)ManipulationCompletedEventArgs_get_Cumulative, nullptr, nullptr, nullptr },
        { const_cast<char*>("pointer_device_type"), (getter)ManipulationCompletedEventArgs_get_PointerDeviceType, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)ManipulationCompletedEventArgs_get_Position, nullptr, nullptr, nullptr },
        { const_cast<char*>("velocities"), (getter)ManipulationCompletedEventArgs_get_Velocities, nullptr, nullptr, nullptr },
        { const_cast<char*>("contact_count"), (getter)ManipulationCompletedEventArgs_get_ContactCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("current_contact_count"), (getter)ManipulationCompletedEventArgs_get_CurrentContactCount, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ManipulationCompletedEventArgs[] = 
    {
        { Py_tp_new, _new_ManipulationCompletedEventArgs },
        { Py_tp_dealloc, _dealloc_ManipulationCompletedEventArgs },
        { Py_tp_methods, _methods_ManipulationCompletedEventArgs },
        { Py_tp_getset, _getset_ManipulationCompletedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ManipulationCompletedEventArgs =
    {
        "_winrt_Windows_UI_Input.ManipulationCompletedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::ManipulationCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationCompletedEventArgs
    };

    // ----- ManipulationInertiaStartingEventArgs class --------------------
    constexpr const char* const _type_name_ManipulationInertiaStartingEventArgs = "ManipulationInertiaStartingEventArgs";

    static PyObject* _new_ManipulationInertiaStartingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ManipulationInertiaStartingEventArgs);
        return nullptr;
    }

    static void _dealloc_ManipulationInertiaStartingEventArgs(py::wrapper::Windows::UI::Input::ManipulationInertiaStartingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ManipulationInertiaStartingEventArgs_get_Cumulative(py::wrapper::Windows::UI::Input::ManipulationInertiaStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Cumulative());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingEventArgs_get_Delta(py::wrapper::Windows::UI::Input::ManipulationInertiaStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Delta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Input::ManipulationInertiaStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingEventArgs_get_Position(py::wrapper::Windows::UI::Input::ManipulationInertiaStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingEventArgs_get_Velocities(py::wrapper::Windows::UI::Input::ManipulationInertiaStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Velocities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingEventArgs_get_ContactCount(py::wrapper::Windows::UI::Input::ManipulationInertiaStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ManipulationInertiaStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::ManipulationInertiaStartingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationInertiaStartingEventArgs[] = {
        { "_from", (PyCFunction)_from_ManipulationInertiaStartingEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ManipulationInertiaStartingEventArgs[] = {
        { const_cast<char*>("cumulative"), (getter)ManipulationInertiaStartingEventArgs_get_Cumulative, nullptr, nullptr, nullptr },
        { const_cast<char*>("delta"), (getter)ManipulationInertiaStartingEventArgs_get_Delta, nullptr, nullptr, nullptr },
        { const_cast<char*>("pointer_device_type"), (getter)ManipulationInertiaStartingEventArgs_get_PointerDeviceType, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)ManipulationInertiaStartingEventArgs_get_Position, nullptr, nullptr, nullptr },
        { const_cast<char*>("velocities"), (getter)ManipulationInertiaStartingEventArgs_get_Velocities, nullptr, nullptr, nullptr },
        { const_cast<char*>("contact_count"), (getter)ManipulationInertiaStartingEventArgs_get_ContactCount, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ManipulationInertiaStartingEventArgs[] = 
    {
        { Py_tp_new, _new_ManipulationInertiaStartingEventArgs },
        { Py_tp_dealloc, _dealloc_ManipulationInertiaStartingEventArgs },
        { Py_tp_methods, _methods_ManipulationInertiaStartingEventArgs },
        { Py_tp_getset, _getset_ManipulationInertiaStartingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ManipulationInertiaStartingEventArgs =
    {
        "_winrt_Windows_UI_Input.ManipulationInertiaStartingEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::ManipulationInertiaStartingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationInertiaStartingEventArgs
    };

    // ----- ManipulationStartedEventArgs class --------------------
    constexpr const char* const _type_name_ManipulationStartedEventArgs = "ManipulationStartedEventArgs";

    static PyObject* _new_ManipulationStartedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ManipulationStartedEventArgs);
        return nullptr;
    }

    static void _dealloc_ManipulationStartedEventArgs(py::wrapper::Windows::UI::Input::ManipulationStartedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ManipulationStartedEventArgs_get_Cumulative(py::wrapper::Windows::UI::Input::ManipulationStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Cumulative());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationStartedEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Input::ManipulationStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationStartedEventArgs_get_Position(py::wrapper::Windows::UI::Input::ManipulationStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationStartedEventArgs_get_ContactCount(py::wrapper::Windows::UI::Input::ManipulationStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ManipulationStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::ManipulationStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationStartedEventArgs[] = {
        { "_from", (PyCFunction)_from_ManipulationStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ManipulationStartedEventArgs[] = {
        { const_cast<char*>("cumulative"), (getter)ManipulationStartedEventArgs_get_Cumulative, nullptr, nullptr, nullptr },
        { const_cast<char*>("pointer_device_type"), (getter)ManipulationStartedEventArgs_get_PointerDeviceType, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)ManipulationStartedEventArgs_get_Position, nullptr, nullptr, nullptr },
        { const_cast<char*>("contact_count"), (getter)ManipulationStartedEventArgs_get_ContactCount, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ManipulationStartedEventArgs[] = 
    {
        { Py_tp_new, _new_ManipulationStartedEventArgs },
        { Py_tp_dealloc, _dealloc_ManipulationStartedEventArgs },
        { Py_tp_methods, _methods_ManipulationStartedEventArgs },
        { Py_tp_getset, _getset_ManipulationStartedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ManipulationStartedEventArgs =
    {
        "_winrt_Windows_UI_Input.ManipulationStartedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::ManipulationStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationStartedEventArgs
    };

    // ----- ManipulationUpdatedEventArgs class --------------------
    constexpr const char* const _type_name_ManipulationUpdatedEventArgs = "ManipulationUpdatedEventArgs";

    static PyObject* _new_ManipulationUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ManipulationUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ManipulationUpdatedEventArgs(py::wrapper::Windows::UI::Input::ManipulationUpdatedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ManipulationUpdatedEventArgs_get_Cumulative(py::wrapper::Windows::UI::Input::ManipulationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Cumulative());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationUpdatedEventArgs_get_Delta(py::wrapper::Windows::UI::Input::ManipulationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Delta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationUpdatedEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Input::ManipulationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationUpdatedEventArgs_get_Position(py::wrapper::Windows::UI::Input::ManipulationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationUpdatedEventArgs_get_Velocities(py::wrapper::Windows::UI::Input::ManipulationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Velocities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationUpdatedEventArgs_get_ContactCount(py::wrapper::Windows::UI::Input::ManipulationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationUpdatedEventArgs_get_CurrentContactCount(py::wrapper::Windows::UI::Input::ManipulationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentContactCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ManipulationUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::ManipulationUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationUpdatedEventArgs[] = {
        { "_from", (PyCFunction)_from_ManipulationUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ManipulationUpdatedEventArgs[] = {
        { const_cast<char*>("cumulative"), (getter)ManipulationUpdatedEventArgs_get_Cumulative, nullptr, nullptr, nullptr },
        { const_cast<char*>("delta"), (getter)ManipulationUpdatedEventArgs_get_Delta, nullptr, nullptr, nullptr },
        { const_cast<char*>("pointer_device_type"), (getter)ManipulationUpdatedEventArgs_get_PointerDeviceType, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)ManipulationUpdatedEventArgs_get_Position, nullptr, nullptr, nullptr },
        { const_cast<char*>("velocities"), (getter)ManipulationUpdatedEventArgs_get_Velocities, nullptr, nullptr, nullptr },
        { const_cast<char*>("contact_count"), (getter)ManipulationUpdatedEventArgs_get_ContactCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("current_contact_count"), (getter)ManipulationUpdatedEventArgs_get_CurrentContactCount, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ManipulationUpdatedEventArgs[] = 
    {
        { Py_tp_new, _new_ManipulationUpdatedEventArgs },
        { Py_tp_dealloc, _dealloc_ManipulationUpdatedEventArgs },
        { Py_tp_methods, _methods_ManipulationUpdatedEventArgs },
        { Py_tp_getset, _getset_ManipulationUpdatedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ManipulationUpdatedEventArgs =
    {
        "_winrt_Windows_UI_Input.ManipulationUpdatedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::ManipulationUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationUpdatedEventArgs
    };

    // ----- MouseWheelParameters class --------------------
    constexpr const char* const _type_name_MouseWheelParameters = "MouseWheelParameters";

    static PyObject* _new_MouseWheelParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MouseWheelParameters);
        return nullptr;
    }

    static void _dealloc_MouseWheelParameters(py::wrapper::Windows::UI::Input::MouseWheelParameters* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MouseWheelParameters_get_PageTranslation(py::wrapper::Windows::UI::Input::MouseWheelParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PageTranslation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MouseWheelParameters_put_PageTranslation(py::wrapper::Windows::UI::Input::MouseWheelParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.PageTranslation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MouseWheelParameters_get_DeltaScale(py::wrapper::Windows::UI::Input::MouseWheelParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeltaScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MouseWheelParameters_put_DeltaScale(py::wrapper::Windows::UI::Input::MouseWheelParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.DeltaScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MouseWheelParameters_get_DeltaRotationAngle(py::wrapper::Windows::UI::Input::MouseWheelParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeltaRotationAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MouseWheelParameters_put_DeltaRotationAngle(py::wrapper::Windows::UI::Input::MouseWheelParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.DeltaRotationAngle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MouseWheelParameters_get_CharTranslation(py::wrapper::Windows::UI::Input::MouseWheelParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharTranslation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MouseWheelParameters_put_CharTranslation(py::wrapper::Windows::UI::Input::MouseWheelParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.CharTranslation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_MouseWheelParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::MouseWheelParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MouseWheelParameters[] = {
        { "_from", (PyCFunction)_from_MouseWheelParameters, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MouseWheelParameters[] = {
        { const_cast<char*>("page_translation"), (getter)MouseWheelParameters_get_PageTranslation, (setter)MouseWheelParameters_put_PageTranslation, nullptr, nullptr },
        { const_cast<char*>("delta_scale"), (getter)MouseWheelParameters_get_DeltaScale, (setter)MouseWheelParameters_put_DeltaScale, nullptr, nullptr },
        { const_cast<char*>("delta_rotation_angle"), (getter)MouseWheelParameters_get_DeltaRotationAngle, (setter)MouseWheelParameters_put_DeltaRotationAngle, nullptr, nullptr },
        { const_cast<char*>("char_translation"), (getter)MouseWheelParameters_get_CharTranslation, (setter)MouseWheelParameters_put_CharTranslation, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MouseWheelParameters[] = 
    {
        { Py_tp_new, _new_MouseWheelParameters },
        { Py_tp_dealloc, _dealloc_MouseWheelParameters },
        { Py_tp_methods, _methods_MouseWheelParameters },
        { Py_tp_getset, _getset_MouseWheelParameters },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MouseWheelParameters =
    {
        "_winrt_Windows_UI_Input.MouseWheelParameters",
        sizeof(py::wrapper::Windows::UI::Input::MouseWheelParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MouseWheelParameters
    };

    // ----- PointerPoint class --------------------
    constexpr const char* const _type_name_PointerPoint = "PointerPoint";

    static PyObject* _new_PointerPoint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PointerPoint);
        return nullptr;
    }

    static void _dealloc_PointerPoint(py::wrapper::Windows::UI::Input::PointerPoint* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PointerPoint_GetCurrentPoint(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::UI::Input::PointerPoint::GetCurrentPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Input::IPointerPointTransform>(args, 1);

                return py::convert(winrt::Windows::UI::Input::PointerPoint::GetCurrentPoint(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerPoint_GetIntermediatePoints(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::UI::Input::PointerPoint::GetIntermediatePoints(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Input::IPointerPointTransform>(args, 1);

                return py::convert(winrt::Windows::UI::Input::PointerPoint::GetIntermediatePoints(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_FrameId(py::wrapper::Windows::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_IsInContact(py::wrapper::Windows::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInContact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_PointerDevice(py::wrapper::Windows::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_PointerId(py::wrapper::Windows::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_Position(py::wrapper::Windows::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_Properties(py::wrapper::Windows::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_RawPosition(py::wrapper::Windows::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_Timestamp(py::wrapper::Windows::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PointerPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::PointerPoint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointerPoint[] = {
        { "get_current_point", (PyCFunction)PointerPoint_GetCurrentPoint, METH_VARARGS | METH_STATIC, nullptr },
        { "get_intermediate_points", (PyCFunction)PointerPoint_GetIntermediatePoints, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_PointerPoint, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PointerPoint[] = {
        { const_cast<char*>("frame_id"), (getter)PointerPoint_get_FrameId, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_in_contact"), (getter)PointerPoint_get_IsInContact, nullptr, nullptr, nullptr },
        { const_cast<char*>("pointer_device"), (getter)PointerPoint_get_PointerDevice, nullptr, nullptr, nullptr },
        { const_cast<char*>("pointer_id"), (getter)PointerPoint_get_PointerId, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)PointerPoint_get_Position, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)PointerPoint_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("raw_position"), (getter)PointerPoint_get_RawPosition, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)PointerPoint_get_Timestamp, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PointerPoint[] = 
    {
        { Py_tp_new, _new_PointerPoint },
        { Py_tp_dealloc, _dealloc_PointerPoint },
        { Py_tp_methods, _methods_PointerPoint },
        { Py_tp_getset, _getset_PointerPoint },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PointerPoint =
    {
        "_winrt_Windows_UI_Input.PointerPoint",
        sizeof(py::wrapper::Windows::UI::Input::PointerPoint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerPoint
    };

    // ----- PointerPointProperties class --------------------
    constexpr const char* const _type_name_PointerPointProperties = "PointerPointProperties";

    static PyObject* _new_PointerPointProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PointerPointProperties);
        return nullptr;
    }

    static void _dealloc_PointerPointProperties(py::wrapper::Windows::UI::Input::PointerPointProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PointerPointProperties_GetUsageValue(py::wrapper::Windows::UI::Input::PointerPointProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetUsageValue(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_HasUsage(py::wrapper::Windows::UI::Input::PointerPointProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.HasUsage(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_ContactRect(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_ContactRectRaw(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactRectRaw());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsBarrelButtonPressed(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBarrelButtonPressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsCanceled(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCanceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsEraser(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEraser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsHorizontalMouseWheel(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHorizontalMouseWheel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsInRange(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsInverted(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInverted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsLeftButtonPressed(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLeftButtonPressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsMiddleButtonPressed(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsMiddleButtonPressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsPrimary(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPrimary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsRightButtonPressed(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRightButtonPressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsXButton1Pressed(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsXButton1Pressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsXButton2Pressed(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsXButton2Pressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_MouseWheelDelta(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MouseWheelDelta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_Orientation(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_PointerUpdateKind(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerUpdateKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_Pressure(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_TouchConfidence(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TouchConfidence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_Twist(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Twist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_XTilt(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.XTilt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_YTilt(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.YTilt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_ZDistance(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZDistance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PointerPointProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::PointerPointProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointerPointProperties[] = {
        { "get_usage_value", (PyCFunction)PointerPointProperties_GetUsageValue, METH_VARARGS, nullptr },
        { "has_usage", (PyCFunction)PointerPointProperties_HasUsage, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PointerPointProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PointerPointProperties[] = {
        { const_cast<char*>("contact_rect"), (getter)PointerPointProperties_get_ContactRect, nullptr, nullptr, nullptr },
        { const_cast<char*>("contact_rect_raw"), (getter)PointerPointProperties_get_ContactRectRaw, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_barrel_button_pressed"), (getter)PointerPointProperties_get_IsBarrelButtonPressed, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_canceled"), (getter)PointerPointProperties_get_IsCanceled, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_eraser"), (getter)PointerPointProperties_get_IsEraser, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_horizontal_mouse_wheel"), (getter)PointerPointProperties_get_IsHorizontalMouseWheel, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_in_range"), (getter)PointerPointProperties_get_IsInRange, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_inverted"), (getter)PointerPointProperties_get_IsInverted, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_left_button_pressed"), (getter)PointerPointProperties_get_IsLeftButtonPressed, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_middle_button_pressed"), (getter)PointerPointProperties_get_IsMiddleButtonPressed, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_primary"), (getter)PointerPointProperties_get_IsPrimary, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_right_button_pressed"), (getter)PointerPointProperties_get_IsRightButtonPressed, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_x_button1_pressed"), (getter)PointerPointProperties_get_IsXButton1Pressed, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_x_button2_pressed"), (getter)PointerPointProperties_get_IsXButton2Pressed, nullptr, nullptr, nullptr },
        { const_cast<char*>("mouse_wheel_delta"), (getter)PointerPointProperties_get_MouseWheelDelta, nullptr, nullptr, nullptr },
        { const_cast<char*>("orientation"), (getter)PointerPointProperties_get_Orientation, nullptr, nullptr, nullptr },
        { const_cast<char*>("pointer_update_kind"), (getter)PointerPointProperties_get_PointerUpdateKind, nullptr, nullptr, nullptr },
        { const_cast<char*>("pressure"), (getter)PointerPointProperties_get_Pressure, nullptr, nullptr, nullptr },
        { const_cast<char*>("touch_confidence"), (getter)PointerPointProperties_get_TouchConfidence, nullptr, nullptr, nullptr },
        { const_cast<char*>("twist"), (getter)PointerPointProperties_get_Twist, nullptr, nullptr, nullptr },
        { const_cast<char*>("x_tilt"), (getter)PointerPointProperties_get_XTilt, nullptr, nullptr, nullptr },
        { const_cast<char*>("y_tilt"), (getter)PointerPointProperties_get_YTilt, nullptr, nullptr, nullptr },
        { const_cast<char*>("z_distance"), (getter)PointerPointProperties_get_ZDistance, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PointerPointProperties[] = 
    {
        { Py_tp_new, _new_PointerPointProperties },
        { Py_tp_dealloc, _dealloc_PointerPointProperties },
        { Py_tp_methods, _methods_PointerPointProperties },
        { Py_tp_getset, _getset_PointerPointProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PointerPointProperties =
    {
        "_winrt_Windows_UI_Input.PointerPointProperties",
        sizeof(py::wrapper::Windows::UI::Input::PointerPointProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerPointProperties
    };

    // ----- PointerVisualizationSettings class --------------------
    constexpr const char* const _type_name_PointerVisualizationSettings = "PointerVisualizationSettings";

    static PyObject* _new_PointerVisualizationSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PointerVisualizationSettings);
        return nullptr;
    }

    static void _dealloc_PointerVisualizationSettings(py::wrapper::Windows::UI::Input::PointerVisualizationSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PointerVisualizationSettings_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::Input::PointerVisualizationSettings::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerVisualizationSettings_get_IsContactFeedbackEnabled(py::wrapper::Windows::UI::Input::PointerVisualizationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsContactFeedbackEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerVisualizationSettings_put_IsContactFeedbackEnabled(py::wrapper::Windows::UI::Input::PointerVisualizationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsContactFeedbackEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerVisualizationSettings_get_IsBarrelButtonFeedbackEnabled(py::wrapper::Windows::UI::Input::PointerVisualizationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBarrelButtonFeedbackEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerVisualizationSettings_put_IsBarrelButtonFeedbackEnabled(py::wrapper::Windows::UI::Input::PointerVisualizationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsBarrelButtonFeedbackEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_PointerVisualizationSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::PointerVisualizationSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointerVisualizationSettings[] = {
        { "get_for_current_view", (PyCFunction)PointerVisualizationSettings_GetForCurrentView, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_PointerVisualizationSettings, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PointerVisualizationSettings[] = {
        { const_cast<char*>("is_contact_feedback_enabled"), (getter)PointerVisualizationSettings_get_IsContactFeedbackEnabled, (setter)PointerVisualizationSettings_put_IsContactFeedbackEnabled, nullptr, nullptr },
        { const_cast<char*>("is_barrel_button_feedback_enabled"), (getter)PointerVisualizationSettings_get_IsBarrelButtonFeedbackEnabled, (setter)PointerVisualizationSettings_put_IsBarrelButtonFeedbackEnabled, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PointerVisualizationSettings[] = 
    {
        { Py_tp_new, _new_PointerVisualizationSettings },
        { Py_tp_dealloc, _dealloc_PointerVisualizationSettings },
        { Py_tp_methods, _methods_PointerVisualizationSettings },
        { Py_tp_getset, _getset_PointerVisualizationSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PointerVisualizationSettings =
    {
        "_winrt_Windows_UI_Input.PointerVisualizationSettings",
        sizeof(py::wrapper::Windows::UI::Input::PointerVisualizationSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerVisualizationSettings
    };

    // ----- RadialController class --------------------
    constexpr const char* const _type_name_RadialController = "RadialController";

    static PyObject* _new_RadialController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RadialController);
        return nullptr;
    }

    static void _dealloc_RadialController(py::wrapper::Windows::UI::Input::RadialController* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RadialController_CreateForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::Input::RadialController::CreateForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialController_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::Input::RadialController::IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialController_get_UseAutomaticHapticFeedback(py::wrapper::Windows::UI::Input::RadialController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UseAutomaticHapticFeedback());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadialController_put_UseAutomaticHapticFeedback(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.UseAutomaticHapticFeedback(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadialController_get_RotationResolutionInDegrees(py::wrapper::Windows::UI::Input::RadialController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RotationResolutionInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadialController_put_RotationResolutionInDegrees(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RotationResolutionInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadialController_get_Menu(py::wrapper::Windows::UI::Input::RadialController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Menu());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_add_ButtonClicked(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialController, winrt::Windows::UI::Input::RadialControllerButtonClickedEventArgs>>(arg);

            return py::convert(self->obj.ButtonClicked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_remove_ButtonClicked(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ButtonClicked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_add_ControlAcquired(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialController, winrt::Windows::UI::Input::RadialControllerControlAcquiredEventArgs>>(arg);

            return py::convert(self->obj.ControlAcquired(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_remove_ControlAcquired(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ControlAcquired(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_add_ControlLost(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialController, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ControlLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_remove_ControlLost(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ControlLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_add_RotationChanged(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialController, winrt::Windows::UI::Input::RadialControllerRotationChangedEventArgs>>(arg);

            return py::convert(self->obj.RotationChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_remove_RotationChanged(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RotationChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_add_ScreenContactContinued(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialController, winrt::Windows::UI::Input::RadialControllerScreenContactContinuedEventArgs>>(arg);

            return py::convert(self->obj.ScreenContactContinued(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_remove_ScreenContactContinued(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ScreenContactContinued(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_add_ScreenContactEnded(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialController, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ScreenContactEnded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_remove_ScreenContactEnded(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ScreenContactEnded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_add_ScreenContactStarted(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialController, winrt::Windows::UI::Input::RadialControllerScreenContactStartedEventArgs>>(arg);

            return py::convert(self->obj.ScreenContactStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_remove_ScreenContactStarted(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ScreenContactStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_add_ButtonHolding(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialController, winrt::Windows::UI::Input::RadialControllerButtonHoldingEventArgs>>(arg);

            return py::convert(self->obj.ButtonHolding(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_remove_ButtonHolding(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ButtonHolding(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_add_ButtonPressed(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialController, winrt::Windows::UI::Input::RadialControllerButtonPressedEventArgs>>(arg);

            return py::convert(self->obj.ButtonPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_remove_ButtonPressed(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ButtonPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_add_ButtonReleased(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialController, winrt::Windows::UI::Input::RadialControllerButtonReleasedEventArgs>>(arg);

            return py::convert(self->obj.ButtonReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_remove_ButtonReleased(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ButtonReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RadialController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialController[] = {
        { "create_for_current_view", (PyCFunction)RadialController_CreateForCurrentView, METH_VARARGS | METH_STATIC, nullptr },
        { "is_supported", (PyCFunction)RadialController_IsSupported, METH_VARARGS | METH_STATIC, nullptr },
        { "add_button_clicked", (PyCFunction)RadialController_add_ButtonClicked, METH_O, nullptr },
        { "remove_button_clicked", (PyCFunction)RadialController_remove_ButtonClicked, METH_O, nullptr },
        { "add_control_acquired", (PyCFunction)RadialController_add_ControlAcquired, METH_O, nullptr },
        { "remove_control_acquired", (PyCFunction)RadialController_remove_ControlAcquired, METH_O, nullptr },
        { "add_control_lost", (PyCFunction)RadialController_add_ControlLost, METH_O, nullptr },
        { "remove_control_lost", (PyCFunction)RadialController_remove_ControlLost, METH_O, nullptr },
        { "add_rotation_changed", (PyCFunction)RadialController_add_RotationChanged, METH_O, nullptr },
        { "remove_rotation_changed", (PyCFunction)RadialController_remove_RotationChanged, METH_O, nullptr },
        { "add_screen_contact_continued", (PyCFunction)RadialController_add_ScreenContactContinued, METH_O, nullptr },
        { "remove_screen_contact_continued", (PyCFunction)RadialController_remove_ScreenContactContinued, METH_O, nullptr },
        { "add_screen_contact_ended", (PyCFunction)RadialController_add_ScreenContactEnded, METH_O, nullptr },
        { "remove_screen_contact_ended", (PyCFunction)RadialController_remove_ScreenContactEnded, METH_O, nullptr },
        { "add_screen_contact_started", (PyCFunction)RadialController_add_ScreenContactStarted, METH_O, nullptr },
        { "remove_screen_contact_started", (PyCFunction)RadialController_remove_ScreenContactStarted, METH_O, nullptr },
        { "add_button_holding", (PyCFunction)RadialController_add_ButtonHolding, METH_O, nullptr },
        { "remove_button_holding", (PyCFunction)RadialController_remove_ButtonHolding, METH_O, nullptr },
        { "add_button_pressed", (PyCFunction)RadialController_add_ButtonPressed, METH_O, nullptr },
        { "remove_button_pressed", (PyCFunction)RadialController_remove_ButtonPressed, METH_O, nullptr },
        { "add_button_released", (PyCFunction)RadialController_add_ButtonReleased, METH_O, nullptr },
        { "remove_button_released", (PyCFunction)RadialController_remove_ButtonReleased, METH_O, nullptr },
        { "_from", (PyCFunction)_from_RadialController, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RadialController[] = {
        { const_cast<char*>("use_automatic_haptic_feedback"), (getter)RadialController_get_UseAutomaticHapticFeedback, (setter)RadialController_put_UseAutomaticHapticFeedback, nullptr, nullptr },
        { const_cast<char*>("rotation_resolution_in_degrees"), (getter)RadialController_get_RotationResolutionInDegrees, (setter)RadialController_put_RotationResolutionInDegrees, nullptr, nullptr },
        { const_cast<char*>("menu"), (getter)RadialController_get_Menu, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RadialController[] = 
    {
        { Py_tp_new, _new_RadialController },
        { Py_tp_dealloc, _dealloc_RadialController },
        { Py_tp_methods, _methods_RadialController },
        { Py_tp_getset, _getset_RadialController },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RadialController =
    {
        "_winrt_Windows_UI_Input.RadialController",
        sizeof(py::wrapper::Windows::UI::Input::RadialController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialController
    };

    // ----- RadialControllerButtonClickedEventArgs class --------------------
    constexpr const char* const _type_name_RadialControllerButtonClickedEventArgs = "RadialControllerButtonClickedEventArgs";

    static PyObject* _new_RadialControllerButtonClickedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RadialControllerButtonClickedEventArgs);
        return nullptr;
    }

    static void _dealloc_RadialControllerButtonClickedEventArgs(py::wrapper::Windows::UI::Input::RadialControllerButtonClickedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RadialControllerButtonClickedEventArgs_get_Contact(py::wrapper::Windows::UI::Input::RadialControllerButtonClickedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerButtonClickedEventArgs_get_SimpleHapticsController(py::wrapper::Windows::UI::Input::RadialControllerButtonClickedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimpleHapticsController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RadialControllerButtonClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerButtonClickedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerButtonClickedEventArgs[] = {
        { "_from", (PyCFunction)_from_RadialControllerButtonClickedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RadialControllerButtonClickedEventArgs[] = {
        { const_cast<char*>("contact"), (getter)RadialControllerButtonClickedEventArgs_get_Contact, nullptr, nullptr, nullptr },
        { const_cast<char*>("simple_haptics_controller"), (getter)RadialControllerButtonClickedEventArgs_get_SimpleHapticsController, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RadialControllerButtonClickedEventArgs[] = 
    {
        { Py_tp_new, _new_RadialControllerButtonClickedEventArgs },
        { Py_tp_dealloc, _dealloc_RadialControllerButtonClickedEventArgs },
        { Py_tp_methods, _methods_RadialControllerButtonClickedEventArgs },
        { Py_tp_getset, _getset_RadialControllerButtonClickedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RadialControllerButtonClickedEventArgs =
    {
        "_winrt_Windows_UI_Input.RadialControllerButtonClickedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerButtonClickedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerButtonClickedEventArgs
    };

    // ----- RadialControllerButtonHoldingEventArgs class --------------------
    constexpr const char* const _type_name_RadialControllerButtonHoldingEventArgs = "RadialControllerButtonHoldingEventArgs";

    static PyObject* _new_RadialControllerButtonHoldingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RadialControllerButtonHoldingEventArgs);
        return nullptr;
    }

    static void _dealloc_RadialControllerButtonHoldingEventArgs(py::wrapper::Windows::UI::Input::RadialControllerButtonHoldingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RadialControllerButtonHoldingEventArgs_get_Contact(py::wrapper::Windows::UI::Input::RadialControllerButtonHoldingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerButtonHoldingEventArgs_get_SimpleHapticsController(py::wrapper::Windows::UI::Input::RadialControllerButtonHoldingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimpleHapticsController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RadialControllerButtonHoldingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerButtonHoldingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerButtonHoldingEventArgs[] = {
        { "_from", (PyCFunction)_from_RadialControllerButtonHoldingEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RadialControllerButtonHoldingEventArgs[] = {
        { const_cast<char*>("contact"), (getter)RadialControllerButtonHoldingEventArgs_get_Contact, nullptr, nullptr, nullptr },
        { const_cast<char*>("simple_haptics_controller"), (getter)RadialControllerButtonHoldingEventArgs_get_SimpleHapticsController, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RadialControllerButtonHoldingEventArgs[] = 
    {
        { Py_tp_new, _new_RadialControllerButtonHoldingEventArgs },
        { Py_tp_dealloc, _dealloc_RadialControllerButtonHoldingEventArgs },
        { Py_tp_methods, _methods_RadialControllerButtonHoldingEventArgs },
        { Py_tp_getset, _getset_RadialControllerButtonHoldingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RadialControllerButtonHoldingEventArgs =
    {
        "_winrt_Windows_UI_Input.RadialControllerButtonHoldingEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerButtonHoldingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerButtonHoldingEventArgs
    };

    // ----- RadialControllerButtonPressedEventArgs class --------------------
    constexpr const char* const _type_name_RadialControllerButtonPressedEventArgs = "RadialControllerButtonPressedEventArgs";

    static PyObject* _new_RadialControllerButtonPressedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RadialControllerButtonPressedEventArgs);
        return nullptr;
    }

    static void _dealloc_RadialControllerButtonPressedEventArgs(py::wrapper::Windows::UI::Input::RadialControllerButtonPressedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RadialControllerButtonPressedEventArgs_get_Contact(py::wrapper::Windows::UI::Input::RadialControllerButtonPressedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerButtonPressedEventArgs_get_SimpleHapticsController(py::wrapper::Windows::UI::Input::RadialControllerButtonPressedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimpleHapticsController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RadialControllerButtonPressedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerButtonPressedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerButtonPressedEventArgs[] = {
        { "_from", (PyCFunction)_from_RadialControllerButtonPressedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RadialControllerButtonPressedEventArgs[] = {
        { const_cast<char*>("contact"), (getter)RadialControllerButtonPressedEventArgs_get_Contact, nullptr, nullptr, nullptr },
        { const_cast<char*>("simple_haptics_controller"), (getter)RadialControllerButtonPressedEventArgs_get_SimpleHapticsController, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RadialControllerButtonPressedEventArgs[] = 
    {
        { Py_tp_new, _new_RadialControllerButtonPressedEventArgs },
        { Py_tp_dealloc, _dealloc_RadialControllerButtonPressedEventArgs },
        { Py_tp_methods, _methods_RadialControllerButtonPressedEventArgs },
        { Py_tp_getset, _getset_RadialControllerButtonPressedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RadialControllerButtonPressedEventArgs =
    {
        "_winrt_Windows_UI_Input.RadialControllerButtonPressedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerButtonPressedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerButtonPressedEventArgs
    };

    // ----- RadialControllerButtonReleasedEventArgs class --------------------
    constexpr const char* const _type_name_RadialControllerButtonReleasedEventArgs = "RadialControllerButtonReleasedEventArgs";

    static PyObject* _new_RadialControllerButtonReleasedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RadialControllerButtonReleasedEventArgs);
        return nullptr;
    }

    static void _dealloc_RadialControllerButtonReleasedEventArgs(py::wrapper::Windows::UI::Input::RadialControllerButtonReleasedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RadialControllerButtonReleasedEventArgs_get_Contact(py::wrapper::Windows::UI::Input::RadialControllerButtonReleasedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerButtonReleasedEventArgs_get_SimpleHapticsController(py::wrapper::Windows::UI::Input::RadialControllerButtonReleasedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimpleHapticsController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RadialControllerButtonReleasedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerButtonReleasedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerButtonReleasedEventArgs[] = {
        { "_from", (PyCFunction)_from_RadialControllerButtonReleasedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RadialControllerButtonReleasedEventArgs[] = {
        { const_cast<char*>("contact"), (getter)RadialControllerButtonReleasedEventArgs_get_Contact, nullptr, nullptr, nullptr },
        { const_cast<char*>("simple_haptics_controller"), (getter)RadialControllerButtonReleasedEventArgs_get_SimpleHapticsController, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RadialControllerButtonReleasedEventArgs[] = 
    {
        { Py_tp_new, _new_RadialControllerButtonReleasedEventArgs },
        { Py_tp_dealloc, _dealloc_RadialControllerButtonReleasedEventArgs },
        { Py_tp_methods, _methods_RadialControllerButtonReleasedEventArgs },
        { Py_tp_getset, _getset_RadialControllerButtonReleasedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RadialControllerButtonReleasedEventArgs =
    {
        "_winrt_Windows_UI_Input.RadialControllerButtonReleasedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerButtonReleasedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerButtonReleasedEventArgs
    };

    // ----- RadialControllerConfiguration class --------------------
    constexpr const char* const _type_name_RadialControllerConfiguration = "RadialControllerConfiguration";

    static PyObject* _new_RadialControllerConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RadialControllerConfiguration);
        return nullptr;
    }

    static void _dealloc_RadialControllerConfiguration(py::wrapper::Windows::UI::Input::RadialControllerConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RadialControllerConfiguration_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::Input::RadialControllerConfiguration::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialControllerConfiguration_ResetToDefaultMenuItems(py::wrapper::Windows::UI::Input::RadialControllerConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ResetToDefaultMenuItems();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialControllerConfiguration_SetDefaultMenuItems(py::wrapper::Windows::UI::Input::RadialControllerConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Input::RadialControllerSystemMenuItemKind>>(args, 0);

                self->obj.SetDefaultMenuItems(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialControllerConfiguration_TrySelectDefaultMenuItem(py::wrapper::Windows::UI::Input::RadialControllerConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::RadialControllerSystemMenuItemKind>(args, 0);

                return py::convert(self->obj.TrySelectDefaultMenuItem(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialControllerConfiguration_get_IsMenuSuppressed(py::wrapper::Windows::UI::Input::RadialControllerConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsMenuSuppressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadialControllerConfiguration_put_IsMenuSuppressed(py::wrapper::Windows::UI::Input::RadialControllerConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMenuSuppressed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadialControllerConfiguration_get_ActiveControllerWhenMenuIsSuppressed(py::wrapper::Windows::UI::Input::RadialControllerConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActiveControllerWhenMenuIsSuppressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadialControllerConfiguration_put_ActiveControllerWhenMenuIsSuppressed(py::wrapper::Windows::UI::Input::RadialControllerConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::RadialController>(arg);

            self->obj.ActiveControllerWhenMenuIsSuppressed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadialControllerConfiguration_get_IsAppControllerEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Input::RadialControllerConfiguration::IsAppControllerEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerConfiguration_put_IsAppControllerEnabled(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        try
        {
            auto param0 = py::convert_to<bool>(arg);

            winrt::Windows::UI::Input::RadialControllerConfiguration::IsAppControllerEnabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerConfiguration_get_AppController(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Input::RadialControllerConfiguration::AppController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerConfiguration_put_AppController(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::RadialController>(arg);

            winrt::Windows::UI::Input::RadialControllerConfiguration::AppController(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RadialControllerConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerConfiguration[] = {
        { "get_for_current_view", (PyCFunction)RadialControllerConfiguration_GetForCurrentView, METH_VARARGS | METH_STATIC, nullptr },
        { "reset_to_default_menu_items", (PyCFunction)RadialControllerConfiguration_ResetToDefaultMenuItems, METH_VARARGS, nullptr },
        { "set_default_menu_items", (PyCFunction)RadialControllerConfiguration_SetDefaultMenuItems, METH_VARARGS, nullptr },
        { "try_select_default_menu_item", (PyCFunction)RadialControllerConfiguration_TrySelectDefaultMenuItem, METH_VARARGS, nullptr },
        { "get_is_app_controller_enabled", (PyCFunction)RadialControllerConfiguration_get_IsAppControllerEnabled, METH_NOARGS | METH_STATIC, nullptr },
        { "put_is_app_controller_enabled", (PyCFunction)RadialControllerConfiguration_put_IsAppControllerEnabled, METH_O | METH_STATIC, nullptr },
        { "get_app_controller", (PyCFunction)RadialControllerConfiguration_get_AppController, METH_NOARGS | METH_STATIC, nullptr },
        { "put_app_controller", (PyCFunction)RadialControllerConfiguration_put_AppController, METH_O | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_RadialControllerConfiguration, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RadialControllerConfiguration[] = {
        { const_cast<char*>("is_menu_suppressed"), (getter)RadialControllerConfiguration_get_IsMenuSuppressed, (setter)RadialControllerConfiguration_put_IsMenuSuppressed, nullptr, nullptr },
        { const_cast<char*>("active_controller_when_menu_is_suppressed"), (getter)RadialControllerConfiguration_get_ActiveControllerWhenMenuIsSuppressed, (setter)RadialControllerConfiguration_put_ActiveControllerWhenMenuIsSuppressed, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RadialControllerConfiguration[] = 
    {
        { Py_tp_new, _new_RadialControllerConfiguration },
        { Py_tp_dealloc, _dealloc_RadialControllerConfiguration },
        { Py_tp_methods, _methods_RadialControllerConfiguration },
        { Py_tp_getset, _getset_RadialControllerConfiguration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RadialControllerConfiguration =
    {
        "_winrt_Windows_UI_Input.RadialControllerConfiguration",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerConfiguration
    };

    // ----- RadialControllerControlAcquiredEventArgs class --------------------
    constexpr const char* const _type_name_RadialControllerControlAcquiredEventArgs = "RadialControllerControlAcquiredEventArgs";

    static PyObject* _new_RadialControllerControlAcquiredEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RadialControllerControlAcquiredEventArgs);
        return nullptr;
    }

    static void _dealloc_RadialControllerControlAcquiredEventArgs(py::wrapper::Windows::UI::Input::RadialControllerControlAcquiredEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RadialControllerControlAcquiredEventArgs_get_Contact(py::wrapper::Windows::UI::Input::RadialControllerControlAcquiredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerControlAcquiredEventArgs_get_IsButtonPressed(py::wrapper::Windows::UI::Input::RadialControllerControlAcquiredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsButtonPressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerControlAcquiredEventArgs_get_SimpleHapticsController(py::wrapper::Windows::UI::Input::RadialControllerControlAcquiredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimpleHapticsController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RadialControllerControlAcquiredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerControlAcquiredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerControlAcquiredEventArgs[] = {
        { "_from", (PyCFunction)_from_RadialControllerControlAcquiredEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RadialControllerControlAcquiredEventArgs[] = {
        { const_cast<char*>("contact"), (getter)RadialControllerControlAcquiredEventArgs_get_Contact, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_button_pressed"), (getter)RadialControllerControlAcquiredEventArgs_get_IsButtonPressed, nullptr, nullptr, nullptr },
        { const_cast<char*>("simple_haptics_controller"), (getter)RadialControllerControlAcquiredEventArgs_get_SimpleHapticsController, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RadialControllerControlAcquiredEventArgs[] = 
    {
        { Py_tp_new, _new_RadialControllerControlAcquiredEventArgs },
        { Py_tp_dealloc, _dealloc_RadialControllerControlAcquiredEventArgs },
        { Py_tp_methods, _methods_RadialControllerControlAcquiredEventArgs },
        { Py_tp_getset, _getset_RadialControllerControlAcquiredEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RadialControllerControlAcquiredEventArgs =
    {
        "_winrt_Windows_UI_Input.RadialControllerControlAcquiredEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerControlAcquiredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerControlAcquiredEventArgs
    };

    // ----- RadialControllerMenu class --------------------
    constexpr const char* const _type_name_RadialControllerMenu = "RadialControllerMenu";

    static PyObject* _new_RadialControllerMenu(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RadialControllerMenu);
        return nullptr;
    }

    static void _dealloc_RadialControllerMenu(py::wrapper::Windows::UI::Input::RadialControllerMenu* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RadialControllerMenu_GetSelectedMenuItem(py::wrapper::Windows::UI::Input::RadialControllerMenu* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSelectedMenuItem());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialControllerMenu_SelectMenuItem(py::wrapper::Windows::UI::Input::RadialControllerMenu* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::RadialControllerMenuItem>(args, 0);

                self->obj.SelectMenuItem(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialControllerMenu_TrySelectPreviouslySelectedMenuItem(py::wrapper::Windows::UI::Input::RadialControllerMenu* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TrySelectPreviouslySelectedMenuItem());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialControllerMenu_get_IsEnabled(py::wrapper::Windows::UI::Input::RadialControllerMenu* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadialControllerMenu_put_IsEnabled(py::wrapper::Windows::UI::Input::RadialControllerMenu* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadialControllerMenu_get_Items(py::wrapper::Windows::UI::Input::RadialControllerMenu* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RadialControllerMenu(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerMenu>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerMenu[] = {
        { "get_selected_menu_item", (PyCFunction)RadialControllerMenu_GetSelectedMenuItem, METH_VARARGS, nullptr },
        { "select_menu_item", (PyCFunction)RadialControllerMenu_SelectMenuItem, METH_VARARGS, nullptr },
        { "try_select_previously_selected_menu_item", (PyCFunction)RadialControllerMenu_TrySelectPreviouslySelectedMenuItem, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_RadialControllerMenu, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RadialControllerMenu[] = {
        { const_cast<char*>("is_enabled"), (getter)RadialControllerMenu_get_IsEnabled, (setter)RadialControllerMenu_put_IsEnabled, nullptr, nullptr },
        { const_cast<char*>("items"), (getter)RadialControllerMenu_get_Items, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RadialControllerMenu[] = 
    {
        { Py_tp_new, _new_RadialControllerMenu },
        { Py_tp_dealloc, _dealloc_RadialControllerMenu },
        { Py_tp_methods, _methods_RadialControllerMenu },
        { Py_tp_getset, _getset_RadialControllerMenu },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RadialControllerMenu =
    {
        "_winrt_Windows_UI_Input.RadialControllerMenu",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerMenu),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerMenu
    };

    // ----- RadialControllerMenuItem class --------------------
    constexpr const char* const _type_name_RadialControllerMenuItem = "RadialControllerMenuItem";

    static PyObject* _new_RadialControllerMenuItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RadialControllerMenuItem);
        return nullptr;
    }

    static void _dealloc_RadialControllerMenuItem(py::wrapper::Windows::UI::Input::RadialControllerMenuItem* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RadialControllerMenuItem_CreateFromFontGlyph(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::UI::Input::RadialControllerMenuItem::CreateFromFontGlyph(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);

                return py::convert(winrt::Windows::UI::Input::RadialControllerMenuItem::CreateFromFontGlyph(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialControllerMenuItem_CreateFromIcon(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::RandomAccessStreamReference>(args, 1);

                return py::convert(winrt::Windows::UI::Input::RadialControllerMenuItem::CreateFromIcon(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialControllerMenuItem_CreateFromKnownIcon(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Input::RadialControllerMenuKnownIcon>(args, 1);

                return py::convert(winrt::Windows::UI::Input::RadialControllerMenuItem::CreateFromKnownIcon(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialControllerMenuItem_get_Tag(py::wrapper::Windows::UI::Input::RadialControllerMenuItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadialControllerMenuItem_put_Tag(py::wrapper::Windows::UI::Input::RadialControllerMenuItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadialControllerMenuItem_get_DisplayText(py::wrapper::Windows::UI::Input::RadialControllerMenuItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerMenuItem_add_Invoked(py::wrapper::Windows::UI::Input::RadialControllerMenuItem* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialControllerMenuItem, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Invoked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerMenuItem_remove_Invoked(py::wrapper::Windows::UI::Input::RadialControllerMenuItem* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Invoked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RadialControllerMenuItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerMenuItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerMenuItem[] = {
        { "create_from_font_glyph", (PyCFunction)RadialControllerMenuItem_CreateFromFontGlyph, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_icon", (PyCFunction)RadialControllerMenuItem_CreateFromIcon, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_known_icon", (PyCFunction)RadialControllerMenuItem_CreateFromKnownIcon, METH_VARARGS | METH_STATIC, nullptr },
        { "add_invoked", (PyCFunction)RadialControllerMenuItem_add_Invoked, METH_O, nullptr },
        { "remove_invoked", (PyCFunction)RadialControllerMenuItem_remove_Invoked, METH_O, nullptr },
        { "_from", (PyCFunction)_from_RadialControllerMenuItem, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RadialControllerMenuItem[] = {
        { const_cast<char*>("tag"), (getter)RadialControllerMenuItem_get_Tag, (setter)RadialControllerMenuItem_put_Tag, nullptr, nullptr },
        { const_cast<char*>("display_text"), (getter)RadialControllerMenuItem_get_DisplayText, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RadialControllerMenuItem[] = 
    {
        { Py_tp_new, _new_RadialControllerMenuItem },
        { Py_tp_dealloc, _dealloc_RadialControllerMenuItem },
        { Py_tp_methods, _methods_RadialControllerMenuItem },
        { Py_tp_getset, _getset_RadialControllerMenuItem },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RadialControllerMenuItem =
    {
        "_winrt_Windows_UI_Input.RadialControllerMenuItem",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerMenuItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerMenuItem
    };

    // ----- RadialControllerRotationChangedEventArgs class --------------------
    constexpr const char* const _type_name_RadialControllerRotationChangedEventArgs = "RadialControllerRotationChangedEventArgs";

    static PyObject* _new_RadialControllerRotationChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RadialControllerRotationChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_RadialControllerRotationChangedEventArgs(py::wrapper::Windows::UI::Input::RadialControllerRotationChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RadialControllerRotationChangedEventArgs_get_Contact(py::wrapper::Windows::UI::Input::RadialControllerRotationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerRotationChangedEventArgs_get_RotationDeltaInDegrees(py::wrapper::Windows::UI::Input::RadialControllerRotationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RotationDeltaInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerRotationChangedEventArgs_get_IsButtonPressed(py::wrapper::Windows::UI::Input::RadialControllerRotationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsButtonPressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerRotationChangedEventArgs_get_SimpleHapticsController(py::wrapper::Windows::UI::Input::RadialControllerRotationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimpleHapticsController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RadialControllerRotationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerRotationChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerRotationChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_RadialControllerRotationChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RadialControllerRotationChangedEventArgs[] = {
        { const_cast<char*>("contact"), (getter)RadialControllerRotationChangedEventArgs_get_Contact, nullptr, nullptr, nullptr },
        { const_cast<char*>("rotation_delta_in_degrees"), (getter)RadialControllerRotationChangedEventArgs_get_RotationDeltaInDegrees, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_button_pressed"), (getter)RadialControllerRotationChangedEventArgs_get_IsButtonPressed, nullptr, nullptr, nullptr },
        { const_cast<char*>("simple_haptics_controller"), (getter)RadialControllerRotationChangedEventArgs_get_SimpleHapticsController, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RadialControllerRotationChangedEventArgs[] = 
    {
        { Py_tp_new, _new_RadialControllerRotationChangedEventArgs },
        { Py_tp_dealloc, _dealloc_RadialControllerRotationChangedEventArgs },
        { Py_tp_methods, _methods_RadialControllerRotationChangedEventArgs },
        { Py_tp_getset, _getset_RadialControllerRotationChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RadialControllerRotationChangedEventArgs =
    {
        "_winrt_Windows_UI_Input.RadialControllerRotationChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerRotationChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerRotationChangedEventArgs
    };

    // ----- RadialControllerScreenContact class --------------------
    constexpr const char* const _type_name_RadialControllerScreenContact = "RadialControllerScreenContact";

    static PyObject* _new_RadialControllerScreenContact(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RadialControllerScreenContact);
        return nullptr;
    }

    static void _dealloc_RadialControllerScreenContact(py::wrapper::Windows::UI::Input::RadialControllerScreenContact* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RadialControllerScreenContact_get_Bounds(py::wrapper::Windows::UI::Input::RadialControllerScreenContact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerScreenContact_get_Position(py::wrapper::Windows::UI::Input::RadialControllerScreenContact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RadialControllerScreenContact(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerScreenContact>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerScreenContact[] = {
        { "_from", (PyCFunction)_from_RadialControllerScreenContact, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RadialControllerScreenContact[] = {
        { const_cast<char*>("bounds"), (getter)RadialControllerScreenContact_get_Bounds, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)RadialControllerScreenContact_get_Position, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RadialControllerScreenContact[] = 
    {
        { Py_tp_new, _new_RadialControllerScreenContact },
        { Py_tp_dealloc, _dealloc_RadialControllerScreenContact },
        { Py_tp_methods, _methods_RadialControllerScreenContact },
        { Py_tp_getset, _getset_RadialControllerScreenContact },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RadialControllerScreenContact =
    {
        "_winrt_Windows_UI_Input.RadialControllerScreenContact",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerScreenContact),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerScreenContact
    };

    // ----- RadialControllerScreenContactContinuedEventArgs class --------------------
    constexpr const char* const _type_name_RadialControllerScreenContactContinuedEventArgs = "RadialControllerScreenContactContinuedEventArgs";

    static PyObject* _new_RadialControllerScreenContactContinuedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RadialControllerScreenContactContinuedEventArgs);
        return nullptr;
    }

    static void _dealloc_RadialControllerScreenContactContinuedEventArgs(py::wrapper::Windows::UI::Input::RadialControllerScreenContactContinuedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RadialControllerScreenContactContinuedEventArgs_get_Contact(py::wrapper::Windows::UI::Input::RadialControllerScreenContactContinuedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerScreenContactContinuedEventArgs_get_IsButtonPressed(py::wrapper::Windows::UI::Input::RadialControllerScreenContactContinuedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsButtonPressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerScreenContactContinuedEventArgs_get_SimpleHapticsController(py::wrapper::Windows::UI::Input::RadialControllerScreenContactContinuedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimpleHapticsController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RadialControllerScreenContactContinuedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerScreenContactContinuedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerScreenContactContinuedEventArgs[] = {
        { "_from", (PyCFunction)_from_RadialControllerScreenContactContinuedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RadialControllerScreenContactContinuedEventArgs[] = {
        { const_cast<char*>("contact"), (getter)RadialControllerScreenContactContinuedEventArgs_get_Contact, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_button_pressed"), (getter)RadialControllerScreenContactContinuedEventArgs_get_IsButtonPressed, nullptr, nullptr, nullptr },
        { const_cast<char*>("simple_haptics_controller"), (getter)RadialControllerScreenContactContinuedEventArgs_get_SimpleHapticsController, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RadialControllerScreenContactContinuedEventArgs[] = 
    {
        { Py_tp_new, _new_RadialControllerScreenContactContinuedEventArgs },
        { Py_tp_dealloc, _dealloc_RadialControllerScreenContactContinuedEventArgs },
        { Py_tp_methods, _methods_RadialControllerScreenContactContinuedEventArgs },
        { Py_tp_getset, _getset_RadialControllerScreenContactContinuedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RadialControllerScreenContactContinuedEventArgs =
    {
        "_winrt_Windows_UI_Input.RadialControllerScreenContactContinuedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerScreenContactContinuedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerScreenContactContinuedEventArgs
    };

    // ----- RadialControllerScreenContactEndedEventArgs class --------------------
    constexpr const char* const _type_name_RadialControllerScreenContactEndedEventArgs = "RadialControllerScreenContactEndedEventArgs";

    static PyObject* _new_RadialControllerScreenContactEndedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RadialControllerScreenContactEndedEventArgs);
        return nullptr;
    }

    static void _dealloc_RadialControllerScreenContactEndedEventArgs(py::wrapper::Windows::UI::Input::RadialControllerScreenContactEndedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RadialControllerScreenContactEndedEventArgs_get_IsButtonPressed(py::wrapper::Windows::UI::Input::RadialControllerScreenContactEndedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsButtonPressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerScreenContactEndedEventArgs_get_SimpleHapticsController(py::wrapper::Windows::UI::Input::RadialControllerScreenContactEndedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimpleHapticsController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RadialControllerScreenContactEndedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerScreenContactEndedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerScreenContactEndedEventArgs[] = {
        { "_from", (PyCFunction)_from_RadialControllerScreenContactEndedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RadialControllerScreenContactEndedEventArgs[] = {
        { const_cast<char*>("is_button_pressed"), (getter)RadialControllerScreenContactEndedEventArgs_get_IsButtonPressed, nullptr, nullptr, nullptr },
        { const_cast<char*>("simple_haptics_controller"), (getter)RadialControllerScreenContactEndedEventArgs_get_SimpleHapticsController, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RadialControllerScreenContactEndedEventArgs[] = 
    {
        { Py_tp_new, _new_RadialControllerScreenContactEndedEventArgs },
        { Py_tp_dealloc, _dealloc_RadialControllerScreenContactEndedEventArgs },
        { Py_tp_methods, _methods_RadialControllerScreenContactEndedEventArgs },
        { Py_tp_getset, _getset_RadialControllerScreenContactEndedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RadialControllerScreenContactEndedEventArgs =
    {
        "_winrt_Windows_UI_Input.RadialControllerScreenContactEndedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerScreenContactEndedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerScreenContactEndedEventArgs
    };

    // ----- RadialControllerScreenContactStartedEventArgs class --------------------
    constexpr const char* const _type_name_RadialControllerScreenContactStartedEventArgs = "RadialControllerScreenContactStartedEventArgs";

    static PyObject* _new_RadialControllerScreenContactStartedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RadialControllerScreenContactStartedEventArgs);
        return nullptr;
    }

    static void _dealloc_RadialControllerScreenContactStartedEventArgs(py::wrapper::Windows::UI::Input::RadialControllerScreenContactStartedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RadialControllerScreenContactStartedEventArgs_get_Contact(py::wrapper::Windows::UI::Input::RadialControllerScreenContactStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerScreenContactStartedEventArgs_get_IsButtonPressed(py::wrapper::Windows::UI::Input::RadialControllerScreenContactStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsButtonPressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerScreenContactStartedEventArgs_get_SimpleHapticsController(py::wrapper::Windows::UI::Input::RadialControllerScreenContactStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimpleHapticsController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RadialControllerScreenContactStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerScreenContactStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerScreenContactStartedEventArgs[] = {
        { "_from", (PyCFunction)_from_RadialControllerScreenContactStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RadialControllerScreenContactStartedEventArgs[] = {
        { const_cast<char*>("contact"), (getter)RadialControllerScreenContactStartedEventArgs_get_Contact, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_button_pressed"), (getter)RadialControllerScreenContactStartedEventArgs_get_IsButtonPressed, nullptr, nullptr, nullptr },
        { const_cast<char*>("simple_haptics_controller"), (getter)RadialControllerScreenContactStartedEventArgs_get_SimpleHapticsController, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RadialControllerScreenContactStartedEventArgs[] = 
    {
        { Py_tp_new, _new_RadialControllerScreenContactStartedEventArgs },
        { Py_tp_dealloc, _dealloc_RadialControllerScreenContactStartedEventArgs },
        { Py_tp_methods, _methods_RadialControllerScreenContactStartedEventArgs },
        { Py_tp_getset, _getset_RadialControllerScreenContactStartedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RadialControllerScreenContactStartedEventArgs =
    {
        "_winrt_Windows_UI_Input.RadialControllerScreenContactStartedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerScreenContactStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerScreenContactStartedEventArgs
    };

    // ----- RightTappedEventArgs class --------------------
    constexpr const char* const _type_name_RightTappedEventArgs = "RightTappedEventArgs";

    static PyObject* _new_RightTappedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RightTappedEventArgs);
        return nullptr;
    }

    static void _dealloc_RightTappedEventArgs(py::wrapper::Windows::UI::Input::RightTappedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RightTappedEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Input::RightTappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RightTappedEventArgs_get_Position(py::wrapper::Windows::UI::Input::RightTappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RightTappedEventArgs_get_ContactCount(py::wrapper::Windows::UI::Input::RightTappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RightTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RightTappedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RightTappedEventArgs[] = {
        { "_from", (PyCFunction)_from_RightTappedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RightTappedEventArgs[] = {
        { const_cast<char*>("pointer_device_type"), (getter)RightTappedEventArgs_get_PointerDeviceType, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)RightTappedEventArgs_get_Position, nullptr, nullptr, nullptr },
        { const_cast<char*>("contact_count"), (getter)RightTappedEventArgs_get_ContactCount, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RightTappedEventArgs[] = 
    {
        { Py_tp_new, _new_RightTappedEventArgs },
        { Py_tp_dealloc, _dealloc_RightTappedEventArgs },
        { Py_tp_methods, _methods_RightTappedEventArgs },
        { Py_tp_getset, _getset_RightTappedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RightTappedEventArgs =
    {
        "_winrt_Windows_UI_Input.RightTappedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::RightTappedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RightTappedEventArgs
    };

    // ----- SystemButtonEventController class --------------------
    constexpr const char* const _type_name_SystemButtonEventController = "SystemButtonEventController";

    static PyObject* _new_SystemButtonEventController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemButtonEventController);
        return nullptr;
    }

    static void _dealloc_SystemButtonEventController(py::wrapper::Windows::UI::Input::SystemButtonEventController* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemButtonEventController_CreateForDispatcherQueue(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::DispatcherQueue>(args, 0);

                return py::convert(winrt::Windows::UI::Input::SystemButtonEventController::CreateForDispatcherQueue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemButtonEventController_add_SystemFunctionButtonPressed(py::wrapper::Windows::UI::Input::SystemButtonEventController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::SystemButtonEventController, winrt::Windows::UI::Input::SystemFunctionButtonEventArgs>>(arg);

            return py::convert(self->obj.SystemFunctionButtonPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemButtonEventController_remove_SystemFunctionButtonPressed(py::wrapper::Windows::UI::Input::SystemButtonEventController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SystemFunctionButtonPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemButtonEventController_add_SystemFunctionButtonReleased(py::wrapper::Windows::UI::Input::SystemButtonEventController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::SystemButtonEventController, winrt::Windows::UI::Input::SystemFunctionButtonEventArgs>>(arg);

            return py::convert(self->obj.SystemFunctionButtonReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemButtonEventController_remove_SystemFunctionButtonReleased(py::wrapper::Windows::UI::Input::SystemButtonEventController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SystemFunctionButtonReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemButtonEventController_add_SystemFunctionLockChanged(py::wrapper::Windows::UI::Input::SystemButtonEventController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::SystemButtonEventController, winrt::Windows::UI::Input::SystemFunctionLockChangedEventArgs>>(arg);

            return py::convert(self->obj.SystemFunctionLockChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemButtonEventController_remove_SystemFunctionLockChanged(py::wrapper::Windows::UI::Input::SystemButtonEventController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SystemFunctionLockChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemButtonEventController_add_SystemFunctionLockIndicatorChanged(py::wrapper::Windows::UI::Input::SystemButtonEventController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::SystemButtonEventController, winrt::Windows::UI::Input::SystemFunctionLockIndicatorChangedEventArgs>>(arg);

            return py::convert(self->obj.SystemFunctionLockIndicatorChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemButtonEventController_remove_SystemFunctionLockIndicatorChanged(py::wrapper::Windows::UI::Input::SystemButtonEventController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SystemFunctionLockIndicatorChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemButtonEventController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::SystemButtonEventController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemButtonEventController[] = {
        { "create_for_dispatcher_queue", (PyCFunction)SystemButtonEventController_CreateForDispatcherQueue, METH_VARARGS | METH_STATIC, nullptr },
        { "add_system_function_button_pressed", (PyCFunction)SystemButtonEventController_add_SystemFunctionButtonPressed, METH_O, nullptr },
        { "remove_system_function_button_pressed", (PyCFunction)SystemButtonEventController_remove_SystemFunctionButtonPressed, METH_O, nullptr },
        { "add_system_function_button_released", (PyCFunction)SystemButtonEventController_add_SystemFunctionButtonReleased, METH_O, nullptr },
        { "remove_system_function_button_released", (PyCFunction)SystemButtonEventController_remove_SystemFunctionButtonReleased, METH_O, nullptr },
        { "add_system_function_lock_changed", (PyCFunction)SystemButtonEventController_add_SystemFunctionLockChanged, METH_O, nullptr },
        { "remove_system_function_lock_changed", (PyCFunction)SystemButtonEventController_remove_SystemFunctionLockChanged, METH_O, nullptr },
        { "add_system_function_lock_indicator_changed", (PyCFunction)SystemButtonEventController_add_SystemFunctionLockIndicatorChanged, METH_O, nullptr },
        { "remove_system_function_lock_indicator_changed", (PyCFunction)SystemButtonEventController_remove_SystemFunctionLockIndicatorChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_SystemButtonEventController, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemButtonEventController[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemButtonEventController[] = 
    {
        { Py_tp_new, _new_SystemButtonEventController },
        { Py_tp_dealloc, _dealloc_SystemButtonEventController },
        { Py_tp_methods, _methods_SystemButtonEventController },
        { Py_tp_getset, _getset_SystemButtonEventController },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemButtonEventController =
    {
        "_winrt_Windows_UI_Input.SystemButtonEventController",
        sizeof(py::wrapper::Windows::UI::Input::SystemButtonEventController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemButtonEventController
    };

    // ----- SystemFunctionButtonEventArgs class --------------------
    constexpr const char* const _type_name_SystemFunctionButtonEventArgs = "SystemFunctionButtonEventArgs";

    static PyObject* _new_SystemFunctionButtonEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemFunctionButtonEventArgs);
        return nullptr;
    }

    static void _dealloc_SystemFunctionButtonEventArgs(py::wrapper::Windows::UI::Input::SystemFunctionButtonEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemFunctionButtonEventArgs_get_Handled(py::wrapper::Windows::UI::Input::SystemFunctionButtonEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemFunctionButtonEventArgs_put_Handled(py::wrapper::Windows::UI::Input::SystemFunctionButtonEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemFunctionButtonEventArgs_get_Timestamp(py::wrapper::Windows::UI::Input::SystemFunctionButtonEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemFunctionButtonEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::SystemFunctionButtonEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemFunctionButtonEventArgs[] = {
        { "_from", (PyCFunction)_from_SystemFunctionButtonEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemFunctionButtonEventArgs[] = {
        { const_cast<char*>("handled"), (getter)SystemFunctionButtonEventArgs_get_Handled, (setter)SystemFunctionButtonEventArgs_put_Handled, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)SystemFunctionButtonEventArgs_get_Timestamp, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemFunctionButtonEventArgs[] = 
    {
        { Py_tp_new, _new_SystemFunctionButtonEventArgs },
        { Py_tp_dealloc, _dealloc_SystemFunctionButtonEventArgs },
        { Py_tp_methods, _methods_SystemFunctionButtonEventArgs },
        { Py_tp_getset, _getset_SystemFunctionButtonEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemFunctionButtonEventArgs =
    {
        "_winrt_Windows_UI_Input.SystemFunctionButtonEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::SystemFunctionButtonEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemFunctionButtonEventArgs
    };

    // ----- SystemFunctionLockChangedEventArgs class --------------------
    constexpr const char* const _type_name_SystemFunctionLockChangedEventArgs = "SystemFunctionLockChangedEventArgs";

    static PyObject* _new_SystemFunctionLockChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemFunctionLockChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_SystemFunctionLockChangedEventArgs(py::wrapper::Windows::UI::Input::SystemFunctionLockChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemFunctionLockChangedEventArgs_get_Handled(py::wrapper::Windows::UI::Input::SystemFunctionLockChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemFunctionLockChangedEventArgs_put_Handled(py::wrapper::Windows::UI::Input::SystemFunctionLockChangedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemFunctionLockChangedEventArgs_get_IsLocked(py::wrapper::Windows::UI::Input::SystemFunctionLockChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLocked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemFunctionLockChangedEventArgs_get_Timestamp(py::wrapper::Windows::UI::Input::SystemFunctionLockChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemFunctionLockChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::SystemFunctionLockChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemFunctionLockChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_SystemFunctionLockChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemFunctionLockChangedEventArgs[] = {
        { const_cast<char*>("handled"), (getter)SystemFunctionLockChangedEventArgs_get_Handled, (setter)SystemFunctionLockChangedEventArgs_put_Handled, nullptr, nullptr },
        { const_cast<char*>("is_locked"), (getter)SystemFunctionLockChangedEventArgs_get_IsLocked, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)SystemFunctionLockChangedEventArgs_get_Timestamp, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemFunctionLockChangedEventArgs[] = 
    {
        { Py_tp_new, _new_SystemFunctionLockChangedEventArgs },
        { Py_tp_dealloc, _dealloc_SystemFunctionLockChangedEventArgs },
        { Py_tp_methods, _methods_SystemFunctionLockChangedEventArgs },
        { Py_tp_getset, _getset_SystemFunctionLockChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemFunctionLockChangedEventArgs =
    {
        "_winrt_Windows_UI_Input.SystemFunctionLockChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::SystemFunctionLockChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemFunctionLockChangedEventArgs
    };

    // ----- SystemFunctionLockIndicatorChangedEventArgs class --------------------
    constexpr const char* const _type_name_SystemFunctionLockIndicatorChangedEventArgs = "SystemFunctionLockIndicatorChangedEventArgs";

    static PyObject* _new_SystemFunctionLockIndicatorChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemFunctionLockIndicatorChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_SystemFunctionLockIndicatorChangedEventArgs(py::wrapper::Windows::UI::Input::SystemFunctionLockIndicatorChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemFunctionLockIndicatorChangedEventArgs_get_Handled(py::wrapper::Windows::UI::Input::SystemFunctionLockIndicatorChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemFunctionLockIndicatorChangedEventArgs_put_Handled(py::wrapper::Windows::UI::Input::SystemFunctionLockIndicatorChangedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemFunctionLockIndicatorChangedEventArgs_get_IsIndicatorOn(py::wrapper::Windows::UI::Input::SystemFunctionLockIndicatorChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsIndicatorOn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemFunctionLockIndicatorChangedEventArgs_get_Timestamp(py::wrapper::Windows::UI::Input::SystemFunctionLockIndicatorChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemFunctionLockIndicatorChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::SystemFunctionLockIndicatorChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemFunctionLockIndicatorChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_SystemFunctionLockIndicatorChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemFunctionLockIndicatorChangedEventArgs[] = {
        { const_cast<char*>("handled"), (getter)SystemFunctionLockIndicatorChangedEventArgs_get_Handled, (setter)SystemFunctionLockIndicatorChangedEventArgs_put_Handled, nullptr, nullptr },
        { const_cast<char*>("is_indicator_on"), (getter)SystemFunctionLockIndicatorChangedEventArgs_get_IsIndicatorOn, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)SystemFunctionLockIndicatorChangedEventArgs_get_Timestamp, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemFunctionLockIndicatorChangedEventArgs[] = 
    {
        { Py_tp_new, _new_SystemFunctionLockIndicatorChangedEventArgs },
        { Py_tp_dealloc, _dealloc_SystemFunctionLockIndicatorChangedEventArgs },
        { Py_tp_methods, _methods_SystemFunctionLockIndicatorChangedEventArgs },
        { Py_tp_getset, _getset_SystemFunctionLockIndicatorChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemFunctionLockIndicatorChangedEventArgs =
    {
        "_winrt_Windows_UI_Input.SystemFunctionLockIndicatorChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::SystemFunctionLockIndicatorChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemFunctionLockIndicatorChangedEventArgs
    };

    // ----- TappedEventArgs class --------------------
    constexpr const char* const _type_name_TappedEventArgs = "TappedEventArgs";

    static PyObject* _new_TappedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TappedEventArgs);
        return nullptr;
    }

    static void _dealloc_TappedEventArgs(py::wrapper::Windows::UI::Input::TappedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TappedEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Input::TappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TappedEventArgs_get_Position(py::wrapper::Windows::UI::Input::TappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TappedEventArgs_get_TapCount(py::wrapper::Windows::UI::Input::TappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TapCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TappedEventArgs_get_ContactCount(py::wrapper::Windows::UI::Input::TappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::TappedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TappedEventArgs[] = {
        { "_from", (PyCFunction)_from_TappedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TappedEventArgs[] = {
        { const_cast<char*>("pointer_device_type"), (getter)TappedEventArgs_get_PointerDeviceType, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)TappedEventArgs_get_Position, nullptr, nullptr, nullptr },
        { const_cast<char*>("tap_count"), (getter)TappedEventArgs_get_TapCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("contact_count"), (getter)TappedEventArgs_get_ContactCount, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TappedEventArgs[] = 
    {
        { Py_tp_new, _new_TappedEventArgs },
        { Py_tp_dealloc, _dealloc_TappedEventArgs },
        { Py_tp_methods, _methods_TappedEventArgs },
        { Py_tp_getset, _getset_TappedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TappedEventArgs =
    {
        "_winrt_Windows_UI_Input.TappedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::TappedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TappedEventArgs
    };

    // ----- IPointerPointTransform interface --------------------
    constexpr const char* const _type_name_IPointerPointTransform = "IPointerPointTransform";

    static PyObject* _new_IPointerPointTransform(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IPointerPointTransform);
        return nullptr;
    }

    static void _dealloc_IPointerPointTransform(py::wrapper::Windows::UI::Input::IPointerPointTransform* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IPointerPointTransform_TransformBounds(py::wrapper::Windows::UI::Input::IPointerPointTransform* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert(self->obj.TransformBounds(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPointerPointTransform_TryTransform(py::wrapper::Windows::UI::Input::IPointerPointTransform* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                winrt::Windows::Foundation::Point param1 {  };

                auto return_value = self->obj.TryTransform(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPointerPointTransform_get_Inverse(py::wrapper::Windows::UI::Input::IPointerPointTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Inverse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IPointerPointTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::IPointerPointTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPointerPointTransform[] = {
        { "transform_bounds", (PyCFunction)IPointerPointTransform_TransformBounds, METH_VARARGS, nullptr },
        { "try_transform", (PyCFunction)IPointerPointTransform_TryTransform, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IPointerPointTransform, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IPointerPointTransform[] = {
        { const_cast<char*>("inverse"), (getter)IPointerPointTransform_get_Inverse, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IPointerPointTransform[] = 
    {
        { Py_tp_new, _new_IPointerPointTransform },
        { Py_tp_dealloc, _dealloc_IPointerPointTransform },
        { Py_tp_methods, _methods_IPointerPointTransform },
        { Py_tp_getset, _getset_IPointerPointTransform },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IPointerPointTransform =
    {
        "_winrt_Windows_UI_Input.IPointerPointTransform",
        sizeof(py::wrapper::Windows::UI::Input::IPointerPointTransform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPointerPointTransform
    };

    // ----- CrossSlideThresholds struct --------------------
    constexpr const char* const _type_name_CrossSlideThresholds = "CrossSlideThresholds";

    PyObject* _new_CrossSlideThresholds(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::Input::CrossSlideThresholds return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::UI::Input::CrossSlideThresholds>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        float _SelectionStart{};
        float _SpeedBumpStart{};
        float _SpeedBumpEnd{};
        float _RearrangeStart{};

        static const char* kwlist[] = {"selection_start", "speed_bump_start", "speed_bump_end", "rearrange_start", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ffff", const_cast<char**>(kwlist), &_SelectionStart, &_SpeedBumpStart, &_SpeedBumpEnd, &_RearrangeStart))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::Input::CrossSlideThresholds return_value{ _SelectionStart, _SpeedBumpStart, _SpeedBumpEnd, _RearrangeStart };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_CrossSlideThresholds(py::wrapper::Windows::UI::Input::CrossSlideThresholds* self)
    {
    }

    static PyObject* CrossSlideThresholds_get_SelectionStart(py::wrapper::Windows::UI::Input::CrossSlideThresholds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SelectionStart);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CrossSlideThresholds_set_SelectionStart(py::wrapper::Windows::UI::Input::CrossSlideThresholds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.SelectionStart = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CrossSlideThresholds_get_SpeedBumpStart(py::wrapper::Windows::UI::Input::CrossSlideThresholds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SpeedBumpStart);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CrossSlideThresholds_set_SpeedBumpStart(py::wrapper::Windows::UI::Input::CrossSlideThresholds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.SpeedBumpStart = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CrossSlideThresholds_get_SpeedBumpEnd(py::wrapper::Windows::UI::Input::CrossSlideThresholds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SpeedBumpEnd);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CrossSlideThresholds_set_SpeedBumpEnd(py::wrapper::Windows::UI::Input::CrossSlideThresholds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.SpeedBumpEnd = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CrossSlideThresholds_get_RearrangeStart(py::wrapper::Windows::UI::Input::CrossSlideThresholds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RearrangeStart);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CrossSlideThresholds_set_RearrangeStart(py::wrapper::Windows::UI::Input::CrossSlideThresholds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.RearrangeStart = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_CrossSlideThresholds[] = {
        { const_cast<char*>("selection_start"), (getter)CrossSlideThresholds_get_SelectionStart, (setter)CrossSlideThresholds_set_SelectionStart, nullptr, nullptr },
        { const_cast<char*>("speed_bump_start"), (getter)CrossSlideThresholds_get_SpeedBumpStart, (setter)CrossSlideThresholds_set_SpeedBumpStart, nullptr, nullptr },
        { const_cast<char*>("speed_bump_end"), (getter)CrossSlideThresholds_get_SpeedBumpEnd, (setter)CrossSlideThresholds_set_SpeedBumpEnd, nullptr, nullptr },
        { const_cast<char*>("rearrange_start"), (getter)CrossSlideThresholds_get_RearrangeStart, (setter)CrossSlideThresholds_set_RearrangeStart, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CrossSlideThresholds[] = 
    {
        { Py_tp_new, _new_CrossSlideThresholds },
        { Py_tp_dealloc, _dealloc_CrossSlideThresholds },
        { Py_tp_getset, _getset_CrossSlideThresholds },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CrossSlideThresholds =
    {
        "_winrt_Windows_UI_Input.CrossSlideThresholds",
        sizeof(py::wrapper::Windows::UI::Input::CrossSlideThresholds),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CrossSlideThresholds
    };

    // ----- ManipulationDelta struct --------------------
    constexpr const char* const _type_name_ManipulationDelta = "ManipulationDelta";

    PyObject* _new_ManipulationDelta(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::Input::ManipulationDelta return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::UI::Input::ManipulationDelta>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        PyObject* _Translation{};
        float _Scale{};
        float _Rotation{};
        float _Expansion{};

        static const char* kwlist[] = {"translation", "scale", "rotation", "expansion", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "Offf", const_cast<char**>(kwlist), &_Translation, &_Scale, &_Rotation, &_Expansion))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::Input::ManipulationDelta return_value{ py::converter<winrt::Windows::Foundation::Point>::convert_to(_Translation), _Scale, _Rotation, _Expansion };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_ManipulationDelta(py::wrapper::Windows::UI::Input::ManipulationDelta* self)
    {
    }

    static PyObject* ManipulationDelta_get_Translation(py::wrapper::Windows::UI::Input::ManipulationDelta* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Translation);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationDelta_set_Translation(py::wrapper::Windows::UI::Input::ManipulationDelta* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Translation = py::converter<winrt::Windows::Foundation::Point>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationDelta_get_Scale(py::wrapper::Windows::UI::Input::ManipulationDelta* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Scale);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationDelta_set_Scale(py::wrapper::Windows::UI::Input::ManipulationDelta* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Scale = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationDelta_get_Rotation(py::wrapper::Windows::UI::Input::ManipulationDelta* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Rotation);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationDelta_set_Rotation(py::wrapper::Windows::UI::Input::ManipulationDelta* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Rotation = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationDelta_get_Expansion(py::wrapper::Windows::UI::Input::ManipulationDelta* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Expansion);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationDelta_set_Expansion(py::wrapper::Windows::UI::Input::ManipulationDelta* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Expansion = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_ManipulationDelta[] = {
        { const_cast<char*>("translation"), (getter)ManipulationDelta_get_Translation, (setter)ManipulationDelta_set_Translation, nullptr, nullptr },
        { const_cast<char*>("scale"), (getter)ManipulationDelta_get_Scale, (setter)ManipulationDelta_set_Scale, nullptr, nullptr },
        { const_cast<char*>("rotation"), (getter)ManipulationDelta_get_Rotation, (setter)ManipulationDelta_set_Rotation, nullptr, nullptr },
        { const_cast<char*>("expansion"), (getter)ManipulationDelta_get_Expansion, (setter)ManipulationDelta_set_Expansion, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ManipulationDelta[] = 
    {
        { Py_tp_new, _new_ManipulationDelta },
        { Py_tp_dealloc, _dealloc_ManipulationDelta },
        { Py_tp_getset, _getset_ManipulationDelta },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ManipulationDelta =
    {
        "_winrt_Windows_UI_Input.ManipulationDelta",
        sizeof(py::wrapper::Windows::UI::Input::ManipulationDelta),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationDelta
    };

    // ----- ManipulationVelocities struct --------------------
    constexpr const char* const _type_name_ManipulationVelocities = "ManipulationVelocities";

    PyObject* _new_ManipulationVelocities(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::Input::ManipulationVelocities return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::UI::Input::ManipulationVelocities>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        PyObject* _Linear{};
        float _Angular{};
        float _Expansion{};

        static const char* kwlist[] = {"linear", "angular", "expansion", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "Off", const_cast<char**>(kwlist), &_Linear, &_Angular, &_Expansion))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::Input::ManipulationVelocities return_value{ py::converter<winrt::Windows::Foundation::Point>::convert_to(_Linear), _Angular, _Expansion };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_ManipulationVelocities(py::wrapper::Windows::UI::Input::ManipulationVelocities* self)
    {
    }

    static PyObject* ManipulationVelocities_get_Linear(py::wrapper::Windows::UI::Input::ManipulationVelocities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Linear);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationVelocities_set_Linear(py::wrapper::Windows::UI::Input::ManipulationVelocities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Linear = py::converter<winrt::Windows::Foundation::Point>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationVelocities_get_Angular(py::wrapper::Windows::UI::Input::ManipulationVelocities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Angular);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationVelocities_set_Angular(py::wrapper::Windows::UI::Input::ManipulationVelocities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Angular = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ManipulationVelocities_get_Expansion(py::wrapper::Windows::UI::Input::ManipulationVelocities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Expansion);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ManipulationVelocities_set_Expansion(py::wrapper::Windows::UI::Input::ManipulationVelocities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Expansion = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_ManipulationVelocities[] = {
        { const_cast<char*>("linear"), (getter)ManipulationVelocities_get_Linear, (setter)ManipulationVelocities_set_Linear, nullptr, nullptr },
        { const_cast<char*>("angular"), (getter)ManipulationVelocities_get_Angular, (setter)ManipulationVelocities_set_Angular, nullptr, nullptr },
        { const_cast<char*>("expansion"), (getter)ManipulationVelocities_get_Expansion, (setter)ManipulationVelocities_set_Expansion, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ManipulationVelocities[] = 
    {
        { Py_tp_new, _new_ManipulationVelocities },
        { Py_tp_dealloc, _dealloc_ManipulationVelocities },
        { Py_tp_getset, _getset_ManipulationVelocities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ManipulationVelocities =
    {
        "_winrt_Windows_UI_Input.ManipulationVelocities",
        sizeof(py::wrapper::Windows::UI::Input::ManipulationVelocities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationVelocities
    };

    // ----- Windows.UI.Input Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::UI::Input::AttachableInputObject>::python_type = py::register_python_type(module, _type_name_AttachableInputObject, &_type_spec_AttachableInputObject, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::CrossSlidingEventArgs>::python_type = py::register_python_type(module, _type_name_CrossSlidingEventArgs, &_type_spec_CrossSlidingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::DraggingEventArgs>::python_type = py::register_python_type(module, _type_name_DraggingEventArgs, &_type_spec_DraggingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::EdgeGesture>::python_type = py::register_python_type(module, _type_name_EdgeGesture, &_type_spec_EdgeGesture, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::EdgeGestureEventArgs>::python_type = py::register_python_type(module, _type_name_EdgeGestureEventArgs, &_type_spec_EdgeGestureEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::GestureRecognizer>::python_type = py::register_python_type(module, _type_name_GestureRecognizer, &_type_spec_GestureRecognizer, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::HoldingEventArgs>::python_type = py::register_python_type(module, _type_name_HoldingEventArgs, &_type_spec_HoldingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::InputActivationListener>::python_type = py::register_python_type(module, _type_name_InputActivationListener, &_type_spec_InputActivationListener, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::InputActivationListenerActivationChangedEventArgs>::python_type = py::register_python_type(module, _type_name_InputActivationListenerActivationChangedEventArgs, &_type_spec_InputActivationListenerActivationChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::KeyboardDeliveryInterceptor>::python_type = py::register_python_type(module, _type_name_KeyboardDeliveryInterceptor, &_type_spec_KeyboardDeliveryInterceptor, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::ManipulationCompletedEventArgs>::python_type = py::register_python_type(module, _type_name_ManipulationCompletedEventArgs, &_type_spec_ManipulationCompletedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::ManipulationInertiaStartingEventArgs>::python_type = py::register_python_type(module, _type_name_ManipulationInertiaStartingEventArgs, &_type_spec_ManipulationInertiaStartingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::ManipulationStartedEventArgs>::python_type = py::register_python_type(module, _type_name_ManipulationStartedEventArgs, &_type_spec_ManipulationStartedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::ManipulationUpdatedEventArgs>::python_type = py::register_python_type(module, _type_name_ManipulationUpdatedEventArgs, &_type_spec_ManipulationUpdatedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::MouseWheelParameters>::python_type = py::register_python_type(module, _type_name_MouseWheelParameters, &_type_spec_MouseWheelParameters, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::PointerPoint>::python_type = py::register_python_type(module, _type_name_PointerPoint, &_type_spec_PointerPoint, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::PointerPointProperties>::python_type = py::register_python_type(module, _type_name_PointerPointProperties, &_type_spec_PointerPointProperties, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::PointerVisualizationSettings>::python_type = py::register_python_type(module, _type_name_PointerVisualizationSettings, &_type_spec_PointerVisualizationSettings, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::RadialController>::python_type = py::register_python_type(module, _type_name_RadialController, &_type_spec_RadialController, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::RadialControllerButtonClickedEventArgs>::python_type = py::register_python_type(module, _type_name_RadialControllerButtonClickedEventArgs, &_type_spec_RadialControllerButtonClickedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::RadialControllerButtonHoldingEventArgs>::python_type = py::register_python_type(module, _type_name_RadialControllerButtonHoldingEventArgs, &_type_spec_RadialControllerButtonHoldingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::RadialControllerButtonPressedEventArgs>::python_type = py::register_python_type(module, _type_name_RadialControllerButtonPressedEventArgs, &_type_spec_RadialControllerButtonPressedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::RadialControllerButtonReleasedEventArgs>::python_type = py::register_python_type(module, _type_name_RadialControllerButtonReleasedEventArgs, &_type_spec_RadialControllerButtonReleasedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::RadialControllerConfiguration>::python_type = py::register_python_type(module, _type_name_RadialControllerConfiguration, &_type_spec_RadialControllerConfiguration, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::RadialControllerControlAcquiredEventArgs>::python_type = py::register_python_type(module, _type_name_RadialControllerControlAcquiredEventArgs, &_type_spec_RadialControllerControlAcquiredEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::RadialControllerMenu>::python_type = py::register_python_type(module, _type_name_RadialControllerMenu, &_type_spec_RadialControllerMenu, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::RadialControllerMenuItem>::python_type = py::register_python_type(module, _type_name_RadialControllerMenuItem, &_type_spec_RadialControllerMenuItem, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::RadialControllerRotationChangedEventArgs>::python_type = py::register_python_type(module, _type_name_RadialControllerRotationChangedEventArgs, &_type_spec_RadialControllerRotationChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::RadialControllerScreenContact>::python_type = py::register_python_type(module, _type_name_RadialControllerScreenContact, &_type_spec_RadialControllerScreenContact, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::RadialControllerScreenContactContinuedEventArgs>::python_type = py::register_python_type(module, _type_name_RadialControllerScreenContactContinuedEventArgs, &_type_spec_RadialControllerScreenContactContinuedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::RadialControllerScreenContactEndedEventArgs>::python_type = py::register_python_type(module, _type_name_RadialControllerScreenContactEndedEventArgs, &_type_spec_RadialControllerScreenContactEndedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::RadialControllerScreenContactStartedEventArgs>::python_type = py::register_python_type(module, _type_name_RadialControllerScreenContactStartedEventArgs, &_type_spec_RadialControllerScreenContactStartedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::RightTappedEventArgs>::python_type = py::register_python_type(module, _type_name_RightTappedEventArgs, &_type_spec_RightTappedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::SystemButtonEventController>::python_type = py::register_python_type(module, _type_name_SystemButtonEventController, &_type_spec_SystemButtonEventController, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::SystemFunctionButtonEventArgs>::python_type = py::register_python_type(module, _type_name_SystemFunctionButtonEventArgs, &_type_spec_SystemFunctionButtonEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::SystemFunctionLockChangedEventArgs>::python_type = py::register_python_type(module, _type_name_SystemFunctionLockChangedEventArgs, &_type_spec_SystemFunctionLockChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::SystemFunctionLockIndicatorChangedEventArgs>::python_type = py::register_python_type(module, _type_name_SystemFunctionLockIndicatorChangedEventArgs, &_type_spec_SystemFunctionLockIndicatorChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::TappedEventArgs>::python_type = py::register_python_type(module, _type_name_TappedEventArgs, &_type_spec_TappedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::IPointerPointTransform>::python_type = py::register_python_type(module, _type_name_IPointerPointTransform, &_type_spec_IPointerPointTransform, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::CrossSlideThresholds>::python_type = py::register_python_type(module, _type_name_CrossSlideThresholds, &_type_spec_CrossSlideThresholds, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::ManipulationDelta>::python_type = py::register_python_type(module, _type_name_ManipulationDelta, &_type_spec_ManipulationDelta, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::ManipulationVelocities>::python_type = py::register_python_type(module, _type_name_ManipulationVelocities, &_type_spec_ManipulationVelocities, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.UI.Input");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_UI_Input",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::UI::Input

PyMODINIT_FUNC
PyInit__winrt_Windows_UI_Input (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::UI::Input::module_def);
}
