// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Media.Protection.PlayReady.h"

PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::NDClient>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::NDCustomData>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::NDStorageFileHelper>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::NDStreamParserNotifier>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::NDTCPMessenger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentResolver>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomain>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyITADataGenerator>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicense>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseManagement>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadySoapMessage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDCustomData>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngine>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDMessenger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDSendResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDStartResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDStorageFileHelper>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDStreamParser>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDStreamParserNotifier>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDTransmitterProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyDomain>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicense>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest>::python_type;

namespace py::cpp::Windows::Media::Protection::PlayReady
{
    // ----- NDClient class --------------------
    constexpr const char* const _type_name_NDClient = "NDClient";

    static PyObject* _new_NDClient(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngine>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDStreamParser>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDMessenger>(args, 2);

                winrt::Windows::Media::Protection::PlayReady::NDClient instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NDClient(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* NDClient_Close(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDClient_LicenseFetchAsync(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>(args, 0);

                return py::convert(self->obj.LicenseFetchAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDClient_ReRegistrationAsync(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDCustomData>(args, 0);

                return py::convert(self->obj.ReRegistrationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDClient_StartAsync(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDCustomData>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>(args, 3);

                return py::convert(self->obj.StartAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDClient_add_ClosedCaptionDataReceived(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Protection::PlayReady::NDClient, winrt::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs>>(arg);

            return py::convert(self->obj.ClosedCaptionDataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_remove_ClosedCaptionDataReceived(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ClosedCaptionDataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_add_LicenseFetchCompleted(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Protection::PlayReady::NDClient, winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs>>(arg);

            return py::convert(self->obj.LicenseFetchCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_remove_LicenseFetchCompleted(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LicenseFetchCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_add_ProximityDetectionCompleted(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Protection::PlayReady::NDClient, winrt::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs>>(arg);

            return py::convert(self->obj.ProximityDetectionCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_remove_ProximityDetectionCompleted(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ProximityDetectionCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_add_ReRegistrationNeeded(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Protection::PlayReady::NDClient, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ReRegistrationNeeded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_remove_ReRegistrationNeeded(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReRegistrationNeeded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_add_RegistrationCompleted(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Protection::PlayReady::NDClient, winrt::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs>>(arg);

            return py::convert(self->obj.RegistrationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDClient_remove_RegistrationCompleted(py::wrapper::Windows::Media::Protection::PlayReady::NDClient* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RegistrationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NDClient(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::NDClient>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NDClient[] = {
        { "close", (PyCFunction)NDClient_Close, METH_VARARGS, nullptr },
        { "license_fetch_async", (PyCFunction)NDClient_LicenseFetchAsync, METH_VARARGS, nullptr },
        { "re_registration_async", (PyCFunction)NDClient_ReRegistrationAsync, METH_VARARGS, nullptr },
        { "start_async", (PyCFunction)NDClient_StartAsync, METH_VARARGS, nullptr },
        { "add_closed_caption_data_received", (PyCFunction)NDClient_add_ClosedCaptionDataReceived, METH_O, nullptr },
        { "remove_closed_caption_data_received", (PyCFunction)NDClient_remove_ClosedCaptionDataReceived, METH_O, nullptr },
        { "add_license_fetch_completed", (PyCFunction)NDClient_add_LicenseFetchCompleted, METH_O, nullptr },
        { "remove_license_fetch_completed", (PyCFunction)NDClient_remove_LicenseFetchCompleted, METH_O, nullptr },
        { "add_proximity_detection_completed", (PyCFunction)NDClient_add_ProximityDetectionCompleted, METH_O, nullptr },
        { "remove_proximity_detection_completed", (PyCFunction)NDClient_remove_ProximityDetectionCompleted, METH_O, nullptr },
        { "add_re_registration_needed", (PyCFunction)NDClient_add_ReRegistrationNeeded, METH_O, nullptr },
        { "remove_re_registration_needed", (PyCFunction)NDClient_remove_ReRegistrationNeeded, METH_O, nullptr },
        { "add_registration_completed", (PyCFunction)NDClient_add_RegistrationCompleted, METH_O, nullptr },
        { "remove_registration_completed", (PyCFunction)NDClient_remove_RegistrationCompleted, METH_O, nullptr },
        { "_from", (PyCFunction)_from_NDClient, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_NDClient[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_NDClient[] = 
    {
        { Py_tp_new, _new_NDClient },
        { Py_tp_dealloc, _dealloc_NDClient },
        { Py_tp_methods, _methods_NDClient },
        { Py_tp_getset, _getset_NDClient },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NDClient =
    {
        "_winrt_Windows_Media_Protection_PlayReady.NDClient",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::NDClient),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NDClient
    };

    // ----- NDCustomData class --------------------
    constexpr const char* const _type_name_NDCustomData = "NDCustomData";

    static PyObject* _new_NDCustomData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                winrt::Windows::Media::Protection::PlayReady::NDCustomData instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NDCustomData(py::wrapper::Windows::Media::Protection::PlayReady::NDCustomData* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* NDCustomData_get_CustomData(py::wrapper::Windows::Media::Protection::PlayReady::NDCustomData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDCustomData_get_CustomDataTypeID(py::wrapper::Windows::Media::Protection::PlayReady::NDCustomData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CustomDataTypeID());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NDCustomData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::NDCustomData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NDCustomData[] = {
        { "_from", (PyCFunction)_from_NDCustomData, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_NDCustomData[] = {
        { const_cast<char*>("custom_data"), (getter)NDCustomData_get_CustomData, nullptr, nullptr, nullptr },
        { const_cast<char*>("custom_data_type_i_d"), (getter)NDCustomData_get_CustomDataTypeID, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_NDCustomData[] = 
    {
        { Py_tp_new, _new_NDCustomData },
        { Py_tp_dealloc, _dealloc_NDCustomData },
        { Py_tp_methods, _methods_NDCustomData },
        { Py_tp_getset, _getset_NDCustomData },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NDCustomData =
    {
        "_winrt_Windows_Media_Protection_PlayReady.NDCustomData",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::NDCustomData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NDCustomData
    };

    // ----- NDDownloadEngineNotifier class --------------------
    constexpr const char* const _type_name_NDDownloadEngineNotifier = "NDDownloadEngineNotifier";

    static PyObject* _new_NDDownloadEngineNotifier(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NDDownloadEngineNotifier(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* NDDownloadEngineNotifier_OnContentIDReceived(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>(args, 0);

                self->obj.OnContentIDReceived(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDDownloadEngineNotifier_OnDataReceived(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.OnDataReceived(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDDownloadEngineNotifier_OnEndOfStream(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.OnEndOfStream();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDDownloadEngineNotifier_OnNetworkError(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.OnNetworkError();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDDownloadEngineNotifier_OnPlayReadyObjectReceived(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                self->obj.OnPlayReadyObjectReceived(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDDownloadEngineNotifier_OnStreamOpened(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.OnStreamOpened();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_NDDownloadEngineNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NDDownloadEngineNotifier[] = {
        { "on_content_i_d_received", (PyCFunction)NDDownloadEngineNotifier_OnContentIDReceived, METH_VARARGS, nullptr },
        { "on_data_received", (PyCFunction)NDDownloadEngineNotifier_OnDataReceived, METH_VARARGS, nullptr },
        { "on_end_of_stream", (PyCFunction)NDDownloadEngineNotifier_OnEndOfStream, METH_VARARGS, nullptr },
        { "on_network_error", (PyCFunction)NDDownloadEngineNotifier_OnNetworkError, METH_VARARGS, nullptr },
        { "on_play_ready_object_received", (PyCFunction)NDDownloadEngineNotifier_OnPlayReadyObjectReceived, METH_VARARGS, nullptr },
        { "on_stream_opened", (PyCFunction)NDDownloadEngineNotifier_OnStreamOpened, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_NDDownloadEngineNotifier, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_NDDownloadEngineNotifier[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_NDDownloadEngineNotifier[] = 
    {
        { Py_tp_new, _new_NDDownloadEngineNotifier },
        { Py_tp_dealloc, _dealloc_NDDownloadEngineNotifier },
        { Py_tp_methods, _methods_NDDownloadEngineNotifier },
        { Py_tp_getset, _getset_NDDownloadEngineNotifier },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NDDownloadEngineNotifier =
    {
        "_winrt_Windows_Media_Protection_PlayReady.NDDownloadEngineNotifier",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NDDownloadEngineNotifier
    };

    // ----- NDLicenseFetchDescriptor class --------------------
    constexpr const char* const _type_name_NDLicenseFetchDescriptor = "NDLicenseFetchDescriptor";

    static PyObject* _new_NDLicenseFetchDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDContentIDType>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDCustomData>(args, 2);

                winrt::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NDLicenseFetchDescriptor(py::wrapper::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* NDLicenseFetchDescriptor_get_LicenseFetchChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LicenseFetchChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NDLicenseFetchDescriptor_put_LicenseFetchChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDCustomData>(arg);

            self->obj.LicenseFetchChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NDLicenseFetchDescriptor_get_ContentID(py::wrapper::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentID());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NDLicenseFetchDescriptor_get_ContentIDType(py::wrapper::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentIDType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NDLicenseFetchDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NDLicenseFetchDescriptor[] = {
        { "_from", (PyCFunction)_from_NDLicenseFetchDescriptor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_NDLicenseFetchDescriptor[] = {
        { const_cast<char*>("license_fetch_challenge_custom_data"), (getter)NDLicenseFetchDescriptor_get_LicenseFetchChallengeCustomData, (setter)NDLicenseFetchDescriptor_put_LicenseFetchChallengeCustomData, nullptr, nullptr },
        { const_cast<char*>("content_i_d"), (getter)NDLicenseFetchDescriptor_get_ContentID, nullptr, nullptr, nullptr },
        { const_cast<char*>("content_i_d_type"), (getter)NDLicenseFetchDescriptor_get_ContentIDType, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_NDLicenseFetchDescriptor[] = 
    {
        { Py_tp_new, _new_NDLicenseFetchDescriptor },
        { Py_tp_dealloc, _dealloc_NDLicenseFetchDescriptor },
        { Py_tp_methods, _methods_NDLicenseFetchDescriptor },
        { Py_tp_getset, _getset_NDLicenseFetchDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NDLicenseFetchDescriptor =
    {
        "_winrt_Windows_Media_Protection_PlayReady.NDLicenseFetchDescriptor",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NDLicenseFetchDescriptor
    };

    // ----- NDStorageFileHelper class --------------------
    constexpr const char* const _type_name_NDStorageFileHelper = "NDStorageFileHelper";

    static PyObject* _new_NDStorageFileHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::NDStorageFileHelper instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NDStorageFileHelper(py::wrapper::Windows::Media::Protection::PlayReady::NDStorageFileHelper* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* NDStorageFileHelper_GetFileURLs(py::wrapper::Windows::Media::Protection::PlayReady::NDStorageFileHelper* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.GetFileURLs(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_NDStorageFileHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::NDStorageFileHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NDStorageFileHelper[] = {
        { "get_file_u_r_ls", (PyCFunction)NDStorageFileHelper_GetFileURLs, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_NDStorageFileHelper, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_NDStorageFileHelper[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_NDStorageFileHelper[] = 
    {
        { Py_tp_new, _new_NDStorageFileHelper },
        { Py_tp_dealloc, _dealloc_NDStorageFileHelper },
        { Py_tp_methods, _methods_NDStorageFileHelper },
        { Py_tp_getset, _getset_NDStorageFileHelper },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NDStorageFileHelper =
    {
        "_winrt_Windows_Media_Protection_PlayReady.NDStorageFileHelper",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::NDStorageFileHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NDStorageFileHelper
    };

    // ----- NDStreamParserNotifier class --------------------
    constexpr const char* const _type_name_NDStreamParserNotifier = "NDStreamParserNotifier";

    static PyObject* _new_NDStreamParserNotifier(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::NDStreamParserNotifier instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NDStreamParserNotifier(py::wrapper::Windows::Media::Protection::PlayReady::NDStreamParserNotifier* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* NDStreamParserNotifier_OnBeginSetupDecryptor(py::wrapper::Windows::Media::Protection::PlayReady::NDStreamParserNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::array_view<uint8_t>>(args, 2);

                self->obj.OnBeginSetupDecryptor(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDStreamParserNotifier_OnContentIDReceived(py::wrapper::Windows::Media::Protection::PlayReady::NDStreamParserNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>(args, 0);

                self->obj.OnContentIDReceived(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDStreamParserNotifier_OnMediaStreamDescriptorCreated(py::wrapper::Windows::Media::Protection::PlayReady::NDStreamParserNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Media::Core::AudioStreamDescriptor>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Media::Core::VideoStreamDescriptor>>(args, 1);

                self->obj.OnMediaStreamDescriptorCreated(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDStreamParserNotifier_OnSampleParsed(py::wrapper::Windows::Media::Protection::PlayReady::NDStreamParserNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDMediaStreamType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Core::MediaStreamSample>(args, 2);
                auto param3 = py::convert_to<int64_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDClosedCaptionFormat>(args, 4);
                auto param5 = py::convert_to<winrt::array_view<uint8_t>>(args, 5);

                self->obj.OnSampleParsed(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_NDStreamParserNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::NDStreamParserNotifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NDStreamParserNotifier[] = {
        { "on_begin_setup_decryptor", (PyCFunction)NDStreamParserNotifier_OnBeginSetupDecryptor, METH_VARARGS, nullptr },
        { "on_content_i_d_received", (PyCFunction)NDStreamParserNotifier_OnContentIDReceived, METH_VARARGS, nullptr },
        { "on_media_stream_descriptor_created", (PyCFunction)NDStreamParserNotifier_OnMediaStreamDescriptorCreated, METH_VARARGS, nullptr },
        { "on_sample_parsed", (PyCFunction)NDStreamParserNotifier_OnSampleParsed, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_NDStreamParserNotifier, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_NDStreamParserNotifier[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_NDStreamParserNotifier[] = 
    {
        { Py_tp_new, _new_NDStreamParserNotifier },
        { Py_tp_dealloc, _dealloc_NDStreamParserNotifier },
        { Py_tp_methods, _methods_NDStreamParserNotifier },
        { Py_tp_getset, _getset_NDStreamParserNotifier },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NDStreamParserNotifier =
    {
        "_winrt_Windows_Media_Protection_PlayReady.NDStreamParserNotifier",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::NDStreamParserNotifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NDStreamParserNotifier
    };

    // ----- NDTCPMessenger class --------------------
    constexpr const char* const _type_name_NDTCPMessenger = "NDTCPMessenger";

    static PyObject* _new_NDTCPMessenger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                winrt::Windows::Media::Protection::PlayReady::NDTCPMessenger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NDTCPMessenger(py::wrapper::Windows::Media::Protection::PlayReady::NDTCPMessenger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* NDTCPMessenger_SendLicenseFetchRequestAsync(py::wrapper::Windows::Media::Protection::PlayReady::NDTCPMessenger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                return py::convert(self->obj.SendLicenseFetchRequestAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDTCPMessenger_SendProximityDetectionResponseAsync(py::wrapper::Windows::Media::Protection::PlayReady::NDTCPMessenger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDProximityDetectionType>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);
                auto param2 = py::convert_to<winrt::array_view<uint8_t>>(args, 2);
                auto param3 = py::convert_to<winrt::array_view<uint8_t>>(args, 3);

                return py::convert(self->obj.SendProximityDetectionResponseAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDTCPMessenger_SendProximityDetectionStartAsync(py::wrapper::Windows::Media::Protection::PlayReady::NDTCPMessenger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDProximityDetectionType>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);
                auto param2 = py::convert_to<winrt::array_view<uint8_t>>(args, 2);
                auto param3 = py::convert_to<winrt::array_view<uint8_t>>(args, 3);

                return py::convert(self->obj.SendProximityDetectionStartAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NDTCPMessenger_SendRegistrationRequestAsync(py::wrapper::Windows::Media::Protection::PlayReady::NDTCPMessenger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                return py::convert(self->obj.SendRegistrationRequestAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_NDTCPMessenger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::NDTCPMessenger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NDTCPMessenger[] = {
        { "send_license_fetch_request_async", (PyCFunction)NDTCPMessenger_SendLicenseFetchRequestAsync, METH_VARARGS, nullptr },
        { "send_proximity_detection_response_async", (PyCFunction)NDTCPMessenger_SendProximityDetectionResponseAsync, METH_VARARGS, nullptr },
        { "send_proximity_detection_start_async", (PyCFunction)NDTCPMessenger_SendProximityDetectionStartAsync, METH_VARARGS, nullptr },
        { "send_registration_request_async", (PyCFunction)NDTCPMessenger_SendRegistrationRequestAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_NDTCPMessenger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_NDTCPMessenger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_NDTCPMessenger[] = 
    {
        { Py_tp_new, _new_NDTCPMessenger },
        { Py_tp_dealloc, _dealloc_NDTCPMessenger },
        { Py_tp_methods, _methods_NDTCPMessenger },
        { Py_tp_getset, _getset_NDTCPMessenger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NDTCPMessenger =
    {
        "_winrt_Windows_Media_Protection_PlayReady.NDTCPMessenger",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::NDTCPMessenger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NDTCPMessenger
    };

    // ----- PlayReadyContentHeader class --------------------
    constexpr const char* const _type_name_PlayReadyContentHeader = "PlayReadyContentHeader";

    static PyObject* _new_PlayReadyContentHeader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 8)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::guid>>(args, 1);
                auto param2 = py::convert_to<winrt::array_view<winrt::hstring>>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyEncryptionAlgorithm>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);
                auto param7 = py::convert_to<winrt::guid>(args, 7);

                winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader instance{ param0, param1, param2, param3, param4, param5, param6, param7 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::guid>(args, 4);

                winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader instance{ param0, param1, param2, param3, param4 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyEncryptionAlgorithm>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);
                auto param6 = py::convert_to<winrt::guid>(args, 6);

                winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader instance{ param0, param1, param2, param3, param4, param5, param6 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyContentHeader(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayReadyContentHeader_GetSerializedHeader(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSerializedHeader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_CustomAttributes(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CustomAttributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_DecryptorSetup(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecryptorSetup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DomainServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_EncryptionType(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncryptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_HeaderWithEmbeddedUpdates(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HeaderWithEmbeddedUpdates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_KeyId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_KeyIdString(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyIdString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_LicenseAcquisitionUrl(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LicenseAcquisitionUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_LicenseAcquisitionUserInterfaceUrl(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LicenseAcquisitionUserInterfaceUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_KeyIdStrings(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyIdStrings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyContentHeader_get_KeyIds(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayReadyContentHeader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyContentHeader[] = {
        { "get_serialized_header", (PyCFunction)PlayReadyContentHeader_GetSerializedHeader, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlayReadyContentHeader, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadyContentHeader[] = {
        { const_cast<char*>("custom_attributes"), (getter)PlayReadyContentHeader_get_CustomAttributes, nullptr, nullptr, nullptr },
        { const_cast<char*>("decryptor_setup"), (getter)PlayReadyContentHeader_get_DecryptorSetup, nullptr, nullptr, nullptr },
        { const_cast<char*>("domain_service_id"), (getter)PlayReadyContentHeader_get_DomainServiceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("encryption_type"), (getter)PlayReadyContentHeader_get_EncryptionType, nullptr, nullptr, nullptr },
        { const_cast<char*>("header_with_embedded_updates"), (getter)PlayReadyContentHeader_get_HeaderWithEmbeddedUpdates, nullptr, nullptr, nullptr },
        { const_cast<char*>("key_id"), (getter)PlayReadyContentHeader_get_KeyId, nullptr, nullptr, nullptr },
        { const_cast<char*>("key_id_string"), (getter)PlayReadyContentHeader_get_KeyIdString, nullptr, nullptr, nullptr },
        { const_cast<char*>("license_acquisition_url"), (getter)PlayReadyContentHeader_get_LicenseAcquisitionUrl, nullptr, nullptr, nullptr },
        { const_cast<char*>("license_acquisition_user_interface_url"), (getter)PlayReadyContentHeader_get_LicenseAcquisitionUserInterfaceUrl, nullptr, nullptr, nullptr },
        { const_cast<char*>("key_id_strings"), (getter)PlayReadyContentHeader_get_KeyIdStrings, nullptr, nullptr, nullptr },
        { const_cast<char*>("key_ids"), (getter)PlayReadyContentHeader_get_KeyIds, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadyContentHeader[] = 
    {
        { Py_tp_new, _new_PlayReadyContentHeader },
        { Py_tp_dealloc, _dealloc_PlayReadyContentHeader },
        { Py_tp_methods, _methods_PlayReadyContentHeader },
        { Py_tp_getset, _getset_PlayReadyContentHeader },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadyContentHeader =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadyContentHeader",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyContentHeader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyContentHeader
    };

    // ----- PlayReadyContentResolver class --------------------
    constexpr const char* const _type_name_PlayReadyContentResolver = "PlayReadyContentResolver";

    static PyObject* _new_PlayReadyContentResolver(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayReadyContentResolver);
        return nullptr;
    }

    static PyObject* PlayReadyContentResolver_ServiceRequest(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(args, 0);

                return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyContentResolver::ServiceRequest(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyContentResolver[] = {
        { "service_request", (PyCFunction)PlayReadyContentResolver_ServiceRequest, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadyContentResolver[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadyContentResolver[] = 
    {
        { Py_tp_new, _new_PlayReadyContentResolver },
        { Py_tp_methods, _methods_PlayReadyContentResolver },
        { Py_tp_getset, _getset_PlayReadyContentResolver },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadyContentResolver =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadyContentResolver",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyContentResolver
    };

    // ----- PlayReadyDomain class --------------------
    constexpr const char* const _type_name_PlayReadyDomain = "PlayReadyDomain";

    static PyObject* _new_PlayReadyDomain(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayReadyDomain);
        return nullptr;
    }

    static void _dealloc_PlayReadyDomain(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomain* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayReadyDomain_get_AccountId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomain_get_DomainJoinUrl(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DomainJoinUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomain_get_FriendlyName(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomain_get_Revision(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Revision());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomain_get_ServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayReadyDomain(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomain>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyDomain[] = {
        { "_from", (PyCFunction)_from_PlayReadyDomain, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadyDomain[] = {
        { const_cast<char*>("account_id"), (getter)PlayReadyDomain_get_AccountId, nullptr, nullptr, nullptr },
        { const_cast<char*>("domain_join_url"), (getter)PlayReadyDomain_get_DomainJoinUrl, nullptr, nullptr, nullptr },
        { const_cast<char*>("friendly_name"), (getter)PlayReadyDomain_get_FriendlyName, nullptr, nullptr, nullptr },
        { const_cast<char*>("revision"), (getter)PlayReadyDomain_get_Revision, nullptr, nullptr, nullptr },
        { const_cast<char*>("service_id"), (getter)PlayReadyDomain_get_ServiceId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadyDomain[] = 
    {
        { Py_tp_new, _new_PlayReadyDomain },
        { Py_tp_dealloc, _dealloc_PlayReadyDomain },
        { Py_tp_methods, _methods_PlayReadyDomain },
        { Py_tp_getset, _getset_PlayReadyDomain },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadyDomain =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadyDomain",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomain),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyDomain
    };

    // ----- PlayReadyDomainIterable class --------------------
    constexpr const char* const _type_name_PlayReadyDomainIterable = "PlayReadyDomainIterable";

    static PyObject* _new_PlayReadyDomainIterable(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyDomainIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayReadyDomainIterable_First(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_PlayReadyDomainIterable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PlayReadyDomainIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyDomainIterable[] = {
        { "first", (PyCFunction)PlayReadyDomainIterable_First, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlayReadyDomainIterable, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadyDomainIterable[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadyDomainIterable[] = 
    {
        { Py_tp_new, _new_PlayReadyDomainIterable },
        { Py_tp_dealloc, _dealloc_PlayReadyDomainIterable },
        { Py_tp_methods, _methods_PlayReadyDomainIterable },
        { Py_tp_getset, _getset_PlayReadyDomainIterable },
        { Py_tp_iter, _iterator_PlayReadyDomainIterable },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadyDomainIterable =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadyDomainIterable",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyDomainIterable
    };

    // ----- PlayReadyDomainIterator class --------------------
    constexpr const char* const _type_name_PlayReadyDomainIterator = "PlayReadyDomainIterator";

    static PyObject* _new_PlayReadyDomainIterator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayReadyDomainIterator);
        return nullptr;
    }

    static void _dealloc_PlayReadyDomainIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayReadyDomainIterator_GetMany(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0_count = py::convert_to<winrt::com_array<winrt::Windows::Media::Protection::PlayReady::IPlayReadyDomain>::size_type>(args, 0);
                winrt::com_array<winrt::Windows::Media::Protection::PlayReady::IPlayReadyDomain> param0 ( param0_count, py::empty_instance<winrt::Windows::Media::Protection::PlayReady::IPlayReadyDomain>::get() );

                auto return_value = self->obj.GetMany(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainIterator_MoveNext(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.MoveNext());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainIterator_get_Current(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainIterator_get_HasCurrent(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasCurrent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayReadyDomainIterator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PlayReadyDomainIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator* self) noexcept
    {
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _iterator_next_PlayReadyDomainIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator* self) noexcept
    {
        try
        {
            if (self->obj.HasCurrent())
            {
                auto cur = self->obj.Current();
                self->obj.MoveNext();
                return py::convert(cur);
            }
            else
            {
                return nullptr;
            }}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyDomainIterator[] = {
        { "get_many", (PyCFunction)PlayReadyDomainIterator_GetMany, METH_VARARGS, nullptr },
        { "move_next", (PyCFunction)PlayReadyDomainIterator_MoveNext, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlayReadyDomainIterator, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadyDomainIterator[] = {
        { const_cast<char*>("current"), (getter)PlayReadyDomainIterator_get_Current, nullptr, nullptr, nullptr },
        { const_cast<char*>("has_current"), (getter)PlayReadyDomainIterator_get_HasCurrent, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadyDomainIterator[] = 
    {
        { Py_tp_new, _new_PlayReadyDomainIterator },
        { Py_tp_dealloc, _dealloc_PlayReadyDomainIterator },
        { Py_tp_methods, _methods_PlayReadyDomainIterator },
        { Py_tp_getset, _getset_PlayReadyDomainIterator },
        { Py_tp_iter, _iterator_PlayReadyDomainIterator },
        { Py_tp_iternext, _iterator_next_PlayReadyDomainIterator },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadyDomainIterator =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadyDomainIterator",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyDomainIterator
    };

    // ----- PlayReadyDomainJoinServiceRequest class --------------------
    constexpr const char* const _type_name_PlayReadyDomainJoinServiceRequest = "PlayReadyDomainJoinServiceRequest";

    static PyObject* _new_PlayReadyDomainJoinServiceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyDomainJoinServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.BeginServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GenerateManualEnablingChallenge());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.NextServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(self->obj.ProcessManualEnablingResponse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtectionSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DomainServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainJoinServiceRequest_put_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.DomainServiceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_DomainFriendlyName(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DomainFriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainJoinServiceRequest_put_DomainFriendlyName(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DomainFriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_DomainAccountId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DomainAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainJoinServiceRequest_put_DomainAccountId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.DomainAccountId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainJoinServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainJoinServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainJoinServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayReadyDomainJoinServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyDomainJoinServiceRequest[] = {
        { "begin_service_request", (PyCFunction)PlayReadyDomainJoinServiceRequest_BeginServiceRequest, METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", (PyCFunction)PlayReadyDomainJoinServiceRequest_GenerateManualEnablingChallenge, METH_VARARGS, nullptr },
        { "next_service_request", (PyCFunction)PlayReadyDomainJoinServiceRequest_NextServiceRequest, METH_VARARGS, nullptr },
        { "process_manual_enabling_response", (PyCFunction)PlayReadyDomainJoinServiceRequest_ProcessManualEnablingResponse, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlayReadyDomainJoinServiceRequest, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadyDomainJoinServiceRequest[] = {
        { const_cast<char*>("protection_system"), (getter)PlayReadyDomainJoinServiceRequest_get_ProtectionSystem, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)PlayReadyDomainJoinServiceRequest_get_Type, nullptr, nullptr, nullptr },
        { const_cast<char*>("domain_service_id"), (getter)PlayReadyDomainJoinServiceRequest_get_DomainServiceId, (setter)PlayReadyDomainJoinServiceRequest_put_DomainServiceId, nullptr, nullptr },
        { const_cast<char*>("domain_friendly_name"), (getter)PlayReadyDomainJoinServiceRequest_get_DomainFriendlyName, (setter)PlayReadyDomainJoinServiceRequest_put_DomainFriendlyName, nullptr, nullptr },
        { const_cast<char*>("domain_account_id"), (getter)PlayReadyDomainJoinServiceRequest_get_DomainAccountId, (setter)PlayReadyDomainJoinServiceRequest_put_DomainAccountId, nullptr, nullptr },
        { const_cast<char*>("uri"), (getter)PlayReadyDomainJoinServiceRequest_get_Uri, (setter)PlayReadyDomainJoinServiceRequest_put_Uri, nullptr, nullptr },
        { const_cast<char*>("challenge_custom_data"), (getter)PlayReadyDomainJoinServiceRequest_get_ChallengeCustomData, (setter)PlayReadyDomainJoinServiceRequest_put_ChallengeCustomData, nullptr, nullptr },
        { const_cast<char*>("response_custom_data"), (getter)PlayReadyDomainJoinServiceRequest_get_ResponseCustomData, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadyDomainJoinServiceRequest[] = 
    {
        { Py_tp_new, _new_PlayReadyDomainJoinServiceRequest },
        { Py_tp_dealloc, _dealloc_PlayReadyDomainJoinServiceRequest },
        { Py_tp_methods, _methods_PlayReadyDomainJoinServiceRequest },
        { Py_tp_getset, _getset_PlayReadyDomainJoinServiceRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadyDomainJoinServiceRequest =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadyDomainJoinServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyDomainJoinServiceRequest
    };

    // ----- PlayReadyDomainLeaveServiceRequest class --------------------
    constexpr const char* const _type_name_PlayReadyDomainLeaveServiceRequest = "PlayReadyDomainLeaveServiceRequest";

    static PyObject* _new_PlayReadyDomainLeaveServiceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyDomainLeaveServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.BeginServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GenerateManualEnablingChallenge());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.NextServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(self->obj.ProcessManualEnablingResponse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtectionSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_get_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DomainServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainLeaveServiceRequest_put_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.DomainServiceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_get_DomainAccountId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DomainAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainLeaveServiceRequest_put_DomainAccountId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.DomainAccountId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainLeaveServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyDomainLeaveServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyDomainLeaveServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayReadyDomainLeaveServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyDomainLeaveServiceRequest[] = {
        { "begin_service_request", (PyCFunction)PlayReadyDomainLeaveServiceRequest_BeginServiceRequest, METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", (PyCFunction)PlayReadyDomainLeaveServiceRequest_GenerateManualEnablingChallenge, METH_VARARGS, nullptr },
        { "next_service_request", (PyCFunction)PlayReadyDomainLeaveServiceRequest_NextServiceRequest, METH_VARARGS, nullptr },
        { "process_manual_enabling_response", (PyCFunction)PlayReadyDomainLeaveServiceRequest_ProcessManualEnablingResponse, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlayReadyDomainLeaveServiceRequest, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadyDomainLeaveServiceRequest[] = {
        { const_cast<char*>("protection_system"), (getter)PlayReadyDomainLeaveServiceRequest_get_ProtectionSystem, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)PlayReadyDomainLeaveServiceRequest_get_Type, nullptr, nullptr, nullptr },
        { const_cast<char*>("domain_service_id"), (getter)PlayReadyDomainLeaveServiceRequest_get_DomainServiceId, (setter)PlayReadyDomainLeaveServiceRequest_put_DomainServiceId, nullptr, nullptr },
        { const_cast<char*>("domain_account_id"), (getter)PlayReadyDomainLeaveServiceRequest_get_DomainAccountId, (setter)PlayReadyDomainLeaveServiceRequest_put_DomainAccountId, nullptr, nullptr },
        { const_cast<char*>("uri"), (getter)PlayReadyDomainLeaveServiceRequest_get_Uri, (setter)PlayReadyDomainLeaveServiceRequest_put_Uri, nullptr, nullptr },
        { const_cast<char*>("challenge_custom_data"), (getter)PlayReadyDomainLeaveServiceRequest_get_ChallengeCustomData, (setter)PlayReadyDomainLeaveServiceRequest_put_ChallengeCustomData, nullptr, nullptr },
        { const_cast<char*>("response_custom_data"), (getter)PlayReadyDomainLeaveServiceRequest_get_ResponseCustomData, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadyDomainLeaveServiceRequest[] = 
    {
        { Py_tp_new, _new_PlayReadyDomainLeaveServiceRequest },
        { Py_tp_dealloc, _dealloc_PlayReadyDomainLeaveServiceRequest },
        { Py_tp_methods, _methods_PlayReadyDomainLeaveServiceRequest },
        { Py_tp_getset, _getset_PlayReadyDomainLeaveServiceRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadyDomainLeaveServiceRequest =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadyDomainLeaveServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyDomainLeaveServiceRequest
    };

    // ----- PlayReadyITADataGenerator class --------------------
    constexpr const char* const _type_name_PlayReadyITADataGenerator = "PlayReadyITADataGenerator";

    static PyObject* _new_PlayReadyITADataGenerator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyITADataGenerator instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyITADataGenerator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyITADataGenerator* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayReadyITADataGenerator_GenerateData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyITADataGenerator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyITADataFormat>(args, 3);

                return py::convert(self->obj.GenerateData(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_PlayReadyITADataGenerator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyITADataGenerator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyITADataGenerator[] = {
        { "generate_data", (PyCFunction)PlayReadyITADataGenerator_GenerateData, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlayReadyITADataGenerator, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadyITADataGenerator[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadyITADataGenerator[] = 
    {
        { Py_tp_new, _new_PlayReadyITADataGenerator },
        { Py_tp_dealloc, _dealloc_PlayReadyITADataGenerator },
        { Py_tp_methods, _methods_PlayReadyITADataGenerator },
        { Py_tp_getset, _getset_PlayReadyITADataGenerator },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadyITADataGenerator =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadyITADataGenerator",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyITADataGenerator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyITADataGenerator
    };

    // ----- PlayReadyIndividualizationServiceRequest class --------------------
    constexpr const char* const _type_name_PlayReadyIndividualizationServiceRequest = "PlayReadyIndividualizationServiceRequest";

    static PyObject* _new_PlayReadyIndividualizationServiceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyIndividualizationServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.BeginServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GenerateManualEnablingChallenge());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.NextServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(self->obj.ProcessManualEnablingResponse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtectionSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyIndividualizationServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyIndividualizationServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyIndividualizationServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayReadyIndividualizationServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyIndividualizationServiceRequest[] = {
        { "begin_service_request", (PyCFunction)PlayReadyIndividualizationServiceRequest_BeginServiceRequest, METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", (PyCFunction)PlayReadyIndividualizationServiceRequest_GenerateManualEnablingChallenge, METH_VARARGS, nullptr },
        { "next_service_request", (PyCFunction)PlayReadyIndividualizationServiceRequest_NextServiceRequest, METH_VARARGS, nullptr },
        { "process_manual_enabling_response", (PyCFunction)PlayReadyIndividualizationServiceRequest_ProcessManualEnablingResponse, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlayReadyIndividualizationServiceRequest, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadyIndividualizationServiceRequest[] = {
        { const_cast<char*>("protection_system"), (getter)PlayReadyIndividualizationServiceRequest_get_ProtectionSystem, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)PlayReadyIndividualizationServiceRequest_get_Type, nullptr, nullptr, nullptr },
        { const_cast<char*>("uri"), (getter)PlayReadyIndividualizationServiceRequest_get_Uri, (setter)PlayReadyIndividualizationServiceRequest_put_Uri, nullptr, nullptr },
        { const_cast<char*>("challenge_custom_data"), (getter)PlayReadyIndividualizationServiceRequest_get_ChallengeCustomData, (setter)PlayReadyIndividualizationServiceRequest_put_ChallengeCustomData, nullptr, nullptr },
        { const_cast<char*>("response_custom_data"), (getter)PlayReadyIndividualizationServiceRequest_get_ResponseCustomData, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadyIndividualizationServiceRequest[] = 
    {
        { Py_tp_new, _new_PlayReadyIndividualizationServiceRequest },
        { Py_tp_dealloc, _dealloc_PlayReadyIndividualizationServiceRequest },
        { Py_tp_methods, _methods_PlayReadyIndividualizationServiceRequest },
        { Py_tp_getset, _getset_PlayReadyIndividualizationServiceRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadyIndividualizationServiceRequest =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadyIndividualizationServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyIndividualizationServiceRequest
    };

    // ----- PlayReadyLicense class --------------------
    constexpr const char* const _type_name_PlayReadyLicense = "PlayReadyLicense";

    static PyObject* _new_PlayReadyLicense(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayReadyLicense);
        return nullptr;
    }

    static void _dealloc_PlayReadyLicense(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayReadyLicense_GetKIDAtChainDepth(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetKIDAtChainDepth(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_ChainDepth(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChainDepth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_DomainAccountID(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DomainAccountID());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_ExpirationDate(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_ExpireAfterFirstPlay(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpireAfterFirstPlay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_FullyEvaluated(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FullyEvaluated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_UsableForPlay(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UsableForPlay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_ExpiresInRealTime(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpiresInRealTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_InMemoryOnly(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InMemoryOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_SecureStopId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SecureStopId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicense_get_SecurityLevel(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SecurityLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayReadyLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyLicense[] = {
        { "get_k_i_d_at_chain_depth", (PyCFunction)PlayReadyLicense_GetKIDAtChainDepth, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlayReadyLicense, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadyLicense[] = {
        { const_cast<char*>("chain_depth"), (getter)PlayReadyLicense_get_ChainDepth, nullptr, nullptr, nullptr },
        { const_cast<char*>("domain_account_i_d"), (getter)PlayReadyLicense_get_DomainAccountID, nullptr, nullptr, nullptr },
        { const_cast<char*>("expiration_date"), (getter)PlayReadyLicense_get_ExpirationDate, nullptr, nullptr, nullptr },
        { const_cast<char*>("expire_after_first_play"), (getter)PlayReadyLicense_get_ExpireAfterFirstPlay, nullptr, nullptr, nullptr },
        { const_cast<char*>("fully_evaluated"), (getter)PlayReadyLicense_get_FullyEvaluated, nullptr, nullptr, nullptr },
        { const_cast<char*>("usable_for_play"), (getter)PlayReadyLicense_get_UsableForPlay, nullptr, nullptr, nullptr },
        { const_cast<char*>("expires_in_real_time"), (getter)PlayReadyLicense_get_ExpiresInRealTime, nullptr, nullptr, nullptr },
        { const_cast<char*>("in_memory_only"), (getter)PlayReadyLicense_get_InMemoryOnly, nullptr, nullptr, nullptr },
        { const_cast<char*>("secure_stop_id"), (getter)PlayReadyLicense_get_SecureStopId, nullptr, nullptr, nullptr },
        { const_cast<char*>("security_level"), (getter)PlayReadyLicense_get_SecurityLevel, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadyLicense[] = 
    {
        { Py_tp_new, _new_PlayReadyLicense },
        { Py_tp_dealloc, _dealloc_PlayReadyLicense },
        { Py_tp_methods, _methods_PlayReadyLicense },
        { Py_tp_getset, _getset_PlayReadyLicense },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadyLicense =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadyLicense",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicense),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyLicense
    };

    // ----- PlayReadyLicenseAcquisitionServiceRequest class --------------------
    constexpr const char* const _type_name_PlayReadyLicenseAcquisitionServiceRequest = "PlayReadyLicenseAcquisitionServiceRequest";

    static PyObject* _new_PlayReadyLicenseAcquisitionServiceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyLicenseAcquisitionServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.BeginServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_CreateLicenseIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.CreateLicenseIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GenerateManualEnablingChallenge());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.NextServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(self->obj.ProcessManualEnablingResponse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtectionSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DomainServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyLicenseAcquisitionServiceRequest_put_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.DomainServiceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_ContentHeader(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentHeader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyLicenseAcquisitionServiceRequest_put_ContentHeader(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(arg);

            self->obj.ContentHeader(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_SessionId(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SessionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyLicenseAcquisitionServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyLicenseAcquisitionServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyLicenseAcquisitionServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayReadyLicenseAcquisitionServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyLicenseAcquisitionServiceRequest[] = {
        { "begin_service_request", (PyCFunction)PlayReadyLicenseAcquisitionServiceRequest_BeginServiceRequest, METH_VARARGS, nullptr },
        { "create_license_iterable", (PyCFunction)PlayReadyLicenseAcquisitionServiceRequest_CreateLicenseIterable, METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", (PyCFunction)PlayReadyLicenseAcquisitionServiceRequest_GenerateManualEnablingChallenge, METH_VARARGS, nullptr },
        { "next_service_request", (PyCFunction)PlayReadyLicenseAcquisitionServiceRequest_NextServiceRequest, METH_VARARGS, nullptr },
        { "process_manual_enabling_response", (PyCFunction)PlayReadyLicenseAcquisitionServiceRequest_ProcessManualEnablingResponse, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlayReadyLicenseAcquisitionServiceRequest, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadyLicenseAcquisitionServiceRequest[] = {
        { const_cast<char*>("protection_system"), (getter)PlayReadyLicenseAcquisitionServiceRequest_get_ProtectionSystem, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)PlayReadyLicenseAcquisitionServiceRequest_get_Type, nullptr, nullptr, nullptr },
        { const_cast<char*>("domain_service_id"), (getter)PlayReadyLicenseAcquisitionServiceRequest_get_DomainServiceId, (setter)PlayReadyLicenseAcquisitionServiceRequest_put_DomainServiceId, nullptr, nullptr },
        { const_cast<char*>("content_header"), (getter)PlayReadyLicenseAcquisitionServiceRequest_get_ContentHeader, (setter)PlayReadyLicenseAcquisitionServiceRequest_put_ContentHeader, nullptr, nullptr },
        { const_cast<char*>("session_id"), (getter)PlayReadyLicenseAcquisitionServiceRequest_get_SessionId, nullptr, nullptr, nullptr },
        { const_cast<char*>("uri"), (getter)PlayReadyLicenseAcquisitionServiceRequest_get_Uri, (setter)PlayReadyLicenseAcquisitionServiceRequest_put_Uri, nullptr, nullptr },
        { const_cast<char*>("challenge_custom_data"), (getter)PlayReadyLicenseAcquisitionServiceRequest_get_ChallengeCustomData, (setter)PlayReadyLicenseAcquisitionServiceRequest_put_ChallengeCustomData, nullptr, nullptr },
        { const_cast<char*>("response_custom_data"), (getter)PlayReadyLicenseAcquisitionServiceRequest_get_ResponseCustomData, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadyLicenseAcquisitionServiceRequest[] = 
    {
        { Py_tp_new, _new_PlayReadyLicenseAcquisitionServiceRequest },
        { Py_tp_dealloc, _dealloc_PlayReadyLicenseAcquisitionServiceRequest },
        { Py_tp_methods, _methods_PlayReadyLicenseAcquisitionServiceRequest },
        { Py_tp_getset, _getset_PlayReadyLicenseAcquisitionServiceRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadyLicenseAcquisitionServiceRequest =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadyLicenseAcquisitionServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyLicenseAcquisitionServiceRequest
    };

    // ----- PlayReadyLicenseIterable class --------------------
    constexpr const char* const _type_name_PlayReadyLicenseIterable = "PlayReadyLicenseIterable";

    static PyObject* _new_PlayReadyLicenseIterable(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyLicenseIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayReadyLicenseIterable_First(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_PlayReadyLicenseIterable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PlayReadyLicenseIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyLicenseIterable[] = {
        { "first", (PyCFunction)PlayReadyLicenseIterable_First, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlayReadyLicenseIterable, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadyLicenseIterable[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadyLicenseIterable[] = 
    {
        { Py_tp_new, _new_PlayReadyLicenseIterable },
        { Py_tp_dealloc, _dealloc_PlayReadyLicenseIterable },
        { Py_tp_methods, _methods_PlayReadyLicenseIterable },
        { Py_tp_getset, _getset_PlayReadyLicenseIterable },
        { Py_tp_iter, _iterator_PlayReadyLicenseIterable },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadyLicenseIterable =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadyLicenseIterable",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyLicenseIterable
    };

    // ----- PlayReadyLicenseIterator class --------------------
    constexpr const char* const _type_name_PlayReadyLicenseIterator = "PlayReadyLicenseIterator";

    static PyObject* _new_PlayReadyLicenseIterator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayReadyLicenseIterator);
        return nullptr;
    }

    static void _dealloc_PlayReadyLicenseIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayReadyLicenseIterator_GetMany(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0_count = py::convert_to<winrt::com_array<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicense>::size_type>(args, 0);
                winrt::com_array<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicense> param0 ( param0_count, py::empty_instance<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicense>::get() );

                auto return_value = self->obj.GetMany(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseIterator_MoveNext(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.MoveNext());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseIterator_get_Current(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseIterator_get_HasCurrent(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasCurrent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayReadyLicenseIterator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PlayReadyLicenseIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator* self) noexcept
    {
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _iterator_next_PlayReadyLicenseIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator* self) noexcept
    {
        try
        {
            if (self->obj.HasCurrent())
            {
                auto cur = self->obj.Current();
                self->obj.MoveNext();
                return py::convert(cur);
            }
            else
            {
                return nullptr;
            }}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyLicenseIterator[] = {
        { "get_many", (PyCFunction)PlayReadyLicenseIterator_GetMany, METH_VARARGS, nullptr },
        { "move_next", (PyCFunction)PlayReadyLicenseIterator_MoveNext, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlayReadyLicenseIterator, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadyLicenseIterator[] = {
        { const_cast<char*>("current"), (getter)PlayReadyLicenseIterator_get_Current, nullptr, nullptr, nullptr },
        { const_cast<char*>("has_current"), (getter)PlayReadyLicenseIterator_get_HasCurrent, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadyLicenseIterator[] = 
    {
        { Py_tp_new, _new_PlayReadyLicenseIterator },
        { Py_tp_dealloc, _dealloc_PlayReadyLicenseIterator },
        { Py_tp_methods, _methods_PlayReadyLicenseIterator },
        { Py_tp_getset, _getset_PlayReadyLicenseIterator },
        { Py_tp_iter, _iterator_PlayReadyLicenseIterator },
        { Py_tp_iternext, _iterator_next_PlayReadyLicenseIterator },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadyLicenseIterator =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadyLicenseIterator",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyLicenseIterator
    };

    // ----- PlayReadyLicenseManagement class --------------------
    constexpr const char* const _type_name_PlayReadyLicenseManagement = "PlayReadyLicenseManagement";

    static PyObject* _new_PlayReadyLicenseManagement(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayReadyLicenseManagement);
        return nullptr;
    }

    static PyObject* PlayReadyLicenseManagement_DeleteLicenses(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(args, 0);

                return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseManagement::DeleteLicenses(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyLicenseManagement[] = {
        { "delete_licenses", (PyCFunction)PlayReadyLicenseManagement_DeleteLicenses, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadyLicenseManagement[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadyLicenseManagement[] = 
    {
        { Py_tp_new, _new_PlayReadyLicenseManagement },
        { Py_tp_methods, _methods_PlayReadyLicenseManagement },
        { Py_tp_getset, _getset_PlayReadyLicenseManagement },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadyLicenseManagement =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadyLicenseManagement",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyLicenseManagement
    };

    // ----- PlayReadyLicenseSession class --------------------
    constexpr const char* const _type_name_PlayReadyLicenseSession = "PlayReadyLicenseSession";

    static PyObject* _new_PlayReadyLicenseSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyLicenseSession(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayReadyLicenseSession_ConfigureMediaProtectionManager(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::MediaProtectionManager>(args, 0);

                self->obj.ConfigureMediaProtectionManager(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseSession_CreateLAServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateLAServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyLicenseSession_CreateLicenseIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.CreateLicenseIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_PlayReadyLicenseSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyLicenseSession[] = {
        { "configure_media_protection_manager", (PyCFunction)PlayReadyLicenseSession_ConfigureMediaProtectionManager, METH_VARARGS, nullptr },
        { "create_l_a_service_request", (PyCFunction)PlayReadyLicenseSession_CreateLAServiceRequest, METH_VARARGS, nullptr },
        { "create_license_iterable", (PyCFunction)PlayReadyLicenseSession_CreateLicenseIterable, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlayReadyLicenseSession, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadyLicenseSession[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadyLicenseSession[] = 
    {
        { Py_tp_new, _new_PlayReadyLicenseSession },
        { Py_tp_dealloc, _dealloc_PlayReadyLicenseSession },
        { Py_tp_methods, _methods_PlayReadyLicenseSession },
        { Py_tp_getset, _getset_PlayReadyLicenseSession },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadyLicenseSession =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadyLicenseSession",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyLicenseSession
    };

    // ----- PlayReadyMeteringReportServiceRequest class --------------------
    constexpr const char* const _type_name_PlayReadyMeteringReportServiceRequest = "PlayReadyMeteringReportServiceRequest";

    static PyObject* _new_PlayReadyMeteringReportServiceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyMeteringReportServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.BeginServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GenerateManualEnablingChallenge());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.NextServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(self->obj.ProcessManualEnablingResponse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtectionSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_get_MeteringCertificate(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MeteringCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyMeteringReportServiceRequest_put_MeteringCertificate(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::array_view<uint8_t>>(arg);

            self->obj.MeteringCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyMeteringReportServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyMeteringReportServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyMeteringReportServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayReadyMeteringReportServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyMeteringReportServiceRequest[] = {
        { "begin_service_request", (PyCFunction)PlayReadyMeteringReportServiceRequest_BeginServiceRequest, METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", (PyCFunction)PlayReadyMeteringReportServiceRequest_GenerateManualEnablingChallenge, METH_VARARGS, nullptr },
        { "next_service_request", (PyCFunction)PlayReadyMeteringReportServiceRequest_NextServiceRequest, METH_VARARGS, nullptr },
        { "process_manual_enabling_response", (PyCFunction)PlayReadyMeteringReportServiceRequest_ProcessManualEnablingResponse, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlayReadyMeteringReportServiceRequest, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadyMeteringReportServiceRequest[] = {
        { const_cast<char*>("protection_system"), (getter)PlayReadyMeteringReportServiceRequest_get_ProtectionSystem, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)PlayReadyMeteringReportServiceRequest_get_Type, nullptr, nullptr, nullptr },
        { const_cast<char*>("metering_certificate"), (getter)PlayReadyMeteringReportServiceRequest_get_MeteringCertificate, (setter)PlayReadyMeteringReportServiceRequest_put_MeteringCertificate, nullptr, nullptr },
        { const_cast<char*>("uri"), (getter)PlayReadyMeteringReportServiceRequest_get_Uri, (setter)PlayReadyMeteringReportServiceRequest_put_Uri, nullptr, nullptr },
        { const_cast<char*>("challenge_custom_data"), (getter)PlayReadyMeteringReportServiceRequest_get_ChallengeCustomData, (setter)PlayReadyMeteringReportServiceRequest_put_ChallengeCustomData, nullptr, nullptr },
        { const_cast<char*>("response_custom_data"), (getter)PlayReadyMeteringReportServiceRequest_get_ResponseCustomData, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadyMeteringReportServiceRequest[] = 
    {
        { Py_tp_new, _new_PlayReadyMeteringReportServiceRequest },
        { Py_tp_dealloc, _dealloc_PlayReadyMeteringReportServiceRequest },
        { Py_tp_methods, _methods_PlayReadyMeteringReportServiceRequest },
        { Py_tp_getset, _getset_PlayReadyMeteringReportServiceRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadyMeteringReportServiceRequest =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadyMeteringReportServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyMeteringReportServiceRequest
    };

    // ----- PlayReadyRevocationServiceRequest class --------------------
    constexpr const char* const _type_name_PlayReadyRevocationServiceRequest = "PlayReadyRevocationServiceRequest";

    static PyObject* _new_PlayReadyRevocationServiceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadyRevocationServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayReadyRevocationServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.BeginServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GenerateManualEnablingChallenge());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.NextServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(self->obj.ProcessManualEnablingResponse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtectionSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyRevocationServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadyRevocationServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadyRevocationServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayReadyRevocationServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyRevocationServiceRequest[] = {
        { "begin_service_request", (PyCFunction)PlayReadyRevocationServiceRequest_BeginServiceRequest, METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", (PyCFunction)PlayReadyRevocationServiceRequest_GenerateManualEnablingChallenge, METH_VARARGS, nullptr },
        { "next_service_request", (PyCFunction)PlayReadyRevocationServiceRequest_NextServiceRequest, METH_VARARGS, nullptr },
        { "process_manual_enabling_response", (PyCFunction)PlayReadyRevocationServiceRequest_ProcessManualEnablingResponse, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlayReadyRevocationServiceRequest, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadyRevocationServiceRequest[] = {
        { const_cast<char*>("protection_system"), (getter)PlayReadyRevocationServiceRequest_get_ProtectionSystem, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)PlayReadyRevocationServiceRequest_get_Type, nullptr, nullptr, nullptr },
        { const_cast<char*>("uri"), (getter)PlayReadyRevocationServiceRequest_get_Uri, (setter)PlayReadyRevocationServiceRequest_put_Uri, nullptr, nullptr },
        { const_cast<char*>("challenge_custom_data"), (getter)PlayReadyRevocationServiceRequest_get_ChallengeCustomData, (setter)PlayReadyRevocationServiceRequest_put_ChallengeCustomData, nullptr, nullptr },
        { const_cast<char*>("response_custom_data"), (getter)PlayReadyRevocationServiceRequest_get_ResponseCustomData, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadyRevocationServiceRequest[] = 
    {
        { Py_tp_new, _new_PlayReadyRevocationServiceRequest },
        { Py_tp_dealloc, _dealloc_PlayReadyRevocationServiceRequest },
        { Py_tp_methods, _methods_PlayReadyRevocationServiceRequest },
        { Py_tp_getset, _getset_PlayReadyRevocationServiceRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadyRevocationServiceRequest =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadyRevocationServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyRevocationServiceRequest
    };

    // ----- PlayReadySecureStopIterable class --------------------
    constexpr const char* const _type_name_PlayReadySecureStopIterable = "PlayReadySecureStopIterable";

    static PyObject* _new_PlayReadySecureStopIterable(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadySecureStopIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayReadySecureStopIterable_First(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_PlayReadySecureStopIterable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PlayReadySecureStopIterable(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadySecureStopIterable[] = {
        { "first", (PyCFunction)PlayReadySecureStopIterable_First, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlayReadySecureStopIterable, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadySecureStopIterable[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadySecureStopIterable[] = 
    {
        { Py_tp_new, _new_PlayReadySecureStopIterable },
        { Py_tp_dealloc, _dealloc_PlayReadySecureStopIterable },
        { Py_tp_methods, _methods_PlayReadySecureStopIterable },
        { Py_tp_getset, _getset_PlayReadySecureStopIterable },
        { Py_tp_iter, _iterator_PlayReadySecureStopIterable },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadySecureStopIterable =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadySecureStopIterable",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadySecureStopIterable
    };

    // ----- PlayReadySecureStopIterator class --------------------
    constexpr const char* const _type_name_PlayReadySecureStopIterator = "PlayReadySecureStopIterator";

    static PyObject* _new_PlayReadySecureStopIterator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayReadySecureStopIterator);
        return nullptr;
    }

    static void _dealloc_PlayReadySecureStopIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayReadySecureStopIterator_GetMany(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0_count = py::convert_to<winrt::com_array<winrt::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest>::size_type>(args, 0);
                winrt::com_array<winrt::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest> param0 ( param0_count, py::empty_instance<winrt::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest>::get() );

                auto return_value = self->obj.GetMany(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopIterator_MoveNext(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.MoveNext());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopIterator_get_Current(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopIterator_get_HasCurrent(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasCurrent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayReadySecureStopIterator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PlayReadySecureStopIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator* self) noexcept
    {
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _iterator_next_PlayReadySecureStopIterator(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator* self) noexcept
    {
        try
        {
            if (self->obj.HasCurrent())
            {
                auto cur = self->obj.Current();
                self->obj.MoveNext();
                return py::convert(cur);
            }
            else
            {
                return nullptr;
            }}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadySecureStopIterator[] = {
        { "get_many", (PyCFunction)PlayReadySecureStopIterator_GetMany, METH_VARARGS, nullptr },
        { "move_next", (PyCFunction)PlayReadySecureStopIterator_MoveNext, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlayReadySecureStopIterator, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadySecureStopIterator[] = {
        { const_cast<char*>("current"), (getter)PlayReadySecureStopIterator_get_Current, nullptr, nullptr, nullptr },
        { const_cast<char*>("has_current"), (getter)PlayReadySecureStopIterator_get_HasCurrent, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadySecureStopIterator[] = 
    {
        { Py_tp_new, _new_PlayReadySecureStopIterator },
        { Py_tp_dealloc, _dealloc_PlayReadySecureStopIterator },
        { Py_tp_methods, _methods_PlayReadySecureStopIterator },
        { Py_tp_getset, _getset_PlayReadySecureStopIterator },
        { Py_tp_iter, _iterator_PlayReadySecureStopIterator },
        { Py_tp_iternext, _iterator_next_PlayReadySecureStopIterator },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadySecureStopIterator =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadySecureStopIterator",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadySecureStopIterator
    };

    // ----- PlayReadySecureStopServiceRequest class --------------------
    constexpr const char* const _type_name_PlayReadySecureStopServiceRequest = "PlayReadySecureStopServiceRequest";

    static PyObject* _new_PlayReadySecureStopServiceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayReadySecureStopServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayReadySecureStopServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.BeginServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GenerateManualEnablingChallenge());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.NextServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(self->obj.ProcessManualEnablingResponse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtectionSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_PublisherCertificate(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PublisherCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_SessionID(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SessionID());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_StartTime(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_Stopped(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Stopped());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_UpdateTime(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadySecureStopServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayReadySecureStopServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayReadySecureStopServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayReadySecureStopServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadySecureStopServiceRequest[] = {
        { "begin_service_request", (PyCFunction)PlayReadySecureStopServiceRequest_BeginServiceRequest, METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", (PyCFunction)PlayReadySecureStopServiceRequest_GenerateManualEnablingChallenge, METH_VARARGS, nullptr },
        { "next_service_request", (PyCFunction)PlayReadySecureStopServiceRequest_NextServiceRequest, METH_VARARGS, nullptr },
        { "process_manual_enabling_response", (PyCFunction)PlayReadySecureStopServiceRequest_ProcessManualEnablingResponse, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlayReadySecureStopServiceRequest, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadySecureStopServiceRequest[] = {
        { const_cast<char*>("protection_system"), (getter)PlayReadySecureStopServiceRequest_get_ProtectionSystem, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)PlayReadySecureStopServiceRequest_get_Type, nullptr, nullptr, nullptr },
        { const_cast<char*>("publisher_certificate"), (getter)PlayReadySecureStopServiceRequest_get_PublisherCertificate, nullptr, nullptr, nullptr },
        { const_cast<char*>("session_i_d"), (getter)PlayReadySecureStopServiceRequest_get_SessionID, nullptr, nullptr, nullptr },
        { const_cast<char*>("start_time"), (getter)PlayReadySecureStopServiceRequest_get_StartTime, nullptr, nullptr, nullptr },
        { const_cast<char*>("stopped"), (getter)PlayReadySecureStopServiceRequest_get_Stopped, nullptr, nullptr, nullptr },
        { const_cast<char*>("update_time"), (getter)PlayReadySecureStopServiceRequest_get_UpdateTime, nullptr, nullptr, nullptr },
        { const_cast<char*>("uri"), (getter)PlayReadySecureStopServiceRequest_get_Uri, (setter)PlayReadySecureStopServiceRequest_put_Uri, nullptr, nullptr },
        { const_cast<char*>("challenge_custom_data"), (getter)PlayReadySecureStopServiceRequest_get_ChallengeCustomData, (setter)PlayReadySecureStopServiceRequest_put_ChallengeCustomData, nullptr, nullptr },
        { const_cast<char*>("response_custom_data"), (getter)PlayReadySecureStopServiceRequest_get_ResponseCustomData, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadySecureStopServiceRequest[] = 
    {
        { Py_tp_new, _new_PlayReadySecureStopServiceRequest },
        { Py_tp_dealloc, _dealloc_PlayReadySecureStopServiceRequest },
        { Py_tp_methods, _methods_PlayReadySecureStopServiceRequest },
        { Py_tp_getset, _getset_PlayReadySecureStopServiceRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadySecureStopServiceRequest =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadySecureStopServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadySecureStopServiceRequest
    };

    // ----- PlayReadySoapMessage class --------------------
    constexpr const char* const _type_name_PlayReadySoapMessage = "PlayReadySoapMessage";

    static PyObject* _new_PlayReadySoapMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayReadySoapMessage);
        return nullptr;
    }

    static void _dealloc_PlayReadySoapMessage(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySoapMessage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayReadySoapMessage_GetMessageBody(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySoapMessage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetMessageBody());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadySoapMessage_get_MessageHeaders(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySoapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageHeaders());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadySoapMessage_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySoapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayReadySoapMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::PlayReadySoapMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadySoapMessage[] = {
        { "get_message_body", (PyCFunction)PlayReadySoapMessage_GetMessageBody, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PlayReadySoapMessage, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadySoapMessage[] = {
        { const_cast<char*>("message_headers"), (getter)PlayReadySoapMessage_get_MessageHeaders, nullptr, nullptr, nullptr },
        { const_cast<char*>("uri"), (getter)PlayReadySoapMessage_get_Uri, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadySoapMessage[] = 
    {
        { Py_tp_new, _new_PlayReadySoapMessage },
        { Py_tp_dealloc, _dealloc_PlayReadySoapMessage },
        { Py_tp_methods, _methods_PlayReadySoapMessage },
        { Py_tp_getset, _getset_PlayReadySoapMessage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadySoapMessage =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadySoapMessage",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::PlayReadySoapMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadySoapMessage
    };

    // ----- PlayReadyStatics class --------------------
    constexpr const char* const _type_name_PlayReadyStatics = "PlayReadyStatics";

    static PyObject* _new_PlayReadyStatics(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayReadyStatics);
        return nullptr;
    }

    static PyObject* PlayReadyStatics_CheckSupportedHardware(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyHardwareDRMFeatures>(args, 0);

                return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::CheckSupportedHardware(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_ResetHardwareDRMDisabled(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::ResetHardwareDRMDisabled();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_DomainJoinServiceRequestType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::DomainJoinServiceRequestType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_DomainLeaveServiceRequestType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::DomainLeaveServiceRequestType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_IndividualizationServiceRequestType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::IndividualizationServiceRequestType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_LicenseAcquirerServiceRequestType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::LicenseAcquirerServiceRequestType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_MediaProtectionSystemId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::MediaProtectionSystemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_MeteringReportServiceRequestType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::MeteringReportServiceRequestType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_PlayReadySecurityVersion(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::PlayReadySecurityVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_RevocationServiceRequestType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::RevocationServiceRequestType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_PlayReadyCertificateSecurityLevel(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::PlayReadyCertificateSecurityLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_SecureStopServiceRequestType(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::SecureStopServiceRequestType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_ProtectionSystemId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::ProtectionSystemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_InputTrustAuthorityToCreate(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::InputTrustAuthorityToCreate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_HardwareDRMDisabledUntilTime(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::HardwareDRMDisabledUntilTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayReadyStatics_get_HardwareDRMDisabledAtTime(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics::HardwareDRMDisabledAtTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayReadyStatics[] = {
        { "check_supported_hardware", (PyCFunction)PlayReadyStatics_CheckSupportedHardware, METH_VARARGS | METH_STATIC, nullptr },
        { "reset_hardware_d_r_m_disabled", (PyCFunction)PlayReadyStatics_ResetHardwareDRMDisabled, METH_VARARGS | METH_STATIC, nullptr },
        { "get_domain_join_service_request_type", (PyCFunction)PlayReadyStatics_get_DomainJoinServiceRequestType, METH_NOARGS | METH_STATIC, nullptr },
        { "get_domain_leave_service_request_type", (PyCFunction)PlayReadyStatics_get_DomainLeaveServiceRequestType, METH_NOARGS | METH_STATIC, nullptr },
        { "get_individualization_service_request_type", (PyCFunction)PlayReadyStatics_get_IndividualizationServiceRequestType, METH_NOARGS | METH_STATIC, nullptr },
        { "get_license_acquirer_service_request_type", (PyCFunction)PlayReadyStatics_get_LicenseAcquirerServiceRequestType, METH_NOARGS | METH_STATIC, nullptr },
        { "get_media_protection_system_id", (PyCFunction)PlayReadyStatics_get_MediaProtectionSystemId, METH_NOARGS | METH_STATIC, nullptr },
        { "get_metering_report_service_request_type", (PyCFunction)PlayReadyStatics_get_MeteringReportServiceRequestType, METH_NOARGS | METH_STATIC, nullptr },
        { "get_play_ready_security_version", (PyCFunction)PlayReadyStatics_get_PlayReadySecurityVersion, METH_NOARGS | METH_STATIC, nullptr },
        { "get_revocation_service_request_type", (PyCFunction)PlayReadyStatics_get_RevocationServiceRequestType, METH_NOARGS | METH_STATIC, nullptr },
        { "get_play_ready_certificate_security_level", (PyCFunction)PlayReadyStatics_get_PlayReadyCertificateSecurityLevel, METH_NOARGS | METH_STATIC, nullptr },
        { "get_secure_stop_service_request_type", (PyCFunction)PlayReadyStatics_get_SecureStopServiceRequestType, METH_NOARGS | METH_STATIC, nullptr },
        { "get_protection_system_id", (PyCFunction)PlayReadyStatics_get_ProtectionSystemId, METH_NOARGS | METH_STATIC, nullptr },
        { "get_input_trust_authority_to_create", (PyCFunction)PlayReadyStatics_get_InputTrustAuthorityToCreate, METH_NOARGS | METH_STATIC, nullptr },
        { "get_hardware_d_r_m_disabled_until_time", (PyCFunction)PlayReadyStatics_get_HardwareDRMDisabledUntilTime, METH_NOARGS | METH_STATIC, nullptr },
        { "get_hardware_d_r_m_disabled_at_time", (PyCFunction)PlayReadyStatics_get_HardwareDRMDisabledAtTime, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PlayReadyStatics[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PlayReadyStatics[] = 
    {
        { Py_tp_new, _new_PlayReadyStatics },
        { Py_tp_methods, _methods_PlayReadyStatics },
        { Py_tp_getset, _getset_PlayReadyStatics },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayReadyStatics =
    {
        "_winrt_Windows_Media_Protection_PlayReady.PlayReadyStatics",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayReadyStatics
    };

    // ----- INDClosedCaptionDataReceivedEventArgs interface --------------------
    constexpr const char* const _type_name_INDClosedCaptionDataReceivedEventArgs = "INDClosedCaptionDataReceivedEventArgs";

    static PyObject* _new_INDClosedCaptionDataReceivedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_INDClosedCaptionDataReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_INDClosedCaptionDataReceivedEventArgs(py::wrapper::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* INDClosedCaptionDataReceivedEventArgs_get_ClosedCaptionData(py::wrapper::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ClosedCaptionData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDClosedCaptionDataReceivedEventArgs_get_ClosedCaptionDataFormat(py::wrapper::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ClosedCaptionDataFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDClosedCaptionDataReceivedEventArgs_get_PresentationTimestamp(py::wrapper::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PresentationTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_INDClosedCaptionDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDClosedCaptionDataReceivedEventArgs[] = {
        { "_from", (PyCFunction)_from_INDClosedCaptionDataReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_INDClosedCaptionDataReceivedEventArgs[] = {
        { const_cast<char*>("closed_caption_data"), (getter)INDClosedCaptionDataReceivedEventArgs_get_ClosedCaptionData, nullptr, nullptr, nullptr },
        { const_cast<char*>("closed_caption_data_format"), (getter)INDClosedCaptionDataReceivedEventArgs_get_ClosedCaptionDataFormat, nullptr, nullptr, nullptr },
        { const_cast<char*>("presentation_timestamp"), (getter)INDClosedCaptionDataReceivedEventArgs_get_PresentationTimestamp, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_INDClosedCaptionDataReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_INDClosedCaptionDataReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_INDClosedCaptionDataReceivedEventArgs },
        { Py_tp_methods, _methods_INDClosedCaptionDataReceivedEventArgs },
        { Py_tp_getset, _getset_INDClosedCaptionDataReceivedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_INDClosedCaptionDataReceivedEventArgs =
    {
        "_winrt_Windows_Media_Protection_PlayReady.INDClosedCaptionDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDClosedCaptionDataReceivedEventArgs
    };

    // ----- INDCustomData interface --------------------
    constexpr const char* const _type_name_INDCustomData = "INDCustomData";

    static PyObject* _new_INDCustomData(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_INDCustomData);
        return nullptr;
    }

    static void _dealloc_INDCustomData(py::wrapper::Windows::Media::Protection::PlayReady::INDCustomData* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* INDCustomData_get_CustomData(py::wrapper::Windows::Media::Protection::PlayReady::INDCustomData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDCustomData_get_CustomDataTypeID(py::wrapper::Windows::Media::Protection::PlayReady::INDCustomData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CustomDataTypeID());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_INDCustomData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDCustomData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDCustomData[] = {
        { "_from", (PyCFunction)_from_INDCustomData, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_INDCustomData[] = {
        { const_cast<char*>("custom_data"), (getter)INDCustomData_get_CustomData, nullptr, nullptr, nullptr },
        { const_cast<char*>("custom_data_type_i_d"), (getter)INDCustomData_get_CustomDataTypeID, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_INDCustomData[] = 
    {
        { Py_tp_new, _new_INDCustomData },
        { Py_tp_dealloc, _dealloc_INDCustomData },
        { Py_tp_methods, _methods_INDCustomData },
        { Py_tp_getset, _getset_INDCustomData },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_INDCustomData =
    {
        "_winrt_Windows_Media_Protection_PlayReady.INDCustomData",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDCustomData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDCustomData
    };

    // ----- INDDownloadEngine interface --------------------
    constexpr const char* const _type_name_INDDownloadEngine = "INDDownloadEngine";

    static PyObject* _new_INDDownloadEngine(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_INDDownloadEngine);
        return nullptr;
    }

    static void _dealloc_INDDownloadEngine(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* INDDownloadEngine_Close(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_Open(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                self->obj.Open(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_Pause(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Pause();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_Resume(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Resume();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_Seek(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_get_BufferFullMaxThresholdInSamples(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BufferFullMaxThresholdInSamples());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_get_BufferFullMinThresholdInSamples(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BufferFullMinThresholdInSamples());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_get_CanSeek(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanSeek());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngine_get_Notifier(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Notifier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_INDDownloadEngine(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngine>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDDownloadEngine[] = {
        { "close", (PyCFunction)INDDownloadEngine_Close, METH_VARARGS, nullptr },
        { "open", (PyCFunction)INDDownloadEngine_Open, METH_VARARGS, nullptr },
        { "pause", (PyCFunction)INDDownloadEngine_Pause, METH_VARARGS, nullptr },
        { "resume", (PyCFunction)INDDownloadEngine_Resume, METH_VARARGS, nullptr },
        { "seek", (PyCFunction)INDDownloadEngine_Seek, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_INDDownloadEngine, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_INDDownloadEngine[] = {
        { const_cast<char*>("buffer_full_max_threshold_in_samples"), (getter)INDDownloadEngine_get_BufferFullMaxThresholdInSamples, nullptr, nullptr, nullptr },
        { const_cast<char*>("buffer_full_min_threshold_in_samples"), (getter)INDDownloadEngine_get_BufferFullMinThresholdInSamples, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_seek"), (getter)INDDownloadEngine_get_CanSeek, nullptr, nullptr, nullptr },
        { const_cast<char*>("notifier"), (getter)INDDownloadEngine_get_Notifier, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_INDDownloadEngine[] = 
    {
        { Py_tp_new, _new_INDDownloadEngine },
        { Py_tp_dealloc, _dealloc_INDDownloadEngine },
        { Py_tp_methods, _methods_INDDownloadEngine },
        { Py_tp_getset, _getset_INDDownloadEngine },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_INDDownloadEngine =
    {
        "_winrt_Windows_Media_Protection_PlayReady.INDDownloadEngine",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngine),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDDownloadEngine
    };

    // ----- INDDownloadEngineNotifier interface --------------------
    constexpr const char* const _type_name_INDDownloadEngineNotifier = "INDDownloadEngineNotifier";

    static PyObject* _new_INDDownloadEngineNotifier(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_INDDownloadEngineNotifier);
        return nullptr;
    }

    static void _dealloc_INDDownloadEngineNotifier(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* INDDownloadEngineNotifier_OnContentIDReceived(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>(args, 0);

                self->obj.OnContentIDReceived(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngineNotifier_OnDataReceived(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.OnDataReceived(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngineNotifier_OnEndOfStream(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.OnEndOfStream();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngineNotifier_OnNetworkError(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.OnNetworkError();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngineNotifier_OnPlayReadyObjectReceived(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                self->obj.OnPlayReadyObjectReceived(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDDownloadEngineNotifier_OnStreamOpened(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.OnStreamOpened();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_INDDownloadEngineNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDDownloadEngineNotifier[] = {
        { "on_content_i_d_received", (PyCFunction)INDDownloadEngineNotifier_OnContentIDReceived, METH_VARARGS, nullptr },
        { "on_data_received", (PyCFunction)INDDownloadEngineNotifier_OnDataReceived, METH_VARARGS, nullptr },
        { "on_end_of_stream", (PyCFunction)INDDownloadEngineNotifier_OnEndOfStream, METH_VARARGS, nullptr },
        { "on_network_error", (PyCFunction)INDDownloadEngineNotifier_OnNetworkError, METH_VARARGS, nullptr },
        { "on_play_ready_object_received", (PyCFunction)INDDownloadEngineNotifier_OnPlayReadyObjectReceived, METH_VARARGS, nullptr },
        { "on_stream_opened", (PyCFunction)INDDownloadEngineNotifier_OnStreamOpened, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_INDDownloadEngineNotifier, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_INDDownloadEngineNotifier[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_INDDownloadEngineNotifier[] = 
    {
        { Py_tp_new, _new_INDDownloadEngineNotifier },
        { Py_tp_dealloc, _dealloc_INDDownloadEngineNotifier },
        { Py_tp_methods, _methods_INDDownloadEngineNotifier },
        { Py_tp_getset, _getset_INDDownloadEngineNotifier },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_INDDownloadEngineNotifier =
    {
        "_winrt_Windows_Media_Protection_PlayReady.INDDownloadEngineNotifier",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDDownloadEngineNotifier
    };

    // ----- INDLicenseFetchCompletedEventArgs interface --------------------
    constexpr const char* const _type_name_INDLicenseFetchCompletedEventArgs = "INDLicenseFetchCompletedEventArgs";

    static PyObject* _new_INDLicenseFetchCompletedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_INDLicenseFetchCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_INDLicenseFetchCompletedEventArgs(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* INDLicenseFetchCompletedEventArgs_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_INDLicenseFetchCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDLicenseFetchCompletedEventArgs[] = {
        { "_from", (PyCFunction)_from_INDLicenseFetchCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_INDLicenseFetchCompletedEventArgs[] = {
        { const_cast<char*>("response_custom_data"), (getter)INDLicenseFetchCompletedEventArgs_get_ResponseCustomData, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_INDLicenseFetchCompletedEventArgs[] = 
    {
        { Py_tp_new, _new_INDLicenseFetchCompletedEventArgs },
        { Py_tp_dealloc, _dealloc_INDLicenseFetchCompletedEventArgs },
        { Py_tp_methods, _methods_INDLicenseFetchCompletedEventArgs },
        { Py_tp_getset, _getset_INDLicenseFetchCompletedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_INDLicenseFetchCompletedEventArgs =
    {
        "_winrt_Windows_Media_Protection_PlayReady.INDLicenseFetchCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDLicenseFetchCompletedEventArgs
    };

    // ----- INDLicenseFetchDescriptor interface --------------------
    constexpr const char* const _type_name_INDLicenseFetchDescriptor = "INDLicenseFetchDescriptor";

    static PyObject* _new_INDLicenseFetchDescriptor(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_INDLicenseFetchDescriptor);
        return nullptr;
    }

    static void _dealloc_INDLicenseFetchDescriptor(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* INDLicenseFetchDescriptor_get_ContentID(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentID());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDLicenseFetchDescriptor_get_ContentIDType(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentIDType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDLicenseFetchDescriptor_get_LicenseFetchChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LicenseFetchChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int INDLicenseFetchDescriptor_put_LicenseFetchChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDCustomData>(arg);

            self->obj.LicenseFetchChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_INDLicenseFetchDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDLicenseFetchDescriptor[] = {
        { "_from", (PyCFunction)_from_INDLicenseFetchDescriptor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_INDLicenseFetchDescriptor[] = {
        { const_cast<char*>("content_i_d"), (getter)INDLicenseFetchDescriptor_get_ContentID, nullptr, nullptr, nullptr },
        { const_cast<char*>("content_i_d_type"), (getter)INDLicenseFetchDescriptor_get_ContentIDType, nullptr, nullptr, nullptr },
        { const_cast<char*>("license_fetch_challenge_custom_data"), (getter)INDLicenseFetchDescriptor_get_LicenseFetchChallengeCustomData, (setter)INDLicenseFetchDescriptor_put_LicenseFetchChallengeCustomData, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_INDLicenseFetchDescriptor[] = 
    {
        { Py_tp_new, _new_INDLicenseFetchDescriptor },
        { Py_tp_dealloc, _dealloc_INDLicenseFetchDescriptor },
        { Py_tp_methods, _methods_INDLicenseFetchDescriptor },
        { Py_tp_getset, _getset_INDLicenseFetchDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_INDLicenseFetchDescriptor =
    {
        "_winrt_Windows_Media_Protection_PlayReady.INDLicenseFetchDescriptor",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDLicenseFetchDescriptor
    };

    // ----- INDLicenseFetchResult interface --------------------
    constexpr const char* const _type_name_INDLicenseFetchResult = "INDLicenseFetchResult";

    static PyObject* _new_INDLicenseFetchResult(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_INDLicenseFetchResult);
        return nullptr;
    }

    static void _dealloc_INDLicenseFetchResult(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* INDLicenseFetchResult_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_INDLicenseFetchResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDLicenseFetchResult[] = {
        { "_from", (PyCFunction)_from_INDLicenseFetchResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_INDLicenseFetchResult[] = {
        { const_cast<char*>("response_custom_data"), (getter)INDLicenseFetchResult_get_ResponseCustomData, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_INDLicenseFetchResult[] = 
    {
        { Py_tp_new, _new_INDLicenseFetchResult },
        { Py_tp_dealloc, _dealloc_INDLicenseFetchResult },
        { Py_tp_methods, _methods_INDLicenseFetchResult },
        { Py_tp_getset, _getset_INDLicenseFetchResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_INDLicenseFetchResult =
    {
        "_winrt_Windows_Media_Protection_PlayReady.INDLicenseFetchResult",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDLicenseFetchResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDLicenseFetchResult
    };

    // ----- INDMessenger interface --------------------
    constexpr const char* const _type_name_INDMessenger = "INDMessenger";

    static PyObject* _new_INDMessenger(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_INDMessenger);
        return nullptr;
    }

    static void _dealloc_INDMessenger(py::wrapper::Windows::Media::Protection::PlayReady::INDMessenger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* INDMessenger_SendLicenseFetchRequestAsync(py::wrapper::Windows::Media::Protection::PlayReady::INDMessenger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                return py::convert(self->obj.SendLicenseFetchRequestAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDMessenger_SendProximityDetectionResponseAsync(py::wrapper::Windows::Media::Protection::PlayReady::INDMessenger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDProximityDetectionType>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);
                auto param2 = py::convert_to<winrt::array_view<uint8_t>>(args, 2);
                auto param3 = py::convert_to<winrt::array_view<uint8_t>>(args, 3);

                return py::convert(self->obj.SendProximityDetectionResponseAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDMessenger_SendProximityDetectionStartAsync(py::wrapper::Windows::Media::Protection::PlayReady::INDMessenger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDProximityDetectionType>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);
                auto param2 = py::convert_to<winrt::array_view<uint8_t>>(args, 2);
                auto param3 = py::convert_to<winrt::array_view<uint8_t>>(args, 3);

                return py::convert(self->obj.SendProximityDetectionStartAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDMessenger_SendRegistrationRequestAsync(py::wrapper::Windows::Media::Protection::PlayReady::INDMessenger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                return py::convert(self->obj.SendRegistrationRequestAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_INDMessenger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDMessenger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDMessenger[] = {
        { "send_license_fetch_request_async", (PyCFunction)INDMessenger_SendLicenseFetchRequestAsync, METH_VARARGS, nullptr },
        { "send_proximity_detection_response_async", (PyCFunction)INDMessenger_SendProximityDetectionResponseAsync, METH_VARARGS, nullptr },
        { "send_proximity_detection_start_async", (PyCFunction)INDMessenger_SendProximityDetectionStartAsync, METH_VARARGS, nullptr },
        { "send_registration_request_async", (PyCFunction)INDMessenger_SendRegistrationRequestAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_INDMessenger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_INDMessenger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_INDMessenger[] = 
    {
        { Py_tp_new, _new_INDMessenger },
        { Py_tp_dealloc, _dealloc_INDMessenger },
        { Py_tp_methods, _methods_INDMessenger },
        { Py_tp_getset, _getset_INDMessenger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_INDMessenger =
    {
        "_winrt_Windows_Media_Protection_PlayReady.INDMessenger",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDMessenger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDMessenger
    };

    // ----- INDProximityDetectionCompletedEventArgs interface --------------------
    constexpr const char* const _type_name_INDProximityDetectionCompletedEventArgs = "INDProximityDetectionCompletedEventArgs";

    static PyObject* _new_INDProximityDetectionCompletedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_INDProximityDetectionCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_INDProximityDetectionCompletedEventArgs(py::wrapper::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* INDProximityDetectionCompletedEventArgs_get_ProximityDetectionRetryCount(py::wrapper::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProximityDetectionRetryCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_INDProximityDetectionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDProximityDetectionCompletedEventArgs[] = {
        { "_from", (PyCFunction)_from_INDProximityDetectionCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_INDProximityDetectionCompletedEventArgs[] = {
        { const_cast<char*>("proximity_detection_retry_count"), (getter)INDProximityDetectionCompletedEventArgs_get_ProximityDetectionRetryCount, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_INDProximityDetectionCompletedEventArgs[] = 
    {
        { Py_tp_new, _new_INDProximityDetectionCompletedEventArgs },
        { Py_tp_dealloc, _dealloc_INDProximityDetectionCompletedEventArgs },
        { Py_tp_methods, _methods_INDProximityDetectionCompletedEventArgs },
        { Py_tp_getset, _getset_INDProximityDetectionCompletedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_INDProximityDetectionCompletedEventArgs =
    {
        "_winrt_Windows_Media_Protection_PlayReady.INDProximityDetectionCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDProximityDetectionCompletedEventArgs
    };

    // ----- INDRegistrationCompletedEventArgs interface --------------------
    constexpr const char* const _type_name_INDRegistrationCompletedEventArgs = "INDRegistrationCompletedEventArgs";

    static PyObject* _new_INDRegistrationCompletedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_INDRegistrationCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_INDRegistrationCompletedEventArgs(py::wrapper::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* INDRegistrationCompletedEventArgs_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDRegistrationCompletedEventArgs_get_TransmitterCertificateAccepted(py::wrapper::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransmitterCertificateAccepted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int INDRegistrationCompletedEventArgs_put_TransmitterCertificateAccepted(py::wrapper::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.TransmitterCertificateAccepted(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* INDRegistrationCompletedEventArgs_get_TransmitterProperties(py::wrapper::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransmitterProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_INDRegistrationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDRegistrationCompletedEventArgs[] = {
        { "_from", (PyCFunction)_from_INDRegistrationCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_INDRegistrationCompletedEventArgs[] = {
        { const_cast<char*>("response_custom_data"), (getter)INDRegistrationCompletedEventArgs_get_ResponseCustomData, nullptr, nullptr, nullptr },
        { const_cast<char*>("transmitter_certificate_accepted"), (getter)INDRegistrationCompletedEventArgs_get_TransmitterCertificateAccepted, (setter)INDRegistrationCompletedEventArgs_put_TransmitterCertificateAccepted, nullptr, nullptr },
        { const_cast<char*>("transmitter_properties"), (getter)INDRegistrationCompletedEventArgs_get_TransmitterProperties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_INDRegistrationCompletedEventArgs[] = 
    {
        { Py_tp_new, _new_INDRegistrationCompletedEventArgs },
        { Py_tp_dealloc, _dealloc_INDRegistrationCompletedEventArgs },
        { Py_tp_methods, _methods_INDRegistrationCompletedEventArgs },
        { Py_tp_getset, _getset_INDRegistrationCompletedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_INDRegistrationCompletedEventArgs =
    {
        "_winrt_Windows_Media_Protection_PlayReady.INDRegistrationCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDRegistrationCompletedEventArgs
    };

    // ----- INDSendResult interface --------------------
    constexpr const char* const _type_name_INDSendResult = "INDSendResult";

    static PyObject* _new_INDSendResult(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_INDSendResult);
        return nullptr;
    }

    static void _dealloc_INDSendResult(py::wrapper::Windows::Media::Protection::PlayReady::INDSendResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* INDSendResult_get_Response(py::wrapper::Windows::Media::Protection::PlayReady::INDSendResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Response());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_INDSendResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDSendResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDSendResult[] = {
        { "_from", (PyCFunction)_from_INDSendResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_INDSendResult[] = {
        { const_cast<char*>("response"), (getter)INDSendResult_get_Response, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_INDSendResult[] = 
    {
        { Py_tp_new, _new_INDSendResult },
        { Py_tp_dealloc, _dealloc_INDSendResult },
        { Py_tp_methods, _methods_INDSendResult },
        { Py_tp_getset, _getset_INDSendResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_INDSendResult =
    {
        "_winrt_Windows_Media_Protection_PlayReady.INDSendResult",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDSendResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDSendResult
    };

    // ----- INDStartResult interface --------------------
    constexpr const char* const _type_name_INDStartResult = "INDStartResult";

    static PyObject* _new_INDStartResult(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_INDStartResult);
        return nullptr;
    }

    static void _dealloc_INDStartResult(py::wrapper::Windows::Media::Protection::PlayReady::INDStartResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* INDStartResult_get_MediaStreamSource(py::wrapper::Windows::Media::Protection::PlayReady::INDStartResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaStreamSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_INDStartResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDStartResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDStartResult[] = {
        { "_from", (PyCFunction)_from_INDStartResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_INDStartResult[] = {
        { const_cast<char*>("media_stream_source"), (getter)INDStartResult_get_MediaStreamSource, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_INDStartResult[] = 
    {
        { Py_tp_new, _new_INDStartResult },
        { Py_tp_dealloc, _dealloc_INDStartResult },
        { Py_tp_methods, _methods_INDStartResult },
        { Py_tp_getset, _getset_INDStartResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_INDStartResult =
    {
        "_winrt_Windows_Media_Protection_PlayReady.INDStartResult",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDStartResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDStartResult
    };

    // ----- INDStorageFileHelper interface --------------------
    constexpr const char* const _type_name_INDStorageFileHelper = "INDStorageFileHelper";

    static PyObject* _new_INDStorageFileHelper(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_INDStorageFileHelper);
        return nullptr;
    }

    static void _dealloc_INDStorageFileHelper(py::wrapper::Windows::Media::Protection::PlayReady::INDStorageFileHelper* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* INDStorageFileHelper_GetFileURLs(py::wrapper::Windows::Media::Protection::PlayReady::INDStorageFileHelper* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.GetFileURLs(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_INDStorageFileHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDStorageFileHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDStorageFileHelper[] = {
        { "get_file_u_r_ls", (PyCFunction)INDStorageFileHelper_GetFileURLs, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_INDStorageFileHelper, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_INDStorageFileHelper[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_INDStorageFileHelper[] = 
    {
        { Py_tp_new, _new_INDStorageFileHelper },
        { Py_tp_dealloc, _dealloc_INDStorageFileHelper },
        { Py_tp_methods, _methods_INDStorageFileHelper },
        { Py_tp_getset, _getset_INDStorageFileHelper },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_INDStorageFileHelper =
    {
        "_winrt_Windows_Media_Protection_PlayReady.INDStorageFileHelper",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDStorageFileHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDStorageFileHelper
    };

    // ----- INDStreamParser interface --------------------
    constexpr const char* const _type_name_INDStreamParser = "INDStreamParser";

    static PyObject* _new_INDStreamParser(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_INDStreamParser);
        return nullptr;
    }

    static void _dealloc_INDStreamParser(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParser* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* INDStreamParser_BeginOfStream(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.BeginOfStream();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDStreamParser_EndOfStream(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.EndOfStream();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDStreamParser_GetStreamInformation(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);
                winrt::Windows::Media::Protection::PlayReady::NDMediaStreamType param1 {  };

                auto return_value = self->obj.GetStreamInformation(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDStreamParser_ParseData(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                self->obj.ParseData(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDStreamParser_get_Notifier(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParser* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Notifier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_INDStreamParser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDStreamParser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDStreamParser[] = {
        { "begin_of_stream", (PyCFunction)INDStreamParser_BeginOfStream, METH_VARARGS, nullptr },
        { "end_of_stream", (PyCFunction)INDStreamParser_EndOfStream, METH_VARARGS, nullptr },
        { "get_stream_information", (PyCFunction)INDStreamParser_GetStreamInformation, METH_VARARGS, nullptr },
        { "parse_data", (PyCFunction)INDStreamParser_ParseData, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_INDStreamParser, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_INDStreamParser[] = {
        { const_cast<char*>("notifier"), (getter)INDStreamParser_get_Notifier, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_INDStreamParser[] = 
    {
        { Py_tp_new, _new_INDStreamParser },
        { Py_tp_dealloc, _dealloc_INDStreamParser },
        { Py_tp_methods, _methods_INDStreamParser },
        { Py_tp_getset, _getset_INDStreamParser },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_INDStreamParser =
    {
        "_winrt_Windows_Media_Protection_PlayReady.INDStreamParser",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDStreamParser
    };

    // ----- INDStreamParserNotifier interface --------------------
    constexpr const char* const _type_name_INDStreamParserNotifier = "INDStreamParserNotifier";

    static PyObject* _new_INDStreamParserNotifier(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_INDStreamParserNotifier);
        return nullptr;
    }

    static void _dealloc_INDStreamParserNotifier(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParserNotifier* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* INDStreamParserNotifier_OnBeginSetupDecryptor(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParserNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::array_view<uint8_t>>(args, 2);

                self->obj.OnBeginSetupDecryptor(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDStreamParserNotifier_OnContentIDReceived(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParserNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>(args, 0);

                self->obj.OnContentIDReceived(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDStreamParserNotifier_OnMediaStreamDescriptorCreated(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParserNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Media::Core::AudioStreamDescriptor>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Media::Core::VideoStreamDescriptor>>(args, 1);

                self->obj.OnMediaStreamDescriptorCreated(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* INDStreamParserNotifier_OnSampleParsed(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParserNotifier* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDMediaStreamType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Core::MediaStreamSample>(args, 2);
                auto param3 = py::convert_to<int64_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::NDClosedCaptionFormat>(args, 4);
                auto param5 = py::convert_to<winrt::array_view<uint8_t>>(args, 5);

                self->obj.OnSampleParsed(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_INDStreamParserNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDStreamParserNotifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDStreamParserNotifier[] = {
        { "on_begin_setup_decryptor", (PyCFunction)INDStreamParserNotifier_OnBeginSetupDecryptor, METH_VARARGS, nullptr },
        { "on_content_i_d_received", (PyCFunction)INDStreamParserNotifier_OnContentIDReceived, METH_VARARGS, nullptr },
        { "on_media_stream_descriptor_created", (PyCFunction)INDStreamParserNotifier_OnMediaStreamDescriptorCreated, METH_VARARGS, nullptr },
        { "on_sample_parsed", (PyCFunction)INDStreamParserNotifier_OnSampleParsed, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_INDStreamParserNotifier, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_INDStreamParserNotifier[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_INDStreamParserNotifier[] = 
    {
        { Py_tp_new, _new_INDStreamParserNotifier },
        { Py_tp_dealloc, _dealloc_INDStreamParserNotifier },
        { Py_tp_methods, _methods_INDStreamParserNotifier },
        { Py_tp_getset, _getset_INDStreamParserNotifier },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_INDStreamParserNotifier =
    {
        "_winrt_Windows_Media_Protection_PlayReady.INDStreamParserNotifier",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDStreamParserNotifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDStreamParserNotifier
    };

    // ----- INDTransmitterProperties interface --------------------
    constexpr const char* const _type_name_INDTransmitterProperties = "INDTransmitterProperties";

    static PyObject* _new_INDTransmitterProperties(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_INDTransmitterProperties);
        return nullptr;
    }

    static void _dealloc_INDTransmitterProperties(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* INDTransmitterProperties_get_CertificateType(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CertificateType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_ClientID(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ClientID());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_ExpirationDate(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_ModelDigest(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ModelDigest());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_ModelManufacturerName(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ModelManufacturerName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_ModelName(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ModelName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_ModelNumber(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ModelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_PlatformIdentifier(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlatformIdentifier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_SecurityLevel(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SecurityLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_SecurityVersion(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SecurityVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INDTransmitterProperties_get_SupportedFeatures(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedFeatures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_INDTransmitterProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::INDTransmitterProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INDTransmitterProperties[] = {
        { "_from", (PyCFunction)_from_INDTransmitterProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_INDTransmitterProperties[] = {
        { const_cast<char*>("certificate_type"), (getter)INDTransmitterProperties_get_CertificateType, nullptr, nullptr, nullptr },
        { const_cast<char*>("client_i_d"), (getter)INDTransmitterProperties_get_ClientID, nullptr, nullptr, nullptr },
        { const_cast<char*>("expiration_date"), (getter)INDTransmitterProperties_get_ExpirationDate, nullptr, nullptr, nullptr },
        { const_cast<char*>("model_digest"), (getter)INDTransmitterProperties_get_ModelDigest, nullptr, nullptr, nullptr },
        { const_cast<char*>("model_manufacturer_name"), (getter)INDTransmitterProperties_get_ModelManufacturerName, nullptr, nullptr, nullptr },
        { const_cast<char*>("model_name"), (getter)INDTransmitterProperties_get_ModelName, nullptr, nullptr, nullptr },
        { const_cast<char*>("model_number"), (getter)INDTransmitterProperties_get_ModelNumber, nullptr, nullptr, nullptr },
        { const_cast<char*>("platform_identifier"), (getter)INDTransmitterProperties_get_PlatformIdentifier, nullptr, nullptr, nullptr },
        { const_cast<char*>("security_level"), (getter)INDTransmitterProperties_get_SecurityLevel, nullptr, nullptr, nullptr },
        { const_cast<char*>("security_version"), (getter)INDTransmitterProperties_get_SecurityVersion, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_features"), (getter)INDTransmitterProperties_get_SupportedFeatures, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_INDTransmitterProperties[] = 
    {
        { Py_tp_new, _new_INDTransmitterProperties },
        { Py_tp_dealloc, _dealloc_INDTransmitterProperties },
        { Py_tp_methods, _methods_INDTransmitterProperties },
        { Py_tp_getset, _getset_INDTransmitterProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_INDTransmitterProperties =
    {
        "_winrt_Windows_Media_Protection_PlayReady.INDTransmitterProperties",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::INDTransmitterProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INDTransmitterProperties
    };

    // ----- IPlayReadyDomain interface --------------------
    constexpr const char* const _type_name_IPlayReadyDomain = "IPlayReadyDomain";

    static PyObject* _new_IPlayReadyDomain(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IPlayReadyDomain);
        return nullptr;
    }

    static void _dealloc_IPlayReadyDomain(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyDomain* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IPlayReadyDomain_get_AccountId(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyDomain_get_DomainJoinUrl(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DomainJoinUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyDomain_get_FriendlyName(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyDomain_get_Revision(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Revision());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyDomain_get_ServiceId(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyDomain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IPlayReadyDomain(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::IPlayReadyDomain>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPlayReadyDomain[] = {
        { "_from", (PyCFunction)_from_IPlayReadyDomain, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IPlayReadyDomain[] = {
        { const_cast<char*>("account_id"), (getter)IPlayReadyDomain_get_AccountId, nullptr, nullptr, nullptr },
        { const_cast<char*>("domain_join_url"), (getter)IPlayReadyDomain_get_DomainJoinUrl, nullptr, nullptr, nullptr },
        { const_cast<char*>("friendly_name"), (getter)IPlayReadyDomain_get_FriendlyName, nullptr, nullptr, nullptr },
        { const_cast<char*>("revision"), (getter)IPlayReadyDomain_get_Revision, nullptr, nullptr, nullptr },
        { const_cast<char*>("service_id"), (getter)IPlayReadyDomain_get_ServiceId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IPlayReadyDomain[] = 
    {
        { Py_tp_new, _new_IPlayReadyDomain },
        { Py_tp_dealloc, _dealloc_IPlayReadyDomain },
        { Py_tp_methods, _methods_IPlayReadyDomain },
        { Py_tp_getset, _getset_IPlayReadyDomain },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IPlayReadyDomain =
    {
        "_winrt_Windows_Media_Protection_PlayReady.IPlayReadyDomain",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyDomain),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPlayReadyDomain
    };

    // ----- IPlayReadyLicense interface --------------------
    constexpr const char* const _type_name_IPlayReadyLicense = "IPlayReadyLicense";

    static PyObject* _new_IPlayReadyLicense(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IPlayReadyLicense);
        return nullptr;
    }

    static void _dealloc_IPlayReadyLicense(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IPlayReadyLicense_GetKIDAtChainDepth(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetKIDAtChainDepth(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicense_get_ChainDepth(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChainDepth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicense_get_DomainAccountID(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DomainAccountID());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicense_get_ExpirationDate(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicense_get_ExpireAfterFirstPlay(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpireAfterFirstPlay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicense_get_FullyEvaluated(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FullyEvaluated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicense_get_UsableForPlay(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UsableForPlay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IPlayReadyLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPlayReadyLicense[] = {
        { "get_k_i_d_at_chain_depth", (PyCFunction)IPlayReadyLicense_GetKIDAtChainDepth, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IPlayReadyLicense, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IPlayReadyLicense[] = {
        { const_cast<char*>("chain_depth"), (getter)IPlayReadyLicense_get_ChainDepth, nullptr, nullptr, nullptr },
        { const_cast<char*>("domain_account_i_d"), (getter)IPlayReadyLicense_get_DomainAccountID, nullptr, nullptr, nullptr },
        { const_cast<char*>("expiration_date"), (getter)IPlayReadyLicense_get_ExpirationDate, nullptr, nullptr, nullptr },
        { const_cast<char*>("expire_after_first_play"), (getter)IPlayReadyLicense_get_ExpireAfterFirstPlay, nullptr, nullptr, nullptr },
        { const_cast<char*>("fully_evaluated"), (getter)IPlayReadyLicense_get_FullyEvaluated, nullptr, nullptr, nullptr },
        { const_cast<char*>("usable_for_play"), (getter)IPlayReadyLicense_get_UsableForPlay, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IPlayReadyLicense[] = 
    {
        { Py_tp_new, _new_IPlayReadyLicense },
        { Py_tp_dealloc, _dealloc_IPlayReadyLicense },
        { Py_tp_methods, _methods_IPlayReadyLicense },
        { Py_tp_getset, _getset_IPlayReadyLicense },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IPlayReadyLicense =
    {
        "_winrt_Windows_Media_Protection_PlayReady.IPlayReadyLicense",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicense),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPlayReadyLicense
    };

    // ----- IPlayReadyLicenseAcquisitionServiceRequest interface --------------------
    constexpr const char* const _type_name_IPlayReadyLicenseAcquisitionServiceRequest = "IPlayReadyLicenseAcquisitionServiceRequest";

    static PyObject* _new_IPlayReadyLicenseAcquisitionServiceRequest(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IPlayReadyLicenseAcquisitionServiceRequest);
        return nullptr;
    }

    static void _dealloc_IPlayReadyLicenseAcquisitionServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.BeginServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GenerateManualEnablingChallenge());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.NextServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(self->obj.ProcessManualEnablingResponse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_get_ContentHeader(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentHeader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadyLicenseAcquisitionServiceRequest_put_ContentHeader(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(arg);

            self->obj.ContentHeader(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_get_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DomainServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadyLicenseAcquisitionServiceRequest_put_DomainServiceId(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.DomainServiceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadyLicenseAcquisitionServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadyLicenseAcquisitionServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtectionSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseAcquisitionServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IPlayReadyLicenseAcquisitionServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPlayReadyLicenseAcquisitionServiceRequest[] = {
        { "begin_service_request", (PyCFunction)IPlayReadyLicenseAcquisitionServiceRequest_BeginServiceRequest, METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", (PyCFunction)IPlayReadyLicenseAcquisitionServiceRequest_GenerateManualEnablingChallenge, METH_VARARGS, nullptr },
        { "next_service_request", (PyCFunction)IPlayReadyLicenseAcquisitionServiceRequest_NextServiceRequest, METH_VARARGS, nullptr },
        { "process_manual_enabling_response", (PyCFunction)IPlayReadyLicenseAcquisitionServiceRequest_ProcessManualEnablingResponse, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IPlayReadyLicenseAcquisitionServiceRequest, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IPlayReadyLicenseAcquisitionServiceRequest[] = {
        { const_cast<char*>("content_header"), (getter)IPlayReadyLicenseAcquisitionServiceRequest_get_ContentHeader, (setter)IPlayReadyLicenseAcquisitionServiceRequest_put_ContentHeader, nullptr, nullptr },
        { const_cast<char*>("domain_service_id"), (getter)IPlayReadyLicenseAcquisitionServiceRequest_get_DomainServiceId, (setter)IPlayReadyLicenseAcquisitionServiceRequest_put_DomainServiceId, nullptr, nullptr },
        { const_cast<char*>("challenge_custom_data"), (getter)IPlayReadyLicenseAcquisitionServiceRequest_get_ChallengeCustomData, (setter)IPlayReadyLicenseAcquisitionServiceRequest_put_ChallengeCustomData, nullptr, nullptr },
        { const_cast<char*>("response_custom_data"), (getter)IPlayReadyLicenseAcquisitionServiceRequest_get_ResponseCustomData, nullptr, nullptr, nullptr },
        { const_cast<char*>("uri"), (getter)IPlayReadyLicenseAcquisitionServiceRequest_get_Uri, (setter)IPlayReadyLicenseAcquisitionServiceRequest_put_Uri, nullptr, nullptr },
        { const_cast<char*>("protection_system"), (getter)IPlayReadyLicenseAcquisitionServiceRequest_get_ProtectionSystem, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)IPlayReadyLicenseAcquisitionServiceRequest_get_Type, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IPlayReadyLicenseAcquisitionServiceRequest[] = 
    {
        { Py_tp_new, _new_IPlayReadyLicenseAcquisitionServiceRequest },
        { Py_tp_dealloc, _dealloc_IPlayReadyLicenseAcquisitionServiceRequest },
        { Py_tp_methods, _methods_IPlayReadyLicenseAcquisitionServiceRequest },
        { Py_tp_getset, _getset_IPlayReadyLicenseAcquisitionServiceRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IPlayReadyLicenseAcquisitionServiceRequest =
    {
        "_winrt_Windows_Media_Protection_PlayReady.IPlayReadyLicenseAcquisitionServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPlayReadyLicenseAcquisitionServiceRequest
    };

    // ----- IPlayReadyLicenseSession interface --------------------
    constexpr const char* const _type_name_IPlayReadyLicenseSession = "IPlayReadyLicenseSession";

    static PyObject* _new_IPlayReadyLicenseSession(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IPlayReadyLicenseSession);
        return nullptr;
    }

    static void _dealloc_IPlayReadyLicenseSession(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IPlayReadyLicenseSession_ConfigureMediaProtectionManager(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::MediaProtectionManager>(args, 0);

                self->obj.ConfigureMediaProtectionManager(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseSession_CreateLAServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateLAServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IPlayReadyLicenseSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPlayReadyLicenseSession[] = {
        { "configure_media_protection_manager", (PyCFunction)IPlayReadyLicenseSession_ConfigureMediaProtectionManager, METH_VARARGS, nullptr },
        { "create_l_a_service_request", (PyCFunction)IPlayReadyLicenseSession_CreateLAServiceRequest, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IPlayReadyLicenseSession, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IPlayReadyLicenseSession[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IPlayReadyLicenseSession[] = 
    {
        { Py_tp_new, _new_IPlayReadyLicenseSession },
        { Py_tp_dealloc, _dealloc_IPlayReadyLicenseSession },
        { Py_tp_methods, _methods_IPlayReadyLicenseSession },
        { Py_tp_getset, _getset_IPlayReadyLicenseSession },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IPlayReadyLicenseSession =
    {
        "_winrt_Windows_Media_Protection_PlayReady.IPlayReadyLicenseSession",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPlayReadyLicenseSession
    };

    // ----- IPlayReadyLicenseSession2 interface --------------------
    constexpr const char* const _type_name_IPlayReadyLicenseSession2 = "IPlayReadyLicenseSession2";

    static PyObject* _new_IPlayReadyLicenseSession2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IPlayReadyLicenseSession2);
        return nullptr;
    }

    static void _dealloc_IPlayReadyLicenseSession2(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IPlayReadyLicenseSession2_ConfigureMediaProtectionManager(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::MediaProtectionManager>(args, 0);

                self->obj.ConfigureMediaProtectionManager(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseSession2_CreateLAServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateLAServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyLicenseSession2_CreateLicenseIterable(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.CreateLicenseIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IPlayReadyLicenseSession2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPlayReadyLicenseSession2[] = {
        { "create_license_iterable", (PyCFunction)IPlayReadyLicenseSession2_CreateLicenseIterable, METH_VARARGS, nullptr },
        { "configure_media_protection_manager", (PyCFunction)IPlayReadyLicenseSession2_ConfigureMediaProtectionManager, METH_VARARGS, nullptr },
        { "create_l_a_service_request", (PyCFunction)IPlayReadyLicenseSession2_CreateLAServiceRequest, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IPlayReadyLicenseSession2, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IPlayReadyLicenseSession2[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IPlayReadyLicenseSession2[] = 
    {
        { Py_tp_new, _new_IPlayReadyLicenseSession2 },
        { Py_tp_dealloc, _dealloc_IPlayReadyLicenseSession2 },
        { Py_tp_methods, _methods_IPlayReadyLicenseSession2 },
        { Py_tp_getset, _getset_IPlayReadyLicenseSession2 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IPlayReadyLicenseSession2 =
    {
        "_winrt_Windows_Media_Protection_PlayReady.IPlayReadyLicenseSession2",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPlayReadyLicenseSession2
    };

    // ----- IPlayReadySecureStopServiceRequest interface --------------------
    constexpr const char* const _type_name_IPlayReadySecureStopServiceRequest = "IPlayReadySecureStopServiceRequest";

    static PyObject* _new_IPlayReadySecureStopServiceRequest(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IPlayReadySecureStopServiceRequest);
        return nullptr;
    }

    static void _dealloc_IPlayReadySecureStopServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IPlayReadySecureStopServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.BeginServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GenerateManualEnablingChallenge());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.NextServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(self->obj.ProcessManualEnablingResponse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_PublisherCertificate(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PublisherCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_SessionID(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SessionID());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_StartTime(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_Stopped(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Stopped());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_UpdateTime(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadySecureStopServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadySecureStopServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtectionSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadySecureStopServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IPlayReadySecureStopServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPlayReadySecureStopServiceRequest[] = {
        { "begin_service_request", (PyCFunction)IPlayReadySecureStopServiceRequest_BeginServiceRequest, METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", (PyCFunction)IPlayReadySecureStopServiceRequest_GenerateManualEnablingChallenge, METH_VARARGS, nullptr },
        { "next_service_request", (PyCFunction)IPlayReadySecureStopServiceRequest_NextServiceRequest, METH_VARARGS, nullptr },
        { "process_manual_enabling_response", (PyCFunction)IPlayReadySecureStopServiceRequest_ProcessManualEnablingResponse, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IPlayReadySecureStopServiceRequest, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IPlayReadySecureStopServiceRequest[] = {
        { const_cast<char*>("publisher_certificate"), (getter)IPlayReadySecureStopServiceRequest_get_PublisherCertificate, nullptr, nullptr, nullptr },
        { const_cast<char*>("session_i_d"), (getter)IPlayReadySecureStopServiceRequest_get_SessionID, nullptr, nullptr, nullptr },
        { const_cast<char*>("start_time"), (getter)IPlayReadySecureStopServiceRequest_get_StartTime, nullptr, nullptr, nullptr },
        { const_cast<char*>("stopped"), (getter)IPlayReadySecureStopServiceRequest_get_Stopped, nullptr, nullptr, nullptr },
        { const_cast<char*>("update_time"), (getter)IPlayReadySecureStopServiceRequest_get_UpdateTime, nullptr, nullptr, nullptr },
        { const_cast<char*>("challenge_custom_data"), (getter)IPlayReadySecureStopServiceRequest_get_ChallengeCustomData, (setter)IPlayReadySecureStopServiceRequest_put_ChallengeCustomData, nullptr, nullptr },
        { const_cast<char*>("response_custom_data"), (getter)IPlayReadySecureStopServiceRequest_get_ResponseCustomData, nullptr, nullptr, nullptr },
        { const_cast<char*>("uri"), (getter)IPlayReadySecureStopServiceRequest_get_Uri, (setter)IPlayReadySecureStopServiceRequest_put_Uri, nullptr, nullptr },
        { const_cast<char*>("protection_system"), (getter)IPlayReadySecureStopServiceRequest_get_ProtectionSystem, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)IPlayReadySecureStopServiceRequest_get_Type, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IPlayReadySecureStopServiceRequest[] = 
    {
        { Py_tp_new, _new_IPlayReadySecureStopServiceRequest },
        { Py_tp_dealloc, _dealloc_IPlayReadySecureStopServiceRequest },
        { Py_tp_methods, _methods_IPlayReadySecureStopServiceRequest },
        { Py_tp_getset, _getset_IPlayReadySecureStopServiceRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IPlayReadySecureStopServiceRequest =
    {
        "_winrt_Windows_Media_Protection_PlayReady.IPlayReadySecureStopServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPlayReadySecureStopServiceRequest
    };

    // ----- IPlayReadyServiceRequest interface --------------------
    constexpr const char* const _type_name_IPlayReadyServiceRequest = "IPlayReadyServiceRequest";

    static PyObject* _new_IPlayReadyServiceRequest(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IPlayReadyServiceRequest);
        return nullptr;
    }

    static void _dealloc_IPlayReadyServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IPlayReadyServiceRequest_BeginServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.BeginServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyServiceRequest_GenerateManualEnablingChallenge(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GenerateManualEnablingChallenge());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyServiceRequest_NextServiceRequest(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.NextServiceRequest());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyServiceRequest_ProcessManualEnablingResponse(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(self->obj.ProcessManualEnablingResponse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPlayReadyServiceRequest_get_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChallengeCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadyServiceRequest_put_ChallengeCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ChallengeCustomData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadyServiceRequest_get_ResponseCustomData(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResponseCustomData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyServiceRequest_get_Uri(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IPlayReadyServiceRequest_put_Uri(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IPlayReadyServiceRequest_get_ProtectionSystem(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtectionSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPlayReadyServiceRequest_get_Type(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IPlayReadyServiceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPlayReadyServiceRequest[] = {
        { "begin_service_request", (PyCFunction)IPlayReadyServiceRequest_BeginServiceRequest, METH_VARARGS, nullptr },
        { "generate_manual_enabling_challenge", (PyCFunction)IPlayReadyServiceRequest_GenerateManualEnablingChallenge, METH_VARARGS, nullptr },
        { "next_service_request", (PyCFunction)IPlayReadyServiceRequest_NextServiceRequest, METH_VARARGS, nullptr },
        { "process_manual_enabling_response", (PyCFunction)IPlayReadyServiceRequest_ProcessManualEnablingResponse, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IPlayReadyServiceRequest, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IPlayReadyServiceRequest[] = {
        { const_cast<char*>("challenge_custom_data"), (getter)IPlayReadyServiceRequest_get_ChallengeCustomData, (setter)IPlayReadyServiceRequest_put_ChallengeCustomData, nullptr, nullptr },
        { const_cast<char*>("response_custom_data"), (getter)IPlayReadyServiceRequest_get_ResponseCustomData, nullptr, nullptr, nullptr },
        { const_cast<char*>("uri"), (getter)IPlayReadyServiceRequest_get_Uri, (setter)IPlayReadyServiceRequest_put_Uri, nullptr, nullptr },
        { const_cast<char*>("protection_system"), (getter)IPlayReadyServiceRequest_get_ProtectionSystem, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)IPlayReadyServiceRequest_get_Type, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IPlayReadyServiceRequest[] = 
    {
        { Py_tp_new, _new_IPlayReadyServiceRequest },
        { Py_tp_dealloc, _dealloc_IPlayReadyServiceRequest },
        { Py_tp_methods, _methods_IPlayReadyServiceRequest },
        { Py_tp_getset, _getset_IPlayReadyServiceRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IPlayReadyServiceRequest =
    {
        "_winrt_Windows_Media_Protection_PlayReady.IPlayReadyServiceRequest",
        sizeof(py::wrapper::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPlayReadyServiceRequest
    };

    // ----- Windows.Media.Protection.PlayReady Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::NDClient>::python_type = py::register_python_type(module, _type_name_NDClient, &_type_spec_NDClient, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::NDCustomData>::python_type = py::register_python_type(module, _type_name_NDCustomData, &_type_spec_NDCustomData, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::NDDownloadEngineNotifier>::python_type = py::register_python_type(module, _type_name_NDDownloadEngineNotifier, &_type_spec_NDDownloadEngineNotifier, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::NDLicenseFetchDescriptor>::python_type = py::register_python_type(module, _type_name_NDLicenseFetchDescriptor, &_type_spec_NDLicenseFetchDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::NDStorageFileHelper>::python_type = py::register_python_type(module, _type_name_NDStorageFileHelper, &_type_spec_NDStorageFileHelper, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::NDStreamParserNotifier>::python_type = py::register_python_type(module, _type_name_NDStreamParserNotifier, &_type_spec_NDStreamParserNotifier, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::NDTCPMessenger>::python_type = py::register_python_type(module, _type_name_NDTCPMessenger, &_type_spec_NDTCPMessenger, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentHeader>::python_type = py::register_python_type(module, _type_name_PlayReadyContentHeader, &_type_spec_PlayReadyContentHeader, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyContentResolver>::python_type = py::register_python_type(module, _type_name_PlayReadyContentResolver, &_type_spec_PlayReadyContentResolver, nullptr);
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomain>::python_type = py::register_python_type(module, _type_name_PlayReadyDomain, &_type_spec_PlayReadyDomain, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainIterable>::python_type = py::register_python_type(module, _type_name_PlayReadyDomainIterable, &_type_spec_PlayReadyDomainIterable, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainIterator>::python_type = py::register_python_type(module, _type_name_PlayReadyDomainIterator, &_type_spec_PlayReadyDomainIterator, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainJoinServiceRequest>::python_type = py::register_python_type(module, _type_name_PlayReadyDomainJoinServiceRequest, &_type_spec_PlayReadyDomainJoinServiceRequest, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyDomainLeaveServiceRequest>::python_type = py::register_python_type(module, _type_name_PlayReadyDomainLeaveServiceRequest, &_type_spec_PlayReadyDomainLeaveServiceRequest, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyITADataGenerator>::python_type = py::register_python_type(module, _type_name_PlayReadyITADataGenerator, &_type_spec_PlayReadyITADataGenerator, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyIndividualizationServiceRequest>::python_type = py::register_python_type(module, _type_name_PlayReadyIndividualizationServiceRequest, &_type_spec_PlayReadyIndividualizationServiceRequest, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicense>::python_type = py::register_python_type(module, _type_name_PlayReadyLicense, &_type_spec_PlayReadyLicense, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseAcquisitionServiceRequest>::python_type = py::register_python_type(module, _type_name_PlayReadyLicenseAcquisitionServiceRequest, &_type_spec_PlayReadyLicenseAcquisitionServiceRequest, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterable>::python_type = py::register_python_type(module, _type_name_PlayReadyLicenseIterable, &_type_spec_PlayReadyLicenseIterable, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseIterator>::python_type = py::register_python_type(module, _type_name_PlayReadyLicenseIterator, &_type_spec_PlayReadyLicenseIterator, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseManagement>::python_type = py::register_python_type(module, _type_name_PlayReadyLicenseManagement, &_type_spec_PlayReadyLicenseManagement, nullptr);
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyLicenseSession>::python_type = py::register_python_type(module, _type_name_PlayReadyLicenseSession, &_type_spec_PlayReadyLicenseSession, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyMeteringReportServiceRequest>::python_type = py::register_python_type(module, _type_name_PlayReadyMeteringReportServiceRequest, &_type_spec_PlayReadyMeteringReportServiceRequest, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyRevocationServiceRequest>::python_type = py::register_python_type(module, _type_name_PlayReadyRevocationServiceRequest, &_type_spec_PlayReadyRevocationServiceRequest, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterable>::python_type = py::register_python_type(module, _type_name_PlayReadySecureStopIterable, &_type_spec_PlayReadySecureStopIterable, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopIterator>::python_type = py::register_python_type(module, _type_name_PlayReadySecureStopIterator, &_type_spec_PlayReadySecureStopIterator, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadySecureStopServiceRequest>::python_type = py::register_python_type(module, _type_name_PlayReadySecureStopServiceRequest, &_type_spec_PlayReadySecureStopServiceRequest, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadySoapMessage>::python_type = py::register_python_type(module, _type_name_PlayReadySoapMessage, &_type_spec_PlayReadySoapMessage, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::PlayReadyStatics>::python_type = py::register_python_type(module, _type_name_PlayReadyStatics, &_type_spec_PlayReadyStatics, nullptr);
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDClosedCaptionDataReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_INDClosedCaptionDataReceivedEventArgs, &_type_spec_INDClosedCaptionDataReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDCustomData>::python_type = py::register_python_type(module, _type_name_INDCustomData, &_type_spec_INDCustomData, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngine>::python_type = py::register_python_type(module, _type_name_INDDownloadEngine, &_type_spec_INDDownloadEngine, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDDownloadEngineNotifier>::python_type = py::register_python_type(module, _type_name_INDDownloadEngineNotifier, &_type_spec_INDDownloadEngineNotifier, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchCompletedEventArgs>::python_type = py::register_python_type(module, _type_name_INDLicenseFetchCompletedEventArgs, &_type_spec_INDLicenseFetchCompletedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchDescriptor>::python_type = py::register_python_type(module, _type_name_INDLicenseFetchDescriptor, &_type_spec_INDLicenseFetchDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDLicenseFetchResult>::python_type = py::register_python_type(module, _type_name_INDLicenseFetchResult, &_type_spec_INDLicenseFetchResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDMessenger>::python_type = py::register_python_type(module, _type_name_INDMessenger, &_type_spec_INDMessenger, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDProximityDetectionCompletedEventArgs>::python_type = py::register_python_type(module, _type_name_INDProximityDetectionCompletedEventArgs, &_type_spec_INDProximityDetectionCompletedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDRegistrationCompletedEventArgs>::python_type = py::register_python_type(module, _type_name_INDRegistrationCompletedEventArgs, &_type_spec_INDRegistrationCompletedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDSendResult>::python_type = py::register_python_type(module, _type_name_INDSendResult, &_type_spec_INDSendResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDStartResult>::python_type = py::register_python_type(module, _type_name_INDStartResult, &_type_spec_INDStartResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDStorageFileHelper>::python_type = py::register_python_type(module, _type_name_INDStorageFileHelper, &_type_spec_INDStorageFileHelper, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDStreamParser>::python_type = py::register_python_type(module, _type_name_INDStreamParser, &_type_spec_INDStreamParser, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDStreamParserNotifier>::python_type = py::register_python_type(module, _type_name_INDStreamParserNotifier, &_type_spec_INDStreamParserNotifier, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::INDTransmitterProperties>::python_type = py::register_python_type(module, _type_name_INDTransmitterProperties, &_type_spec_INDTransmitterProperties, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyDomain>::python_type = py::register_python_type(module, _type_name_IPlayReadyDomain, &_type_spec_IPlayReadyDomain, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicense>::python_type = py::register_python_type(module, _type_name_IPlayReadyLicense, &_type_spec_IPlayReadyLicense, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseAcquisitionServiceRequest>::python_type = py::register_python_type(module, _type_name_IPlayReadyLicenseAcquisitionServiceRequest, &_type_spec_IPlayReadyLicenseAcquisitionServiceRequest, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession>::python_type = py::register_python_type(module, _type_name_IPlayReadyLicenseSession, &_type_spec_IPlayReadyLicenseSession, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyLicenseSession2>::python_type = py::register_python_type(module, _type_name_IPlayReadyLicenseSession2, &_type_spec_IPlayReadyLicenseSession2, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadySecureStopServiceRequest>::python_type = py::register_python_type(module, _type_name_IPlayReadySecureStopServiceRequest, &_type_spec_IPlayReadySecureStopServiceRequest, bases.get());
            py::winrt_type<winrt::Windows::Media::Protection::PlayReady::IPlayReadyServiceRequest>::python_type = py::register_python_type(module, _type_name_IPlayReadyServiceRequest, &_type_spec_IPlayReadyServiceRequest, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Media.Protection.PlayReady");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Media_Protection_PlayReady",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Media::Protection::PlayReady

PyMODINIT_FUNC
PyInit__winrt_Windows_Media_Protection_PlayReady (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Media::Protection::PlayReady::module_def);
}
