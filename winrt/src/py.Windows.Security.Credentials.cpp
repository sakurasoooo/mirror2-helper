// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Security.Credentials.h"

PyTypeObject* py::winrt_type<winrt::Windows::Security::Credentials::KeyCredential>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Credentials::KeyCredentialAttestationResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Credentials::KeyCredentialManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Credentials::KeyCredentialOperationResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Credentials::KeyCredentialRetrievalResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Credentials::PasswordCredential>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Credentials::PasswordCredentialPropertyStore>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Credentials::PasswordVault>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Credentials::WebAccount>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Credentials::WebAccountProvider>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Credentials::IWebAccount>::python_type;

namespace py::cpp::Windows::Security::Credentials
{
    // ----- KeyCredential class --------------------
    constexpr const char* const _type_name_KeyCredential = "KeyCredential";

    static PyObject* _new_KeyCredential(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KeyCredential);
        return nullptr;
    }

    static void _dealloc_KeyCredential(py::wrapper::Windows::Security::Credentials::KeyCredential* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* KeyCredential_GetAttestationAsync(py::wrapper::Windows::Security::Credentials::KeyCredential* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAttestationAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyCredential_RequestSignAsync(py::wrapper::Windows::Security::Credentials::KeyCredential* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.RequestSignAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyCredential_RetrievePublicKey(py::wrapper::Windows::Security::Credentials::KeyCredential* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RetrievePublicKey());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPublicKeyBlobType>(args, 0);

                return py::convert(self->obj.RetrievePublicKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyCredential_get_Name(py::wrapper::Windows::Security::Credentials::KeyCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_KeyCredential(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Credentials::KeyCredential>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyCredential[] = {
        { "get_attestation_async", (PyCFunction)KeyCredential_GetAttestationAsync, METH_VARARGS, nullptr },
        { "request_sign_async", (PyCFunction)KeyCredential_RequestSignAsync, METH_VARARGS, nullptr },
        { "retrieve_public_key", (PyCFunction)KeyCredential_RetrievePublicKey, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_KeyCredential, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_KeyCredential[] = {
        { const_cast<char*>("name"), (getter)KeyCredential_get_Name, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_KeyCredential[] = 
    {
        { Py_tp_new, _new_KeyCredential },
        { Py_tp_dealloc, _dealloc_KeyCredential },
        { Py_tp_methods, _methods_KeyCredential },
        { Py_tp_getset, _getset_KeyCredential },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_KeyCredential =
    {
        "_winrt_Windows_Security_Credentials.KeyCredential",
        sizeof(py::wrapper::Windows::Security::Credentials::KeyCredential),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyCredential
    };

    // ----- KeyCredentialAttestationResult class --------------------
    constexpr const char* const _type_name_KeyCredentialAttestationResult = "KeyCredentialAttestationResult";

    static PyObject* _new_KeyCredentialAttestationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KeyCredentialAttestationResult);
        return nullptr;
    }

    static void _dealloc_KeyCredentialAttestationResult(py::wrapper::Windows::Security::Credentials::KeyCredentialAttestationResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* KeyCredentialAttestationResult_get_AttestationBuffer(py::wrapper::Windows::Security::Credentials::KeyCredentialAttestationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AttestationBuffer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyCredentialAttestationResult_get_CertificateChainBuffer(py::wrapper::Windows::Security::Credentials::KeyCredentialAttestationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CertificateChainBuffer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyCredentialAttestationResult_get_Status(py::wrapper::Windows::Security::Credentials::KeyCredentialAttestationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_KeyCredentialAttestationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Credentials::KeyCredentialAttestationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyCredentialAttestationResult[] = {
        { "_from", (PyCFunction)_from_KeyCredentialAttestationResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_KeyCredentialAttestationResult[] = {
        { const_cast<char*>("attestation_buffer"), (getter)KeyCredentialAttestationResult_get_AttestationBuffer, nullptr, nullptr, nullptr },
        { const_cast<char*>("certificate_chain_buffer"), (getter)KeyCredentialAttestationResult_get_CertificateChainBuffer, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)KeyCredentialAttestationResult_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_KeyCredentialAttestationResult[] = 
    {
        { Py_tp_new, _new_KeyCredentialAttestationResult },
        { Py_tp_dealloc, _dealloc_KeyCredentialAttestationResult },
        { Py_tp_methods, _methods_KeyCredentialAttestationResult },
        { Py_tp_getset, _getset_KeyCredentialAttestationResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_KeyCredentialAttestationResult =
    {
        "_winrt_Windows_Security_Credentials.KeyCredentialAttestationResult",
        sizeof(py::wrapper::Windows::Security::Credentials::KeyCredentialAttestationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyCredentialAttestationResult
    };

    // ----- KeyCredentialManager class --------------------
    constexpr const char* const _type_name_KeyCredentialManager = "KeyCredentialManager";

    static PyObject* _new_KeyCredentialManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KeyCredentialManager);
        return nullptr;
    }

    static PyObject* KeyCredentialManager_DeleteAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Credentials::KeyCredentialManager::DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyCredentialManager_IsSupportedAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Security::Credentials::KeyCredentialManager::IsSupportedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyCredentialManager_OpenAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Credentials::KeyCredentialManager::OpenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyCredentialManager_RenewAttestationAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Security::Credentials::KeyCredentialManager::RenewAttestationAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyCredentialManager_RequestCreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Credentials::KeyCredentialCreationOption>(args, 1);

                return py::convert(winrt::Windows::Security::Credentials::KeyCredentialManager::RequestCreateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyCredentialManager[] = {
        { "delete_async", (PyCFunction)KeyCredentialManager_DeleteAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "is_supported_async", (PyCFunction)KeyCredentialManager_IsSupportedAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "open_async", (PyCFunction)KeyCredentialManager_OpenAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "renew_attestation_async", (PyCFunction)KeyCredentialManager_RenewAttestationAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "request_create_async", (PyCFunction)KeyCredentialManager_RequestCreateAsync, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_KeyCredentialManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_KeyCredentialManager[] = 
    {
        { Py_tp_new, _new_KeyCredentialManager },
        { Py_tp_methods, _methods_KeyCredentialManager },
        { Py_tp_getset, _getset_KeyCredentialManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_KeyCredentialManager =
    {
        "_winrt_Windows_Security_Credentials.KeyCredentialManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyCredentialManager
    };

    // ----- KeyCredentialOperationResult class --------------------
    constexpr const char* const _type_name_KeyCredentialOperationResult = "KeyCredentialOperationResult";

    static PyObject* _new_KeyCredentialOperationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KeyCredentialOperationResult);
        return nullptr;
    }

    static void _dealloc_KeyCredentialOperationResult(py::wrapper::Windows::Security::Credentials::KeyCredentialOperationResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* KeyCredentialOperationResult_get_Result(py::wrapper::Windows::Security::Credentials::KeyCredentialOperationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyCredentialOperationResult_get_Status(py::wrapper::Windows::Security::Credentials::KeyCredentialOperationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_KeyCredentialOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Credentials::KeyCredentialOperationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyCredentialOperationResult[] = {
        { "_from", (PyCFunction)_from_KeyCredentialOperationResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_KeyCredentialOperationResult[] = {
        { const_cast<char*>("result"), (getter)KeyCredentialOperationResult_get_Result, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)KeyCredentialOperationResult_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_KeyCredentialOperationResult[] = 
    {
        { Py_tp_new, _new_KeyCredentialOperationResult },
        { Py_tp_dealloc, _dealloc_KeyCredentialOperationResult },
        { Py_tp_methods, _methods_KeyCredentialOperationResult },
        { Py_tp_getset, _getset_KeyCredentialOperationResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_KeyCredentialOperationResult =
    {
        "_winrt_Windows_Security_Credentials.KeyCredentialOperationResult",
        sizeof(py::wrapper::Windows::Security::Credentials::KeyCredentialOperationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyCredentialOperationResult
    };

    // ----- KeyCredentialRetrievalResult class --------------------
    constexpr const char* const _type_name_KeyCredentialRetrievalResult = "KeyCredentialRetrievalResult";

    static PyObject* _new_KeyCredentialRetrievalResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KeyCredentialRetrievalResult);
        return nullptr;
    }

    static void _dealloc_KeyCredentialRetrievalResult(py::wrapper::Windows::Security::Credentials::KeyCredentialRetrievalResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* KeyCredentialRetrievalResult_get_Credential(py::wrapper::Windows::Security::Credentials::KeyCredentialRetrievalResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Credential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyCredentialRetrievalResult_get_Status(py::wrapper::Windows::Security::Credentials::KeyCredentialRetrievalResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_KeyCredentialRetrievalResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Credentials::KeyCredentialRetrievalResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyCredentialRetrievalResult[] = {
        { "_from", (PyCFunction)_from_KeyCredentialRetrievalResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_KeyCredentialRetrievalResult[] = {
        { const_cast<char*>("credential"), (getter)KeyCredentialRetrievalResult_get_Credential, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)KeyCredentialRetrievalResult_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_KeyCredentialRetrievalResult[] = 
    {
        { Py_tp_new, _new_KeyCredentialRetrievalResult },
        { Py_tp_dealloc, _dealloc_KeyCredentialRetrievalResult },
        { Py_tp_methods, _methods_KeyCredentialRetrievalResult },
        { Py_tp_getset, _getset_KeyCredentialRetrievalResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_KeyCredentialRetrievalResult =
    {
        "_winrt_Windows_Security_Credentials.KeyCredentialRetrievalResult",
        sizeof(py::wrapper::Windows::Security::Credentials::KeyCredentialRetrievalResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyCredentialRetrievalResult
    };

    // ----- PasswordCredential class --------------------
    constexpr const char* const _type_name_PasswordCredential = "PasswordCredential";

    static PyObject* _new_PasswordCredential(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::Security::Credentials::PasswordCredential instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Credentials::PasswordCredential instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PasswordCredential(py::wrapper::Windows::Security::Credentials::PasswordCredential* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PasswordCredential_RetrievePassword(py::wrapper::Windows::Security::Credentials::PasswordCredential* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RetrievePassword();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PasswordCredential_get_UserName(py::wrapper::Windows::Security::Credentials::PasswordCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PasswordCredential_put_UserName(py::wrapper::Windows::Security::Credentials::PasswordCredential* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.UserName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PasswordCredential_get_Resource(py::wrapper::Windows::Security::Credentials::PasswordCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Resource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PasswordCredential_put_Resource(py::wrapper::Windows::Security::Credentials::PasswordCredential* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Resource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PasswordCredential_get_Password(py::wrapper::Windows::Security::Credentials::PasswordCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Password());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PasswordCredential_put_Password(py::wrapper::Windows::Security::Credentials::PasswordCredential* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Password(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PasswordCredential_get_Properties(py::wrapper::Windows::Security::Credentials::PasswordCredential* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PasswordCredential(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Credentials::PasswordCredential>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PasswordCredential[] = {
        { "retrieve_password", (PyCFunction)PasswordCredential_RetrievePassword, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PasswordCredential, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PasswordCredential[] = {
        { const_cast<char*>("user_name"), (getter)PasswordCredential_get_UserName, (setter)PasswordCredential_put_UserName, nullptr, nullptr },
        { const_cast<char*>("resource"), (getter)PasswordCredential_get_Resource, (setter)PasswordCredential_put_Resource, nullptr, nullptr },
        { const_cast<char*>("password"), (getter)PasswordCredential_get_Password, (setter)PasswordCredential_put_Password, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)PasswordCredential_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PasswordCredential[] = 
    {
        { Py_tp_new, _new_PasswordCredential },
        { Py_tp_dealloc, _dealloc_PasswordCredential },
        { Py_tp_methods, _methods_PasswordCredential },
        { Py_tp_getset, _getset_PasswordCredential },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PasswordCredential =
    {
        "_winrt_Windows_Security_Credentials.PasswordCredential",
        sizeof(py::wrapper::Windows::Security::Credentials::PasswordCredential),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PasswordCredential
    };

    // ----- PasswordCredentialPropertyStore class --------------------
    constexpr const char* const _type_name_PasswordCredentialPropertyStore = "PasswordCredentialPropertyStore";

    static PyObject* _new_PasswordCredentialPropertyStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Credentials::PasswordCredentialPropertyStore instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PasswordCredentialPropertyStore(py::wrapper::Windows::Security::Credentials::PasswordCredentialPropertyStore* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PasswordCredentialPropertyStore_Clear(py::wrapper::Windows::Security::Credentials::PasswordCredentialPropertyStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PasswordCredentialPropertyStore_First(py::wrapper::Windows::Security::Credentials::PasswordCredentialPropertyStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PasswordCredentialPropertyStore_GetView(py::wrapper::Windows::Security::Credentials::PasswordCredentialPropertyStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PasswordCredentialPropertyStore_HasKey(py::wrapper::Windows::Security::Credentials::PasswordCredentialPropertyStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PasswordCredentialPropertyStore_Insert(py::wrapper::Windows::Security::Credentials::PasswordCredentialPropertyStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PasswordCredentialPropertyStore_Lookup(py::wrapper::Windows::Security::Credentials::PasswordCredentialPropertyStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PasswordCredentialPropertyStore_Remove(py::wrapper::Windows::Security::Credentials::PasswordCredentialPropertyStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PasswordCredentialPropertyStore_get_Size(py::wrapper::Windows::Security::Credentials::PasswordCredentialPropertyStore* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PasswordCredentialPropertyStore_add_MapChanged(py::wrapper::Windows::Security::Credentials::PasswordCredentialPropertyStore* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::MapChangedEventHandler<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.MapChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PasswordCredentialPropertyStore_remove_MapChanged(py::wrapper::Windows::Security::Credentials::PasswordCredentialPropertyStore* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PasswordCredentialPropertyStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Credentials::PasswordCredentialPropertyStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PasswordCredentialPropertyStore(py::wrapper::Windows::Security::Credentials::PasswordCredentialPropertyStore* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _map_length_PasswordCredentialPropertyStore(py::wrapper::Windows::Security::Credentials::PasswordCredentialPropertyStore* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_PasswordCredentialPropertyStore(py::wrapper::Windows::Security::Credentials::PasswordCredentialPropertyStore* self, PyObject* key) noexcept
    {
        try
        {
            return py::convert(self->obj.Lookup(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_PasswordCredentialPropertyStore(py::wrapper::Windows::Security::Credentials::PasswordCredentialPropertyStore* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            if (value == nullptr) { self->obj.Remove(_key); }
            else { self->obj.Insert(_key, py::convert_to<winrt::Windows::Foundation::IInspectable>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_PasswordCredentialPropertyStore[] = {
        { "clear", (PyCFunction)PasswordCredentialPropertyStore_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)PasswordCredentialPropertyStore_First, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)PasswordCredentialPropertyStore_GetView, METH_VARARGS, nullptr },
        { "has_key", (PyCFunction)PasswordCredentialPropertyStore_HasKey, METH_VARARGS, nullptr },
        { "insert", (PyCFunction)PasswordCredentialPropertyStore_Insert, METH_VARARGS, nullptr },
        { "lookup", (PyCFunction)PasswordCredentialPropertyStore_Lookup, METH_VARARGS, nullptr },
        { "remove", (PyCFunction)PasswordCredentialPropertyStore_Remove, METH_VARARGS, nullptr },
        { "add_map_changed", (PyCFunction)PasswordCredentialPropertyStore_add_MapChanged, METH_O, nullptr },
        { "remove_map_changed", (PyCFunction)PasswordCredentialPropertyStore_remove_MapChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_PasswordCredentialPropertyStore, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PasswordCredentialPropertyStore[] = {
        { const_cast<char*>("size"), (getter)PasswordCredentialPropertyStore_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PasswordCredentialPropertyStore[] = 
    {
        { Py_tp_new, _new_PasswordCredentialPropertyStore },
        { Py_tp_dealloc, _dealloc_PasswordCredentialPropertyStore },
        { Py_tp_methods, _methods_PasswordCredentialPropertyStore },
        { Py_tp_getset, _getset_PasswordCredentialPropertyStore },
        { Py_tp_iter, _iterator_PasswordCredentialPropertyStore },
        { Py_mp_length, _map_length_PasswordCredentialPropertyStore },
        { Py_mp_subscript, _map_subscript_PasswordCredentialPropertyStore },
        { Py_mp_ass_subscript, _map_assign_PasswordCredentialPropertyStore },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PasswordCredentialPropertyStore =
    {
        "_winrt_Windows_Security_Credentials.PasswordCredentialPropertyStore",
        sizeof(py::wrapper::Windows::Security::Credentials::PasswordCredentialPropertyStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PasswordCredentialPropertyStore
    };

    // ----- PasswordVault class --------------------
    constexpr const char* const _type_name_PasswordVault = "PasswordVault";

    static PyObject* _new_PasswordVault(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Credentials::PasswordVault instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PasswordVault(py::wrapper::Windows::Security::Credentials::PasswordVault* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PasswordVault_Add(py::wrapper::Windows::Security::Credentials::PasswordVault* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(args, 0);

                self->obj.Add(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PasswordVault_FindAllByResource(py::wrapper::Windows::Security::Credentials::PasswordVault* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindAllByResource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PasswordVault_FindAllByUserName(py::wrapper::Windows::Security::Credentials::PasswordVault* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindAllByUserName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PasswordVault_Remove(py::wrapper::Windows::Security::Credentials::PasswordVault* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PasswordVault_Retrieve(py::wrapper::Windows::Security::Credentials::PasswordVault* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.Retrieve(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PasswordVault_RetrieveAll(py::wrapper::Windows::Security::Credentials::PasswordVault* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RetrieveAll());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_PasswordVault(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Credentials::PasswordVault>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PasswordVault[] = {
        { "add", (PyCFunction)PasswordVault_Add, METH_VARARGS, nullptr },
        { "find_all_by_resource", (PyCFunction)PasswordVault_FindAllByResource, METH_VARARGS, nullptr },
        { "find_all_by_user_name", (PyCFunction)PasswordVault_FindAllByUserName, METH_VARARGS, nullptr },
        { "remove", (PyCFunction)PasswordVault_Remove, METH_VARARGS, nullptr },
        { "retrieve", (PyCFunction)PasswordVault_Retrieve, METH_VARARGS, nullptr },
        { "retrieve_all", (PyCFunction)PasswordVault_RetrieveAll, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PasswordVault, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PasswordVault[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PasswordVault[] = 
    {
        { Py_tp_new, _new_PasswordVault },
        { Py_tp_dealloc, _dealloc_PasswordVault },
        { Py_tp_methods, _methods_PasswordVault },
        { Py_tp_getset, _getset_PasswordVault },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PasswordVault =
    {
        "_winrt_Windows_Security_Credentials.PasswordVault",
        sizeof(py::wrapper::Windows::Security::Credentials::PasswordVault),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PasswordVault
    };

    // ----- WebAccount class --------------------
    constexpr const char* const _type_name_WebAccount = "WebAccount";

    static PyObject* _new_WebAccount(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Credentials::WebAccountProvider>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Credentials::WebAccountState>(args, 2);

                winrt::Windows::Security::Credentials::WebAccount instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WebAccount(py::wrapper::Windows::Security::Credentials::WebAccount* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* WebAccount_GetPictureAsync(py::wrapper::Windows::Security::Credentials::WebAccount* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Credentials::WebAccountPictureSize>(args, 0);

                return py::convert(self->obj.GetPictureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebAccount_SignOutAsync(py::wrapper::Windows::Security::Credentials::WebAccount* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.SignOutAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SignOutAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebAccount_get_State(py::wrapper::Windows::Security::Credentials::WebAccount* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccount_get_UserName(py::wrapper::Windows::Security::Credentials::WebAccount* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccount_get_WebAccountProvider(py::wrapper::Windows::Security::Credentials::WebAccount* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WebAccountProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccount_get_Id(py::wrapper::Windows::Security::Credentials::WebAccount* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccount_get_Properties(py::wrapper::Windows::Security::Credentials::WebAccount* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_WebAccount(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Credentials::WebAccount>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebAccount[] = {
        { "get_picture_async", (PyCFunction)WebAccount_GetPictureAsync, METH_VARARGS, nullptr },
        { "sign_out_async", (PyCFunction)WebAccount_SignOutAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_WebAccount, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_WebAccount[] = {
        { const_cast<char*>("state"), (getter)WebAccount_get_State, nullptr, nullptr, nullptr },
        { const_cast<char*>("user_name"), (getter)WebAccount_get_UserName, nullptr, nullptr, nullptr },
        { const_cast<char*>("web_account_provider"), (getter)WebAccount_get_WebAccountProvider, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)WebAccount_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)WebAccount_get_Properties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_WebAccount[] = 
    {
        { Py_tp_new, _new_WebAccount },
        { Py_tp_dealloc, _dealloc_WebAccount },
        { Py_tp_methods, _methods_WebAccount },
        { Py_tp_getset, _getset_WebAccount },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_WebAccount =
    {
        "_winrt_Windows_Security_Credentials.WebAccount",
        sizeof(py::wrapper::Windows::Security::Credentials::WebAccount),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebAccount
    };

    // ----- WebAccountProvider class --------------------
    constexpr const char* const _type_name_WebAccountProvider = "WebAccountProvider";

    static PyObject* _new_WebAccountProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 2);

                winrt::Windows::Security::Credentials::WebAccountProvider instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WebAccountProvider(py::wrapper::Windows::Security::Credentials::WebAccountProvider* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* WebAccountProvider_get_DisplayName(py::wrapper::Windows::Security::Credentials::WebAccountProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccountProvider_get_IconUri(py::wrapper::Windows::Security::Credentials::WebAccountProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IconUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccountProvider_get_Id(py::wrapper::Windows::Security::Credentials::WebAccountProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccountProvider_get_Authority(py::wrapper::Windows::Security::Credentials::WebAccountProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Authority());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccountProvider_get_DisplayPurpose(py::wrapper::Windows::Security::Credentials::WebAccountProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayPurpose());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccountProvider_get_User(py::wrapper::Windows::Security::Credentials::WebAccountProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccountProvider_get_IsSystemProvider(py::wrapper::Windows::Security::Credentials::WebAccountProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSystemProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_WebAccountProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Credentials::WebAccountProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebAccountProvider[] = {
        { "_from", (PyCFunction)_from_WebAccountProvider, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_WebAccountProvider[] = {
        { const_cast<char*>("display_name"), (getter)WebAccountProvider_get_DisplayName, nullptr, nullptr, nullptr },
        { const_cast<char*>("icon_uri"), (getter)WebAccountProvider_get_IconUri, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)WebAccountProvider_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("authority"), (getter)WebAccountProvider_get_Authority, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_purpose"), (getter)WebAccountProvider_get_DisplayPurpose, nullptr, nullptr, nullptr },
        { const_cast<char*>("user"), (getter)WebAccountProvider_get_User, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_system_provider"), (getter)WebAccountProvider_get_IsSystemProvider, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_WebAccountProvider[] = 
    {
        { Py_tp_new, _new_WebAccountProvider },
        { Py_tp_dealloc, _dealloc_WebAccountProvider },
        { Py_tp_methods, _methods_WebAccountProvider },
        { Py_tp_getset, _getset_WebAccountProvider },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_WebAccountProvider =
    {
        "_winrt_Windows_Security_Credentials.WebAccountProvider",
        sizeof(py::wrapper::Windows::Security::Credentials::WebAccountProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebAccountProvider
    };

    // ----- IWebAccount interface --------------------
    constexpr const char* const _type_name_IWebAccount = "IWebAccount";

    static PyObject* _new_IWebAccount(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IWebAccount);
        return nullptr;
    }

    static void _dealloc_IWebAccount(py::wrapper::Windows::Security::Credentials::IWebAccount* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IWebAccount_get_State(py::wrapper::Windows::Security::Credentials::IWebAccount* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAccount_get_UserName(py::wrapper::Windows::Security::Credentials::IWebAccount* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAccount_get_WebAccountProvider(py::wrapper::Windows::Security::Credentials::IWebAccount* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WebAccountProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IWebAccount(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Credentials::IWebAccount>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebAccount[] = {
        { "_from", (PyCFunction)_from_IWebAccount, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IWebAccount[] = {
        { const_cast<char*>("state"), (getter)IWebAccount_get_State, nullptr, nullptr, nullptr },
        { const_cast<char*>("user_name"), (getter)IWebAccount_get_UserName, nullptr, nullptr, nullptr },
        { const_cast<char*>("web_account_provider"), (getter)IWebAccount_get_WebAccountProvider, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IWebAccount[] = 
    {
        { Py_tp_new, _new_IWebAccount },
        { Py_tp_dealloc, _dealloc_IWebAccount },
        { Py_tp_methods, _methods_IWebAccount },
        { Py_tp_getset, _getset_IWebAccount },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IWebAccount =
    {
        "_winrt_Windows_Security_Credentials.IWebAccount",
        sizeof(py::wrapper::Windows::Security::Credentials::IWebAccount),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebAccount
    };

    // ----- Windows.Security.Credentials Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Security::Credentials::KeyCredential>::python_type = py::register_python_type(module, _type_name_KeyCredential, &_type_spec_KeyCredential, bases.get());
            py::winrt_type<winrt::Windows::Security::Credentials::KeyCredentialAttestationResult>::python_type = py::register_python_type(module, _type_name_KeyCredentialAttestationResult, &_type_spec_KeyCredentialAttestationResult, bases.get());
            py::winrt_type<winrt::Windows::Security::Credentials::KeyCredentialManager>::python_type = py::register_python_type(module, _type_name_KeyCredentialManager, &_type_spec_KeyCredentialManager, nullptr);
            py::winrt_type<winrt::Windows::Security::Credentials::KeyCredentialOperationResult>::python_type = py::register_python_type(module, _type_name_KeyCredentialOperationResult, &_type_spec_KeyCredentialOperationResult, bases.get());
            py::winrt_type<winrt::Windows::Security::Credentials::KeyCredentialRetrievalResult>::python_type = py::register_python_type(module, _type_name_KeyCredentialRetrievalResult, &_type_spec_KeyCredentialRetrievalResult, bases.get());
            py::winrt_type<winrt::Windows::Security::Credentials::PasswordCredential>::python_type = py::register_python_type(module, _type_name_PasswordCredential, &_type_spec_PasswordCredential, bases.get());
            py::winrt_type<winrt::Windows::Security::Credentials::PasswordCredentialPropertyStore>::python_type = py::register_python_type(module, _type_name_PasswordCredentialPropertyStore, &_type_spec_PasswordCredentialPropertyStore, bases.get());
            py::winrt_type<winrt::Windows::Security::Credentials::PasswordVault>::python_type = py::register_python_type(module, _type_name_PasswordVault, &_type_spec_PasswordVault, bases.get());
            py::winrt_type<winrt::Windows::Security::Credentials::WebAccount>::python_type = py::register_python_type(module, _type_name_WebAccount, &_type_spec_WebAccount, bases.get());
            py::winrt_type<winrt::Windows::Security::Credentials::WebAccountProvider>::python_type = py::register_python_type(module, _type_name_WebAccountProvider, &_type_spec_WebAccountProvider, bases.get());
            py::winrt_type<winrt::Windows::Security::Credentials::IWebAccount>::python_type = py::register_python_type(module, _type_name_IWebAccount, &_type_spec_IWebAccount, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Security.Credentials");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Security_Credentials",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Security::Credentials

PyMODINIT_FUNC
PyInit__winrt_Windows_Security_Credentials (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Security::Credentials::module_def);
}
