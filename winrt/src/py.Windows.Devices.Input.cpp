// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Devices.Input.h"

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::KeyboardCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::MouseCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::MouseDevice>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::MouseEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::PenButtonListener>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::PenDevice>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::PenDockListener>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::PenDockedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::PenTailButtonClickedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::PenTailButtonLongPressedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::PenUndockedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::PointerDevice>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::TouchCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::MouseDelta>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Input::PointerDeviceUsage>::python_type;

PyObject* py::converter<winrt::Windows::Devices::Input::MouseDelta>::convert(winrt::Windows::Devices::Input::MouseDelta instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Devices::Input::MouseDelta>());
}
winrt::Windows::Devices::Input::MouseDelta py::converter<winrt::Windows::Devices::Input::MouseDelta>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Devices::Input::MouseDelta>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Devices::Input::MouseDelta>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Devices::Input::MouseDelta return_value{};

    PyObject* py_X = PyDict_GetItemString(obj, "x");
    if (!py_X) { throw winrt::hresult_invalid_argument(); }
    return_value.X = converter<int32_t>::convert_to(py_X);

    PyObject* py_Y = PyDict_GetItemString(obj, "y");
    if (!py_Y) { throw winrt::hresult_invalid_argument(); }
    return_value.Y = converter<int32_t>::convert_to(py_Y);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Devices::Input::PointerDeviceUsage>::convert(winrt::Windows::Devices::Input::PointerDeviceUsage instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Devices::Input::PointerDeviceUsage>());
}
winrt::Windows::Devices::Input::PointerDeviceUsage py::converter<winrt::Windows::Devices::Input::PointerDeviceUsage>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Devices::Input::PointerDeviceUsage>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Devices::Input::PointerDeviceUsage>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Devices::Input::PointerDeviceUsage return_value{};

    PyObject* py_UsagePage = PyDict_GetItemString(obj, "usage_page");
    if (!py_UsagePage) { throw winrt::hresult_invalid_argument(); }
    return_value.UsagePage = converter<uint32_t>::convert_to(py_UsagePage);

    PyObject* py_Usage = PyDict_GetItemString(obj, "usage");
    if (!py_Usage) { throw winrt::hresult_invalid_argument(); }
    return_value.Usage = converter<uint32_t>::convert_to(py_Usage);

    PyObject* py_MinLogical = PyDict_GetItemString(obj, "min_logical");
    if (!py_MinLogical) { throw winrt::hresult_invalid_argument(); }
    return_value.MinLogical = converter<int32_t>::convert_to(py_MinLogical);

    PyObject* py_MaxLogical = PyDict_GetItemString(obj, "max_logical");
    if (!py_MaxLogical) { throw winrt::hresult_invalid_argument(); }
    return_value.MaxLogical = converter<int32_t>::convert_to(py_MaxLogical);

    PyObject* py_MinPhysical = PyDict_GetItemString(obj, "min_physical");
    if (!py_MinPhysical) { throw winrt::hresult_invalid_argument(); }
    return_value.MinPhysical = converter<int32_t>::convert_to(py_MinPhysical);

    PyObject* py_MaxPhysical = PyDict_GetItemString(obj, "max_physical");
    if (!py_MaxPhysical) { throw winrt::hresult_invalid_argument(); }
    return_value.MaxPhysical = converter<int32_t>::convert_to(py_MaxPhysical);

    PyObject* py_Unit = PyDict_GetItemString(obj, "unit");
    if (!py_Unit) { throw winrt::hresult_invalid_argument(); }
    return_value.Unit = converter<uint32_t>::convert_to(py_Unit);

    PyObject* py_PhysicalMultiplier = PyDict_GetItemString(obj, "physical_multiplier");
    if (!py_PhysicalMultiplier) { throw winrt::hresult_invalid_argument(); }
    return_value.PhysicalMultiplier = converter<float>::convert_to(py_PhysicalMultiplier);

    return return_value;
}

namespace py::cpp::Windows::Devices::Input
{
    // ----- KeyboardCapabilities class --------------------
    constexpr const char* const _type_name_KeyboardCapabilities = "KeyboardCapabilities";

    static PyObject* _new_KeyboardCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Input::KeyboardCapabilities instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_KeyboardCapabilities(py::wrapper::Windows::Devices::Input::KeyboardCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* KeyboardCapabilities_get_KeyboardPresent(py::wrapper::Windows::Devices::Input::KeyboardCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyboardPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_KeyboardCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::KeyboardCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyboardCapabilities[] = {
        { "_from", (PyCFunction)_from_KeyboardCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_KeyboardCapabilities[] = {
        { const_cast<char*>("keyboard_present"), (getter)KeyboardCapabilities_get_KeyboardPresent, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_KeyboardCapabilities[] = 
    {
        { Py_tp_new, _new_KeyboardCapabilities },
        { Py_tp_dealloc, _dealloc_KeyboardCapabilities },
        { Py_tp_methods, _methods_KeyboardCapabilities },
        { Py_tp_getset, _getset_KeyboardCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_KeyboardCapabilities =
    {
        "_winrt_Windows_Devices_Input.KeyboardCapabilities",
        sizeof(py::wrapper::Windows::Devices::Input::KeyboardCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyboardCapabilities
    };

    // ----- MouseCapabilities class --------------------
    constexpr const char* const _type_name_MouseCapabilities = "MouseCapabilities";

    static PyObject* _new_MouseCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Input::MouseCapabilities instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MouseCapabilities(py::wrapper::Windows::Devices::Input::MouseCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MouseCapabilities_get_HorizontalWheelPresent(py::wrapper::Windows::Devices::Input::MouseCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HorizontalWheelPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MouseCapabilities_get_MousePresent(py::wrapper::Windows::Devices::Input::MouseCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MousePresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MouseCapabilities_get_NumberOfButtons(py::wrapper::Windows::Devices::Input::MouseCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NumberOfButtons());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MouseCapabilities_get_SwapButtons(py::wrapper::Windows::Devices::Input::MouseCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SwapButtons());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MouseCapabilities_get_VerticalWheelPresent(py::wrapper::Windows::Devices::Input::MouseCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VerticalWheelPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MouseCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::MouseCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MouseCapabilities[] = {
        { "_from", (PyCFunction)_from_MouseCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MouseCapabilities[] = {
        { const_cast<char*>("horizontal_wheel_present"), (getter)MouseCapabilities_get_HorizontalWheelPresent, nullptr, nullptr, nullptr },
        { const_cast<char*>("mouse_present"), (getter)MouseCapabilities_get_MousePresent, nullptr, nullptr, nullptr },
        { const_cast<char*>("number_of_buttons"), (getter)MouseCapabilities_get_NumberOfButtons, nullptr, nullptr, nullptr },
        { const_cast<char*>("swap_buttons"), (getter)MouseCapabilities_get_SwapButtons, nullptr, nullptr, nullptr },
        { const_cast<char*>("vertical_wheel_present"), (getter)MouseCapabilities_get_VerticalWheelPresent, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MouseCapabilities[] = 
    {
        { Py_tp_new, _new_MouseCapabilities },
        { Py_tp_dealloc, _dealloc_MouseCapabilities },
        { Py_tp_methods, _methods_MouseCapabilities },
        { Py_tp_getset, _getset_MouseCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MouseCapabilities =
    {
        "_winrt_Windows_Devices_Input.MouseCapabilities",
        sizeof(py::wrapper::Windows::Devices::Input::MouseCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MouseCapabilities
    };

    // ----- MouseDevice class --------------------
    constexpr const char* const _type_name_MouseDevice = "MouseDevice";

    static PyObject* _new_MouseDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MouseDevice);
        return nullptr;
    }

    static void _dealloc_MouseDevice(py::wrapper::Windows::Devices::Input::MouseDevice* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MouseDevice_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Input::MouseDevice::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MouseDevice_add_MouseMoved(py::wrapper::Windows::Devices::Input::MouseDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::MouseDevice, winrt::Windows::Devices::Input::MouseEventArgs>>(arg);

            return py::convert(self->obj.MouseMoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MouseDevice_remove_MouseMoved(py::wrapper::Windows::Devices::Input::MouseDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MouseMoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MouseDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::MouseDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MouseDevice[] = {
        { "get_for_current_view", (PyCFunction)MouseDevice_GetForCurrentView, METH_VARARGS | METH_STATIC, nullptr },
        { "add_mouse_moved", (PyCFunction)MouseDevice_add_MouseMoved, METH_O, nullptr },
        { "remove_mouse_moved", (PyCFunction)MouseDevice_remove_MouseMoved, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MouseDevice, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MouseDevice[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_MouseDevice[] = 
    {
        { Py_tp_new, _new_MouseDevice },
        { Py_tp_dealloc, _dealloc_MouseDevice },
        { Py_tp_methods, _methods_MouseDevice },
        { Py_tp_getset, _getset_MouseDevice },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MouseDevice =
    {
        "_winrt_Windows_Devices_Input.MouseDevice",
        sizeof(py::wrapper::Windows::Devices::Input::MouseDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MouseDevice
    };

    // ----- MouseEventArgs class --------------------
    constexpr const char* const _type_name_MouseEventArgs = "MouseEventArgs";

    static PyObject* _new_MouseEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MouseEventArgs);
        return nullptr;
    }

    static void _dealloc_MouseEventArgs(py::wrapper::Windows::Devices::Input::MouseEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MouseEventArgs_get_MouseDelta(py::wrapper::Windows::Devices::Input::MouseEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MouseDelta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MouseEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::MouseEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MouseEventArgs[] = {
        { "_from", (PyCFunction)_from_MouseEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MouseEventArgs[] = {
        { const_cast<char*>("mouse_delta"), (getter)MouseEventArgs_get_MouseDelta, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MouseEventArgs[] = 
    {
        { Py_tp_new, _new_MouseEventArgs },
        { Py_tp_dealloc, _dealloc_MouseEventArgs },
        { Py_tp_methods, _methods_MouseEventArgs },
        { Py_tp_getset, _getset_MouseEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MouseEventArgs =
    {
        "_winrt_Windows_Devices_Input.MouseEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::MouseEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MouseEventArgs
    };

    // ----- PenButtonListener class --------------------
    constexpr const char* const _type_name_PenButtonListener = "PenButtonListener";

    static PyObject* _new_PenButtonListener(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PenButtonListener);
        return nullptr;
    }

    static void _dealloc_PenButtonListener(py::wrapper::Windows::Devices::Input::PenButtonListener* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PenButtonListener_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Input::PenButtonListener::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_IsSupported(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_add_IsSupportedChanged(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenButtonListener, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsSupportedChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_remove_IsSupportedChanged(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsSupportedChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_add_TailButtonClicked(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenButtonListener, winrt::Windows::Devices::Input::PenTailButtonClickedEventArgs>>(arg);

            return py::convert(self->obj.TailButtonClicked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_remove_TailButtonClicked(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TailButtonClicked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_add_TailButtonDoubleClicked(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenButtonListener, winrt::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs>>(arg);

            return py::convert(self->obj.TailButtonDoubleClicked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_remove_TailButtonDoubleClicked(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TailButtonDoubleClicked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_add_TailButtonLongPressed(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenButtonListener, winrt::Windows::Devices::Input::PenTailButtonLongPressedEventArgs>>(arg);

            return py::convert(self->obj.TailButtonLongPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenButtonListener_remove_TailButtonLongPressed(py::wrapper::Windows::Devices::Input::PenButtonListener* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TailButtonLongPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PenButtonListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenButtonListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenButtonListener[] = {
        { "get_default", (PyCFunction)PenButtonListener_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "is_supported", (PyCFunction)PenButtonListener_IsSupported, METH_VARARGS, nullptr },
        { "add_is_supported_changed", (PyCFunction)PenButtonListener_add_IsSupportedChanged, METH_O, nullptr },
        { "remove_is_supported_changed", (PyCFunction)PenButtonListener_remove_IsSupportedChanged, METH_O, nullptr },
        { "add_tail_button_clicked", (PyCFunction)PenButtonListener_add_TailButtonClicked, METH_O, nullptr },
        { "remove_tail_button_clicked", (PyCFunction)PenButtonListener_remove_TailButtonClicked, METH_O, nullptr },
        { "add_tail_button_double_clicked", (PyCFunction)PenButtonListener_add_TailButtonDoubleClicked, METH_O, nullptr },
        { "remove_tail_button_double_clicked", (PyCFunction)PenButtonListener_remove_TailButtonDoubleClicked, METH_O, nullptr },
        { "add_tail_button_long_pressed", (PyCFunction)PenButtonListener_add_TailButtonLongPressed, METH_O, nullptr },
        { "remove_tail_button_long_pressed", (PyCFunction)PenButtonListener_remove_TailButtonLongPressed, METH_O, nullptr },
        { "_from", (PyCFunction)_from_PenButtonListener, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PenButtonListener[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PenButtonListener[] = 
    {
        { Py_tp_new, _new_PenButtonListener },
        { Py_tp_dealloc, _dealloc_PenButtonListener },
        { Py_tp_methods, _methods_PenButtonListener },
        { Py_tp_getset, _getset_PenButtonListener },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PenButtonListener =
    {
        "_winrt_Windows_Devices_Input.PenButtonListener",
        sizeof(py::wrapper::Windows::Devices::Input::PenButtonListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenButtonListener
    };

    // ----- PenDevice class --------------------
    constexpr const char* const _type_name_PenDevice = "PenDevice";

    static PyObject* _new_PenDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PenDevice);
        return nullptr;
    }

    static void _dealloc_PenDevice(py::wrapper::Windows::Devices::Input::PenDevice* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PenDevice_GetFromPointerId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Input::PenDevice::GetFromPointerId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenDevice_get_PenId(py::wrapper::Windows::Devices::Input::PenDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PenId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDevice_get_SimpleHapticsController(py::wrapper::Windows::Devices::Input::PenDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimpleHapticsController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PenDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenDevice[] = {
        { "get_from_pointer_id", (PyCFunction)PenDevice_GetFromPointerId, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_PenDevice, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PenDevice[] = {
        { const_cast<char*>("pen_id"), (getter)PenDevice_get_PenId, nullptr, nullptr, nullptr },
        { const_cast<char*>("simple_haptics_controller"), (getter)PenDevice_get_SimpleHapticsController, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PenDevice[] = 
    {
        { Py_tp_new, _new_PenDevice },
        { Py_tp_dealloc, _dealloc_PenDevice },
        { Py_tp_methods, _methods_PenDevice },
        { Py_tp_getset, _getset_PenDevice },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PenDevice =
    {
        "_winrt_Windows_Devices_Input.PenDevice",
        sizeof(py::wrapper::Windows::Devices::Input::PenDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenDevice
    };

    // ----- PenDockListener class --------------------
    constexpr const char* const _type_name_PenDockListener = "PenDockListener";

    static PyObject* _new_PenDockListener(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PenDockListener);
        return nullptr;
    }

    static void _dealloc_PenDockListener(py::wrapper::Windows::Devices::Input::PenDockListener* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PenDockListener_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Input::PenDockListener::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenDockListener_IsSupported(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenDockListener_add_Docked(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenDockListener, winrt::Windows::Devices::Input::PenDockedEventArgs>>(arg);

            return py::convert(self->obj.Docked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDockListener_remove_Docked(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Docked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDockListener_add_IsSupportedChanged(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenDockListener, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsSupportedChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDockListener_remove_IsSupportedChanged(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsSupportedChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDockListener_add_Undocked(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Input::PenDockListener, winrt::Windows::Devices::Input::PenUndockedEventArgs>>(arg);

            return py::convert(self->obj.Undocked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenDockListener_remove_Undocked(py::wrapper::Windows::Devices::Input::PenDockListener* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Undocked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PenDockListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenDockListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenDockListener[] = {
        { "get_default", (PyCFunction)PenDockListener_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "is_supported", (PyCFunction)PenDockListener_IsSupported, METH_VARARGS, nullptr },
        { "add_docked", (PyCFunction)PenDockListener_add_Docked, METH_O, nullptr },
        { "remove_docked", (PyCFunction)PenDockListener_remove_Docked, METH_O, nullptr },
        { "add_is_supported_changed", (PyCFunction)PenDockListener_add_IsSupportedChanged, METH_O, nullptr },
        { "remove_is_supported_changed", (PyCFunction)PenDockListener_remove_IsSupportedChanged, METH_O, nullptr },
        { "add_undocked", (PyCFunction)PenDockListener_add_Undocked, METH_O, nullptr },
        { "remove_undocked", (PyCFunction)PenDockListener_remove_Undocked, METH_O, nullptr },
        { "_from", (PyCFunction)_from_PenDockListener, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PenDockListener[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PenDockListener[] = 
    {
        { Py_tp_new, _new_PenDockListener },
        { Py_tp_dealloc, _dealloc_PenDockListener },
        { Py_tp_methods, _methods_PenDockListener },
        { Py_tp_getset, _getset_PenDockListener },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PenDockListener =
    {
        "_winrt_Windows_Devices_Input.PenDockListener",
        sizeof(py::wrapper::Windows::Devices::Input::PenDockListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenDockListener
    };

    // ----- PenDockedEventArgs class --------------------
    constexpr const char* const _type_name_PenDockedEventArgs = "PenDockedEventArgs";

    static PyObject* _new_PenDockedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PenDockedEventArgs);
        return nullptr;
    }

    static void _dealloc_PenDockedEventArgs(py::wrapper::Windows::Devices::Input::PenDockedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_PenDockedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenDockedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenDockedEventArgs[] = {
        { "_from", (PyCFunction)_from_PenDockedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PenDockedEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PenDockedEventArgs[] = 
    {
        { Py_tp_new, _new_PenDockedEventArgs },
        { Py_tp_dealloc, _dealloc_PenDockedEventArgs },
        { Py_tp_methods, _methods_PenDockedEventArgs },
        { Py_tp_getset, _getset_PenDockedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PenDockedEventArgs =
    {
        "_winrt_Windows_Devices_Input.PenDockedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::PenDockedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenDockedEventArgs
    };

    // ----- PenTailButtonClickedEventArgs class --------------------
    constexpr const char* const _type_name_PenTailButtonClickedEventArgs = "PenTailButtonClickedEventArgs";

    static PyObject* _new_PenTailButtonClickedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PenTailButtonClickedEventArgs);
        return nullptr;
    }

    static void _dealloc_PenTailButtonClickedEventArgs(py::wrapper::Windows::Devices::Input::PenTailButtonClickedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_PenTailButtonClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenTailButtonClickedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenTailButtonClickedEventArgs[] = {
        { "_from", (PyCFunction)_from_PenTailButtonClickedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PenTailButtonClickedEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PenTailButtonClickedEventArgs[] = 
    {
        { Py_tp_new, _new_PenTailButtonClickedEventArgs },
        { Py_tp_dealloc, _dealloc_PenTailButtonClickedEventArgs },
        { Py_tp_methods, _methods_PenTailButtonClickedEventArgs },
        { Py_tp_getset, _getset_PenTailButtonClickedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PenTailButtonClickedEventArgs =
    {
        "_winrt_Windows_Devices_Input.PenTailButtonClickedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::PenTailButtonClickedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenTailButtonClickedEventArgs
    };

    // ----- PenTailButtonDoubleClickedEventArgs class --------------------
    constexpr const char* const _type_name_PenTailButtonDoubleClickedEventArgs = "PenTailButtonDoubleClickedEventArgs";

    static PyObject* _new_PenTailButtonDoubleClickedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PenTailButtonDoubleClickedEventArgs);
        return nullptr;
    }

    static void _dealloc_PenTailButtonDoubleClickedEventArgs(py::wrapper::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_PenTailButtonDoubleClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenTailButtonDoubleClickedEventArgs[] = {
        { "_from", (PyCFunction)_from_PenTailButtonDoubleClickedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PenTailButtonDoubleClickedEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PenTailButtonDoubleClickedEventArgs[] = 
    {
        { Py_tp_new, _new_PenTailButtonDoubleClickedEventArgs },
        { Py_tp_dealloc, _dealloc_PenTailButtonDoubleClickedEventArgs },
        { Py_tp_methods, _methods_PenTailButtonDoubleClickedEventArgs },
        { Py_tp_getset, _getset_PenTailButtonDoubleClickedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PenTailButtonDoubleClickedEventArgs =
    {
        "_winrt_Windows_Devices_Input.PenTailButtonDoubleClickedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenTailButtonDoubleClickedEventArgs
    };

    // ----- PenTailButtonLongPressedEventArgs class --------------------
    constexpr const char* const _type_name_PenTailButtonLongPressedEventArgs = "PenTailButtonLongPressedEventArgs";

    static PyObject* _new_PenTailButtonLongPressedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PenTailButtonLongPressedEventArgs);
        return nullptr;
    }

    static void _dealloc_PenTailButtonLongPressedEventArgs(py::wrapper::Windows::Devices::Input::PenTailButtonLongPressedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_PenTailButtonLongPressedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenTailButtonLongPressedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenTailButtonLongPressedEventArgs[] = {
        { "_from", (PyCFunction)_from_PenTailButtonLongPressedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PenTailButtonLongPressedEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PenTailButtonLongPressedEventArgs[] = 
    {
        { Py_tp_new, _new_PenTailButtonLongPressedEventArgs },
        { Py_tp_dealloc, _dealloc_PenTailButtonLongPressedEventArgs },
        { Py_tp_methods, _methods_PenTailButtonLongPressedEventArgs },
        { Py_tp_getset, _getset_PenTailButtonLongPressedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PenTailButtonLongPressedEventArgs =
    {
        "_winrt_Windows_Devices_Input.PenTailButtonLongPressedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::PenTailButtonLongPressedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenTailButtonLongPressedEventArgs
    };

    // ----- PenUndockedEventArgs class --------------------
    constexpr const char* const _type_name_PenUndockedEventArgs = "PenUndockedEventArgs";

    static PyObject* _new_PenUndockedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PenUndockedEventArgs);
        return nullptr;
    }

    static void _dealloc_PenUndockedEventArgs(py::wrapper::Windows::Devices::Input::PenUndockedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_PenUndockedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PenUndockedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenUndockedEventArgs[] = {
        { "_from", (PyCFunction)_from_PenUndockedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PenUndockedEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PenUndockedEventArgs[] = 
    {
        { Py_tp_new, _new_PenUndockedEventArgs },
        { Py_tp_dealloc, _dealloc_PenUndockedEventArgs },
        { Py_tp_methods, _methods_PenUndockedEventArgs },
        { Py_tp_getset, _getset_PenUndockedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PenUndockedEventArgs =
    {
        "_winrt_Windows_Devices_Input.PenUndockedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Input::PenUndockedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenUndockedEventArgs
    };

    // ----- PointerDevice class --------------------
    constexpr const char* const _type_name_PointerDevice = "PointerDevice";

    static PyObject* _new_PointerDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PointerDevice);
        return nullptr;
    }

    static void _dealloc_PointerDevice(py::wrapper::Windows::Devices::Input::PointerDevice* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PointerDevice_GetPointerDevice(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Input::PointerDevice::GetPointerDevice(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerDevice_GetPointerDevices(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Input::PointerDevice::GetPointerDevices());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_IsIntegrated(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsIntegrated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_MaxContacts(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxContacts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_PhysicalDeviceRect(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhysicalDeviceRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_PointerDeviceType(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerDeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_ScreenRect(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScreenRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_SupportedUsages(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerDevice_get_MaxPointersWithZDistance(py::wrapper::Windows::Devices::Input::PointerDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPointersWithZDistance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PointerDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::PointerDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointerDevice[] = {
        { "get_pointer_device", (PyCFunction)PointerDevice_GetPointerDevice, METH_VARARGS | METH_STATIC, nullptr },
        { "get_pointer_devices", (PyCFunction)PointerDevice_GetPointerDevices, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_PointerDevice, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PointerDevice[] = {
        { const_cast<char*>("is_integrated"), (getter)PointerDevice_get_IsIntegrated, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_contacts"), (getter)PointerDevice_get_MaxContacts, nullptr, nullptr, nullptr },
        { const_cast<char*>("physical_device_rect"), (getter)PointerDevice_get_PhysicalDeviceRect, nullptr, nullptr, nullptr },
        { const_cast<char*>("pointer_device_type"), (getter)PointerDevice_get_PointerDeviceType, nullptr, nullptr, nullptr },
        { const_cast<char*>("screen_rect"), (getter)PointerDevice_get_ScreenRect, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_usages"), (getter)PointerDevice_get_SupportedUsages, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_pointers_with_z_distance"), (getter)PointerDevice_get_MaxPointersWithZDistance, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PointerDevice[] = 
    {
        { Py_tp_new, _new_PointerDevice },
        { Py_tp_dealloc, _dealloc_PointerDevice },
        { Py_tp_methods, _methods_PointerDevice },
        { Py_tp_getset, _getset_PointerDevice },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PointerDevice =
    {
        "_winrt_Windows_Devices_Input.PointerDevice",
        sizeof(py::wrapper::Windows::Devices::Input::PointerDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerDevice
    };

    // ----- TouchCapabilities class --------------------
    constexpr const char* const _type_name_TouchCapabilities = "TouchCapabilities";

    static PyObject* _new_TouchCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Input::TouchCapabilities instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TouchCapabilities(py::wrapper::Windows::Devices::Input::TouchCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TouchCapabilities_get_Contacts(py::wrapper::Windows::Devices::Input::TouchCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contacts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TouchCapabilities_get_TouchPresent(py::wrapper::Windows::Devices::Input::TouchCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TouchPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TouchCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Input::TouchCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TouchCapabilities[] = {
        { "_from", (PyCFunction)_from_TouchCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TouchCapabilities[] = {
        { const_cast<char*>("contacts"), (getter)TouchCapabilities_get_Contacts, nullptr, nullptr, nullptr },
        { const_cast<char*>("touch_present"), (getter)TouchCapabilities_get_TouchPresent, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TouchCapabilities[] = 
    {
        { Py_tp_new, _new_TouchCapabilities },
        { Py_tp_dealloc, _dealloc_TouchCapabilities },
        { Py_tp_methods, _methods_TouchCapabilities },
        { Py_tp_getset, _getset_TouchCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TouchCapabilities =
    {
        "_winrt_Windows_Devices_Input.TouchCapabilities",
        sizeof(py::wrapper::Windows::Devices::Input::TouchCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TouchCapabilities
    };

    // ----- MouseDelta struct --------------------
    constexpr const char* const _type_name_MouseDelta = "MouseDelta";

    PyObject* _new_MouseDelta(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Devices::Input::MouseDelta return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Devices::Input::MouseDelta>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        int32_t _X{};
        int32_t _Y{};

        static const char* kwlist[] = {"x", "y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ii", const_cast<char**>(kwlist), &_X, &_Y))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Devices::Input::MouseDelta return_value{ _X, _Y };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_MouseDelta(py::wrapper::Windows::Devices::Input::MouseDelta* self)
    {
    }

    static PyObject* MouseDelta_get_X(py::wrapper::Windows::Devices::Input::MouseDelta* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MouseDelta_set_X(py::wrapper::Windows::Devices::Input::MouseDelta* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.X = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MouseDelta_get_Y(py::wrapper::Windows::Devices::Input::MouseDelta* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MouseDelta_set_Y(py::wrapper::Windows::Devices::Input::MouseDelta* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Y = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_MouseDelta[] = {
        { const_cast<char*>("x"), (getter)MouseDelta_get_X, (setter)MouseDelta_set_X, nullptr, nullptr },
        { const_cast<char*>("y"), (getter)MouseDelta_get_Y, (setter)MouseDelta_set_Y, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MouseDelta[] = 
    {
        { Py_tp_new, _new_MouseDelta },
        { Py_tp_dealloc, _dealloc_MouseDelta },
        { Py_tp_getset, _getset_MouseDelta },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MouseDelta =
    {
        "_winrt_Windows_Devices_Input.MouseDelta",
        sizeof(py::wrapper::Windows::Devices::Input::MouseDelta),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MouseDelta
    };

    // ----- PointerDeviceUsage struct --------------------
    constexpr const char* const _type_name_PointerDeviceUsage = "PointerDeviceUsage";

    PyObject* _new_PointerDeviceUsage(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Devices::Input::PointerDeviceUsage return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Devices::Input::PointerDeviceUsage>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint32_t _UsagePage{};
        uint32_t _Usage{};
        int32_t _MinLogical{};
        int32_t _MaxLogical{};
        int32_t _MinPhysical{};
        int32_t _MaxPhysical{};
        uint32_t _Unit{};
        float _PhysicalMultiplier{};

        static const char* kwlist[] = {"usage_page", "usage", "min_logical", "max_logical", "min_physical", "max_physical", "unit", "physical_multiplier", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIiiiiIf", const_cast<char**>(kwlist), &_UsagePage, &_Usage, &_MinLogical, &_MaxLogical, &_MinPhysical, &_MaxPhysical, &_Unit, &_PhysicalMultiplier))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Devices::Input::PointerDeviceUsage return_value{ _UsagePage, _Usage, _MinLogical, _MaxLogical, _MinPhysical, _MaxPhysical, _Unit, _PhysicalMultiplier };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_PointerDeviceUsage(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self)
    {
    }

    static PyObject* PointerDeviceUsage_get_UsagePage(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UsagePage);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_UsagePage(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.UsagePage = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDeviceUsage_get_Usage(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Usage);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_Usage(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Usage = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDeviceUsage_get_MinLogical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinLogical);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_MinLogical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.MinLogical = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDeviceUsage_get_MaxLogical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxLogical);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_MaxLogical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.MaxLogical = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDeviceUsage_get_MinPhysical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinPhysical);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_MinPhysical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.MinPhysical = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDeviceUsage_get_MaxPhysical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPhysical);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_MaxPhysical(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.MaxPhysical = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDeviceUsage_get_Unit(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_Unit(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerDeviceUsage_get_PhysicalMultiplier(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhysicalMultiplier);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerDeviceUsage_set_PhysicalMultiplier(py::wrapper::Windows::Devices::Input::PointerDeviceUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PhysicalMultiplier = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_PointerDeviceUsage[] = {
        { const_cast<char*>("usage_page"), (getter)PointerDeviceUsage_get_UsagePage, (setter)PointerDeviceUsage_set_UsagePage, nullptr, nullptr },
        { const_cast<char*>("usage"), (getter)PointerDeviceUsage_get_Usage, (setter)PointerDeviceUsage_set_Usage, nullptr, nullptr },
        { const_cast<char*>("min_logical"), (getter)PointerDeviceUsage_get_MinLogical, (setter)PointerDeviceUsage_set_MinLogical, nullptr, nullptr },
        { const_cast<char*>("max_logical"), (getter)PointerDeviceUsage_get_MaxLogical, (setter)PointerDeviceUsage_set_MaxLogical, nullptr, nullptr },
        { const_cast<char*>("min_physical"), (getter)PointerDeviceUsage_get_MinPhysical, (setter)PointerDeviceUsage_set_MinPhysical, nullptr, nullptr },
        { const_cast<char*>("max_physical"), (getter)PointerDeviceUsage_get_MaxPhysical, (setter)PointerDeviceUsage_set_MaxPhysical, nullptr, nullptr },
        { const_cast<char*>("unit"), (getter)PointerDeviceUsage_get_Unit, (setter)PointerDeviceUsage_set_Unit, nullptr, nullptr },
        { const_cast<char*>("physical_multiplier"), (getter)PointerDeviceUsage_get_PhysicalMultiplier, (setter)PointerDeviceUsage_set_PhysicalMultiplier, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PointerDeviceUsage[] = 
    {
        { Py_tp_new, _new_PointerDeviceUsage },
        { Py_tp_dealloc, _dealloc_PointerDeviceUsage },
        { Py_tp_getset, _getset_PointerDeviceUsage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PointerDeviceUsage =
    {
        "_winrt_Windows_Devices_Input.PointerDeviceUsage",
        sizeof(py::wrapper::Windows::Devices::Input::PointerDeviceUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerDeviceUsage
    };

    // ----- Windows.Devices.Input Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Devices::Input::KeyboardCapabilities>::python_type = py::register_python_type(module, _type_name_KeyboardCapabilities, &_type_spec_KeyboardCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::Input::MouseCapabilities>::python_type = py::register_python_type(module, _type_name_MouseCapabilities, &_type_spec_MouseCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::Input::MouseDevice>::python_type = py::register_python_type(module, _type_name_MouseDevice, &_type_spec_MouseDevice, bases.get());
            py::winrt_type<winrt::Windows::Devices::Input::MouseEventArgs>::python_type = py::register_python_type(module, _type_name_MouseEventArgs, &_type_spec_MouseEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Input::PenButtonListener>::python_type = py::register_python_type(module, _type_name_PenButtonListener, &_type_spec_PenButtonListener, bases.get());
            py::winrt_type<winrt::Windows::Devices::Input::PenDevice>::python_type = py::register_python_type(module, _type_name_PenDevice, &_type_spec_PenDevice, bases.get());
            py::winrt_type<winrt::Windows::Devices::Input::PenDockListener>::python_type = py::register_python_type(module, _type_name_PenDockListener, &_type_spec_PenDockListener, bases.get());
            py::winrt_type<winrt::Windows::Devices::Input::PenDockedEventArgs>::python_type = py::register_python_type(module, _type_name_PenDockedEventArgs, &_type_spec_PenDockedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Input::PenTailButtonClickedEventArgs>::python_type = py::register_python_type(module, _type_name_PenTailButtonClickedEventArgs, &_type_spec_PenTailButtonClickedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Input::PenTailButtonDoubleClickedEventArgs>::python_type = py::register_python_type(module, _type_name_PenTailButtonDoubleClickedEventArgs, &_type_spec_PenTailButtonDoubleClickedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Input::PenTailButtonLongPressedEventArgs>::python_type = py::register_python_type(module, _type_name_PenTailButtonLongPressedEventArgs, &_type_spec_PenTailButtonLongPressedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Input::PenUndockedEventArgs>::python_type = py::register_python_type(module, _type_name_PenUndockedEventArgs, &_type_spec_PenUndockedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Input::PointerDevice>::python_type = py::register_python_type(module, _type_name_PointerDevice, &_type_spec_PointerDevice, bases.get());
            py::winrt_type<winrt::Windows::Devices::Input::TouchCapabilities>::python_type = py::register_python_type(module, _type_name_TouchCapabilities, &_type_spec_TouchCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::Input::MouseDelta>::python_type = py::register_python_type(module, _type_name_MouseDelta, &_type_spec_MouseDelta, bases.get());
            py::winrt_type<winrt::Windows::Devices::Input::PointerDeviceUsage>::python_type = py::register_python_type(module, _type_name_PointerDeviceUsage, &_type_spec_PointerDeviceUsage, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Devices.Input");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Devices_Input",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Devices::Input

PyMODINIT_FUNC
PyInit__winrt_Windows_Devices_Input (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Devices::Input::module_def);
}
