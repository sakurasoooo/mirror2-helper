// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Media.MediaProperties.h"

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::ContainerEncodingProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::H264ProfileIds>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::MediaPropertySet>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::MediaRatio>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>::python_type;

namespace py::cpp::Windows::Media::MediaProperties
{
    // ----- AudioEncodingProperties class --------------------
    constexpr const char* const _type_name_AudioEncodingProperties = "AudioEncodingProperties";

    static PyObject* _new_AudioEncodingProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::AudioEncodingProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioEncodingProperties(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioEncodingProperties_Copy(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateAac(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateAac(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateAacAdts(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateAacAdts(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateAlac(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateAlac(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateFlac(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateFlac(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateMp3(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateMp3(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreatePcm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreatePcm(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateWma(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateWma(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_GetFormatUserData(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetFormatUserData(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_SetFormatUserData(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                self->obj.SetFormatUserData(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_get_SampleRate(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SampleRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioEncodingProperties_put_SampleRate(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.SampleRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioEncodingProperties_get_ChannelCount(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChannelCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioEncodingProperties_put_ChannelCount(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ChannelCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioEncodingProperties_get_BitsPerSample(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitsPerSample());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioEncodingProperties_put_BitsPerSample(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.BitsPerSample(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioEncodingProperties_get_Bitrate(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioEncodingProperties_put_Bitrate(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Bitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioEncodingProperties_get_IsSpatial(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSpatial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioEncodingProperties[] = {
        { "copy", (PyCFunction)AudioEncodingProperties_Copy, METH_VARARGS, nullptr },
        { "create_aac", (PyCFunction)AudioEncodingProperties_CreateAac, METH_VARARGS | METH_STATIC, nullptr },
        { "create_aac_adts", (PyCFunction)AudioEncodingProperties_CreateAacAdts, METH_VARARGS | METH_STATIC, nullptr },
        { "create_alac", (PyCFunction)AudioEncodingProperties_CreateAlac, METH_VARARGS | METH_STATIC, nullptr },
        { "create_flac", (PyCFunction)AudioEncodingProperties_CreateFlac, METH_VARARGS | METH_STATIC, nullptr },
        { "create_mp3", (PyCFunction)AudioEncodingProperties_CreateMp3, METH_VARARGS | METH_STATIC, nullptr },
        { "create_pcm", (PyCFunction)AudioEncodingProperties_CreatePcm, METH_VARARGS | METH_STATIC, nullptr },
        { "create_wma", (PyCFunction)AudioEncodingProperties_CreateWma, METH_VARARGS | METH_STATIC, nullptr },
        { "get_format_user_data", (PyCFunction)AudioEncodingProperties_GetFormatUserData, METH_VARARGS, nullptr },
        { "set_format_user_data", (PyCFunction)AudioEncodingProperties_SetFormatUserData, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AudioEncodingProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioEncodingProperties[] = {
        { const_cast<char*>("sample_rate"), (getter)AudioEncodingProperties_get_SampleRate, (setter)AudioEncodingProperties_put_SampleRate, nullptr, nullptr },
        { const_cast<char*>("channel_count"), (getter)AudioEncodingProperties_get_ChannelCount, (setter)AudioEncodingProperties_put_ChannelCount, nullptr, nullptr },
        { const_cast<char*>("bits_per_sample"), (getter)AudioEncodingProperties_get_BitsPerSample, (setter)AudioEncodingProperties_put_BitsPerSample, nullptr, nullptr },
        { const_cast<char*>("bitrate"), (getter)AudioEncodingProperties_get_Bitrate, (setter)AudioEncodingProperties_put_Bitrate, nullptr, nullptr },
        { const_cast<char*>("is_spatial"), (getter)AudioEncodingProperties_get_IsSpatial, nullptr, nullptr, nullptr },
        { const_cast<char*>("subtype"), (getter)AudioEncodingProperties_get_Subtype, (setter)AudioEncodingProperties_put_Subtype, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)AudioEncodingProperties_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)AudioEncodingProperties_get_Type, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioEncodingProperties[] = 
    {
        { Py_tp_new, _new_AudioEncodingProperties },
        { Py_tp_dealloc, _dealloc_AudioEncodingProperties },
        { Py_tp_methods, _methods_AudioEncodingProperties },
        { Py_tp_getset, _getset_AudioEncodingProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioEncodingProperties =
    {
        "_winrt_Windows_Media_MediaProperties.AudioEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioEncodingProperties
    };

    // ----- ContainerEncodingProperties class --------------------
    constexpr const char* const _type_name_ContainerEncodingProperties = "ContainerEncodingProperties";

    static PyObject* _new_ContainerEncodingProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::ContainerEncodingProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContainerEncodingProperties(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContainerEncodingProperties_Copy(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContainerEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContainerEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContainerEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContainerEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContainerEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::ContainerEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContainerEncodingProperties[] = {
        { "copy", (PyCFunction)ContainerEncodingProperties_Copy, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ContainerEncodingProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContainerEncodingProperties[] = {
        { const_cast<char*>("subtype"), (getter)ContainerEncodingProperties_get_Subtype, (setter)ContainerEncodingProperties_put_Subtype, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)ContainerEncodingProperties_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)ContainerEncodingProperties_get_Type, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContainerEncodingProperties[] = 
    {
        { Py_tp_new, _new_ContainerEncodingProperties },
        { Py_tp_dealloc, _dealloc_ContainerEncodingProperties },
        { Py_tp_methods, _methods_ContainerEncodingProperties },
        { Py_tp_getset, _getset_ContainerEncodingProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContainerEncodingProperties =
    {
        "_winrt_Windows_Media_MediaProperties.ContainerEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContainerEncodingProperties
    };

    // ----- H264ProfileIds class --------------------
    constexpr const char* const _type_name_H264ProfileIds = "H264ProfileIds";

    static PyObject* _new_H264ProfileIds(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_H264ProfileIds);
        return nullptr;
    }

    static PyObject* H264ProfileIds_get_Baseline(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::Baseline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_ConstrainedBaseline(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::ConstrainedBaseline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_Extended(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::Extended());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_High(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::High());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_High10(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::High10());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_High422(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::High422());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_High444(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::High444());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_Main(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::Main());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_MultiviewHigh(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::MultiviewHigh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_StereoHigh(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::StereoHigh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_H264ProfileIds[] = {
        { "get_baseline", (PyCFunction)H264ProfileIds_get_Baseline, METH_NOARGS | METH_STATIC, nullptr },
        { "get_constrained_baseline", (PyCFunction)H264ProfileIds_get_ConstrainedBaseline, METH_NOARGS | METH_STATIC, nullptr },
        { "get_extended", (PyCFunction)H264ProfileIds_get_Extended, METH_NOARGS | METH_STATIC, nullptr },
        { "get_high", (PyCFunction)H264ProfileIds_get_High, METH_NOARGS | METH_STATIC, nullptr },
        { "get_high10", (PyCFunction)H264ProfileIds_get_High10, METH_NOARGS | METH_STATIC, nullptr },
        { "get_high422", (PyCFunction)H264ProfileIds_get_High422, METH_NOARGS | METH_STATIC, nullptr },
        { "get_high444", (PyCFunction)H264ProfileIds_get_High444, METH_NOARGS | METH_STATIC, nullptr },
        { "get_main", (PyCFunction)H264ProfileIds_get_Main, METH_NOARGS | METH_STATIC, nullptr },
        { "get_multiview_high", (PyCFunction)H264ProfileIds_get_MultiviewHigh, METH_NOARGS | METH_STATIC, nullptr },
        { "get_stereo_high", (PyCFunction)H264ProfileIds_get_StereoHigh, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_H264ProfileIds[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_H264ProfileIds[] = 
    {
        { Py_tp_new, _new_H264ProfileIds },
        { Py_tp_methods, _methods_H264ProfileIds },
        { Py_tp_getset, _getset_H264ProfileIds },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_H264ProfileIds =
    {
        "_winrt_Windows_Media_MediaProperties.H264ProfileIds",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_H264ProfileIds
    };

    // ----- ImageEncodingProperties class --------------------
    constexpr const char* const _type_name_ImageEncodingProperties = "ImageEncodingProperties";

    static PyObject* _new_ImageEncodingProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::ImageEncodingProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ImageEncodingProperties(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ImageEncodingProperties_Copy(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreateBmp(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreateBmp());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreateHeif(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreateHeif());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreateJpeg(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreateJpeg());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreateJpegXR(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreateJpegXR());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreatePng(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreatePng());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreateUncompressed(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaPixelFormat>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreateUncompressed(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_get_Width(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageEncodingProperties_put_Width(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Width(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageEncodingProperties_get_Height(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageEncodingProperties_put_Height(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Height(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ImageEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageEncodingProperties[] = {
        { "copy", (PyCFunction)ImageEncodingProperties_Copy, METH_VARARGS, nullptr },
        { "create_bmp", (PyCFunction)ImageEncodingProperties_CreateBmp, METH_VARARGS | METH_STATIC, nullptr },
        { "create_heif", (PyCFunction)ImageEncodingProperties_CreateHeif, METH_VARARGS | METH_STATIC, nullptr },
        { "create_jpeg", (PyCFunction)ImageEncodingProperties_CreateJpeg, METH_VARARGS | METH_STATIC, nullptr },
        { "create_jpeg_x_r", (PyCFunction)ImageEncodingProperties_CreateJpegXR, METH_VARARGS | METH_STATIC, nullptr },
        { "create_png", (PyCFunction)ImageEncodingProperties_CreatePng, METH_VARARGS | METH_STATIC, nullptr },
        { "create_uncompressed", (PyCFunction)ImageEncodingProperties_CreateUncompressed, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_ImageEncodingProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ImageEncodingProperties[] = {
        { const_cast<char*>("width"), (getter)ImageEncodingProperties_get_Width, (setter)ImageEncodingProperties_put_Width, nullptr, nullptr },
        { const_cast<char*>("height"), (getter)ImageEncodingProperties_get_Height, (setter)ImageEncodingProperties_put_Height, nullptr, nullptr },
        { const_cast<char*>("subtype"), (getter)ImageEncodingProperties_get_Subtype, (setter)ImageEncodingProperties_put_Subtype, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)ImageEncodingProperties_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)ImageEncodingProperties_get_Type, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ImageEncodingProperties[] = 
    {
        { Py_tp_new, _new_ImageEncodingProperties },
        { Py_tp_dealloc, _dealloc_ImageEncodingProperties },
        { Py_tp_methods, _methods_ImageEncodingProperties },
        { Py_tp_getset, _getset_ImageEncodingProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ImageEncodingProperties =
    {
        "_winrt_Windows_Media_MediaProperties.ImageEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageEncodingProperties
    };

    // ----- MediaEncodingProfile class --------------------
    constexpr const char* const _type_name_MediaEncodingProfile = "MediaEncodingProfile";

    static PyObject* _new_MediaEncodingProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::MediaEncodingProfile instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaEncodingProfile(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaEncodingProfile_CreateAlac(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateAlac(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateAvi(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateAvi(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateFlac(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateFlac(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateFromFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateFromFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateFromStreamAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateFromStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateHevc(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateHevc(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateM4a(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateM4a(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateMp3(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateMp3(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateMp4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateMp4(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateWav(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateWav(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateWma(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateWma(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateWmv(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateWmv(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_GetAudioTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioTracks());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_GetTimedMetadataTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetTimedMetadataTracks());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_GetVideoTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetVideoTracks());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_SetAudioTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Core::AudioStreamDescriptor>>(args, 0);

                self->obj.SetAudioTracks(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_SetTimedMetadataTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Core::TimedMetadataStreamDescriptor>>(args, 0);

                self->obj.SetTimedMetadataTracks(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_SetVideoTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Core::VideoStreamDescriptor>>(args, 0);

                self->obj.SetVideoTracks(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_get_Video(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Video());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaEncodingProfile_put_Video(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>(arg);

            self->obj.Video(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaEncodingProfile_get_Container(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Container());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaEncodingProfile_put_Container(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ContainerEncodingProperties>(arg);

            self->obj.Container(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaEncodingProfile_get_Audio(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Audio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaEncodingProfile_put_Audio(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(arg);

            self->obj.Audio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_MediaEncodingProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaEncodingProfile[] = {
        { "create_alac", (PyCFunction)MediaEncodingProfile_CreateAlac, METH_VARARGS | METH_STATIC, nullptr },
        { "create_avi", (PyCFunction)MediaEncodingProfile_CreateAvi, METH_VARARGS | METH_STATIC, nullptr },
        { "create_flac", (PyCFunction)MediaEncodingProfile_CreateFlac, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_file_async", (PyCFunction)MediaEncodingProfile_CreateFromFileAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_stream_async", (PyCFunction)MediaEncodingProfile_CreateFromStreamAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "create_hevc", (PyCFunction)MediaEncodingProfile_CreateHevc, METH_VARARGS | METH_STATIC, nullptr },
        { "create_m4a", (PyCFunction)MediaEncodingProfile_CreateM4a, METH_VARARGS | METH_STATIC, nullptr },
        { "create_mp3", (PyCFunction)MediaEncodingProfile_CreateMp3, METH_VARARGS | METH_STATIC, nullptr },
        { "create_mp4", (PyCFunction)MediaEncodingProfile_CreateMp4, METH_VARARGS | METH_STATIC, nullptr },
        { "create_wav", (PyCFunction)MediaEncodingProfile_CreateWav, METH_VARARGS | METH_STATIC, nullptr },
        { "create_wma", (PyCFunction)MediaEncodingProfile_CreateWma, METH_VARARGS | METH_STATIC, nullptr },
        { "create_wmv", (PyCFunction)MediaEncodingProfile_CreateWmv, METH_VARARGS | METH_STATIC, nullptr },
        { "get_audio_tracks", (PyCFunction)MediaEncodingProfile_GetAudioTracks, METH_VARARGS, nullptr },
        { "get_timed_metadata_tracks", (PyCFunction)MediaEncodingProfile_GetTimedMetadataTracks, METH_VARARGS, nullptr },
        { "get_video_tracks", (PyCFunction)MediaEncodingProfile_GetVideoTracks, METH_VARARGS, nullptr },
        { "set_audio_tracks", (PyCFunction)MediaEncodingProfile_SetAudioTracks, METH_VARARGS, nullptr },
        { "set_timed_metadata_tracks", (PyCFunction)MediaEncodingProfile_SetTimedMetadataTracks, METH_VARARGS, nullptr },
        { "set_video_tracks", (PyCFunction)MediaEncodingProfile_SetVideoTracks, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaEncodingProfile, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaEncodingProfile[] = {
        { const_cast<char*>("video"), (getter)MediaEncodingProfile_get_Video, (setter)MediaEncodingProfile_put_Video, nullptr, nullptr },
        { const_cast<char*>("container"), (getter)MediaEncodingProfile_get_Container, (setter)MediaEncodingProfile_put_Container, nullptr, nullptr },
        { const_cast<char*>("audio"), (getter)MediaEncodingProfile_get_Audio, (setter)MediaEncodingProfile_put_Audio, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaEncodingProfile[] = 
    {
        { Py_tp_new, _new_MediaEncodingProfile },
        { Py_tp_dealloc, _dealloc_MediaEncodingProfile },
        { Py_tp_methods, _methods_MediaEncodingProfile },
        { Py_tp_getset, _getset_MediaEncodingProfile },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaEncodingProfile =
    {
        "_winrt_Windows_Media_MediaProperties.MediaEncodingProfile",
        sizeof(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaEncodingProfile
    };

    // ----- MediaEncodingSubtypes class --------------------
    constexpr const char* const _type_name_MediaEncodingSubtypes = "MediaEncodingSubtypes";

    static PyObject* _new_MediaEncodingSubtypes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaEncodingSubtypes);
        return nullptr;
    }

    static PyObject* MediaEncodingSubtypes_get_Asf(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Asf());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Aac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Aac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_AacAdts(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::AacAdts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Ac3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Ac3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_AmrNb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::AmrNb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_AmrWb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::AmrWb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Argb32(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Argb32());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mpeg1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mpeg1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Avi(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Avi());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Bgra8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Bgra8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Bmp(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Bmp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Eac3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Eac3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Float(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Float());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Gif(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Gif());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_H263(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::H263());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_H264(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::H264());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_H264Es(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::H264Es());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Hevc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Hevc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_HevcEs(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::HevcEs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Iyuv(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Iyuv());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Jpeg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Jpeg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_JpegXr(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::JpegXr());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mjpg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mjpg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mp3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mp3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mpeg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mpeg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mpeg2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mpeg2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mpeg4(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mpeg4());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Nv12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Nv12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Pcm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Pcm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Png(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Png());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Rgb24(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Rgb24());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Rgb32(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Rgb32());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Tiff(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Tiff());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Wave(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Wave());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Wma8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Wma8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Wma9(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Wma9());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Wmv3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Wmv3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Wvc1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Wvc1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Yuy2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Yuy2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Yv12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Yv12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_D16(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::D16());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_L16(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::L16());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_L8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::L8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Vp9(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Vp9());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Alac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Alac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Flac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Flac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_P010(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::P010());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Heif(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Heif());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Srt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Srt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Ssa(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Ssa());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_VobSub(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::VobSub());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Pgs(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Pgs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaEncodingSubtypes[] = {
        { "get_asf", (PyCFunction)MediaEncodingSubtypes_get_Asf, METH_NOARGS | METH_STATIC, nullptr },
        { "get_aac", (PyCFunction)MediaEncodingSubtypes_get_Aac, METH_NOARGS | METH_STATIC, nullptr },
        { "get_aac_adts", (PyCFunction)MediaEncodingSubtypes_get_AacAdts, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ac3", (PyCFunction)MediaEncodingSubtypes_get_Ac3, METH_NOARGS | METH_STATIC, nullptr },
        { "get_amr_nb", (PyCFunction)MediaEncodingSubtypes_get_AmrNb, METH_NOARGS | METH_STATIC, nullptr },
        { "get_amr_wb", (PyCFunction)MediaEncodingSubtypes_get_AmrWb, METH_NOARGS | METH_STATIC, nullptr },
        { "get_argb32", (PyCFunction)MediaEncodingSubtypes_get_Argb32, METH_NOARGS | METH_STATIC, nullptr },
        { "get_mpeg1", (PyCFunction)MediaEncodingSubtypes_get_Mpeg1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_avi", (PyCFunction)MediaEncodingSubtypes_get_Avi, METH_NOARGS | METH_STATIC, nullptr },
        { "get_bgra8", (PyCFunction)MediaEncodingSubtypes_get_Bgra8, METH_NOARGS | METH_STATIC, nullptr },
        { "get_bmp", (PyCFunction)MediaEncodingSubtypes_get_Bmp, METH_NOARGS | METH_STATIC, nullptr },
        { "get_eac3", (PyCFunction)MediaEncodingSubtypes_get_Eac3, METH_NOARGS | METH_STATIC, nullptr },
        { "get_float", (PyCFunction)MediaEncodingSubtypes_get_Float, METH_NOARGS | METH_STATIC, nullptr },
        { "get_gif", (PyCFunction)MediaEncodingSubtypes_get_Gif, METH_NOARGS | METH_STATIC, nullptr },
        { "get_h263", (PyCFunction)MediaEncodingSubtypes_get_H263, METH_NOARGS | METH_STATIC, nullptr },
        { "get_h264", (PyCFunction)MediaEncodingSubtypes_get_H264, METH_NOARGS | METH_STATIC, nullptr },
        { "get_h264_es", (PyCFunction)MediaEncodingSubtypes_get_H264Es, METH_NOARGS | METH_STATIC, nullptr },
        { "get_hevc", (PyCFunction)MediaEncodingSubtypes_get_Hevc, METH_NOARGS | METH_STATIC, nullptr },
        { "get_hevc_es", (PyCFunction)MediaEncodingSubtypes_get_HevcEs, METH_NOARGS | METH_STATIC, nullptr },
        { "get_iyuv", (PyCFunction)MediaEncodingSubtypes_get_Iyuv, METH_NOARGS | METH_STATIC, nullptr },
        { "get_jpeg", (PyCFunction)MediaEncodingSubtypes_get_Jpeg, METH_NOARGS | METH_STATIC, nullptr },
        { "get_jpeg_xr", (PyCFunction)MediaEncodingSubtypes_get_JpegXr, METH_NOARGS | METH_STATIC, nullptr },
        { "get_mjpg", (PyCFunction)MediaEncodingSubtypes_get_Mjpg, METH_NOARGS | METH_STATIC, nullptr },
        { "get_mp3", (PyCFunction)MediaEncodingSubtypes_get_Mp3, METH_NOARGS | METH_STATIC, nullptr },
        { "get_mpeg", (PyCFunction)MediaEncodingSubtypes_get_Mpeg, METH_NOARGS | METH_STATIC, nullptr },
        { "get_mpeg2", (PyCFunction)MediaEncodingSubtypes_get_Mpeg2, METH_NOARGS | METH_STATIC, nullptr },
        { "get_mpeg4", (PyCFunction)MediaEncodingSubtypes_get_Mpeg4, METH_NOARGS | METH_STATIC, nullptr },
        { "get_nv12", (PyCFunction)MediaEncodingSubtypes_get_Nv12, METH_NOARGS | METH_STATIC, nullptr },
        { "get_pcm", (PyCFunction)MediaEncodingSubtypes_get_Pcm, METH_NOARGS | METH_STATIC, nullptr },
        { "get_png", (PyCFunction)MediaEncodingSubtypes_get_Png, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rgb24", (PyCFunction)MediaEncodingSubtypes_get_Rgb24, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rgb32", (PyCFunction)MediaEncodingSubtypes_get_Rgb32, METH_NOARGS | METH_STATIC, nullptr },
        { "get_tiff", (PyCFunction)MediaEncodingSubtypes_get_Tiff, METH_NOARGS | METH_STATIC, nullptr },
        { "get_wave", (PyCFunction)MediaEncodingSubtypes_get_Wave, METH_NOARGS | METH_STATIC, nullptr },
        { "get_wma8", (PyCFunction)MediaEncodingSubtypes_get_Wma8, METH_NOARGS | METH_STATIC, nullptr },
        { "get_wma9", (PyCFunction)MediaEncodingSubtypes_get_Wma9, METH_NOARGS | METH_STATIC, nullptr },
        { "get_wmv3", (PyCFunction)MediaEncodingSubtypes_get_Wmv3, METH_NOARGS | METH_STATIC, nullptr },
        { "get_wvc1", (PyCFunction)MediaEncodingSubtypes_get_Wvc1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_yuy2", (PyCFunction)MediaEncodingSubtypes_get_Yuy2, METH_NOARGS | METH_STATIC, nullptr },
        { "get_yv12", (PyCFunction)MediaEncodingSubtypes_get_Yv12, METH_NOARGS | METH_STATIC, nullptr },
        { "get_d16", (PyCFunction)MediaEncodingSubtypes_get_D16, METH_NOARGS | METH_STATIC, nullptr },
        { "get_l16", (PyCFunction)MediaEncodingSubtypes_get_L16, METH_NOARGS | METH_STATIC, nullptr },
        { "get_l8", (PyCFunction)MediaEncodingSubtypes_get_L8, METH_NOARGS | METH_STATIC, nullptr },
        { "get_vp9", (PyCFunction)MediaEncodingSubtypes_get_Vp9, METH_NOARGS | METH_STATIC, nullptr },
        { "get_alac", (PyCFunction)MediaEncodingSubtypes_get_Alac, METH_NOARGS | METH_STATIC, nullptr },
        { "get_flac", (PyCFunction)MediaEncodingSubtypes_get_Flac, METH_NOARGS | METH_STATIC, nullptr },
        { "get_p010", (PyCFunction)MediaEncodingSubtypes_get_P010, METH_NOARGS | METH_STATIC, nullptr },
        { "get_heif", (PyCFunction)MediaEncodingSubtypes_get_Heif, METH_NOARGS | METH_STATIC, nullptr },
        { "get_srt", (PyCFunction)MediaEncodingSubtypes_get_Srt, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ssa", (PyCFunction)MediaEncodingSubtypes_get_Ssa, METH_NOARGS | METH_STATIC, nullptr },
        { "get_vob_sub", (PyCFunction)MediaEncodingSubtypes_get_VobSub, METH_NOARGS | METH_STATIC, nullptr },
        { "get_pgs", (PyCFunction)MediaEncodingSubtypes_get_Pgs, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaEncodingSubtypes[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaEncodingSubtypes[] = 
    {
        { Py_tp_new, _new_MediaEncodingSubtypes },
        { Py_tp_methods, _methods_MediaEncodingSubtypes },
        { Py_tp_getset, _getset_MediaEncodingSubtypes },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaEncodingSubtypes =
    {
        "_winrt_Windows_Media_MediaProperties.MediaEncodingSubtypes",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaEncodingSubtypes
    };

    // ----- MediaPropertySet class --------------------
    constexpr const char* const _type_name_MediaPropertySet = "MediaPropertySet";

    static PyObject* _new_MediaPropertySet(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::MediaPropertySet instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaPropertySet_Clear(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_First(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_GetView(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_HasKey(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_Insert(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_Lookup(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_Remove(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_get_Size(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::MediaPropertySet>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _map_length_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* key) noexcept
    {
        try
        {
            return py::convert(self->obj.Lookup(py::convert_to<winrt::guid>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::guid>(key);
            if (value == nullptr) { self->obj.Remove(_key); }
            else { self->obj.Insert(_key, py::convert_to<winrt::Windows::Foundation::IInspectable>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_MediaPropertySet[] = {
        { "clear", (PyCFunction)MediaPropertySet_Clear, METH_VARARGS, nullptr },
        { "first", (PyCFunction)MediaPropertySet_First, METH_VARARGS, nullptr },
        { "get_view", (PyCFunction)MediaPropertySet_GetView, METH_VARARGS, nullptr },
        { "has_key", (PyCFunction)MediaPropertySet_HasKey, METH_VARARGS, nullptr },
        { "insert", (PyCFunction)MediaPropertySet_Insert, METH_VARARGS, nullptr },
        { "lookup", (PyCFunction)MediaPropertySet_Lookup, METH_VARARGS, nullptr },
        { "remove", (PyCFunction)MediaPropertySet_Remove, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaPropertySet, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaPropertySet[] = {
        { const_cast<char*>("size"), (getter)MediaPropertySet_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaPropertySet[] = 
    {
        { Py_tp_new, _new_MediaPropertySet },
        { Py_tp_dealloc, _dealloc_MediaPropertySet },
        { Py_tp_methods, _methods_MediaPropertySet },
        { Py_tp_getset, _getset_MediaPropertySet },
        { Py_tp_iter, _iterator_MediaPropertySet },
        { Py_mp_length, _map_length_MediaPropertySet },
        { Py_mp_subscript, _map_subscript_MediaPropertySet },
        { Py_mp_ass_subscript, _map_assign_MediaPropertySet },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaPropertySet =
    {
        "_winrt_Windows_Media_MediaProperties.MediaPropertySet",
        sizeof(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPropertySet
    };

    // ----- MediaRatio class --------------------
    constexpr const char* const _type_name_MediaRatio = "MediaRatio";

    static PyObject* _new_MediaRatio(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaRatio);
        return nullptr;
    }

    static void _dealloc_MediaRatio(py::wrapper::Windows::Media::MediaProperties::MediaRatio* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaRatio_get_Numerator(py::wrapper::Windows::Media::MediaProperties::MediaRatio* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Numerator());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaRatio_put_Numerator(py::wrapper::Windows::Media::MediaProperties::MediaRatio* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Numerator(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaRatio_get_Denominator(py::wrapper::Windows::Media::MediaProperties::MediaRatio* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Denominator());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaRatio_put_Denominator(py::wrapper::Windows::Media::MediaProperties::MediaRatio* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Denominator(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_MediaRatio(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::MediaRatio>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaRatio[] = {
        { "_from", (PyCFunction)_from_MediaRatio, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaRatio[] = {
        { const_cast<char*>("numerator"), (getter)MediaRatio_get_Numerator, (setter)MediaRatio_put_Numerator, nullptr, nullptr },
        { const_cast<char*>("denominator"), (getter)MediaRatio_get_Denominator, (setter)MediaRatio_put_Denominator, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaRatio[] = 
    {
        { Py_tp_new, _new_MediaRatio },
        { Py_tp_dealloc, _dealloc_MediaRatio },
        { Py_tp_methods, _methods_MediaRatio },
        { Py_tp_getset, _getset_MediaRatio },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaRatio =
    {
        "_winrt_Windows_Media_MediaProperties.MediaRatio",
        sizeof(py::wrapper::Windows::Media::MediaProperties::MediaRatio),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaRatio
    };

    // ----- Mpeg2ProfileIds class --------------------
    constexpr const char* const _type_name_Mpeg2ProfileIds = "Mpeg2ProfileIds";

    static PyObject* _new_Mpeg2ProfileIds(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_Mpeg2ProfileIds);
        return nullptr;
    }

    static PyObject* Mpeg2ProfileIds_get_High(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds::High());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Mpeg2ProfileIds_get_Main(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds::Main());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Mpeg2ProfileIds_get_SignalNoiseRatioScalable(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds::SignalNoiseRatioScalable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Mpeg2ProfileIds_get_Simple(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds::Simple());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Mpeg2ProfileIds_get_SpatiallyScalable(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds::SpatiallyScalable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Mpeg2ProfileIds[] = {
        { "get_high", (PyCFunction)Mpeg2ProfileIds_get_High, METH_NOARGS | METH_STATIC, nullptr },
        { "get_main", (PyCFunction)Mpeg2ProfileIds_get_Main, METH_NOARGS | METH_STATIC, nullptr },
        { "get_signal_noise_ratio_scalable", (PyCFunction)Mpeg2ProfileIds_get_SignalNoiseRatioScalable, METH_NOARGS | METH_STATIC, nullptr },
        { "get_simple", (PyCFunction)Mpeg2ProfileIds_get_Simple, METH_NOARGS | METH_STATIC, nullptr },
        { "get_spatially_scalable", (PyCFunction)Mpeg2ProfileIds_get_SpatiallyScalable, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_Mpeg2ProfileIds[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_Mpeg2ProfileIds[] = 
    {
        { Py_tp_new, _new_Mpeg2ProfileIds },
        { Py_tp_methods, _methods_Mpeg2ProfileIds },
        { Py_tp_getset, _getset_Mpeg2ProfileIds },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Mpeg2ProfileIds =
    {
        "_winrt_Windows_Media_MediaProperties.Mpeg2ProfileIds",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Mpeg2ProfileIds
    };

    // ----- TimedMetadataEncodingProperties class --------------------
    constexpr const char* const _type_name_TimedMetadataEncodingProperties = "TimedMetadataEncodingProperties";

    static PyObject* _new_TimedMetadataEncodingProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedMetadataEncodingProperties(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedMetadataEncodingProperties_Copy(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_CreatePgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties::CreatePgs());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_CreateSrt(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties::CreateSrt());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_CreateSsa(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties::CreateSsa(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_CreateVobSub(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties::CreateVobSub(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_GetFormatUserData(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetFormatUserData(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_SetFormatUserData(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                self->obj.SetFormatUserData(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedMetadataEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataEncodingProperties[] = {
        { "copy", (PyCFunction)TimedMetadataEncodingProperties_Copy, METH_VARARGS, nullptr },
        { "create_pgs", (PyCFunction)TimedMetadataEncodingProperties_CreatePgs, METH_VARARGS | METH_STATIC, nullptr },
        { "create_srt", (PyCFunction)TimedMetadataEncodingProperties_CreateSrt, METH_VARARGS | METH_STATIC, nullptr },
        { "create_ssa", (PyCFunction)TimedMetadataEncodingProperties_CreateSsa, METH_VARARGS | METH_STATIC, nullptr },
        { "create_vob_sub", (PyCFunction)TimedMetadataEncodingProperties_CreateVobSub, METH_VARARGS | METH_STATIC, nullptr },
        { "get_format_user_data", (PyCFunction)TimedMetadataEncodingProperties_GetFormatUserData, METH_VARARGS, nullptr },
        { "set_format_user_data", (PyCFunction)TimedMetadataEncodingProperties_SetFormatUserData, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_TimedMetadataEncodingProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TimedMetadataEncodingProperties[] = {
        { const_cast<char*>("subtype"), (getter)TimedMetadataEncodingProperties_get_Subtype, (setter)TimedMetadataEncodingProperties_put_Subtype, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)TimedMetadataEncodingProperties_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)TimedMetadataEncodingProperties_get_Type, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TimedMetadataEncodingProperties[] = 
    {
        { Py_tp_new, _new_TimedMetadataEncodingProperties },
        { Py_tp_dealloc, _dealloc_TimedMetadataEncodingProperties },
        { Py_tp_methods, _methods_TimedMetadataEncodingProperties },
        { Py_tp_getset, _getset_TimedMetadataEncodingProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimedMetadataEncodingProperties =
    {
        "_winrt_Windows_Media_MediaProperties.TimedMetadataEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataEncodingProperties
    };

    // ----- VideoEncodingProperties class --------------------
    constexpr const char* const _type_name_VideoEncodingProperties = "VideoEncodingProperties";

    static PyObject* _new_VideoEncodingProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::VideoEncodingProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoEncodingProperties(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoEncodingProperties_Copy(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_CreateH264(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::VideoEncodingProperties::CreateH264());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_CreateHevc(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::VideoEncodingProperties::CreateHevc());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_CreateMpeg2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::VideoEncodingProperties::CreateMpeg2());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_CreateUncompressed(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::VideoEncodingProperties::CreateUncompressed(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_GetFormatUserData(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetFormatUserData(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_SetFormatUserData(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                self->obj.SetFormatUserData(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_Width(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoEncodingProperties_put_Width(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Width(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoEncodingProperties_get_Height(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoEncodingProperties_put_Height(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Height(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoEncodingProperties_get_Bitrate(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoEncodingProperties_put_Bitrate(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Bitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoEncodingProperties_get_PixelAspectRatio(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelAspectRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_FrameRate(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_ProfileId(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProfileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoEncodingProperties_put_ProfileId(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ProfileId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoEncodingProperties_get_StereoscopicVideoPackingMode(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StereoscopicVideoPackingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_SphericalVideoFrameFormat(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SphericalVideoFrameFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoEncodingProperties[] = {
        { "copy", (PyCFunction)VideoEncodingProperties_Copy, METH_VARARGS, nullptr },
        { "create_h264", (PyCFunction)VideoEncodingProperties_CreateH264, METH_VARARGS | METH_STATIC, nullptr },
        { "create_hevc", (PyCFunction)VideoEncodingProperties_CreateHevc, METH_VARARGS | METH_STATIC, nullptr },
        { "create_mpeg2", (PyCFunction)VideoEncodingProperties_CreateMpeg2, METH_VARARGS | METH_STATIC, nullptr },
        { "create_uncompressed", (PyCFunction)VideoEncodingProperties_CreateUncompressed, METH_VARARGS | METH_STATIC, nullptr },
        { "get_format_user_data", (PyCFunction)VideoEncodingProperties_GetFormatUserData, METH_VARARGS, nullptr },
        { "set_format_user_data", (PyCFunction)VideoEncodingProperties_SetFormatUserData, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_VideoEncodingProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VideoEncodingProperties[] = {
        { const_cast<char*>("subtype"), (getter)VideoEncodingProperties_get_Subtype, (setter)VideoEncodingProperties_put_Subtype, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)VideoEncodingProperties_get_Type, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)VideoEncodingProperties_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("width"), (getter)VideoEncodingProperties_get_Width, (setter)VideoEncodingProperties_put_Width, nullptr, nullptr },
        { const_cast<char*>("height"), (getter)VideoEncodingProperties_get_Height, (setter)VideoEncodingProperties_put_Height, nullptr, nullptr },
        { const_cast<char*>("bitrate"), (getter)VideoEncodingProperties_get_Bitrate, (setter)VideoEncodingProperties_put_Bitrate, nullptr, nullptr },
        { const_cast<char*>("pixel_aspect_ratio"), (getter)VideoEncodingProperties_get_PixelAspectRatio, nullptr, nullptr, nullptr },
        { const_cast<char*>("frame_rate"), (getter)VideoEncodingProperties_get_FrameRate, nullptr, nullptr, nullptr },
        { const_cast<char*>("profile_id"), (getter)VideoEncodingProperties_get_ProfileId, (setter)VideoEncodingProperties_put_ProfileId, nullptr, nullptr },
        { const_cast<char*>("stereoscopic_video_packing_mode"), (getter)VideoEncodingProperties_get_StereoscopicVideoPackingMode, nullptr, nullptr, nullptr },
        { const_cast<char*>("spherical_video_frame_format"), (getter)VideoEncodingProperties_get_SphericalVideoFrameFormat, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VideoEncodingProperties[] = 
    {
        { Py_tp_new, _new_VideoEncodingProperties },
        { Py_tp_dealloc, _dealloc_VideoEncodingProperties },
        { Py_tp_methods, _methods_VideoEncodingProperties },
        { Py_tp_getset, _getset_VideoEncodingProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoEncodingProperties =
    {
        "_winrt_Windows_Media_MediaProperties.VideoEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoEncodingProperties
    };

    // ----- IMediaEncodingProperties interface --------------------
    constexpr const char* const _type_name_IMediaEncodingProperties = "IMediaEncodingProperties";

    static PyObject* _new_IMediaEncodingProperties(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IMediaEncodingProperties);
        return nullptr;
    }

    static void _dealloc_IMediaEncodingProperties(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IMediaEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IMediaEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaEncodingProperties[] = {
        { "_from", (PyCFunction)_from_IMediaEncodingProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IMediaEncodingProperties[] = {
        { const_cast<char*>("properties"), (getter)IMediaEncodingProperties_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("subtype"), (getter)IMediaEncodingProperties_get_Subtype, (setter)IMediaEncodingProperties_put_Subtype, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)IMediaEncodingProperties_get_Type, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IMediaEncodingProperties[] = 
    {
        { Py_tp_new, _new_IMediaEncodingProperties },
        { Py_tp_dealloc, _dealloc_IMediaEncodingProperties },
        { Py_tp_methods, _methods_IMediaEncodingProperties },
        { Py_tp_getset, _getset_IMediaEncodingProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IMediaEncodingProperties =
    {
        "_winrt_Windows_Media_MediaProperties.IMediaEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaEncodingProperties
    };

    // ----- Windows.Media.MediaProperties Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>::python_type = py::register_python_type(module, _type_name_AudioEncodingProperties, &_type_spec_AudioEncodingProperties, bases.get());
            py::winrt_type<winrt::Windows::Media::MediaProperties::ContainerEncodingProperties>::python_type = py::register_python_type(module, _type_name_ContainerEncodingProperties, &_type_spec_ContainerEncodingProperties, bases.get());
            py::winrt_type<winrt::Windows::Media::MediaProperties::H264ProfileIds>::python_type = py::register_python_type(module, _type_name_H264ProfileIds, &_type_spec_H264ProfileIds, nullptr);
            py::winrt_type<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>::python_type = py::register_python_type(module, _type_name_ImageEncodingProperties, &_type_spec_ImageEncodingProperties, bases.get());
            py::winrt_type<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>::python_type = py::register_python_type(module, _type_name_MediaEncodingProfile, &_type_spec_MediaEncodingProfile, bases.get());
            py::winrt_type<winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes>::python_type = py::register_python_type(module, _type_name_MediaEncodingSubtypes, &_type_spec_MediaEncodingSubtypes, nullptr);
            py::winrt_type<winrt::Windows::Media::MediaProperties::MediaPropertySet>::python_type = py::register_python_type(module, _type_name_MediaPropertySet, &_type_spec_MediaPropertySet, bases.get());
            py::winrt_type<winrt::Windows::Media::MediaProperties::MediaRatio>::python_type = py::register_python_type(module, _type_name_MediaRatio, &_type_spec_MediaRatio, bases.get());
            py::winrt_type<winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds>::python_type = py::register_python_type(module, _type_name_Mpeg2ProfileIds, &_type_spec_Mpeg2ProfileIds, nullptr);
            py::winrt_type<winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties>::python_type = py::register_python_type(module, _type_name_TimedMetadataEncodingProperties, &_type_spec_TimedMetadataEncodingProperties, bases.get());
            py::winrt_type<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>::python_type = py::register_python_type(module, _type_name_VideoEncodingProperties, &_type_spec_VideoEncodingProperties, bases.get());
            py::winrt_type<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>::python_type = py::register_python_type(module, _type_name_IMediaEncodingProperties, &_type_spec_IMediaEncodingProperties, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Media.MediaProperties");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Media_MediaProperties",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Media::MediaProperties

PyMODINIT_FUNC
PyInit__winrt_Windows_Media_MediaProperties (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Media::MediaProperties::module_def);
}
