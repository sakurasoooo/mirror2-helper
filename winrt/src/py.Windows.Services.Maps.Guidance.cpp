// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Services.Maps.Guidance.h"

PyTypeObject* py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceAudioNotificationRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceLaneInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceManeuver>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceMapMatchedCoordinate>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceNavigator>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceReroutedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceRoadSegment>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceRoadSignpost>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceRoute>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceTelemetryCollector>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceUpdatedEventArgs>::python_type;

namespace py::cpp::Windows::Services::Maps::Guidance
{
    // ----- GuidanceAudioNotificationRequestedEventArgs class --------------------
    constexpr const char* const _type_name_GuidanceAudioNotificationRequestedEventArgs = "GuidanceAudioNotificationRequestedEventArgs";

    static PyObject* _new_GuidanceAudioNotificationRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GuidanceAudioNotificationRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_GuidanceAudioNotificationRequestedEventArgs(py::wrapper::Windows::Services::Maps::Guidance::GuidanceAudioNotificationRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GuidanceAudioNotificationRequestedEventArgs_get_AudioFilePaths(py::wrapper::Windows::Services::Maps::Guidance::GuidanceAudioNotificationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioFilePaths());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceAudioNotificationRequestedEventArgs_get_AudioNotification(py::wrapper::Windows::Services::Maps::Guidance::GuidanceAudioNotificationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceAudioNotificationRequestedEventArgs_get_AudioText(py::wrapper::Windows::Services::Maps::Guidance::GuidanceAudioNotificationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GuidanceAudioNotificationRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Maps::Guidance::GuidanceAudioNotificationRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GuidanceAudioNotificationRequestedEventArgs[] = {
        { "_from", (PyCFunction)_from_GuidanceAudioNotificationRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GuidanceAudioNotificationRequestedEventArgs[] = {
        { const_cast<char*>("audio_file_paths"), (getter)GuidanceAudioNotificationRequestedEventArgs_get_AudioFilePaths, nullptr, nullptr, nullptr },
        { const_cast<char*>("audio_notification"), (getter)GuidanceAudioNotificationRequestedEventArgs_get_AudioNotification, nullptr, nullptr, nullptr },
        { const_cast<char*>("audio_text"), (getter)GuidanceAudioNotificationRequestedEventArgs_get_AudioText, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GuidanceAudioNotificationRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_GuidanceAudioNotificationRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_GuidanceAudioNotificationRequestedEventArgs },
        { Py_tp_methods, _methods_GuidanceAudioNotificationRequestedEventArgs },
        { Py_tp_getset, _getset_GuidanceAudioNotificationRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GuidanceAudioNotificationRequestedEventArgs =
    {
        "_winrt_Windows_Services_Maps_Guidance.GuidanceAudioNotificationRequestedEventArgs",
        sizeof(py::wrapper::Windows::Services::Maps::Guidance::GuidanceAudioNotificationRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GuidanceAudioNotificationRequestedEventArgs
    };

    // ----- GuidanceLaneInfo class --------------------
    constexpr const char* const _type_name_GuidanceLaneInfo = "GuidanceLaneInfo";

    static PyObject* _new_GuidanceLaneInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GuidanceLaneInfo);
        return nullptr;
    }

    static void _dealloc_GuidanceLaneInfo(py::wrapper::Windows::Services::Maps::Guidance::GuidanceLaneInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GuidanceLaneInfo_get_IsOnRoute(py::wrapper::Windows::Services::Maps::Guidance::GuidanceLaneInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOnRoute());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceLaneInfo_get_LaneMarkers(py::wrapper::Windows::Services::Maps::Guidance::GuidanceLaneInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LaneMarkers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GuidanceLaneInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Maps::Guidance::GuidanceLaneInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GuidanceLaneInfo[] = {
        { "_from", (PyCFunction)_from_GuidanceLaneInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GuidanceLaneInfo[] = {
        { const_cast<char*>("is_on_route"), (getter)GuidanceLaneInfo_get_IsOnRoute, nullptr, nullptr, nullptr },
        { const_cast<char*>("lane_markers"), (getter)GuidanceLaneInfo_get_LaneMarkers, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GuidanceLaneInfo[] = 
    {
        { Py_tp_new, _new_GuidanceLaneInfo },
        { Py_tp_dealloc, _dealloc_GuidanceLaneInfo },
        { Py_tp_methods, _methods_GuidanceLaneInfo },
        { Py_tp_getset, _getset_GuidanceLaneInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GuidanceLaneInfo =
    {
        "_winrt_Windows_Services_Maps_Guidance.GuidanceLaneInfo",
        sizeof(py::wrapper::Windows::Services::Maps::Guidance::GuidanceLaneInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GuidanceLaneInfo
    };

    // ----- GuidanceManeuver class --------------------
    constexpr const char* const _type_name_GuidanceManeuver = "GuidanceManeuver";

    static PyObject* _new_GuidanceManeuver(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GuidanceManeuver);
        return nullptr;
    }

    static void _dealloc_GuidanceManeuver(py::wrapper::Windows::Services::Maps::Guidance::GuidanceManeuver* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GuidanceManeuver_get_DepartureRoadName(py::wrapper::Windows::Services::Maps::Guidance::GuidanceManeuver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DepartureRoadName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceManeuver_get_DepartureShortRoadName(py::wrapper::Windows::Services::Maps::Guidance::GuidanceManeuver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DepartureShortRoadName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceManeuver_get_DistanceFromPreviousManeuver(py::wrapper::Windows::Services::Maps::Guidance::GuidanceManeuver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DistanceFromPreviousManeuver());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceManeuver_get_DistanceFromRouteStart(py::wrapper::Windows::Services::Maps::Guidance::GuidanceManeuver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DistanceFromRouteStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceManeuver_get_EndAngle(py::wrapper::Windows::Services::Maps::Guidance::GuidanceManeuver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceManeuver_get_InstructionText(py::wrapper::Windows::Services::Maps::Guidance::GuidanceManeuver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstructionText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceManeuver_get_Kind(py::wrapper::Windows::Services::Maps::Guidance::GuidanceManeuver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceManeuver_get_NextRoadName(py::wrapper::Windows::Services::Maps::Guidance::GuidanceManeuver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NextRoadName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceManeuver_get_NextShortRoadName(py::wrapper::Windows::Services::Maps::Guidance::GuidanceManeuver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NextShortRoadName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceManeuver_get_RoadSignpost(py::wrapper::Windows::Services::Maps::Guidance::GuidanceManeuver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoadSignpost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceManeuver_get_StartAngle(py::wrapper::Windows::Services::Maps::Guidance::GuidanceManeuver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceManeuver_get_StartLocation(py::wrapper::Windows::Services::Maps::Guidance::GuidanceManeuver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GuidanceManeuver(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Maps::Guidance::GuidanceManeuver>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GuidanceManeuver[] = {
        { "_from", (PyCFunction)_from_GuidanceManeuver, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GuidanceManeuver[] = {
        { const_cast<char*>("departure_road_name"), (getter)GuidanceManeuver_get_DepartureRoadName, nullptr, nullptr, nullptr },
        { const_cast<char*>("departure_short_road_name"), (getter)GuidanceManeuver_get_DepartureShortRoadName, nullptr, nullptr, nullptr },
        { const_cast<char*>("distance_from_previous_maneuver"), (getter)GuidanceManeuver_get_DistanceFromPreviousManeuver, nullptr, nullptr, nullptr },
        { const_cast<char*>("distance_from_route_start"), (getter)GuidanceManeuver_get_DistanceFromRouteStart, nullptr, nullptr, nullptr },
        { const_cast<char*>("end_angle"), (getter)GuidanceManeuver_get_EndAngle, nullptr, nullptr, nullptr },
        { const_cast<char*>("instruction_text"), (getter)GuidanceManeuver_get_InstructionText, nullptr, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)GuidanceManeuver_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("next_road_name"), (getter)GuidanceManeuver_get_NextRoadName, nullptr, nullptr, nullptr },
        { const_cast<char*>("next_short_road_name"), (getter)GuidanceManeuver_get_NextShortRoadName, nullptr, nullptr, nullptr },
        { const_cast<char*>("road_signpost"), (getter)GuidanceManeuver_get_RoadSignpost, nullptr, nullptr, nullptr },
        { const_cast<char*>("start_angle"), (getter)GuidanceManeuver_get_StartAngle, nullptr, nullptr, nullptr },
        { const_cast<char*>("start_location"), (getter)GuidanceManeuver_get_StartLocation, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GuidanceManeuver[] = 
    {
        { Py_tp_new, _new_GuidanceManeuver },
        { Py_tp_dealloc, _dealloc_GuidanceManeuver },
        { Py_tp_methods, _methods_GuidanceManeuver },
        { Py_tp_getset, _getset_GuidanceManeuver },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GuidanceManeuver =
    {
        "_winrt_Windows_Services_Maps_Guidance.GuidanceManeuver",
        sizeof(py::wrapper::Windows::Services::Maps::Guidance::GuidanceManeuver),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GuidanceManeuver
    };

    // ----- GuidanceMapMatchedCoordinate class --------------------
    constexpr const char* const _type_name_GuidanceMapMatchedCoordinate = "GuidanceMapMatchedCoordinate";

    static PyObject* _new_GuidanceMapMatchedCoordinate(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GuidanceMapMatchedCoordinate);
        return nullptr;
    }

    static void _dealloc_GuidanceMapMatchedCoordinate(py::wrapper::Windows::Services::Maps::Guidance::GuidanceMapMatchedCoordinate* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GuidanceMapMatchedCoordinate_get_CurrentHeading(py::wrapper::Windows::Services::Maps::Guidance::GuidanceMapMatchedCoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentHeading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceMapMatchedCoordinate_get_CurrentSpeed(py::wrapper::Windows::Services::Maps::Guidance::GuidanceMapMatchedCoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentSpeed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceMapMatchedCoordinate_get_IsOnStreet(py::wrapper::Windows::Services::Maps::Guidance::GuidanceMapMatchedCoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOnStreet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceMapMatchedCoordinate_get_Location(py::wrapper::Windows::Services::Maps::Guidance::GuidanceMapMatchedCoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceMapMatchedCoordinate_get_Road(py::wrapper::Windows::Services::Maps::Guidance::GuidanceMapMatchedCoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Road());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GuidanceMapMatchedCoordinate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Maps::Guidance::GuidanceMapMatchedCoordinate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GuidanceMapMatchedCoordinate[] = {
        { "_from", (PyCFunction)_from_GuidanceMapMatchedCoordinate, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GuidanceMapMatchedCoordinate[] = {
        { const_cast<char*>("current_heading"), (getter)GuidanceMapMatchedCoordinate_get_CurrentHeading, nullptr, nullptr, nullptr },
        { const_cast<char*>("current_speed"), (getter)GuidanceMapMatchedCoordinate_get_CurrentSpeed, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_on_street"), (getter)GuidanceMapMatchedCoordinate_get_IsOnStreet, nullptr, nullptr, nullptr },
        { const_cast<char*>("location"), (getter)GuidanceMapMatchedCoordinate_get_Location, nullptr, nullptr, nullptr },
        { const_cast<char*>("road"), (getter)GuidanceMapMatchedCoordinate_get_Road, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GuidanceMapMatchedCoordinate[] = 
    {
        { Py_tp_new, _new_GuidanceMapMatchedCoordinate },
        { Py_tp_dealloc, _dealloc_GuidanceMapMatchedCoordinate },
        { Py_tp_methods, _methods_GuidanceMapMatchedCoordinate },
        { Py_tp_getset, _getset_GuidanceMapMatchedCoordinate },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GuidanceMapMatchedCoordinate =
    {
        "_winrt_Windows_Services_Maps_Guidance.GuidanceMapMatchedCoordinate",
        sizeof(py::wrapper::Windows::Services::Maps::Guidance::GuidanceMapMatchedCoordinate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GuidanceMapMatchedCoordinate
    };

    // ----- GuidanceNavigator class --------------------
    constexpr const char* const _type_name_GuidanceNavigator = "GuidanceNavigator";

    static PyObject* _new_GuidanceNavigator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GuidanceNavigator);
        return nullptr;
    }

    static void _dealloc_GuidanceNavigator(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GuidanceNavigator_GetCurrent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Services::Maps::Guidance::GuidanceNavigator::GetCurrent());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_Pause(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Pause();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_RepeatLastAudioNotification(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RepeatLastAudioNotification();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_Resume(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Resume();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_SetGuidanceVoice(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetGuidanceVoice(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_StartNavigating(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Maps::Guidance::GuidanceRoute>(args, 0);

                self->obj.StartNavigating(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_StartSimulating(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Maps::Guidance::GuidanceRoute>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.StartSimulating(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_StartTracking(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.StartTracking();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_Stop(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_UpdateUserLocation(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geocoordinate>(args, 0);

                self->obj.UpdateUserLocation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geocoordinate>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 1);

                self->obj.UpdateUserLocation(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_get_AudioNotifications(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioNotifications());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GuidanceNavigator_put_AudioNotifications(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Services::Maps::Guidance::GuidanceAudioNotifications>(arg);

            self->obj.AudioNotifications(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GuidanceNavigator_get_AudioMeasurementSystem(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioMeasurementSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GuidanceNavigator_put_AudioMeasurementSystem(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Services::Maps::Guidance::GuidanceAudioMeasurementSystem>(arg);

            self->obj.AudioMeasurementSystem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GuidanceNavigator_get_IsGuidanceAudioMuted(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsGuidanceAudioMuted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GuidanceNavigator_put_IsGuidanceAudioMuted(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsGuidanceAudioMuted(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GuidanceNavigator_get_UseAppProvidedVoice(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Services::Maps::Guidance::GuidanceNavigator::UseAppProvidedVoice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_add_DestinationReached(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Maps::Guidance::GuidanceNavigator, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.DestinationReached(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_remove_DestinationReached(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DestinationReached(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_add_GuidanceUpdated(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Maps::Guidance::GuidanceNavigator, winrt::Windows::Services::Maps::Guidance::GuidanceUpdatedEventArgs>>(arg);

            return py::convert(self->obj.GuidanceUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_remove_GuidanceUpdated(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.GuidanceUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_add_RerouteFailed(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Maps::Guidance::GuidanceNavigator, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.RerouteFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_remove_RerouteFailed(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RerouteFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_add_Rerouted(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Maps::Guidance::GuidanceNavigator, winrt::Windows::Services::Maps::Guidance::GuidanceReroutedEventArgs>>(arg);

            return py::convert(self->obj.Rerouted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_remove_Rerouted(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Rerouted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_add_Rerouting(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Maps::Guidance::GuidanceNavigator, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Rerouting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_remove_Rerouting(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Rerouting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_add_UserLocationLost(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Maps::Guidance::GuidanceNavigator, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.UserLocationLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_remove_UserLocationLost(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserLocationLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_add_UserLocationRestored(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Maps::Guidance::GuidanceNavigator, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.UserLocationRestored(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_remove_UserLocationRestored(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserLocationRestored(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_add_AudioNotificationRequested(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Maps::Guidance::GuidanceNavigator, winrt::Windows::Services::Maps::Guidance::GuidanceAudioNotificationRequestedEventArgs>>(arg);

            return py::convert(self->obj.AudioNotificationRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceNavigator_remove_AudioNotificationRequested(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioNotificationRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GuidanceNavigator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Maps::Guidance::GuidanceNavigator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GuidanceNavigator[] = {
        { "get_current", (PyCFunction)GuidanceNavigator_GetCurrent, METH_VARARGS | METH_STATIC, nullptr },
        { "pause", (PyCFunction)GuidanceNavigator_Pause, METH_VARARGS, nullptr },
        { "repeat_last_audio_notification", (PyCFunction)GuidanceNavigator_RepeatLastAudioNotification, METH_VARARGS, nullptr },
        { "resume", (PyCFunction)GuidanceNavigator_Resume, METH_VARARGS, nullptr },
        { "set_guidance_voice", (PyCFunction)GuidanceNavigator_SetGuidanceVoice, METH_VARARGS, nullptr },
        { "start_navigating", (PyCFunction)GuidanceNavigator_StartNavigating, METH_VARARGS, nullptr },
        { "start_simulating", (PyCFunction)GuidanceNavigator_StartSimulating, METH_VARARGS, nullptr },
        { "start_tracking", (PyCFunction)GuidanceNavigator_StartTracking, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)GuidanceNavigator_Stop, METH_VARARGS, nullptr },
        { "update_user_location", (PyCFunction)GuidanceNavigator_UpdateUserLocation, METH_VARARGS, nullptr },
        { "get_use_app_provided_voice", (PyCFunction)GuidanceNavigator_get_UseAppProvidedVoice, METH_NOARGS | METH_STATIC, nullptr },
        { "add_destination_reached", (PyCFunction)GuidanceNavigator_add_DestinationReached, METH_O, nullptr },
        { "remove_destination_reached", (PyCFunction)GuidanceNavigator_remove_DestinationReached, METH_O, nullptr },
        { "add_guidance_updated", (PyCFunction)GuidanceNavigator_add_GuidanceUpdated, METH_O, nullptr },
        { "remove_guidance_updated", (PyCFunction)GuidanceNavigator_remove_GuidanceUpdated, METH_O, nullptr },
        { "add_reroute_failed", (PyCFunction)GuidanceNavigator_add_RerouteFailed, METH_O, nullptr },
        { "remove_reroute_failed", (PyCFunction)GuidanceNavigator_remove_RerouteFailed, METH_O, nullptr },
        { "add_rerouted", (PyCFunction)GuidanceNavigator_add_Rerouted, METH_O, nullptr },
        { "remove_rerouted", (PyCFunction)GuidanceNavigator_remove_Rerouted, METH_O, nullptr },
        { "add_rerouting", (PyCFunction)GuidanceNavigator_add_Rerouting, METH_O, nullptr },
        { "remove_rerouting", (PyCFunction)GuidanceNavigator_remove_Rerouting, METH_O, nullptr },
        { "add_user_location_lost", (PyCFunction)GuidanceNavigator_add_UserLocationLost, METH_O, nullptr },
        { "remove_user_location_lost", (PyCFunction)GuidanceNavigator_remove_UserLocationLost, METH_O, nullptr },
        { "add_user_location_restored", (PyCFunction)GuidanceNavigator_add_UserLocationRestored, METH_O, nullptr },
        { "remove_user_location_restored", (PyCFunction)GuidanceNavigator_remove_UserLocationRestored, METH_O, nullptr },
        { "add_audio_notification_requested", (PyCFunction)GuidanceNavigator_add_AudioNotificationRequested, METH_O, nullptr },
        { "remove_audio_notification_requested", (PyCFunction)GuidanceNavigator_remove_AudioNotificationRequested, METH_O, nullptr },
        { "_from", (PyCFunction)_from_GuidanceNavigator, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GuidanceNavigator[] = {
        { const_cast<char*>("audio_notifications"), (getter)GuidanceNavigator_get_AudioNotifications, (setter)GuidanceNavigator_put_AudioNotifications, nullptr, nullptr },
        { const_cast<char*>("audio_measurement_system"), (getter)GuidanceNavigator_get_AudioMeasurementSystem, (setter)GuidanceNavigator_put_AudioMeasurementSystem, nullptr, nullptr },
        { const_cast<char*>("is_guidance_audio_muted"), (getter)GuidanceNavigator_get_IsGuidanceAudioMuted, (setter)GuidanceNavigator_put_IsGuidanceAudioMuted, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GuidanceNavigator[] = 
    {
        { Py_tp_new, _new_GuidanceNavigator },
        { Py_tp_dealloc, _dealloc_GuidanceNavigator },
        { Py_tp_methods, _methods_GuidanceNavigator },
        { Py_tp_getset, _getset_GuidanceNavigator },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GuidanceNavigator =
    {
        "_winrt_Windows_Services_Maps_Guidance.GuidanceNavigator",
        sizeof(py::wrapper::Windows::Services::Maps::Guidance::GuidanceNavigator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GuidanceNavigator
    };

    // ----- GuidanceReroutedEventArgs class --------------------
    constexpr const char* const _type_name_GuidanceReroutedEventArgs = "GuidanceReroutedEventArgs";

    static PyObject* _new_GuidanceReroutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GuidanceReroutedEventArgs);
        return nullptr;
    }

    static void _dealloc_GuidanceReroutedEventArgs(py::wrapper::Windows::Services::Maps::Guidance::GuidanceReroutedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GuidanceReroutedEventArgs_get_Route(py::wrapper::Windows::Services::Maps::Guidance::GuidanceReroutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Route());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GuidanceReroutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Maps::Guidance::GuidanceReroutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GuidanceReroutedEventArgs[] = {
        { "_from", (PyCFunction)_from_GuidanceReroutedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GuidanceReroutedEventArgs[] = {
        { const_cast<char*>("route"), (getter)GuidanceReroutedEventArgs_get_Route, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GuidanceReroutedEventArgs[] = 
    {
        { Py_tp_new, _new_GuidanceReroutedEventArgs },
        { Py_tp_dealloc, _dealloc_GuidanceReroutedEventArgs },
        { Py_tp_methods, _methods_GuidanceReroutedEventArgs },
        { Py_tp_getset, _getset_GuidanceReroutedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GuidanceReroutedEventArgs =
    {
        "_winrt_Windows_Services_Maps_Guidance.GuidanceReroutedEventArgs",
        sizeof(py::wrapper::Windows::Services::Maps::Guidance::GuidanceReroutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GuidanceReroutedEventArgs
    };

    // ----- GuidanceRoadSegment class --------------------
    constexpr const char* const _type_name_GuidanceRoadSegment = "GuidanceRoadSegment";

    static PyObject* _new_GuidanceRoadSegment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GuidanceRoadSegment);
        return nullptr;
    }

    static void _dealloc_GuidanceRoadSegment(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoadSegment* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GuidanceRoadSegment_get_Id(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoadSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceRoadSegment_get_IsHighway(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoadSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHighway());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceRoadSegment_get_IsTollRoad(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoadSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTollRoad());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceRoadSegment_get_IsTunnel(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoadSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTunnel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceRoadSegment_get_Path(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoadSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceRoadSegment_get_RoadName(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoadSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoadName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceRoadSegment_get_ShortRoadName(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoadSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShortRoadName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceRoadSegment_get_SpeedLimit(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoadSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SpeedLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceRoadSegment_get_TravelTime(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoadSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TravelTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceRoadSegment_get_IsScenic(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoadSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsScenic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GuidanceRoadSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Maps::Guidance::GuidanceRoadSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GuidanceRoadSegment[] = {
        { "_from", (PyCFunction)_from_GuidanceRoadSegment, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GuidanceRoadSegment[] = {
        { const_cast<char*>("id"), (getter)GuidanceRoadSegment_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_highway"), (getter)GuidanceRoadSegment_get_IsHighway, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_toll_road"), (getter)GuidanceRoadSegment_get_IsTollRoad, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_tunnel"), (getter)GuidanceRoadSegment_get_IsTunnel, nullptr, nullptr, nullptr },
        { const_cast<char*>("path"), (getter)GuidanceRoadSegment_get_Path, nullptr, nullptr, nullptr },
        { const_cast<char*>("road_name"), (getter)GuidanceRoadSegment_get_RoadName, nullptr, nullptr, nullptr },
        { const_cast<char*>("short_road_name"), (getter)GuidanceRoadSegment_get_ShortRoadName, nullptr, nullptr, nullptr },
        { const_cast<char*>("speed_limit"), (getter)GuidanceRoadSegment_get_SpeedLimit, nullptr, nullptr, nullptr },
        { const_cast<char*>("travel_time"), (getter)GuidanceRoadSegment_get_TravelTime, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_scenic"), (getter)GuidanceRoadSegment_get_IsScenic, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GuidanceRoadSegment[] = 
    {
        { Py_tp_new, _new_GuidanceRoadSegment },
        { Py_tp_dealloc, _dealloc_GuidanceRoadSegment },
        { Py_tp_methods, _methods_GuidanceRoadSegment },
        { Py_tp_getset, _getset_GuidanceRoadSegment },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GuidanceRoadSegment =
    {
        "_winrt_Windows_Services_Maps_Guidance.GuidanceRoadSegment",
        sizeof(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoadSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GuidanceRoadSegment
    };

    // ----- GuidanceRoadSignpost class --------------------
    constexpr const char* const _type_name_GuidanceRoadSignpost = "GuidanceRoadSignpost";

    static PyObject* _new_GuidanceRoadSignpost(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GuidanceRoadSignpost);
        return nullptr;
    }

    static void _dealloc_GuidanceRoadSignpost(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoadSignpost* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GuidanceRoadSignpost_get_BackgroundColor(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoadSignpost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceRoadSignpost_get_Exit(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoadSignpost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Exit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceRoadSignpost_get_ExitDirections(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoadSignpost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExitDirections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceRoadSignpost_get_ExitNumber(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoadSignpost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExitNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceRoadSignpost_get_ForegroundColor(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoadSignpost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GuidanceRoadSignpost(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Maps::Guidance::GuidanceRoadSignpost>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GuidanceRoadSignpost[] = {
        { "_from", (PyCFunction)_from_GuidanceRoadSignpost, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GuidanceRoadSignpost[] = {
        { const_cast<char*>("background_color"), (getter)GuidanceRoadSignpost_get_BackgroundColor, nullptr, nullptr, nullptr },
        { const_cast<char*>("exit"), (getter)GuidanceRoadSignpost_get_Exit, nullptr, nullptr, nullptr },
        { const_cast<char*>("exit_directions"), (getter)GuidanceRoadSignpost_get_ExitDirections, nullptr, nullptr, nullptr },
        { const_cast<char*>("exit_number"), (getter)GuidanceRoadSignpost_get_ExitNumber, nullptr, nullptr, nullptr },
        { const_cast<char*>("foreground_color"), (getter)GuidanceRoadSignpost_get_ForegroundColor, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GuidanceRoadSignpost[] = 
    {
        { Py_tp_new, _new_GuidanceRoadSignpost },
        { Py_tp_dealloc, _dealloc_GuidanceRoadSignpost },
        { Py_tp_methods, _methods_GuidanceRoadSignpost },
        { Py_tp_getset, _getset_GuidanceRoadSignpost },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GuidanceRoadSignpost =
    {
        "_winrt_Windows_Services_Maps_Guidance.GuidanceRoadSignpost",
        sizeof(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoadSignpost),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GuidanceRoadSignpost
    };

    // ----- GuidanceRoute class --------------------
    constexpr const char* const _type_name_GuidanceRoute = "GuidanceRoute";

    static PyObject* _new_GuidanceRoute(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GuidanceRoute);
        return nullptr;
    }

    static void _dealloc_GuidanceRoute(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoute* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GuidanceRoute_CanCreateFromMapRoute(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Maps::MapRoute>(args, 0);

                return py::convert(winrt::Windows::Services::Maps::Guidance::GuidanceRoute::CanCreateFromMapRoute(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidanceRoute_ConvertToMapRoute(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoute* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ConvertToMapRoute());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidanceRoute_TryCreateFromMapRoute(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Maps::MapRoute>(args, 0);

                return py::convert(winrt::Windows::Services::Maps::Guidance::GuidanceRoute::TryCreateFromMapRoute(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidanceRoute_get_BoundingBox(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoute* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BoundingBox());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceRoute_get_Distance(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoute* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Distance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceRoute_get_Duration(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoute* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceRoute_get_Maneuvers(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoute* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Maneuvers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceRoute_get_Path(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoute* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceRoute_get_RoadSegments(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoute* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoadSegments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GuidanceRoute(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Maps::Guidance::GuidanceRoute>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GuidanceRoute[] = {
        { "can_create_from_map_route", (PyCFunction)GuidanceRoute_CanCreateFromMapRoute, METH_VARARGS | METH_STATIC, nullptr },
        { "convert_to_map_route", (PyCFunction)GuidanceRoute_ConvertToMapRoute, METH_VARARGS, nullptr },
        { "try_create_from_map_route", (PyCFunction)GuidanceRoute_TryCreateFromMapRoute, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_GuidanceRoute, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GuidanceRoute[] = {
        { const_cast<char*>("bounding_box"), (getter)GuidanceRoute_get_BoundingBox, nullptr, nullptr, nullptr },
        { const_cast<char*>("distance"), (getter)GuidanceRoute_get_Distance, nullptr, nullptr, nullptr },
        { const_cast<char*>("duration"), (getter)GuidanceRoute_get_Duration, nullptr, nullptr, nullptr },
        { const_cast<char*>("maneuvers"), (getter)GuidanceRoute_get_Maneuvers, nullptr, nullptr, nullptr },
        { const_cast<char*>("path"), (getter)GuidanceRoute_get_Path, nullptr, nullptr, nullptr },
        { const_cast<char*>("road_segments"), (getter)GuidanceRoute_get_RoadSegments, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GuidanceRoute[] = 
    {
        { Py_tp_new, _new_GuidanceRoute },
        { Py_tp_dealloc, _dealloc_GuidanceRoute },
        { Py_tp_methods, _methods_GuidanceRoute },
        { Py_tp_getset, _getset_GuidanceRoute },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GuidanceRoute =
    {
        "_winrt_Windows_Services_Maps_Guidance.GuidanceRoute",
        sizeof(py::wrapper::Windows::Services::Maps::Guidance::GuidanceRoute),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GuidanceRoute
    };

    // ----- GuidanceTelemetryCollector class --------------------
    constexpr const char* const _type_name_GuidanceTelemetryCollector = "GuidanceTelemetryCollector";

    static PyObject* _new_GuidanceTelemetryCollector(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GuidanceTelemetryCollector);
        return nullptr;
    }

    static void _dealloc_GuidanceTelemetryCollector(py::wrapper::Windows::Services::Maps::Guidance::GuidanceTelemetryCollector* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GuidanceTelemetryCollector_ClearLocalData(py::wrapper::Windows::Services::Maps::Guidance::GuidanceTelemetryCollector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ClearLocalData();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidanceTelemetryCollector_GetCurrent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Services::Maps::Guidance::GuidanceTelemetryCollector::GetCurrent());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GuidanceTelemetryCollector_get_UploadFrequency(py::wrapper::Windows::Services::Maps::Guidance::GuidanceTelemetryCollector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UploadFrequency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GuidanceTelemetryCollector_put_UploadFrequency(py::wrapper::Windows::Services::Maps::Guidance::GuidanceTelemetryCollector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.UploadFrequency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GuidanceTelemetryCollector_get_SpeedTrigger(py::wrapper::Windows::Services::Maps::Guidance::GuidanceTelemetryCollector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SpeedTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GuidanceTelemetryCollector_put_SpeedTrigger(py::wrapper::Windows::Services::Maps::Guidance::GuidanceTelemetryCollector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.SpeedTrigger(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GuidanceTelemetryCollector_get_Enabled(py::wrapper::Windows::Services::Maps::Guidance::GuidanceTelemetryCollector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GuidanceTelemetryCollector_put_Enabled(py::wrapper::Windows::Services::Maps::Guidance::GuidanceTelemetryCollector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_GuidanceTelemetryCollector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Maps::Guidance::GuidanceTelemetryCollector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GuidanceTelemetryCollector[] = {
        { "clear_local_data", (PyCFunction)GuidanceTelemetryCollector_ClearLocalData, METH_VARARGS, nullptr },
        { "get_current", (PyCFunction)GuidanceTelemetryCollector_GetCurrent, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_GuidanceTelemetryCollector, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GuidanceTelemetryCollector[] = {
        { const_cast<char*>("upload_frequency"), (getter)GuidanceTelemetryCollector_get_UploadFrequency, (setter)GuidanceTelemetryCollector_put_UploadFrequency, nullptr, nullptr },
        { const_cast<char*>("speed_trigger"), (getter)GuidanceTelemetryCollector_get_SpeedTrigger, (setter)GuidanceTelemetryCollector_put_SpeedTrigger, nullptr, nullptr },
        { const_cast<char*>("enabled"), (getter)GuidanceTelemetryCollector_get_Enabled, (setter)GuidanceTelemetryCollector_put_Enabled, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GuidanceTelemetryCollector[] = 
    {
        { Py_tp_new, _new_GuidanceTelemetryCollector },
        { Py_tp_dealloc, _dealloc_GuidanceTelemetryCollector },
        { Py_tp_methods, _methods_GuidanceTelemetryCollector },
        { Py_tp_getset, _getset_GuidanceTelemetryCollector },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GuidanceTelemetryCollector =
    {
        "_winrt_Windows_Services_Maps_Guidance.GuidanceTelemetryCollector",
        sizeof(py::wrapper::Windows::Services::Maps::Guidance::GuidanceTelemetryCollector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GuidanceTelemetryCollector
    };

    // ----- GuidanceUpdatedEventArgs class --------------------
    constexpr const char* const _type_name_GuidanceUpdatedEventArgs = "GuidanceUpdatedEventArgs";

    static PyObject* _new_GuidanceUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GuidanceUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_GuidanceUpdatedEventArgs(py::wrapper::Windows::Services::Maps::Guidance::GuidanceUpdatedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GuidanceUpdatedEventArgs_get_AfterNextManeuver(py::wrapper::Windows::Services::Maps::Guidance::GuidanceUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AfterNextManeuver());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceUpdatedEventArgs_get_AfterNextManeuverDistance(py::wrapper::Windows::Services::Maps::Guidance::GuidanceUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AfterNextManeuverDistance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceUpdatedEventArgs_get_CurrentLocation(py::wrapper::Windows::Services::Maps::Guidance::GuidanceUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceUpdatedEventArgs_get_DistanceToDestination(py::wrapper::Windows::Services::Maps::Guidance::GuidanceUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DistanceToDestination());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceUpdatedEventArgs_get_ElapsedDistance(py::wrapper::Windows::Services::Maps::Guidance::GuidanceUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ElapsedDistance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceUpdatedEventArgs_get_ElapsedTime(py::wrapper::Windows::Services::Maps::Guidance::GuidanceUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ElapsedTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceUpdatedEventArgs_get_IsNewManeuver(py::wrapper::Windows::Services::Maps::Guidance::GuidanceUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsNewManeuver());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceUpdatedEventArgs_get_LaneInfo(py::wrapper::Windows::Services::Maps::Guidance::GuidanceUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LaneInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceUpdatedEventArgs_get_Mode(py::wrapper::Windows::Services::Maps::Guidance::GuidanceUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceUpdatedEventArgs_get_NextManeuver(py::wrapper::Windows::Services::Maps::Guidance::GuidanceUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NextManeuver());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceUpdatedEventArgs_get_NextManeuverDistance(py::wrapper::Windows::Services::Maps::Guidance::GuidanceUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NextManeuverDistance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceUpdatedEventArgs_get_RoadName(py::wrapper::Windows::Services::Maps::Guidance::GuidanceUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoadName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceUpdatedEventArgs_get_Route(py::wrapper::Windows::Services::Maps::Guidance::GuidanceUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Route());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GuidanceUpdatedEventArgs_get_TimeToDestination(py::wrapper::Windows::Services::Maps::Guidance::GuidanceUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimeToDestination());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GuidanceUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Maps::Guidance::GuidanceUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GuidanceUpdatedEventArgs[] = {
        { "_from", (PyCFunction)_from_GuidanceUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GuidanceUpdatedEventArgs[] = {
        { const_cast<char*>("after_next_maneuver"), (getter)GuidanceUpdatedEventArgs_get_AfterNextManeuver, nullptr, nullptr, nullptr },
        { const_cast<char*>("after_next_maneuver_distance"), (getter)GuidanceUpdatedEventArgs_get_AfterNextManeuverDistance, nullptr, nullptr, nullptr },
        { const_cast<char*>("current_location"), (getter)GuidanceUpdatedEventArgs_get_CurrentLocation, nullptr, nullptr, nullptr },
        { const_cast<char*>("distance_to_destination"), (getter)GuidanceUpdatedEventArgs_get_DistanceToDestination, nullptr, nullptr, nullptr },
        { const_cast<char*>("elapsed_distance"), (getter)GuidanceUpdatedEventArgs_get_ElapsedDistance, nullptr, nullptr, nullptr },
        { const_cast<char*>("elapsed_time"), (getter)GuidanceUpdatedEventArgs_get_ElapsedTime, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_new_maneuver"), (getter)GuidanceUpdatedEventArgs_get_IsNewManeuver, nullptr, nullptr, nullptr },
        { const_cast<char*>("lane_info"), (getter)GuidanceUpdatedEventArgs_get_LaneInfo, nullptr, nullptr, nullptr },
        { const_cast<char*>("mode"), (getter)GuidanceUpdatedEventArgs_get_Mode, nullptr, nullptr, nullptr },
        { const_cast<char*>("next_maneuver"), (getter)GuidanceUpdatedEventArgs_get_NextManeuver, nullptr, nullptr, nullptr },
        { const_cast<char*>("next_maneuver_distance"), (getter)GuidanceUpdatedEventArgs_get_NextManeuverDistance, nullptr, nullptr, nullptr },
        { const_cast<char*>("road_name"), (getter)GuidanceUpdatedEventArgs_get_RoadName, nullptr, nullptr, nullptr },
        { const_cast<char*>("route"), (getter)GuidanceUpdatedEventArgs_get_Route, nullptr, nullptr, nullptr },
        { const_cast<char*>("time_to_destination"), (getter)GuidanceUpdatedEventArgs_get_TimeToDestination, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GuidanceUpdatedEventArgs[] = 
    {
        { Py_tp_new, _new_GuidanceUpdatedEventArgs },
        { Py_tp_dealloc, _dealloc_GuidanceUpdatedEventArgs },
        { Py_tp_methods, _methods_GuidanceUpdatedEventArgs },
        { Py_tp_getset, _getset_GuidanceUpdatedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GuidanceUpdatedEventArgs =
    {
        "_winrt_Windows_Services_Maps_Guidance.GuidanceUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Services::Maps::Guidance::GuidanceUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GuidanceUpdatedEventArgs
    };

    // ----- Windows.Services.Maps.Guidance Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceAudioNotificationRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_GuidanceAudioNotificationRequestedEventArgs, &_type_spec_GuidanceAudioNotificationRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceLaneInfo>::python_type = py::register_python_type(module, _type_name_GuidanceLaneInfo, &_type_spec_GuidanceLaneInfo, bases.get());
            py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceManeuver>::python_type = py::register_python_type(module, _type_name_GuidanceManeuver, &_type_spec_GuidanceManeuver, bases.get());
            py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceMapMatchedCoordinate>::python_type = py::register_python_type(module, _type_name_GuidanceMapMatchedCoordinate, &_type_spec_GuidanceMapMatchedCoordinate, bases.get());
            py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceNavigator>::python_type = py::register_python_type(module, _type_name_GuidanceNavigator, &_type_spec_GuidanceNavigator, bases.get());
            py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceReroutedEventArgs>::python_type = py::register_python_type(module, _type_name_GuidanceReroutedEventArgs, &_type_spec_GuidanceReroutedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceRoadSegment>::python_type = py::register_python_type(module, _type_name_GuidanceRoadSegment, &_type_spec_GuidanceRoadSegment, bases.get());
            py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceRoadSignpost>::python_type = py::register_python_type(module, _type_name_GuidanceRoadSignpost, &_type_spec_GuidanceRoadSignpost, bases.get());
            py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceRoute>::python_type = py::register_python_type(module, _type_name_GuidanceRoute, &_type_spec_GuidanceRoute, bases.get());
            py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceTelemetryCollector>::python_type = py::register_python_type(module, _type_name_GuidanceTelemetryCollector, &_type_spec_GuidanceTelemetryCollector, bases.get());
            py::winrt_type<winrt::Windows::Services::Maps::Guidance::GuidanceUpdatedEventArgs>::python_type = py::register_python_type(module, _type_name_GuidanceUpdatedEventArgs, &_type_spec_GuidanceUpdatedEventArgs, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Services.Maps.Guidance");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Services_Maps_Guidance",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Services::Maps::Guidance

PyMODINIT_FUNC
PyInit__winrt_Windows_Services_Maps_Guidance (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Services::Maps::Guidance::module_def);
}
