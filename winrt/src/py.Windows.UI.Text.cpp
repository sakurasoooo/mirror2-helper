// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.UI.Text.h"

PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::ContentLinkInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::FontWeights>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::RichEditTextDocument>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::RichEditTextRange>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::TextConstants>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::ITextCharacterFormat>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::ITextDocument>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::ITextParagraphFormat>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::ITextRange>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::ITextSelection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Text::FontWeight>::python_type;

PyObject* py::converter<winrt::Windows::UI::Text::FontWeight>::convert(winrt::Windows::UI::Text::FontWeight instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::UI::Text::FontWeight>());
}
winrt::Windows::UI::Text::FontWeight py::converter<winrt::Windows::UI::Text::FontWeight>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::UI::Text::FontWeight>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::UI::Text::FontWeight>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::UI::Text::FontWeight return_value{};

    PyObject* py_Weight = PyDict_GetItemString(obj, "weight");
    if (!py_Weight) { throw winrt::hresult_invalid_argument(); }
    return_value.Weight = converter<uint16_t>::convert_to(py_Weight);

    return return_value;
}

namespace py::cpp::Windows::UI::Text
{
    // ----- ContentLinkInfo class --------------------
    constexpr const char* const _type_name_ContentLinkInfo = "ContentLinkInfo";

    static PyObject* _new_ContentLinkInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Text::ContentLinkInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContentLinkInfo(py::wrapper::Windows::UI::Text::ContentLinkInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContentLinkInfo_get_Uri(py::wrapper::Windows::UI::Text::ContentLinkInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentLinkInfo_put_Uri(py::wrapper::Windows::UI::Text::ContentLinkInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentLinkInfo_get_SecondaryText(py::wrapper::Windows::UI::Text::ContentLinkInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SecondaryText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentLinkInfo_put_SecondaryText(py::wrapper::Windows::UI::Text::ContentLinkInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SecondaryText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentLinkInfo_get_LinkContentKind(py::wrapper::Windows::UI::Text::ContentLinkInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LinkContentKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentLinkInfo_put_LinkContentKind(py::wrapper::Windows::UI::Text::ContentLinkInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.LinkContentKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentLinkInfo_get_Id(py::wrapper::Windows::UI::Text::ContentLinkInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentLinkInfo_put_Id(py::wrapper::Windows::UI::Text::ContentLinkInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentLinkInfo_get_DisplayText(py::wrapper::Windows::UI::Text::ContentLinkInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentLinkInfo_put_DisplayText(py::wrapper::Windows::UI::Text::ContentLinkInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContentLinkInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::ContentLinkInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentLinkInfo[] = {
        { "_from", (PyCFunction)_from_ContentLinkInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContentLinkInfo[] = {
        { const_cast<char*>("uri"), (getter)ContentLinkInfo_get_Uri, (setter)ContentLinkInfo_put_Uri, nullptr, nullptr },
        { const_cast<char*>("secondary_text"), (getter)ContentLinkInfo_get_SecondaryText, (setter)ContentLinkInfo_put_SecondaryText, nullptr, nullptr },
        { const_cast<char*>("link_content_kind"), (getter)ContentLinkInfo_get_LinkContentKind, (setter)ContentLinkInfo_put_LinkContentKind, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)ContentLinkInfo_get_Id, (setter)ContentLinkInfo_put_Id, nullptr, nullptr },
        { const_cast<char*>("display_text"), (getter)ContentLinkInfo_get_DisplayText, (setter)ContentLinkInfo_put_DisplayText, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContentLinkInfo[] = 
    {
        { Py_tp_new, _new_ContentLinkInfo },
        { Py_tp_dealloc, _dealloc_ContentLinkInfo },
        { Py_tp_methods, _methods_ContentLinkInfo },
        { Py_tp_getset, _getset_ContentLinkInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContentLinkInfo =
    {
        "_winrt_Windows_UI_Text.ContentLinkInfo",
        sizeof(py::wrapper::Windows::UI::Text::ContentLinkInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentLinkInfo
    };

    // ----- FontWeights class --------------------
    constexpr const char* const _type_name_FontWeights = "FontWeights";

    static PyObject* _new_FontWeights(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FontWeights);
        return nullptr;
    }

    static void _dealloc_FontWeights(py::wrapper::Windows::UI::Text::FontWeights* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FontWeights_get_Black(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Text::FontWeights::Black());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontWeights_get_Bold(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Text::FontWeights::Bold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontWeights_get_ExtraBlack(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Text::FontWeights::ExtraBlack());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontWeights_get_ExtraBold(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Text::FontWeights::ExtraBold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontWeights_get_ExtraLight(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Text::FontWeights::ExtraLight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontWeights_get_Light(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Text::FontWeights::Light());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontWeights_get_Medium(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Text::FontWeights::Medium());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontWeights_get_Normal(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Text::FontWeights::Normal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontWeights_get_SemiBold(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Text::FontWeights::SemiBold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontWeights_get_SemiLight(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Text::FontWeights::SemiLight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontWeights_get_Thin(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Text::FontWeights::Thin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FontWeights(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::FontWeights>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FontWeights[] = {
        { "get_black", (PyCFunction)FontWeights_get_Black, METH_NOARGS | METH_STATIC, nullptr },
        { "get_bold", (PyCFunction)FontWeights_get_Bold, METH_NOARGS | METH_STATIC, nullptr },
        { "get_extra_black", (PyCFunction)FontWeights_get_ExtraBlack, METH_NOARGS | METH_STATIC, nullptr },
        { "get_extra_bold", (PyCFunction)FontWeights_get_ExtraBold, METH_NOARGS | METH_STATIC, nullptr },
        { "get_extra_light", (PyCFunction)FontWeights_get_ExtraLight, METH_NOARGS | METH_STATIC, nullptr },
        { "get_light", (PyCFunction)FontWeights_get_Light, METH_NOARGS | METH_STATIC, nullptr },
        { "get_medium", (PyCFunction)FontWeights_get_Medium, METH_NOARGS | METH_STATIC, nullptr },
        { "get_normal", (PyCFunction)FontWeights_get_Normal, METH_NOARGS | METH_STATIC, nullptr },
        { "get_semi_bold", (PyCFunction)FontWeights_get_SemiBold, METH_NOARGS | METH_STATIC, nullptr },
        { "get_semi_light", (PyCFunction)FontWeights_get_SemiLight, METH_NOARGS | METH_STATIC, nullptr },
        { "get_thin", (PyCFunction)FontWeights_get_Thin, METH_NOARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_FontWeights, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FontWeights[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_FontWeights[] = 
    {
        { Py_tp_new, _new_FontWeights },
        { Py_tp_dealloc, _dealloc_FontWeights },
        { Py_tp_methods, _methods_FontWeights },
        { Py_tp_getset, _getset_FontWeights },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FontWeights =
    {
        "_winrt_Windows_UI_Text.FontWeights",
        sizeof(py::wrapper::Windows::UI::Text::FontWeights),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FontWeights
    };

    // ----- RichEditTextDocument class --------------------
    constexpr const char* const _type_name_RichEditTextDocument = "RichEditTextDocument";

    static PyObject* _new_RichEditTextDocument(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RichEditTextDocument);
        return nullptr;
    }

    static void _dealloc_RichEditTextDocument(py::wrapper::Windows::UI::Text::RichEditTextDocument* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RichEditTextDocument_ApplyDisplayUpdates(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ApplyDisplayUpdates());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_BatchDisplayUpdates(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.BatchDisplayUpdates());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_BeginUndoGroup(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.BeginUndoGroup();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_CanCopy(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CanCopy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_CanPaste(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CanPaste());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_CanRedo(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CanRedo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_CanUndo(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CanUndo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_ClearUndoRedoHistory(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ClearUndoRedoHistory();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_EndUndoGroup(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.EndUndoGroup();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_GetDefaultCharacterFormat(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDefaultCharacterFormat());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_GetDefaultParagraphFormat(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDefaultParagraphFormat());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_GetMath(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::hstring param0 {  };

                self->obj.GetMath(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_GetRange(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.GetRange(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_GetRangeFromPoint(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 1);

                return py::convert(self->obj.GetRangeFromPoint(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_GetText(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextGetOptions>(args, 0);
                winrt::hstring param1 {  };

                self->obj.GetText(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_LoadFromStream(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextSetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                self->obj.LoadFromStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_Redo(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Redo();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_SaveToStream(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextGetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                self->obj.SaveToStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_SetDefaultCharacterFormat(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextCharacterFormat>(args, 0);

                self->obj.SetDefaultCharacterFormat(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_SetDefaultParagraphFormat(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextParagraphFormat>(args, 0);

                self->obj.SetDefaultParagraphFormat(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_SetMath(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetMath(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_SetMathMode(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::RichEditMathMode>(args, 0);

                self->obj.SetMathMode(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_SetText(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextSetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetText(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_Undo(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Undo();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_get_UndoLimit(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UndoLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextDocument_put_UndoLimit(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.UndoLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextDocument_get_DefaultTabStop(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DefaultTabStop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextDocument_put_DefaultTabStop(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.DefaultTabStop(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextDocument_get_CaretType(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CaretType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextDocument_put_CaretType(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::CaretType>(arg);

            self->obj.CaretType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextDocument_get_Selection(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Selection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RichEditTextDocument_get_IgnoreTrailingCharacterSpacing(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IgnoreTrailingCharacterSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextDocument_put_IgnoreTrailingCharacterSpacing(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IgnoreTrailingCharacterSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextDocument_get_AlignmentIncludesTrailingWhitespace(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlignmentIncludesTrailingWhitespace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextDocument_put_AlignmentIncludesTrailingWhitespace(py::wrapper::Windows::UI::Text::RichEditTextDocument* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AlignmentIncludesTrailingWhitespace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_RichEditTextDocument(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::RichEditTextDocument>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RichEditTextDocument[] = {
        { "apply_display_updates", (PyCFunction)RichEditTextDocument_ApplyDisplayUpdates, METH_VARARGS, nullptr },
        { "batch_display_updates", (PyCFunction)RichEditTextDocument_BatchDisplayUpdates, METH_VARARGS, nullptr },
        { "begin_undo_group", (PyCFunction)RichEditTextDocument_BeginUndoGroup, METH_VARARGS, nullptr },
        { "can_copy", (PyCFunction)RichEditTextDocument_CanCopy, METH_VARARGS, nullptr },
        { "can_paste", (PyCFunction)RichEditTextDocument_CanPaste, METH_VARARGS, nullptr },
        { "can_redo", (PyCFunction)RichEditTextDocument_CanRedo, METH_VARARGS, nullptr },
        { "can_undo", (PyCFunction)RichEditTextDocument_CanUndo, METH_VARARGS, nullptr },
        { "clear_undo_redo_history", (PyCFunction)RichEditTextDocument_ClearUndoRedoHistory, METH_VARARGS, nullptr },
        { "end_undo_group", (PyCFunction)RichEditTextDocument_EndUndoGroup, METH_VARARGS, nullptr },
        { "get_default_character_format", (PyCFunction)RichEditTextDocument_GetDefaultCharacterFormat, METH_VARARGS, nullptr },
        { "get_default_paragraph_format", (PyCFunction)RichEditTextDocument_GetDefaultParagraphFormat, METH_VARARGS, nullptr },
        { "get_math", (PyCFunction)RichEditTextDocument_GetMath, METH_VARARGS, nullptr },
        { "get_range", (PyCFunction)RichEditTextDocument_GetRange, METH_VARARGS, nullptr },
        { "get_range_from_point", (PyCFunction)RichEditTextDocument_GetRangeFromPoint, METH_VARARGS, nullptr },
        { "get_text", (PyCFunction)RichEditTextDocument_GetText, METH_VARARGS, nullptr },
        { "load_from_stream", (PyCFunction)RichEditTextDocument_LoadFromStream, METH_VARARGS, nullptr },
        { "redo", (PyCFunction)RichEditTextDocument_Redo, METH_VARARGS, nullptr },
        { "save_to_stream", (PyCFunction)RichEditTextDocument_SaveToStream, METH_VARARGS, nullptr },
        { "set_default_character_format", (PyCFunction)RichEditTextDocument_SetDefaultCharacterFormat, METH_VARARGS, nullptr },
        { "set_default_paragraph_format", (PyCFunction)RichEditTextDocument_SetDefaultParagraphFormat, METH_VARARGS, nullptr },
        { "set_math", (PyCFunction)RichEditTextDocument_SetMath, METH_VARARGS, nullptr },
        { "set_math_mode", (PyCFunction)RichEditTextDocument_SetMathMode, METH_VARARGS, nullptr },
        { "set_text", (PyCFunction)RichEditTextDocument_SetText, METH_VARARGS, nullptr },
        { "undo", (PyCFunction)RichEditTextDocument_Undo, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_RichEditTextDocument, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RichEditTextDocument[] = {
        { const_cast<char*>("undo_limit"), (getter)RichEditTextDocument_get_UndoLimit, (setter)RichEditTextDocument_put_UndoLimit, nullptr, nullptr },
        { const_cast<char*>("default_tab_stop"), (getter)RichEditTextDocument_get_DefaultTabStop, (setter)RichEditTextDocument_put_DefaultTabStop, nullptr, nullptr },
        { const_cast<char*>("caret_type"), (getter)RichEditTextDocument_get_CaretType, (setter)RichEditTextDocument_put_CaretType, nullptr, nullptr },
        { const_cast<char*>("selection"), (getter)RichEditTextDocument_get_Selection, nullptr, nullptr, nullptr },
        { const_cast<char*>("ignore_trailing_character_spacing"), (getter)RichEditTextDocument_get_IgnoreTrailingCharacterSpacing, (setter)RichEditTextDocument_put_IgnoreTrailingCharacterSpacing, nullptr, nullptr },
        { const_cast<char*>("alignment_includes_trailing_whitespace"), (getter)RichEditTextDocument_get_AlignmentIncludesTrailingWhitespace, (setter)RichEditTextDocument_put_AlignmentIncludesTrailingWhitespace, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RichEditTextDocument[] = 
    {
        { Py_tp_new, _new_RichEditTextDocument },
        { Py_tp_dealloc, _dealloc_RichEditTextDocument },
        { Py_tp_methods, _methods_RichEditTextDocument },
        { Py_tp_getset, _getset_RichEditTextDocument },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RichEditTextDocument =
    {
        "_winrt_Windows_UI_Text.RichEditTextDocument",
        sizeof(py::wrapper::Windows::UI::Text::RichEditTextDocument),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RichEditTextDocument
    };

    // ----- RichEditTextRange class --------------------
    constexpr const char* const _type_name_RichEditTextRange = "RichEditTextRange";

    static PyObject* _new_RichEditTextRange(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RichEditTextRange);
        return nullptr;
    }

    static void _dealloc_RichEditTextRange(py::wrapper::Windows::UI::Text::RichEditTextRange* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RichEditTextRange_CanPaste(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.CanPaste(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_ChangeCase(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::LetterCase>(args, 0);

                self->obj.ChangeCase(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_Collapse(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.Collapse(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_Copy(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Copy();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_Cut(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Cut();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_Delete(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.Delete(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_EndOf(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.EndOf(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_Expand(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);

                return py::convert(self->obj.Expand(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_FindText(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Text::FindOptions>(args, 2);

                return py::convert(self->obj.FindText(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_GetCharacterUtf32(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                uint32_t param0 {  };
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.GetCharacterUtf32(param0, param1);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_GetClone(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetClone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_GetIndex(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);

                return py::convert(self->obj.GetIndex(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_GetPoint(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::HorizontalCharacterAlignment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Text::VerticalCharacterAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 2);
                winrt::Windows::Foundation::Point param3 {  };

                self->obj.GetPoint(param0, param1, param2, param3);

                py::pyobj_handle out3{ py::convert(param3) };
                if (!out3)
                {
                    return nullptr;
                }
                return out3.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_GetRect(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 0);
                winrt::Windows::Foundation::Rect param1 {  };
                int32_t param2 {  };

                self->obj.GetRect(param0, param1, param2);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out1.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_GetText(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextGetOptions>(args, 0);
                winrt::hstring param1 {  };

                self->obj.GetText(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_GetTextViaStream(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextGetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                self->obj.GetTextViaStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_InRange(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(args, 0);

                return py::convert(self->obj.InRange(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_InStory(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(args, 0);

                return py::convert(self->obj.InStory(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_InsertImage(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Text::VerticalCharacterAlignment>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 5);

                self->obj.InsertImage(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_IsEqual(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_MatchSelection(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.MatchSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_Move(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.Move(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_MoveEnd(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.MoveEnd(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_MoveStart(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.MoveStart(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_Paste(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.Paste(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_ScrollIntoView(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 0);

                self->obj.ScrollIntoView(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_SetIndex(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.SetIndex(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_SetPoint(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.SetPoint(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_SetRange(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.SetRange(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_SetText(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextSetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetText(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_SetTextViaStream(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextSetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                self->obj.SetTextViaStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_StartOf(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.StartOf(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_get_ContentLinkInfo(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentLinkInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextRange_put_ContentLinkInfo(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::ContentLinkInfo>(arg);

            self->obj.ContentLinkInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextRange_get_Text(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextRange_put_Text(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextRange_get_StartPosition(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextRange_put_StartPosition(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.StartPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextRange_get_ParagraphFormat(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ParagraphFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextRange_put_ParagraphFormat(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextParagraphFormat>(arg);

            self->obj.ParagraphFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextRange_get_Link(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Link());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextRange_put_Link(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Link(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextRange_get_Gravity(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Gravity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextRange_put_Gravity(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::RangeGravity>(arg);

            self->obj.Gravity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextRange_get_FormattedText(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FormattedText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextRange_put_FormattedText(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(arg);

            self->obj.FormattedText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextRange_get_EndPosition(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextRange_put_EndPosition(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.EndPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextRange_get_CharacterFormat(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharacterFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextRange_put_CharacterFormat(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextCharacterFormat>(arg);

            self->obj.CharacterFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextRange_get_Character(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Character());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RichEditTextRange_put_Character(py::wrapper::Windows::UI::Text::RichEditTextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<char16_t>(arg);

            self->obj.Character(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RichEditTextRange_get_Length(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RichEditTextRange_get_StoryLength(py::wrapper::Windows::UI::Text::RichEditTextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StoryLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RichEditTextRange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::RichEditTextRange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RichEditTextRange[] = {
        { "can_paste", (PyCFunction)RichEditTextRange_CanPaste, METH_VARARGS, nullptr },
        { "change_case", (PyCFunction)RichEditTextRange_ChangeCase, METH_VARARGS, nullptr },
        { "collapse", (PyCFunction)RichEditTextRange_Collapse, METH_VARARGS, nullptr },
        { "copy", (PyCFunction)RichEditTextRange_Copy, METH_VARARGS, nullptr },
        { "cut", (PyCFunction)RichEditTextRange_Cut, METH_VARARGS, nullptr },
        { "delete", (PyCFunction)RichEditTextRange_Delete, METH_VARARGS, nullptr },
        { "end_of", (PyCFunction)RichEditTextRange_EndOf, METH_VARARGS, nullptr },
        { "expand", (PyCFunction)RichEditTextRange_Expand, METH_VARARGS, nullptr },
        { "find_text", (PyCFunction)RichEditTextRange_FindText, METH_VARARGS, nullptr },
        { "get_character_utf32", (PyCFunction)RichEditTextRange_GetCharacterUtf32, METH_VARARGS, nullptr },
        { "get_clone", (PyCFunction)RichEditTextRange_GetClone, METH_VARARGS, nullptr },
        { "get_index", (PyCFunction)RichEditTextRange_GetIndex, METH_VARARGS, nullptr },
        { "get_point", (PyCFunction)RichEditTextRange_GetPoint, METH_VARARGS, nullptr },
        { "get_rect", (PyCFunction)RichEditTextRange_GetRect, METH_VARARGS, nullptr },
        { "get_text", (PyCFunction)RichEditTextRange_GetText, METH_VARARGS, nullptr },
        { "get_text_via_stream", (PyCFunction)RichEditTextRange_GetTextViaStream, METH_VARARGS, nullptr },
        { "in_range", (PyCFunction)RichEditTextRange_InRange, METH_VARARGS, nullptr },
        { "in_story", (PyCFunction)RichEditTextRange_InStory, METH_VARARGS, nullptr },
        { "insert_image", (PyCFunction)RichEditTextRange_InsertImage, METH_VARARGS, nullptr },
        { "is_equal", (PyCFunction)RichEditTextRange_IsEqual, METH_VARARGS, nullptr },
        { "match_selection", (PyCFunction)RichEditTextRange_MatchSelection, METH_VARARGS, nullptr },
        { "move", (PyCFunction)RichEditTextRange_Move, METH_VARARGS, nullptr },
        { "move_end", (PyCFunction)RichEditTextRange_MoveEnd, METH_VARARGS, nullptr },
        { "move_start", (PyCFunction)RichEditTextRange_MoveStart, METH_VARARGS, nullptr },
        { "paste", (PyCFunction)RichEditTextRange_Paste, METH_VARARGS, nullptr },
        { "scroll_into_view", (PyCFunction)RichEditTextRange_ScrollIntoView, METH_VARARGS, nullptr },
        { "set_index", (PyCFunction)RichEditTextRange_SetIndex, METH_VARARGS, nullptr },
        { "set_point", (PyCFunction)RichEditTextRange_SetPoint, METH_VARARGS, nullptr },
        { "set_range", (PyCFunction)RichEditTextRange_SetRange, METH_VARARGS, nullptr },
        { "set_text", (PyCFunction)RichEditTextRange_SetText, METH_VARARGS, nullptr },
        { "set_text_via_stream", (PyCFunction)RichEditTextRange_SetTextViaStream, METH_VARARGS, nullptr },
        { "start_of", (PyCFunction)RichEditTextRange_StartOf, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_RichEditTextRange, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RichEditTextRange[] = {
        { const_cast<char*>("content_link_info"), (getter)RichEditTextRange_get_ContentLinkInfo, (setter)RichEditTextRange_put_ContentLinkInfo, nullptr, nullptr },
        { const_cast<char*>("text"), (getter)RichEditTextRange_get_Text, (setter)RichEditTextRange_put_Text, nullptr, nullptr },
        { const_cast<char*>("start_position"), (getter)RichEditTextRange_get_StartPosition, (setter)RichEditTextRange_put_StartPosition, nullptr, nullptr },
        { const_cast<char*>("paragraph_format"), (getter)RichEditTextRange_get_ParagraphFormat, (setter)RichEditTextRange_put_ParagraphFormat, nullptr, nullptr },
        { const_cast<char*>("link"), (getter)RichEditTextRange_get_Link, (setter)RichEditTextRange_put_Link, nullptr, nullptr },
        { const_cast<char*>("gravity"), (getter)RichEditTextRange_get_Gravity, (setter)RichEditTextRange_put_Gravity, nullptr, nullptr },
        { const_cast<char*>("formatted_text"), (getter)RichEditTextRange_get_FormattedText, (setter)RichEditTextRange_put_FormattedText, nullptr, nullptr },
        { const_cast<char*>("end_position"), (getter)RichEditTextRange_get_EndPosition, (setter)RichEditTextRange_put_EndPosition, nullptr, nullptr },
        { const_cast<char*>("character_format"), (getter)RichEditTextRange_get_CharacterFormat, (setter)RichEditTextRange_put_CharacterFormat, nullptr, nullptr },
        { const_cast<char*>("character"), (getter)RichEditTextRange_get_Character, (setter)RichEditTextRange_put_Character, nullptr, nullptr },
        { const_cast<char*>("length"), (getter)RichEditTextRange_get_Length, nullptr, nullptr, nullptr },
        { const_cast<char*>("story_length"), (getter)RichEditTextRange_get_StoryLength, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RichEditTextRange[] = 
    {
        { Py_tp_new, _new_RichEditTextRange },
        { Py_tp_dealloc, _dealloc_RichEditTextRange },
        { Py_tp_methods, _methods_RichEditTextRange },
        { Py_tp_getset, _getset_RichEditTextRange },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RichEditTextRange =
    {
        "_winrt_Windows_UI_Text.RichEditTextRange",
        sizeof(py::wrapper::Windows::UI::Text::RichEditTextRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RichEditTextRange
    };

    // ----- TextConstants class --------------------
    constexpr const char* const _type_name_TextConstants = "TextConstants";

    static PyObject* _new_TextConstants(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TextConstants);
        return nullptr;
    }

    static PyObject* TextConstants_get_AutoColor(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Text::TextConstants::AutoColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextConstants_get_MaxUnitCount(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Text::TextConstants::MaxUnitCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextConstants_get_MinUnitCount(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Text::TextConstants::MinUnitCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextConstants_get_UndefinedColor(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Text::TextConstants::UndefinedColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextConstants_get_UndefinedFloatValue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Text::TextConstants::UndefinedFloatValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextConstants_get_UndefinedFontStretch(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Text::TextConstants::UndefinedFontStretch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextConstants_get_UndefinedFontStyle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Text::TextConstants::UndefinedFontStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextConstants_get_UndefinedInt32Value(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Text::TextConstants::UndefinedInt32Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextConstants[] = {
        { "get_auto_color", (PyCFunction)TextConstants_get_AutoColor, METH_NOARGS | METH_STATIC, nullptr },
        { "get_max_unit_count", (PyCFunction)TextConstants_get_MaxUnitCount, METH_NOARGS | METH_STATIC, nullptr },
        { "get_min_unit_count", (PyCFunction)TextConstants_get_MinUnitCount, METH_NOARGS | METH_STATIC, nullptr },
        { "get_undefined_color", (PyCFunction)TextConstants_get_UndefinedColor, METH_NOARGS | METH_STATIC, nullptr },
        { "get_undefined_float_value", (PyCFunction)TextConstants_get_UndefinedFloatValue, METH_NOARGS | METH_STATIC, nullptr },
        { "get_undefined_font_stretch", (PyCFunction)TextConstants_get_UndefinedFontStretch, METH_NOARGS | METH_STATIC, nullptr },
        { "get_undefined_font_style", (PyCFunction)TextConstants_get_UndefinedFontStyle, METH_NOARGS | METH_STATIC, nullptr },
        { "get_undefined_int32_value", (PyCFunction)TextConstants_get_UndefinedInt32Value, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TextConstants[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_TextConstants[] = 
    {
        { Py_tp_new, _new_TextConstants },
        { Py_tp_methods, _methods_TextConstants },
        { Py_tp_getset, _getset_TextConstants },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TextConstants =
    {
        "_winrt_Windows_UI_Text.TextConstants",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TextConstants
    };

    // ----- ITextCharacterFormat interface --------------------
    constexpr const char* const _type_name_ITextCharacterFormat = "ITextCharacterFormat";

    static PyObject* _new_ITextCharacterFormat(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ITextCharacterFormat);
        return nullptr;
    }

    static void _dealloc_ITextCharacterFormat(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ITextCharacterFormat_GetClone(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetClone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextCharacterFormat_IsEqual(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextCharacterFormat>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextCharacterFormat_SetClone(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextCharacterFormat>(args, 0);

                self->obj.SetClone(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextCharacterFormat_get_AllCaps(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllCaps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_AllCaps(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.AllCaps(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_BackgroundColor(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_BackgroundColor(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.BackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Bold(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Bold(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.Bold(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_FontStretch(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FontStretch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_FontStretch(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::FontStretch>(arg);

            self->obj.FontStretch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_FontStyle(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FontStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_FontStyle(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::FontStyle>(arg);

            self->obj.FontStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_ForegroundColor(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_ForegroundColor(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.ForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Hidden(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Hidden());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Hidden(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.Hidden(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Italic(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Italic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Italic(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.Italic(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Kerning(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kerning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Kerning(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.Kerning(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_LanguageTag(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LanguageTag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_LanguageTag(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.LanguageTag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_LinkType(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LinkType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextCharacterFormat_get_Name(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Name(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Outline(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Outline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Outline(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.Outline(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Position(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Position(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_ProtectedText(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtectedText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_ProtectedText(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.ProtectedText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Size(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Size(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_SmallCaps(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SmallCaps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_SmallCaps(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.SmallCaps(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Spacing(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Spacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Spacing(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.Spacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Strikethrough(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Strikethrough());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Strikethrough(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.Strikethrough(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Subscript(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subscript());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Subscript(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.Subscript(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Superscript(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Superscript());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Superscript(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.Superscript(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_TextScript(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TextScript());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_TextScript(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::TextScript>(arg);

            self->obj.TextScript(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Underline(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Underline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Underline(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::UnderlineType>(arg);

            self->obj.Underline(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextCharacterFormat_get_Weight(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Weight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextCharacterFormat_put_Weight(py::wrapper::Windows::UI::Text::ITextCharacterFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Weight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ITextCharacterFormat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::ITextCharacterFormat>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextCharacterFormat[] = {
        { "get_clone", (PyCFunction)ITextCharacterFormat_GetClone, METH_VARARGS, nullptr },
        { "is_equal", (PyCFunction)ITextCharacterFormat_IsEqual, METH_VARARGS, nullptr },
        { "set_clone", (PyCFunction)ITextCharacterFormat_SetClone, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ITextCharacterFormat, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ITextCharacterFormat[] = {
        { const_cast<char*>("all_caps"), (getter)ITextCharacterFormat_get_AllCaps, (setter)ITextCharacterFormat_put_AllCaps, nullptr, nullptr },
        { const_cast<char*>("background_color"), (getter)ITextCharacterFormat_get_BackgroundColor, (setter)ITextCharacterFormat_put_BackgroundColor, nullptr, nullptr },
        { const_cast<char*>("bold"), (getter)ITextCharacterFormat_get_Bold, (setter)ITextCharacterFormat_put_Bold, nullptr, nullptr },
        { const_cast<char*>("font_stretch"), (getter)ITextCharacterFormat_get_FontStretch, (setter)ITextCharacterFormat_put_FontStretch, nullptr, nullptr },
        { const_cast<char*>("font_style"), (getter)ITextCharacterFormat_get_FontStyle, (setter)ITextCharacterFormat_put_FontStyle, nullptr, nullptr },
        { const_cast<char*>("foreground_color"), (getter)ITextCharacterFormat_get_ForegroundColor, (setter)ITextCharacterFormat_put_ForegroundColor, nullptr, nullptr },
        { const_cast<char*>("hidden"), (getter)ITextCharacterFormat_get_Hidden, (setter)ITextCharacterFormat_put_Hidden, nullptr, nullptr },
        { const_cast<char*>("italic"), (getter)ITextCharacterFormat_get_Italic, (setter)ITextCharacterFormat_put_Italic, nullptr, nullptr },
        { const_cast<char*>("kerning"), (getter)ITextCharacterFormat_get_Kerning, (setter)ITextCharacterFormat_put_Kerning, nullptr, nullptr },
        { const_cast<char*>("language_tag"), (getter)ITextCharacterFormat_get_LanguageTag, (setter)ITextCharacterFormat_put_LanguageTag, nullptr, nullptr },
        { const_cast<char*>("link_type"), (getter)ITextCharacterFormat_get_LinkType, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)ITextCharacterFormat_get_Name, (setter)ITextCharacterFormat_put_Name, nullptr, nullptr },
        { const_cast<char*>("outline"), (getter)ITextCharacterFormat_get_Outline, (setter)ITextCharacterFormat_put_Outline, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)ITextCharacterFormat_get_Position, (setter)ITextCharacterFormat_put_Position, nullptr, nullptr },
        { const_cast<char*>("protected_text"), (getter)ITextCharacterFormat_get_ProtectedText, (setter)ITextCharacterFormat_put_ProtectedText, nullptr, nullptr },
        { const_cast<char*>("size"), (getter)ITextCharacterFormat_get_Size, (setter)ITextCharacterFormat_put_Size, nullptr, nullptr },
        { const_cast<char*>("small_caps"), (getter)ITextCharacterFormat_get_SmallCaps, (setter)ITextCharacterFormat_put_SmallCaps, nullptr, nullptr },
        { const_cast<char*>("spacing"), (getter)ITextCharacterFormat_get_Spacing, (setter)ITextCharacterFormat_put_Spacing, nullptr, nullptr },
        { const_cast<char*>("strikethrough"), (getter)ITextCharacterFormat_get_Strikethrough, (setter)ITextCharacterFormat_put_Strikethrough, nullptr, nullptr },
        { const_cast<char*>("subscript"), (getter)ITextCharacterFormat_get_Subscript, (setter)ITextCharacterFormat_put_Subscript, nullptr, nullptr },
        { const_cast<char*>("superscript"), (getter)ITextCharacterFormat_get_Superscript, (setter)ITextCharacterFormat_put_Superscript, nullptr, nullptr },
        { const_cast<char*>("text_script"), (getter)ITextCharacterFormat_get_TextScript, (setter)ITextCharacterFormat_put_TextScript, nullptr, nullptr },
        { const_cast<char*>("underline"), (getter)ITextCharacterFormat_get_Underline, (setter)ITextCharacterFormat_put_Underline, nullptr, nullptr },
        { const_cast<char*>("weight"), (getter)ITextCharacterFormat_get_Weight, (setter)ITextCharacterFormat_put_Weight, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ITextCharacterFormat[] = 
    {
        { Py_tp_new, _new_ITextCharacterFormat },
        { Py_tp_dealloc, _dealloc_ITextCharacterFormat },
        { Py_tp_methods, _methods_ITextCharacterFormat },
        { Py_tp_getset, _getset_ITextCharacterFormat },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ITextCharacterFormat =
    {
        "_winrt_Windows_UI_Text.ITextCharacterFormat",
        sizeof(py::wrapper::Windows::UI::Text::ITextCharacterFormat),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextCharacterFormat
    };

    // ----- ITextDocument interface --------------------
    constexpr const char* const _type_name_ITextDocument = "ITextDocument";

    static PyObject* _new_ITextDocument(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ITextDocument);
        return nullptr;
    }

    static void _dealloc_ITextDocument(py::wrapper::Windows::UI::Text::ITextDocument* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ITextDocument_ApplyDisplayUpdates(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ApplyDisplayUpdates());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_BatchDisplayUpdates(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.BatchDisplayUpdates());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_BeginUndoGroup(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.BeginUndoGroup();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_CanCopy(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CanCopy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_CanPaste(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CanPaste());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_CanRedo(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CanRedo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_CanUndo(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CanUndo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_EndUndoGroup(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.EndUndoGroup();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_GetDefaultCharacterFormat(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDefaultCharacterFormat());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_GetDefaultParagraphFormat(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDefaultParagraphFormat());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_GetRange(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.GetRange(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_GetRangeFromPoint(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 1);

                return py::convert(self->obj.GetRangeFromPoint(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_GetText(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextGetOptions>(args, 0);
                winrt::hstring param1 {  };

                self->obj.GetText(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_LoadFromStream(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextSetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                self->obj.LoadFromStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_Redo(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Redo();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_SaveToStream(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextGetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                self->obj.SaveToStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_SetDefaultCharacterFormat(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextCharacterFormat>(args, 0);

                self->obj.SetDefaultCharacterFormat(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_SetDefaultParagraphFormat(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextParagraphFormat>(args, 0);

                self->obj.SetDefaultParagraphFormat(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_SetText(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextSetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetText(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_Undo(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Undo();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextDocument_get_CaretType(py::wrapper::Windows::UI::Text::ITextDocument* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CaretType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextDocument_put_CaretType(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::CaretType>(arg);

            self->obj.CaretType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextDocument_get_DefaultTabStop(py::wrapper::Windows::UI::Text::ITextDocument* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DefaultTabStop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextDocument_put_DefaultTabStop(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.DefaultTabStop(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextDocument_get_Selection(py::wrapper::Windows::UI::Text::ITextDocument* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Selection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextDocument_get_UndoLimit(py::wrapper::Windows::UI::Text::ITextDocument* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UndoLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextDocument_put_UndoLimit(py::wrapper::Windows::UI::Text::ITextDocument* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.UndoLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ITextDocument(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::ITextDocument>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextDocument[] = {
        { "apply_display_updates", (PyCFunction)ITextDocument_ApplyDisplayUpdates, METH_VARARGS, nullptr },
        { "batch_display_updates", (PyCFunction)ITextDocument_BatchDisplayUpdates, METH_VARARGS, nullptr },
        { "begin_undo_group", (PyCFunction)ITextDocument_BeginUndoGroup, METH_VARARGS, nullptr },
        { "can_copy", (PyCFunction)ITextDocument_CanCopy, METH_VARARGS, nullptr },
        { "can_paste", (PyCFunction)ITextDocument_CanPaste, METH_VARARGS, nullptr },
        { "can_redo", (PyCFunction)ITextDocument_CanRedo, METH_VARARGS, nullptr },
        { "can_undo", (PyCFunction)ITextDocument_CanUndo, METH_VARARGS, nullptr },
        { "end_undo_group", (PyCFunction)ITextDocument_EndUndoGroup, METH_VARARGS, nullptr },
        { "get_default_character_format", (PyCFunction)ITextDocument_GetDefaultCharacterFormat, METH_VARARGS, nullptr },
        { "get_default_paragraph_format", (PyCFunction)ITextDocument_GetDefaultParagraphFormat, METH_VARARGS, nullptr },
        { "get_range", (PyCFunction)ITextDocument_GetRange, METH_VARARGS, nullptr },
        { "get_range_from_point", (PyCFunction)ITextDocument_GetRangeFromPoint, METH_VARARGS, nullptr },
        { "get_text", (PyCFunction)ITextDocument_GetText, METH_VARARGS, nullptr },
        { "load_from_stream", (PyCFunction)ITextDocument_LoadFromStream, METH_VARARGS, nullptr },
        { "redo", (PyCFunction)ITextDocument_Redo, METH_VARARGS, nullptr },
        { "save_to_stream", (PyCFunction)ITextDocument_SaveToStream, METH_VARARGS, nullptr },
        { "set_default_character_format", (PyCFunction)ITextDocument_SetDefaultCharacterFormat, METH_VARARGS, nullptr },
        { "set_default_paragraph_format", (PyCFunction)ITextDocument_SetDefaultParagraphFormat, METH_VARARGS, nullptr },
        { "set_text", (PyCFunction)ITextDocument_SetText, METH_VARARGS, nullptr },
        { "undo", (PyCFunction)ITextDocument_Undo, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ITextDocument, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ITextDocument[] = {
        { const_cast<char*>("caret_type"), (getter)ITextDocument_get_CaretType, (setter)ITextDocument_put_CaretType, nullptr, nullptr },
        { const_cast<char*>("default_tab_stop"), (getter)ITextDocument_get_DefaultTabStop, (setter)ITextDocument_put_DefaultTabStop, nullptr, nullptr },
        { const_cast<char*>("selection"), (getter)ITextDocument_get_Selection, nullptr, nullptr, nullptr },
        { const_cast<char*>("undo_limit"), (getter)ITextDocument_get_UndoLimit, (setter)ITextDocument_put_UndoLimit, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ITextDocument[] = 
    {
        { Py_tp_new, _new_ITextDocument },
        { Py_tp_dealloc, _dealloc_ITextDocument },
        { Py_tp_methods, _methods_ITextDocument },
        { Py_tp_getset, _getset_ITextDocument },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ITextDocument =
    {
        "_winrt_Windows_UI_Text.ITextDocument",
        sizeof(py::wrapper::Windows::UI::Text::ITextDocument),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextDocument
    };

    // ----- ITextParagraphFormat interface --------------------
    constexpr const char* const _type_name_ITextParagraphFormat = "ITextParagraphFormat";

    static PyObject* _new_ITextParagraphFormat(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ITextParagraphFormat);
        return nullptr;
    }

    static void _dealloc_ITextParagraphFormat(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ITextParagraphFormat_AddTab(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Text::TabAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Text::TabLeader>(args, 2);

                self->obj.AddTab(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_ClearAllTabs(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ClearAllTabs();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_DeleteTab(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<float>(args, 0);

                self->obj.DeleteTab(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_GetClone(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetClone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_GetTab(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                float param1 {  };
                winrt::Windows::UI::Text::TabAlignment param2 {  };
                winrt::Windows::UI::Text::TabLeader param3 {  };

                self->obj.GetTab(param0, param1, param2, param3);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                py::pyobj_handle out3{ py::convert(param3) };
                if (!out3)
                {
                    return nullptr;
                }
                return PyTuple_Pack(3, out1.get(), out2.get(), out3.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_IsEqual(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextParagraphFormat>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_SetClone(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextParagraphFormat>(args, 0);

                self->obj.SetClone(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_SetIndents(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<float>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);
                auto param2 = py::convert_to<float>(args, 2);

                self->obj.SetIndents(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_SetLineSpacing(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::LineSpacingRule>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                self->obj.SetLineSpacing(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_get_Alignment(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Alignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_Alignment(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::ParagraphAlignment>(arg);

            self->obj.Alignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_FirstLineIndent(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FirstLineIndent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_get_KeepTogether(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeepTogether());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_KeepTogether(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.KeepTogether(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_KeepWithNext(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeepWithNext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_KeepWithNext(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.KeepWithNext(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_LeftIndent(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftIndent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_get_LineSpacing(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_get_LineSpacingRule(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineSpacingRule());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_get_ListAlignment(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ListAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_ListAlignment(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::MarkerAlignment>(arg);

            self->obj.ListAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_ListLevelIndex(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ListLevelIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_ListLevelIndex(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ListLevelIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_ListStart(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ListStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_ListStart(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ListStart(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_ListStyle(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ListStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_ListStyle(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::MarkerStyle>(arg);

            self->obj.ListStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_ListTab(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ListTab());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_ListTab(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.ListTab(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_ListType(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ListType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_ListType(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::MarkerType>(arg);

            self->obj.ListType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_NoLineNumber(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NoLineNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_NoLineNumber(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.NoLineNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_PageBreakBefore(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PageBreakBefore());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_PageBreakBefore(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.PageBreakBefore(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_RightIndent(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightIndent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_RightIndent(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.RightIndent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_RightToLeft(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightToLeft());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_RightToLeft(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.RightToLeft(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_SpaceAfter(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SpaceAfter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_SpaceAfter(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.SpaceAfter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_SpaceBefore(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SpaceBefore());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_SpaceBefore(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.SpaceBefore(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_Style(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Style());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_Style(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::ParagraphStyle>(arg);

            self->obj.Style(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextParagraphFormat_get_TabCount(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TabCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextParagraphFormat_get_WidowControl(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WidowControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextParagraphFormat_put_WidowControl(py::wrapper::Windows::UI::Text::ITextParagraphFormat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::FormatEffect>(arg);

            self->obj.WidowControl(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ITextParagraphFormat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::ITextParagraphFormat>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextParagraphFormat[] = {
        { "add_tab", (PyCFunction)ITextParagraphFormat_AddTab, METH_VARARGS, nullptr },
        { "clear_all_tabs", (PyCFunction)ITextParagraphFormat_ClearAllTabs, METH_VARARGS, nullptr },
        { "delete_tab", (PyCFunction)ITextParagraphFormat_DeleteTab, METH_VARARGS, nullptr },
        { "get_clone", (PyCFunction)ITextParagraphFormat_GetClone, METH_VARARGS, nullptr },
        { "get_tab", (PyCFunction)ITextParagraphFormat_GetTab, METH_VARARGS, nullptr },
        { "is_equal", (PyCFunction)ITextParagraphFormat_IsEqual, METH_VARARGS, nullptr },
        { "set_clone", (PyCFunction)ITextParagraphFormat_SetClone, METH_VARARGS, nullptr },
        { "set_indents", (PyCFunction)ITextParagraphFormat_SetIndents, METH_VARARGS, nullptr },
        { "set_line_spacing", (PyCFunction)ITextParagraphFormat_SetLineSpacing, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ITextParagraphFormat, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ITextParagraphFormat[] = {
        { const_cast<char*>("alignment"), (getter)ITextParagraphFormat_get_Alignment, (setter)ITextParagraphFormat_put_Alignment, nullptr, nullptr },
        { const_cast<char*>("first_line_indent"), (getter)ITextParagraphFormat_get_FirstLineIndent, nullptr, nullptr, nullptr },
        { const_cast<char*>("keep_together"), (getter)ITextParagraphFormat_get_KeepTogether, (setter)ITextParagraphFormat_put_KeepTogether, nullptr, nullptr },
        { const_cast<char*>("keep_with_next"), (getter)ITextParagraphFormat_get_KeepWithNext, (setter)ITextParagraphFormat_put_KeepWithNext, nullptr, nullptr },
        { const_cast<char*>("left_indent"), (getter)ITextParagraphFormat_get_LeftIndent, nullptr, nullptr, nullptr },
        { const_cast<char*>("line_spacing"), (getter)ITextParagraphFormat_get_LineSpacing, nullptr, nullptr, nullptr },
        { const_cast<char*>("line_spacing_rule"), (getter)ITextParagraphFormat_get_LineSpacingRule, nullptr, nullptr, nullptr },
        { const_cast<char*>("list_alignment"), (getter)ITextParagraphFormat_get_ListAlignment, (setter)ITextParagraphFormat_put_ListAlignment, nullptr, nullptr },
        { const_cast<char*>("list_level_index"), (getter)ITextParagraphFormat_get_ListLevelIndex, (setter)ITextParagraphFormat_put_ListLevelIndex, nullptr, nullptr },
        { const_cast<char*>("list_start"), (getter)ITextParagraphFormat_get_ListStart, (setter)ITextParagraphFormat_put_ListStart, nullptr, nullptr },
        { const_cast<char*>("list_style"), (getter)ITextParagraphFormat_get_ListStyle, (setter)ITextParagraphFormat_put_ListStyle, nullptr, nullptr },
        { const_cast<char*>("list_tab"), (getter)ITextParagraphFormat_get_ListTab, (setter)ITextParagraphFormat_put_ListTab, nullptr, nullptr },
        { const_cast<char*>("list_type"), (getter)ITextParagraphFormat_get_ListType, (setter)ITextParagraphFormat_put_ListType, nullptr, nullptr },
        { const_cast<char*>("no_line_number"), (getter)ITextParagraphFormat_get_NoLineNumber, (setter)ITextParagraphFormat_put_NoLineNumber, nullptr, nullptr },
        { const_cast<char*>("page_break_before"), (getter)ITextParagraphFormat_get_PageBreakBefore, (setter)ITextParagraphFormat_put_PageBreakBefore, nullptr, nullptr },
        { const_cast<char*>("right_indent"), (getter)ITextParagraphFormat_get_RightIndent, (setter)ITextParagraphFormat_put_RightIndent, nullptr, nullptr },
        { const_cast<char*>("right_to_left"), (getter)ITextParagraphFormat_get_RightToLeft, (setter)ITextParagraphFormat_put_RightToLeft, nullptr, nullptr },
        { const_cast<char*>("space_after"), (getter)ITextParagraphFormat_get_SpaceAfter, (setter)ITextParagraphFormat_put_SpaceAfter, nullptr, nullptr },
        { const_cast<char*>("space_before"), (getter)ITextParagraphFormat_get_SpaceBefore, (setter)ITextParagraphFormat_put_SpaceBefore, nullptr, nullptr },
        { const_cast<char*>("style"), (getter)ITextParagraphFormat_get_Style, (setter)ITextParagraphFormat_put_Style, nullptr, nullptr },
        { const_cast<char*>("tab_count"), (getter)ITextParagraphFormat_get_TabCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("widow_control"), (getter)ITextParagraphFormat_get_WidowControl, (setter)ITextParagraphFormat_put_WidowControl, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ITextParagraphFormat[] = 
    {
        { Py_tp_new, _new_ITextParagraphFormat },
        { Py_tp_dealloc, _dealloc_ITextParagraphFormat },
        { Py_tp_methods, _methods_ITextParagraphFormat },
        { Py_tp_getset, _getset_ITextParagraphFormat },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ITextParagraphFormat =
    {
        "_winrt_Windows_UI_Text.ITextParagraphFormat",
        sizeof(py::wrapper::Windows::UI::Text::ITextParagraphFormat),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextParagraphFormat
    };

    // ----- ITextRange interface --------------------
    constexpr const char* const _type_name_ITextRange = "ITextRange";

    static PyObject* _new_ITextRange(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ITextRange);
        return nullptr;
    }

    static void _dealloc_ITextRange(py::wrapper::Windows::UI::Text::ITextRange* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ITextRange_CanPaste(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.CanPaste(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_ChangeCase(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::LetterCase>(args, 0);

                self->obj.ChangeCase(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_Collapse(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.Collapse(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_Copy(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Copy();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_Cut(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Cut();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_Delete(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.Delete(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_EndOf(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.EndOf(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_Expand(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);

                return py::convert(self->obj.Expand(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_FindText(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Text::FindOptions>(args, 2);

                return py::convert(self->obj.FindText(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_GetCharacterUtf32(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                uint32_t param0 {  };
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.GetCharacterUtf32(param0, param1);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_GetClone(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetClone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_GetIndex(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);

                return py::convert(self->obj.GetIndex(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_GetPoint(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::HorizontalCharacterAlignment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Text::VerticalCharacterAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 2);
                winrt::Windows::Foundation::Point param3 {  };

                self->obj.GetPoint(param0, param1, param2, param3);

                py::pyobj_handle out3{ py::convert(param3) };
                if (!out3)
                {
                    return nullptr;
                }
                return out3.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_GetRect(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 0);
                winrt::Windows::Foundation::Rect param1 {  };
                int32_t param2 {  };

                self->obj.GetRect(param0, param1, param2);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out1.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_GetText(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextGetOptions>(args, 0);
                winrt::hstring param1 {  };

                self->obj.GetText(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_GetTextViaStream(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextGetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                self->obj.GetTextViaStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_InRange(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(args, 0);

                return py::convert(self->obj.InRange(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_InStory(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(args, 0);

                return py::convert(self->obj.InStory(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_InsertImage(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Text::VerticalCharacterAlignment>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 5);

                self->obj.InsertImage(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_IsEqual(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_MatchSelection(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.MatchSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_Move(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.Move(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_MoveEnd(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.MoveEnd(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_MoveStart(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.MoveStart(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_Paste(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.Paste(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_ScrollIntoView(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 0);

                self->obj.ScrollIntoView(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_SetIndex(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.SetIndex(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_SetPoint(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.SetPoint(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_SetRange(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.SetRange(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_SetText(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextSetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetText(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_SetTextViaStream(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextSetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                self->obj.SetTextViaStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_StartOf(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.StartOf(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRange_get_Character(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Character());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextRange_put_Character(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<char16_t>(arg);

            self->obj.Character(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextRange_get_CharacterFormat(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharacterFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextRange_put_CharacterFormat(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextCharacterFormat>(arg);

            self->obj.CharacterFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextRange_get_EndPosition(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextRange_put_EndPosition(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.EndPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextRange_get_FormattedText(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FormattedText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextRange_put_FormattedText(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(arg);

            self->obj.FormattedText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextRange_get_Gravity(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Gravity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextRange_put_Gravity(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::RangeGravity>(arg);

            self->obj.Gravity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextRange_get_Length(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextRange_get_Link(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Link());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextRange_put_Link(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Link(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextRange_get_ParagraphFormat(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ParagraphFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextRange_put_ParagraphFormat(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextParagraphFormat>(arg);

            self->obj.ParagraphFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextRange_get_StartPosition(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextRange_put_StartPosition(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.StartPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextRange_get_StoryLength(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StoryLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextRange_get_Text(py::wrapper::Windows::UI::Text::ITextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextRange_put_Text(py::wrapper::Windows::UI::Text::ITextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ITextRange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::ITextRange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextRange[] = {
        { "can_paste", (PyCFunction)ITextRange_CanPaste, METH_VARARGS, nullptr },
        { "change_case", (PyCFunction)ITextRange_ChangeCase, METH_VARARGS, nullptr },
        { "collapse", (PyCFunction)ITextRange_Collapse, METH_VARARGS, nullptr },
        { "copy", (PyCFunction)ITextRange_Copy, METH_VARARGS, nullptr },
        { "cut", (PyCFunction)ITextRange_Cut, METH_VARARGS, nullptr },
        { "delete", (PyCFunction)ITextRange_Delete, METH_VARARGS, nullptr },
        { "end_of", (PyCFunction)ITextRange_EndOf, METH_VARARGS, nullptr },
        { "expand", (PyCFunction)ITextRange_Expand, METH_VARARGS, nullptr },
        { "find_text", (PyCFunction)ITextRange_FindText, METH_VARARGS, nullptr },
        { "get_character_utf32", (PyCFunction)ITextRange_GetCharacterUtf32, METH_VARARGS, nullptr },
        { "get_clone", (PyCFunction)ITextRange_GetClone, METH_VARARGS, nullptr },
        { "get_index", (PyCFunction)ITextRange_GetIndex, METH_VARARGS, nullptr },
        { "get_point", (PyCFunction)ITextRange_GetPoint, METH_VARARGS, nullptr },
        { "get_rect", (PyCFunction)ITextRange_GetRect, METH_VARARGS, nullptr },
        { "get_text", (PyCFunction)ITextRange_GetText, METH_VARARGS, nullptr },
        { "get_text_via_stream", (PyCFunction)ITextRange_GetTextViaStream, METH_VARARGS, nullptr },
        { "in_range", (PyCFunction)ITextRange_InRange, METH_VARARGS, nullptr },
        { "in_story", (PyCFunction)ITextRange_InStory, METH_VARARGS, nullptr },
        { "insert_image", (PyCFunction)ITextRange_InsertImage, METH_VARARGS, nullptr },
        { "is_equal", (PyCFunction)ITextRange_IsEqual, METH_VARARGS, nullptr },
        { "match_selection", (PyCFunction)ITextRange_MatchSelection, METH_VARARGS, nullptr },
        { "move", (PyCFunction)ITextRange_Move, METH_VARARGS, nullptr },
        { "move_end", (PyCFunction)ITextRange_MoveEnd, METH_VARARGS, nullptr },
        { "move_start", (PyCFunction)ITextRange_MoveStart, METH_VARARGS, nullptr },
        { "paste", (PyCFunction)ITextRange_Paste, METH_VARARGS, nullptr },
        { "scroll_into_view", (PyCFunction)ITextRange_ScrollIntoView, METH_VARARGS, nullptr },
        { "set_index", (PyCFunction)ITextRange_SetIndex, METH_VARARGS, nullptr },
        { "set_point", (PyCFunction)ITextRange_SetPoint, METH_VARARGS, nullptr },
        { "set_range", (PyCFunction)ITextRange_SetRange, METH_VARARGS, nullptr },
        { "set_text", (PyCFunction)ITextRange_SetText, METH_VARARGS, nullptr },
        { "set_text_via_stream", (PyCFunction)ITextRange_SetTextViaStream, METH_VARARGS, nullptr },
        { "start_of", (PyCFunction)ITextRange_StartOf, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ITextRange, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ITextRange[] = {
        { const_cast<char*>("character"), (getter)ITextRange_get_Character, (setter)ITextRange_put_Character, nullptr, nullptr },
        { const_cast<char*>("character_format"), (getter)ITextRange_get_CharacterFormat, (setter)ITextRange_put_CharacterFormat, nullptr, nullptr },
        { const_cast<char*>("end_position"), (getter)ITextRange_get_EndPosition, (setter)ITextRange_put_EndPosition, nullptr, nullptr },
        { const_cast<char*>("formatted_text"), (getter)ITextRange_get_FormattedText, (setter)ITextRange_put_FormattedText, nullptr, nullptr },
        { const_cast<char*>("gravity"), (getter)ITextRange_get_Gravity, (setter)ITextRange_put_Gravity, nullptr, nullptr },
        { const_cast<char*>("length"), (getter)ITextRange_get_Length, nullptr, nullptr, nullptr },
        { const_cast<char*>("link"), (getter)ITextRange_get_Link, (setter)ITextRange_put_Link, nullptr, nullptr },
        { const_cast<char*>("paragraph_format"), (getter)ITextRange_get_ParagraphFormat, (setter)ITextRange_put_ParagraphFormat, nullptr, nullptr },
        { const_cast<char*>("start_position"), (getter)ITextRange_get_StartPosition, (setter)ITextRange_put_StartPosition, nullptr, nullptr },
        { const_cast<char*>("story_length"), (getter)ITextRange_get_StoryLength, nullptr, nullptr, nullptr },
        { const_cast<char*>("text"), (getter)ITextRange_get_Text, (setter)ITextRange_put_Text, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ITextRange[] = 
    {
        { Py_tp_new, _new_ITextRange },
        { Py_tp_dealloc, _dealloc_ITextRange },
        { Py_tp_methods, _methods_ITextRange },
        { Py_tp_getset, _getset_ITextRange },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ITextRange =
    {
        "_winrt_Windows_UI_Text.ITextRange",
        sizeof(py::wrapper::Windows::UI::Text::ITextRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextRange
    };

    // ----- ITextSelection interface --------------------
    constexpr const char* const _type_name_ITextSelection = "ITextSelection";

    static PyObject* _new_ITextSelection(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ITextSelection);
        return nullptr;
    }

    static void _dealloc_ITextSelection(py::wrapper::Windows::UI::Text::ITextSelection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ITextSelection_CanPaste(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.CanPaste(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_ChangeCase(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::LetterCase>(args, 0);

                self->obj.ChangeCase(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_Collapse(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.Collapse(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_Copy(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Copy();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_Cut(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Cut();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_Delete(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.Delete(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_EndKey(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.EndKey(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_EndOf(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.EndOf(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_Expand(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);

                return py::convert(self->obj.Expand(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_FindText(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Text::FindOptions>(args, 2);

                return py::convert(self->obj.FindText(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_GetCharacterUtf32(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                uint32_t param0 {  };
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.GetCharacterUtf32(param0, param1);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_GetClone(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetClone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_GetIndex(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);

                return py::convert(self->obj.GetIndex(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_GetPoint(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::HorizontalCharacterAlignment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Text::VerticalCharacterAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 2);
                winrt::Windows::Foundation::Point param3 {  };

                self->obj.GetPoint(param0, param1, param2, param3);

                py::pyobj_handle out3{ py::convert(param3) };
                if (!out3)
                {
                    return nullptr;
                }
                return out3.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_GetRect(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 0);
                winrt::Windows::Foundation::Rect param1 {  };
                int32_t param2 {  };

                self->obj.GetRect(param0, param1, param2);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out1.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_GetText(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextGetOptions>(args, 0);
                winrt::hstring param1 {  };

                self->obj.GetText(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_GetTextViaStream(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextGetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                self->obj.GetTextViaStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_HomeKey(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.HomeKey(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_InRange(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(args, 0);

                return py::convert(self->obj.InRange(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_InStory(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(args, 0);

                return py::convert(self->obj.InStory(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_InsertImage(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Text::VerticalCharacterAlignment>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 5);

                self->obj.InsertImage(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_IsEqual(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_MatchSelection(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.MatchSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_Move(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.Move(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_MoveDown(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                return py::convert(self->obj.MoveDown(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_MoveEnd(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.MoveEnd(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_MoveLeft(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                return py::convert(self->obj.MoveLeft(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_MoveRight(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                return py::convert(self->obj.MoveRight(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_MoveStart(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.MoveStart(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_MoveUp(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                return py::convert(self->obj.MoveUp(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_Paste(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.Paste(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_ScrollIntoView(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 0);

                self->obj.ScrollIntoView(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_SetIndex(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.SetIndex(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_SetPoint(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Text::PointOptions>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.SetPoint(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_SetRange(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.SetRange(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_SetText(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextSetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetText(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_SetTextViaStream(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextSetOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                self->obj.SetTextViaStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_StartOf(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Text::TextRangeUnit>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.StartOf(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_TypeText(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.TypeText(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextSelection_get_Options(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Options());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextSelection_put_Options(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::SelectionOptions>(arg);

            self->obj.Options(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextSelection_get_Type(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextSelection_get_Character(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Character());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextSelection_put_Character(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<char16_t>(arg);

            self->obj.Character(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextSelection_get_CharacterFormat(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharacterFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextSelection_put_CharacterFormat(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextCharacterFormat>(arg);

            self->obj.CharacterFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextSelection_get_EndPosition(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextSelection_put_EndPosition(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.EndPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextSelection_get_FormattedText(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FormattedText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextSelection_put_FormattedText(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextRange>(arg);

            self->obj.FormattedText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextSelection_get_Gravity(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Gravity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextSelection_put_Gravity(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::RangeGravity>(arg);

            self->obj.Gravity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextSelection_get_Length(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextSelection_get_Link(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Link());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextSelection_put_Link(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Link(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextSelection_get_ParagraphFormat(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ParagraphFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextSelection_put_ParagraphFormat(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::ITextParagraphFormat>(arg);

            self->obj.ParagraphFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextSelection_get_StartPosition(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextSelection_put_StartPosition(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.StartPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ITextSelection_get_StoryLength(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StoryLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextSelection_get_Text(py::wrapper::Windows::UI::Text::ITextSelection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ITextSelection_put_Text(py::wrapper::Windows::UI::Text::ITextSelection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ITextSelection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Text::ITextSelection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextSelection[] = {
        { "end_key", (PyCFunction)ITextSelection_EndKey, METH_VARARGS, nullptr },
        { "home_key", (PyCFunction)ITextSelection_HomeKey, METH_VARARGS, nullptr },
        { "move_down", (PyCFunction)ITextSelection_MoveDown, METH_VARARGS, nullptr },
        { "move_left", (PyCFunction)ITextSelection_MoveLeft, METH_VARARGS, nullptr },
        { "move_right", (PyCFunction)ITextSelection_MoveRight, METH_VARARGS, nullptr },
        { "move_up", (PyCFunction)ITextSelection_MoveUp, METH_VARARGS, nullptr },
        { "type_text", (PyCFunction)ITextSelection_TypeText, METH_VARARGS, nullptr },
        { "can_paste", (PyCFunction)ITextSelection_CanPaste, METH_VARARGS, nullptr },
        { "change_case", (PyCFunction)ITextSelection_ChangeCase, METH_VARARGS, nullptr },
        { "collapse", (PyCFunction)ITextSelection_Collapse, METH_VARARGS, nullptr },
        { "copy", (PyCFunction)ITextSelection_Copy, METH_VARARGS, nullptr },
        { "cut", (PyCFunction)ITextSelection_Cut, METH_VARARGS, nullptr },
        { "delete", (PyCFunction)ITextSelection_Delete, METH_VARARGS, nullptr },
        { "end_of", (PyCFunction)ITextSelection_EndOf, METH_VARARGS, nullptr },
        { "expand", (PyCFunction)ITextSelection_Expand, METH_VARARGS, nullptr },
        { "find_text", (PyCFunction)ITextSelection_FindText, METH_VARARGS, nullptr },
        { "get_character_utf32", (PyCFunction)ITextSelection_GetCharacterUtf32, METH_VARARGS, nullptr },
        { "get_clone", (PyCFunction)ITextSelection_GetClone, METH_VARARGS, nullptr },
        { "get_index", (PyCFunction)ITextSelection_GetIndex, METH_VARARGS, nullptr },
        { "get_point", (PyCFunction)ITextSelection_GetPoint, METH_VARARGS, nullptr },
        { "get_rect", (PyCFunction)ITextSelection_GetRect, METH_VARARGS, nullptr },
        { "get_text", (PyCFunction)ITextSelection_GetText, METH_VARARGS, nullptr },
        { "get_text_via_stream", (PyCFunction)ITextSelection_GetTextViaStream, METH_VARARGS, nullptr },
        { "in_range", (PyCFunction)ITextSelection_InRange, METH_VARARGS, nullptr },
        { "in_story", (PyCFunction)ITextSelection_InStory, METH_VARARGS, nullptr },
        { "insert_image", (PyCFunction)ITextSelection_InsertImage, METH_VARARGS, nullptr },
        { "is_equal", (PyCFunction)ITextSelection_IsEqual, METH_VARARGS, nullptr },
        { "match_selection", (PyCFunction)ITextSelection_MatchSelection, METH_VARARGS, nullptr },
        { "move", (PyCFunction)ITextSelection_Move, METH_VARARGS, nullptr },
        { "move_end", (PyCFunction)ITextSelection_MoveEnd, METH_VARARGS, nullptr },
        { "move_start", (PyCFunction)ITextSelection_MoveStart, METH_VARARGS, nullptr },
        { "paste", (PyCFunction)ITextSelection_Paste, METH_VARARGS, nullptr },
        { "scroll_into_view", (PyCFunction)ITextSelection_ScrollIntoView, METH_VARARGS, nullptr },
        { "set_index", (PyCFunction)ITextSelection_SetIndex, METH_VARARGS, nullptr },
        { "set_point", (PyCFunction)ITextSelection_SetPoint, METH_VARARGS, nullptr },
        { "set_range", (PyCFunction)ITextSelection_SetRange, METH_VARARGS, nullptr },
        { "set_text", (PyCFunction)ITextSelection_SetText, METH_VARARGS, nullptr },
        { "set_text_via_stream", (PyCFunction)ITextSelection_SetTextViaStream, METH_VARARGS, nullptr },
        { "start_of", (PyCFunction)ITextSelection_StartOf, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ITextSelection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ITextSelection[] = {
        { const_cast<char*>("options"), (getter)ITextSelection_get_Options, (setter)ITextSelection_put_Options, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)ITextSelection_get_Type, nullptr, nullptr, nullptr },
        { const_cast<char*>("character"), (getter)ITextSelection_get_Character, (setter)ITextSelection_put_Character, nullptr, nullptr },
        { const_cast<char*>("character_format"), (getter)ITextSelection_get_CharacterFormat, (setter)ITextSelection_put_CharacterFormat, nullptr, nullptr },
        { const_cast<char*>("end_position"), (getter)ITextSelection_get_EndPosition, (setter)ITextSelection_put_EndPosition, nullptr, nullptr },
        { const_cast<char*>("formatted_text"), (getter)ITextSelection_get_FormattedText, (setter)ITextSelection_put_FormattedText, nullptr, nullptr },
        { const_cast<char*>("gravity"), (getter)ITextSelection_get_Gravity, (setter)ITextSelection_put_Gravity, nullptr, nullptr },
        { const_cast<char*>("length"), (getter)ITextSelection_get_Length, nullptr, nullptr, nullptr },
        { const_cast<char*>("link"), (getter)ITextSelection_get_Link, (setter)ITextSelection_put_Link, nullptr, nullptr },
        { const_cast<char*>("paragraph_format"), (getter)ITextSelection_get_ParagraphFormat, (setter)ITextSelection_put_ParagraphFormat, nullptr, nullptr },
        { const_cast<char*>("start_position"), (getter)ITextSelection_get_StartPosition, (setter)ITextSelection_put_StartPosition, nullptr, nullptr },
        { const_cast<char*>("story_length"), (getter)ITextSelection_get_StoryLength, nullptr, nullptr, nullptr },
        { const_cast<char*>("text"), (getter)ITextSelection_get_Text, (setter)ITextSelection_put_Text, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ITextSelection[] = 
    {
        { Py_tp_new, _new_ITextSelection },
        { Py_tp_dealloc, _dealloc_ITextSelection },
        { Py_tp_methods, _methods_ITextSelection },
        { Py_tp_getset, _getset_ITextSelection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ITextSelection =
    {
        "_winrt_Windows_UI_Text.ITextSelection",
        sizeof(py::wrapper::Windows::UI::Text::ITextSelection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextSelection
    };

    // ----- FontWeight struct --------------------
    constexpr const char* const _type_name_FontWeight = "FontWeight";

    PyObject* _new_FontWeight(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::Text::FontWeight return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::UI::Text::FontWeight>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint16_t _Weight{};

        static const char* kwlist[] = {"weight", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "H", const_cast<char**>(kwlist), &_Weight))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::Text::FontWeight return_value{ _Weight };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_FontWeight(py::wrapper::Windows::UI::Text::FontWeight* self)
    {
    }

    static PyObject* FontWeight_get_Weight(py::wrapper::Windows::UI::Text::FontWeight* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Weight);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FontWeight_set_Weight(py::wrapper::Windows::UI::Text::FontWeight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Weight = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_FontWeight[] = {
        { const_cast<char*>("weight"), (getter)FontWeight_get_Weight, (setter)FontWeight_set_Weight, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FontWeight[] = 
    {
        { Py_tp_new, _new_FontWeight },
        { Py_tp_dealloc, _dealloc_FontWeight },
        { Py_tp_getset, _getset_FontWeight },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FontWeight =
    {
        "_winrt_Windows_UI_Text.FontWeight",
        sizeof(py::wrapper::Windows::UI::Text::FontWeight),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FontWeight
    };

    // ----- Windows.UI.Text Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::UI::Text::ContentLinkInfo>::python_type = py::register_python_type(module, _type_name_ContentLinkInfo, &_type_spec_ContentLinkInfo, bases.get());
            py::winrt_type<winrt::Windows::UI::Text::FontWeights>::python_type = py::register_python_type(module, _type_name_FontWeights, &_type_spec_FontWeights, bases.get());
            py::winrt_type<winrt::Windows::UI::Text::RichEditTextDocument>::python_type = py::register_python_type(module, _type_name_RichEditTextDocument, &_type_spec_RichEditTextDocument, bases.get());
            py::winrt_type<winrt::Windows::UI::Text::RichEditTextRange>::python_type = py::register_python_type(module, _type_name_RichEditTextRange, &_type_spec_RichEditTextRange, bases.get());
            py::winrt_type<winrt::Windows::UI::Text::TextConstants>::python_type = py::register_python_type(module, _type_name_TextConstants, &_type_spec_TextConstants, nullptr);
            py::winrt_type<winrt::Windows::UI::Text::ITextCharacterFormat>::python_type = py::register_python_type(module, _type_name_ITextCharacterFormat, &_type_spec_ITextCharacterFormat, bases.get());
            py::winrt_type<winrt::Windows::UI::Text::ITextDocument>::python_type = py::register_python_type(module, _type_name_ITextDocument, &_type_spec_ITextDocument, bases.get());
            py::winrt_type<winrt::Windows::UI::Text::ITextParagraphFormat>::python_type = py::register_python_type(module, _type_name_ITextParagraphFormat, &_type_spec_ITextParagraphFormat, bases.get());
            py::winrt_type<winrt::Windows::UI::Text::ITextRange>::python_type = py::register_python_type(module, _type_name_ITextRange, &_type_spec_ITextRange, bases.get());
            py::winrt_type<winrt::Windows::UI::Text::ITextSelection>::python_type = py::register_python_type(module, _type_name_ITextSelection, &_type_spec_ITextSelection, bases.get());
            py::winrt_type<winrt::Windows::UI::Text::FontWeight>::python_type = py::register_python_type(module, _type_name_FontWeight, &_type_spec_FontWeight, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.UI.Text");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_UI_Text",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::UI::Text

PyMODINIT_FUNC
PyInit__winrt_Windows_UI_Text (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::UI::Text::module_def);
}
