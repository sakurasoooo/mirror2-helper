// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Security.Cryptography.Certificates.h"

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::Certificate>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateChain>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateExtension>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateKeyUsages>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateQuery>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateStore>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateStores>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::ChainBuildingParameters>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::ChainValidationParameters>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CmsAttachedSignature>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CmsDetachedSignature>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CmsTimestampInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::KeyAttestationHelper>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::UserCertificateStore>::python_type;

namespace py::cpp::Windows::Security::Cryptography::Certificates
{
    // ----- Certificate class --------------------
    constexpr const char* const _type_name_Certificate = "Certificate";

    static PyObject* _new_Certificate(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Security::Cryptography::Certificates::Certificate instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Certificate(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Certificate_BuildChainAsync(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 0);

                return py::convert(self->obj.BuildChainAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ChainBuildingParameters>(args, 1);

                return py::convert(self->obj.BuildChainAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Certificate_GetCertificateBlob(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCertificateBlob());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Certificate_GetHashValue(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetHashValue());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetHashValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Certificate_get_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Certificate_put_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Certificate_get_EnhancedKeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EnhancedKeyUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_HasPrivateKey(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasPrivateKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_IsStronglyProtected(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStronglyProtected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_Issuer(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Issuer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_SerialNumber(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SerialNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_Subject(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_ValidFrom(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ValidFrom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_ValidTo(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ValidTo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_IsSecurityDeviceBound(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSecurityDeviceBound());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_KeyAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_KeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_SignatureAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignatureAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_SignatureHashAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignatureHashAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_SubjectAlternativeName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SubjectAlternativeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_IsPerUser(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPerUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_KeyStorageProviderName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyStorageProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_StoreName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StoreName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Certificate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::Certificate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Certificate[] = {
        { "build_chain_async", (PyCFunction)Certificate_BuildChainAsync, METH_VARARGS, nullptr },
        { "get_certificate_blob", (PyCFunction)Certificate_GetCertificateBlob, METH_VARARGS, nullptr },
        { "get_hash_value", (PyCFunction)Certificate_GetHashValue, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_Certificate, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_Certificate[] = {
        { const_cast<char*>("friendly_name"), (getter)Certificate_get_FriendlyName, (setter)Certificate_put_FriendlyName, nullptr, nullptr },
        { const_cast<char*>("enhanced_key_usages"), (getter)Certificate_get_EnhancedKeyUsages, nullptr, nullptr, nullptr },
        { const_cast<char*>("has_private_key"), (getter)Certificate_get_HasPrivateKey, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_strongly_protected"), (getter)Certificate_get_IsStronglyProtected, nullptr, nullptr, nullptr },
        { const_cast<char*>("issuer"), (getter)Certificate_get_Issuer, nullptr, nullptr, nullptr },
        { const_cast<char*>("serial_number"), (getter)Certificate_get_SerialNumber, nullptr, nullptr, nullptr },
        { const_cast<char*>("subject"), (getter)Certificate_get_Subject, nullptr, nullptr, nullptr },
        { const_cast<char*>("valid_from"), (getter)Certificate_get_ValidFrom, nullptr, nullptr, nullptr },
        { const_cast<char*>("valid_to"), (getter)Certificate_get_ValidTo, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_security_device_bound"), (getter)Certificate_get_IsSecurityDeviceBound, nullptr, nullptr, nullptr },
        { const_cast<char*>("key_algorithm_name"), (getter)Certificate_get_KeyAlgorithmName, nullptr, nullptr, nullptr },
        { const_cast<char*>("key_usages"), (getter)Certificate_get_KeyUsages, nullptr, nullptr, nullptr },
        { const_cast<char*>("signature_algorithm_name"), (getter)Certificate_get_SignatureAlgorithmName, nullptr, nullptr, nullptr },
        { const_cast<char*>("signature_hash_algorithm_name"), (getter)Certificate_get_SignatureHashAlgorithmName, nullptr, nullptr, nullptr },
        { const_cast<char*>("subject_alternative_name"), (getter)Certificate_get_SubjectAlternativeName, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_per_user"), (getter)Certificate_get_IsPerUser, nullptr, nullptr, nullptr },
        { const_cast<char*>("key_storage_provider_name"), (getter)Certificate_get_KeyStorageProviderName, nullptr, nullptr, nullptr },
        { const_cast<char*>("store_name"), (getter)Certificate_get_StoreName, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Certificate[] = 
    {
        { Py_tp_new, _new_Certificate },
        { Py_tp_dealloc, _dealloc_Certificate },
        { Py_tp_methods, _methods_Certificate },
        { Py_tp_getset, _getset_Certificate },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Certificate =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.Certificate",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Certificate
    };

    // ----- CertificateChain class --------------------
    constexpr const char* const _type_name_CertificateChain = "CertificateChain";

    static PyObject* _new_CertificateChain(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CertificateChain);
        return nullptr;
    }

    static void _dealloc_CertificateChain(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateChain* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CertificateChain_GetCertificates(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateChain* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.GetCertificates(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateChain_Validate(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateChain* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Validate());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ChainValidationParameters>(args, 0);

                return py::convert(self->obj.Validate(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_CertificateChain(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateChain>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateChain[] = {
        { "get_certificates", (PyCFunction)CertificateChain_GetCertificates, METH_VARARGS, nullptr },
        { "validate", (PyCFunction)CertificateChain_Validate, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_CertificateChain, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CertificateChain[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_CertificateChain[] = 
    {
        { Py_tp_new, _new_CertificateChain },
        { Py_tp_dealloc, _dealloc_CertificateChain },
        { Py_tp_methods, _methods_CertificateChain },
        { Py_tp_getset, _getset_CertificateChain },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CertificateChain =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.CertificateChain",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateChain),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateChain
    };

    // ----- CertificateEnrollmentManager class --------------------
    constexpr const char* const _type_name_CertificateEnrollmentManager = "CertificateEnrollmentManager";

    static PyObject* _new_CertificateEnrollmentManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CertificateEnrollmentManager);
        return nullptr;
    }

    static PyObject* CertificateEnrollmentManager_CreateRequestAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::CreateRequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateEnrollmentManager_ImportPfxDataAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::ImportPfxDataAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::ImportPfxDataAsync(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::ImportPfxDataAsync(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateEnrollmentManager_InstallCertificateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::InstallCertificateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateEnrollmentManager_get_UserCertificateEnrollmentManager(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::UserCertificateEnrollmentManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateEnrollmentManager[] = {
        { "create_request_async", (PyCFunction)CertificateEnrollmentManager_CreateRequestAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "import_pfx_data_async", (PyCFunction)CertificateEnrollmentManager_ImportPfxDataAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "install_certificate_async", (PyCFunction)CertificateEnrollmentManager_InstallCertificateAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_user_certificate_enrollment_manager", (PyCFunction)CertificateEnrollmentManager_get_UserCertificateEnrollmentManager, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CertificateEnrollmentManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_CertificateEnrollmentManager[] = 
    {
        { Py_tp_new, _new_CertificateEnrollmentManager },
        { Py_tp_methods, _methods_CertificateEnrollmentManager },
        { Py_tp_getset, _getset_CertificateEnrollmentManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CertificateEnrollmentManager =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.CertificateEnrollmentManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateEnrollmentManager
    };

    // ----- CertificateExtension class --------------------
    constexpr const char* const _type_name_CertificateExtension = "CertificateExtension";

    static PyObject* _new_CertificateExtension(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::CertificateExtension instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CertificateExtension(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CertificateExtension_EncodeValue(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.EncodeValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateExtension_get_Value(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateExtension_put_Value(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::array_view<uint8_t>>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateExtension_get_ObjectId(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ObjectId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateExtension_put_ObjectId(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ObjectId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateExtension_get_IsCritical(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCritical());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateExtension_put_IsCritical(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCritical(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_CertificateExtension(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateExtension>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateExtension[] = {
        { "encode_value", (PyCFunction)CertificateExtension_EncodeValue, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_CertificateExtension, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CertificateExtension[] = {
        { const_cast<char*>("value"), (getter)CertificateExtension_get_Value, (setter)CertificateExtension_put_Value, nullptr, nullptr },
        { const_cast<char*>("object_id"), (getter)CertificateExtension_get_ObjectId, (setter)CertificateExtension_put_ObjectId, nullptr, nullptr },
        { const_cast<char*>("is_critical"), (getter)CertificateExtension_get_IsCritical, (setter)CertificateExtension_put_IsCritical, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CertificateExtension[] = 
    {
        { Py_tp_new, _new_CertificateExtension },
        { Py_tp_dealloc, _dealloc_CertificateExtension },
        { Py_tp_methods, _methods_CertificateExtension },
        { Py_tp_getset, _getset_CertificateExtension },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CertificateExtension =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.CertificateExtension",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateExtension
    };

    // ----- CertificateKeyUsages class --------------------
    constexpr const char* const _type_name_CertificateKeyUsages = "CertificateKeyUsages";

    static PyObject* _new_CertificateKeyUsages(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::CertificateKeyUsages instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CertificateKeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CertificateKeyUsages_get_NonRepudiation(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NonRepudiation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_NonRepudiation(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.NonRepudiation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_KeyEncipherment(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyEncipherment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_KeyEncipherment(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeyEncipherment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_KeyCertificateSign(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyCertificateSign());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_KeyCertificateSign(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeyCertificateSign(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_KeyAgreement(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyAgreement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_KeyAgreement(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeyAgreement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_EncipherOnly(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncipherOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_EncipherOnly(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.EncipherOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_DigitalSignature(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DigitalSignature());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_DigitalSignature(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DigitalSignature(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_DataEncipherment(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DataEncipherment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_DataEncipherment(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DataEncipherment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_CrlSign(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CrlSign());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_CrlSign(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CrlSign(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_CertificateKeyUsages(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateKeyUsages>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateKeyUsages[] = {
        { "_from", (PyCFunction)_from_CertificateKeyUsages, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CertificateKeyUsages[] = {
        { const_cast<char*>("non_repudiation"), (getter)CertificateKeyUsages_get_NonRepudiation, (setter)CertificateKeyUsages_put_NonRepudiation, nullptr, nullptr },
        { const_cast<char*>("key_encipherment"), (getter)CertificateKeyUsages_get_KeyEncipherment, (setter)CertificateKeyUsages_put_KeyEncipherment, nullptr, nullptr },
        { const_cast<char*>("key_certificate_sign"), (getter)CertificateKeyUsages_get_KeyCertificateSign, (setter)CertificateKeyUsages_put_KeyCertificateSign, nullptr, nullptr },
        { const_cast<char*>("key_agreement"), (getter)CertificateKeyUsages_get_KeyAgreement, (setter)CertificateKeyUsages_put_KeyAgreement, nullptr, nullptr },
        { const_cast<char*>("encipher_only"), (getter)CertificateKeyUsages_get_EncipherOnly, (setter)CertificateKeyUsages_put_EncipherOnly, nullptr, nullptr },
        { const_cast<char*>("digital_signature"), (getter)CertificateKeyUsages_get_DigitalSignature, (setter)CertificateKeyUsages_put_DigitalSignature, nullptr, nullptr },
        { const_cast<char*>("data_encipherment"), (getter)CertificateKeyUsages_get_DataEncipherment, (setter)CertificateKeyUsages_put_DataEncipherment, nullptr, nullptr },
        { const_cast<char*>("crl_sign"), (getter)CertificateKeyUsages_get_CrlSign, (setter)CertificateKeyUsages_put_CrlSign, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CertificateKeyUsages[] = 
    {
        { Py_tp_new, _new_CertificateKeyUsages },
        { Py_tp_dealloc, _dealloc_CertificateKeyUsages },
        { Py_tp_methods, _methods_CertificateKeyUsages },
        { Py_tp_getset, _getset_CertificateKeyUsages },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CertificateKeyUsages =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.CertificateKeyUsages",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateKeyUsages
    };

    // ----- CertificateQuery class --------------------
    constexpr const char* const _type_name_CertificateQuery = "CertificateQuery";

    static PyObject* _new_CertificateQuery(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::CertificateQuery instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CertificateQuery(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CertificateQuery_get_Thumbprint(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Thumbprint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_Thumbprint(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::array_view<uint8_t>>(arg);

            self->obj.Thumbprint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_IssuerName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IssuerName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_IssuerName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.IssuerName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_HardwareOnly(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_HardwareOnly(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.HardwareOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_EnhancedKeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EnhancedKeyUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CertificateQuery_get_StoreName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StoreName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_StoreName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.StoreName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_IncludeExpiredCertificates(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IncludeExpiredCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_IncludeExpiredCertificates(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeExpiredCertificates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_IncludeDuplicates(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IncludeDuplicates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_IncludeDuplicates(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeDuplicates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_CertificateQuery(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateQuery>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateQuery[] = {
        { "_from", (PyCFunction)_from_CertificateQuery, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CertificateQuery[] = {
        { const_cast<char*>("thumbprint"), (getter)CertificateQuery_get_Thumbprint, (setter)CertificateQuery_put_Thumbprint, nullptr, nullptr },
        { const_cast<char*>("issuer_name"), (getter)CertificateQuery_get_IssuerName, (setter)CertificateQuery_put_IssuerName, nullptr, nullptr },
        { const_cast<char*>("hardware_only"), (getter)CertificateQuery_get_HardwareOnly, (setter)CertificateQuery_put_HardwareOnly, nullptr, nullptr },
        { const_cast<char*>("friendly_name"), (getter)CertificateQuery_get_FriendlyName, (setter)CertificateQuery_put_FriendlyName, nullptr, nullptr },
        { const_cast<char*>("enhanced_key_usages"), (getter)CertificateQuery_get_EnhancedKeyUsages, nullptr, nullptr, nullptr },
        { const_cast<char*>("store_name"), (getter)CertificateQuery_get_StoreName, (setter)CertificateQuery_put_StoreName, nullptr, nullptr },
        { const_cast<char*>("include_expired_certificates"), (getter)CertificateQuery_get_IncludeExpiredCertificates, (setter)CertificateQuery_put_IncludeExpiredCertificates, nullptr, nullptr },
        { const_cast<char*>("include_duplicates"), (getter)CertificateQuery_get_IncludeDuplicates, (setter)CertificateQuery_put_IncludeDuplicates, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CertificateQuery[] = 
    {
        { Py_tp_new, _new_CertificateQuery },
        { Py_tp_dealloc, _dealloc_CertificateQuery },
        { Py_tp_methods, _methods_CertificateQuery },
        { Py_tp_getset, _getset_CertificateQuery },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CertificateQuery =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.CertificateQuery",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateQuery
    };

    // ----- CertificateRequestProperties class --------------------
    constexpr const char* const _type_name_CertificateRequestProperties = "CertificateRequestProperties";

    static PyObject* _new_CertificateRequestProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CertificateRequestProperties(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CertificateRequestProperties_get_Subject(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_Subject(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subject(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_KeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_KeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::EnrollKeyUsages>(arg);

            self->obj.KeyUsages(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_KeyStorageProviderName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyStorageProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_KeyStorageProviderName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.KeyStorageProviderName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_KeySize(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeySize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_KeySize(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.KeySize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_Exportable(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Exportable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_Exportable(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(arg);

            self->obj.Exportable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_KeyProtectionLevel(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_KeyProtectionLevel(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(arg);

            self->obj.KeyProtectionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_KeyAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_KeyAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.KeyAlgorithmName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_HashAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HashAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_HashAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HashAlgorithmName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_AttestationCredentialCertificate(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AttestationCredentialCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_AttestationCredentialCertificate(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.AttestationCredentialCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_SigningCertificate(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SigningCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_SigningCertificate(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.SigningCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_SmartcardReaderName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SmartcardReaderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_SmartcardReaderName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SmartcardReaderName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_UseExistingKey(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UseExistingKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_UseExistingKey(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.UseExistingKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_CurveParameters(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurveParameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_CurveParameters(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::array_view<uint8_t>>(arg);

            self->obj.CurveParameters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_CurveName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurveName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_CurveName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CurveName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_ContainerNamePrefix(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContainerNamePrefix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_ContainerNamePrefix(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContainerNamePrefix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_ContainerName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContainerName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_ContainerName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContainerName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_Extensions(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Extensions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CertificateRequestProperties_get_SubjectAlternativeName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SubjectAlternativeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CertificateRequestProperties_get_SuppressedDefaults(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuppressedDefaults());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CertificateRequestProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateRequestProperties[] = {
        { "_from", (PyCFunction)_from_CertificateRequestProperties, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CertificateRequestProperties[] = {
        { const_cast<char*>("subject"), (getter)CertificateRequestProperties_get_Subject, (setter)CertificateRequestProperties_put_Subject, nullptr, nullptr },
        { const_cast<char*>("key_usages"), (getter)CertificateRequestProperties_get_KeyUsages, (setter)CertificateRequestProperties_put_KeyUsages, nullptr, nullptr },
        { const_cast<char*>("key_storage_provider_name"), (getter)CertificateRequestProperties_get_KeyStorageProviderName, (setter)CertificateRequestProperties_put_KeyStorageProviderName, nullptr, nullptr },
        { const_cast<char*>("key_size"), (getter)CertificateRequestProperties_get_KeySize, (setter)CertificateRequestProperties_put_KeySize, nullptr, nullptr },
        { const_cast<char*>("exportable"), (getter)CertificateRequestProperties_get_Exportable, (setter)CertificateRequestProperties_put_Exportable, nullptr, nullptr },
        { const_cast<char*>("key_protection_level"), (getter)CertificateRequestProperties_get_KeyProtectionLevel, (setter)CertificateRequestProperties_put_KeyProtectionLevel, nullptr, nullptr },
        { const_cast<char*>("key_algorithm_name"), (getter)CertificateRequestProperties_get_KeyAlgorithmName, (setter)CertificateRequestProperties_put_KeyAlgorithmName, nullptr, nullptr },
        { const_cast<char*>("hash_algorithm_name"), (getter)CertificateRequestProperties_get_HashAlgorithmName, (setter)CertificateRequestProperties_put_HashAlgorithmName, nullptr, nullptr },
        { const_cast<char*>("friendly_name"), (getter)CertificateRequestProperties_get_FriendlyName, (setter)CertificateRequestProperties_put_FriendlyName, nullptr, nullptr },
        { const_cast<char*>("attestation_credential_certificate"), (getter)CertificateRequestProperties_get_AttestationCredentialCertificate, (setter)CertificateRequestProperties_put_AttestationCredentialCertificate, nullptr, nullptr },
        { const_cast<char*>("signing_certificate"), (getter)CertificateRequestProperties_get_SigningCertificate, (setter)CertificateRequestProperties_put_SigningCertificate, nullptr, nullptr },
        { const_cast<char*>("smartcard_reader_name"), (getter)CertificateRequestProperties_get_SmartcardReaderName, (setter)CertificateRequestProperties_put_SmartcardReaderName, nullptr, nullptr },
        { const_cast<char*>("use_existing_key"), (getter)CertificateRequestProperties_get_UseExistingKey, (setter)CertificateRequestProperties_put_UseExistingKey, nullptr, nullptr },
        { const_cast<char*>("curve_parameters"), (getter)CertificateRequestProperties_get_CurveParameters, (setter)CertificateRequestProperties_put_CurveParameters, nullptr, nullptr },
        { const_cast<char*>("curve_name"), (getter)CertificateRequestProperties_get_CurveName, (setter)CertificateRequestProperties_put_CurveName, nullptr, nullptr },
        { const_cast<char*>("container_name_prefix"), (getter)CertificateRequestProperties_get_ContainerNamePrefix, (setter)CertificateRequestProperties_put_ContainerNamePrefix, nullptr, nullptr },
        { const_cast<char*>("container_name"), (getter)CertificateRequestProperties_get_ContainerName, (setter)CertificateRequestProperties_put_ContainerName, nullptr, nullptr },
        { const_cast<char*>("extensions"), (getter)CertificateRequestProperties_get_Extensions, nullptr, nullptr, nullptr },
        { const_cast<char*>("subject_alternative_name"), (getter)CertificateRequestProperties_get_SubjectAlternativeName, nullptr, nullptr, nullptr },
        { const_cast<char*>("suppressed_defaults"), (getter)CertificateRequestProperties_get_SuppressedDefaults, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CertificateRequestProperties[] = 
    {
        { Py_tp_new, _new_CertificateRequestProperties },
        { Py_tp_dealloc, _dealloc_CertificateRequestProperties },
        { Py_tp_methods, _methods_CertificateRequestProperties },
        { Py_tp_getset, _getset_CertificateRequestProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CertificateRequestProperties =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.CertificateRequestProperties",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateRequestProperties
    };

    // ----- CertificateStore class --------------------
    constexpr const char* const _type_name_CertificateStore = "CertificateStore";

    static PyObject* _new_CertificateStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CertificateStore);
        return nullptr;
    }

    static void _dealloc_CertificateStore(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateStore* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CertificateStore_Add(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);

                self->obj.Add(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateStore_Delete(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);

                self->obj.Delete(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateStore_get_Name(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateStore* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CertificateStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateStore[] = {
        { "add", (PyCFunction)CertificateStore_Add, METH_VARARGS, nullptr },
        { "delete", (PyCFunction)CertificateStore_Delete, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_CertificateStore, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CertificateStore[] = {
        { const_cast<char*>("name"), (getter)CertificateStore_get_Name, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CertificateStore[] = 
    {
        { Py_tp_new, _new_CertificateStore },
        { Py_tp_dealloc, _dealloc_CertificateStore },
        { Py_tp_methods, _methods_CertificateStore },
        { Py_tp_getset, _getset_CertificateStore },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CertificateStore =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.CertificateStore",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateStore
    };

    // ----- CertificateStores class --------------------
    constexpr const char* const _type_name_CertificateStores = "CertificateStores";

    static PyObject* _new_CertificateStores(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CertificateStores);
        return nullptr;
    }

    static PyObject* CertificateStores_FindAllAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::FindAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::CertificateQuery>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::FindAllAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateStores_GetStoreByName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::GetStoreByName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateStores_GetUserStoreByName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::GetUserStoreByName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateStores_get_IntermediateCertificationAuthorities(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::IntermediateCertificationAuthorities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CertificateStores_get_TrustedRootCertificationAuthorities(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::TrustedRootCertificationAuthorities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateStores[] = {
        { "find_all_async", (PyCFunction)CertificateStores_FindAllAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_store_by_name", (PyCFunction)CertificateStores_GetStoreByName, METH_VARARGS | METH_STATIC, nullptr },
        { "get_user_store_by_name", (PyCFunction)CertificateStores_GetUserStoreByName, METH_VARARGS | METH_STATIC, nullptr },
        { "get_intermediate_certification_authorities", (PyCFunction)CertificateStores_get_IntermediateCertificationAuthorities, METH_NOARGS | METH_STATIC, nullptr },
        { "get_trusted_root_certification_authorities", (PyCFunction)CertificateStores_get_TrustedRootCertificationAuthorities, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CertificateStores[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_CertificateStores[] = 
    {
        { Py_tp_new, _new_CertificateStores },
        { Py_tp_methods, _methods_CertificateStores },
        { Py_tp_getset, _getset_CertificateStores },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CertificateStores =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.CertificateStores",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateStores
    };

    // ----- ChainBuildingParameters class --------------------
    constexpr const char* const _type_name_ChainBuildingParameters = "ChainBuildingParameters";

    static PyObject* _new_ChainBuildingParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::ChainBuildingParameters instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChainBuildingParameters(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChainBuildingParameters_get_ValidationTimestamp(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ValidationTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainBuildingParameters_put_ValidationTimestamp(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.ValidationTimestamp(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainBuildingParameters_get_RevocationCheckEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RevocationCheckEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainBuildingParameters_put_RevocationCheckEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RevocationCheckEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainBuildingParameters_get_NetworkRetrievalEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkRetrievalEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainBuildingParameters_put_NetworkRetrievalEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.NetworkRetrievalEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainBuildingParameters_get_CurrentTimeValidationEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentTimeValidationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainBuildingParameters_put_CurrentTimeValidationEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CurrentTimeValidationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainBuildingParameters_get_AuthorityInformationAccessEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AuthorityInformationAccessEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainBuildingParameters_put_AuthorityInformationAccessEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AuthorityInformationAccessEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainBuildingParameters_get_EnhancedKeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EnhancedKeyUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChainBuildingParameters_get_ExclusiveTrustRoots(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExclusiveTrustRoots());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChainBuildingParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::ChainBuildingParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChainBuildingParameters[] = {
        { "_from", (PyCFunction)_from_ChainBuildingParameters, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChainBuildingParameters[] = {
        { const_cast<char*>("validation_timestamp"), (getter)ChainBuildingParameters_get_ValidationTimestamp, (setter)ChainBuildingParameters_put_ValidationTimestamp, nullptr, nullptr },
        { const_cast<char*>("revocation_check_enabled"), (getter)ChainBuildingParameters_get_RevocationCheckEnabled, (setter)ChainBuildingParameters_put_RevocationCheckEnabled, nullptr, nullptr },
        { const_cast<char*>("network_retrieval_enabled"), (getter)ChainBuildingParameters_get_NetworkRetrievalEnabled, (setter)ChainBuildingParameters_put_NetworkRetrievalEnabled, nullptr, nullptr },
        { const_cast<char*>("current_time_validation_enabled"), (getter)ChainBuildingParameters_get_CurrentTimeValidationEnabled, (setter)ChainBuildingParameters_put_CurrentTimeValidationEnabled, nullptr, nullptr },
        { const_cast<char*>("authority_information_access_enabled"), (getter)ChainBuildingParameters_get_AuthorityInformationAccessEnabled, (setter)ChainBuildingParameters_put_AuthorityInformationAccessEnabled, nullptr, nullptr },
        { const_cast<char*>("enhanced_key_usages"), (getter)ChainBuildingParameters_get_EnhancedKeyUsages, nullptr, nullptr, nullptr },
        { const_cast<char*>("exclusive_trust_roots"), (getter)ChainBuildingParameters_get_ExclusiveTrustRoots, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ChainBuildingParameters[] = 
    {
        { Py_tp_new, _new_ChainBuildingParameters },
        { Py_tp_dealloc, _dealloc_ChainBuildingParameters },
        { Py_tp_methods, _methods_ChainBuildingParameters },
        { Py_tp_getset, _getset_ChainBuildingParameters },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChainBuildingParameters =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.ChainBuildingParameters",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChainBuildingParameters
    };

    // ----- ChainValidationParameters class --------------------
    constexpr const char* const _type_name_ChainValidationParameters = "ChainValidationParameters";

    static PyObject* _new_ChainValidationParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::ChainValidationParameters instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChainValidationParameters(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChainValidationParameters_get_ServerDnsName(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerDnsName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainValidationParameters_put_ServerDnsName(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(arg);

            self->obj.ServerDnsName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainValidationParameters_get_CertificateChainPolicy(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CertificateChainPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainValidationParameters_put_CertificateChainPolicy(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::CertificateChainPolicy>(arg);

            self->obj.CertificateChainPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ChainValidationParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::ChainValidationParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChainValidationParameters[] = {
        { "_from", (PyCFunction)_from_ChainValidationParameters, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChainValidationParameters[] = {
        { const_cast<char*>("server_dns_name"), (getter)ChainValidationParameters_get_ServerDnsName, (setter)ChainValidationParameters_put_ServerDnsName, nullptr, nullptr },
        { const_cast<char*>("certificate_chain_policy"), (getter)ChainValidationParameters_get_CertificateChainPolicy, (setter)ChainValidationParameters_put_CertificateChainPolicy, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ChainValidationParameters[] = 
    {
        { Py_tp_new, _new_ChainValidationParameters },
        { Py_tp_dealloc, _dealloc_ChainValidationParameters },
        { Py_tp_methods, _methods_ChainValidationParameters },
        { Py_tp_getset, _getset_ChainValidationParameters },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChainValidationParameters =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.ChainValidationParameters",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChainValidationParameters
    };

    // ----- CmsAttachedSignature class --------------------
    constexpr const char* const _type_name_CmsAttachedSignature = "CmsAttachedSignature";

    static PyObject* _new_CmsAttachedSignature(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Security::Cryptography::Certificates::CmsAttachedSignature instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CmsAttachedSignature(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CmsAttachedSignature_GenerateSignatureAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CmsAttachedSignature::GenerateSignatureAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CmsAttachedSignature_VerifySignature(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.VerifySignature());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CmsAttachedSignature_get_Certificates(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Certificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CmsAttachedSignature_get_Content(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CmsAttachedSignature_get_Signers(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Signers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CmsAttachedSignature(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CmsAttachedSignature>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CmsAttachedSignature[] = {
        { "generate_signature_async", (PyCFunction)CmsAttachedSignature_GenerateSignatureAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "verify_signature", (PyCFunction)CmsAttachedSignature_VerifySignature, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_CmsAttachedSignature, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CmsAttachedSignature[] = {
        { const_cast<char*>("certificates"), (getter)CmsAttachedSignature_get_Certificates, nullptr, nullptr, nullptr },
        { const_cast<char*>("content"), (getter)CmsAttachedSignature_get_Content, nullptr, nullptr, nullptr },
        { const_cast<char*>("signers"), (getter)CmsAttachedSignature_get_Signers, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CmsAttachedSignature[] = 
    {
        { Py_tp_new, _new_CmsAttachedSignature },
        { Py_tp_dealloc, _dealloc_CmsAttachedSignature },
        { Py_tp_methods, _methods_CmsAttachedSignature },
        { Py_tp_getset, _getset_CmsAttachedSignature },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CmsAttachedSignature =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.CmsAttachedSignature",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CmsAttachedSignature
    };

    // ----- CmsDetachedSignature class --------------------
    constexpr const char* const _type_name_CmsDetachedSignature = "CmsDetachedSignature";

    static PyObject* _new_CmsDetachedSignature(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Security::Cryptography::Certificates::CmsDetachedSignature instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CmsDetachedSignature(py::wrapper::Windows::Security::Cryptography::Certificates::CmsDetachedSignature* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CmsDetachedSignature_GenerateSignatureAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CmsDetachedSignature::GenerateSignatureAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CmsDetachedSignature_VerifySignatureAsync(py::wrapper::Windows::Security::Cryptography::Certificates::CmsDetachedSignature* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.VerifySignatureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CmsDetachedSignature_get_Certificates(py::wrapper::Windows::Security::Cryptography::Certificates::CmsDetachedSignature* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Certificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CmsDetachedSignature_get_Signers(py::wrapper::Windows::Security::Cryptography::Certificates::CmsDetachedSignature* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Signers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CmsDetachedSignature(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CmsDetachedSignature>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CmsDetachedSignature[] = {
        { "generate_signature_async", (PyCFunction)CmsDetachedSignature_GenerateSignatureAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "verify_signature_async", (PyCFunction)CmsDetachedSignature_VerifySignatureAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_CmsDetachedSignature, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CmsDetachedSignature[] = {
        { const_cast<char*>("certificates"), (getter)CmsDetachedSignature_get_Certificates, nullptr, nullptr, nullptr },
        { const_cast<char*>("signers"), (getter)CmsDetachedSignature_get_Signers, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CmsDetachedSignature[] = 
    {
        { Py_tp_new, _new_CmsDetachedSignature },
        { Py_tp_dealloc, _dealloc_CmsDetachedSignature },
        { Py_tp_methods, _methods_CmsDetachedSignature },
        { Py_tp_getset, _getset_CmsDetachedSignature },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CmsDetachedSignature =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.CmsDetachedSignature",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CmsDetachedSignature),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CmsDetachedSignature
    };

    // ----- CmsSignerInfo class --------------------
    constexpr const char* const _type_name_CmsSignerInfo = "CmsSignerInfo";

    static PyObject* _new_CmsSignerInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CmsSignerInfo(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CmsSignerInfo_get_HashAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HashAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CmsSignerInfo_put_HashAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HashAlgorithmName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CmsSignerInfo_get_Certificate(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Certificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CmsSignerInfo_put_Certificate(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.Certificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CmsSignerInfo_get_TimestampInfo(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimestampInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CmsSignerInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CmsSignerInfo[] = {
        { "_from", (PyCFunction)_from_CmsSignerInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CmsSignerInfo[] = {
        { const_cast<char*>("hash_algorithm_name"), (getter)CmsSignerInfo_get_HashAlgorithmName, (setter)CmsSignerInfo_put_HashAlgorithmName, nullptr, nullptr },
        { const_cast<char*>("certificate"), (getter)CmsSignerInfo_get_Certificate, (setter)CmsSignerInfo_put_Certificate, nullptr, nullptr },
        { const_cast<char*>("timestamp_info"), (getter)CmsSignerInfo_get_TimestampInfo, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CmsSignerInfo[] = 
    {
        { Py_tp_new, _new_CmsSignerInfo },
        { Py_tp_dealloc, _dealloc_CmsSignerInfo },
        { Py_tp_methods, _methods_CmsSignerInfo },
        { Py_tp_getset, _getset_CmsSignerInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CmsSignerInfo =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.CmsSignerInfo",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CmsSignerInfo
    };

    // ----- CmsTimestampInfo class --------------------
    constexpr const char* const _type_name_CmsTimestampInfo = "CmsTimestampInfo";

    static PyObject* _new_CmsTimestampInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CmsTimestampInfo);
        return nullptr;
    }

    static void _dealloc_CmsTimestampInfo(py::wrapper::Windows::Security::Cryptography::Certificates::CmsTimestampInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CmsTimestampInfo_get_Certificates(py::wrapper::Windows::Security::Cryptography::Certificates::CmsTimestampInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Certificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CmsTimestampInfo_get_SigningCertificate(py::wrapper::Windows::Security::Cryptography::Certificates::CmsTimestampInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SigningCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CmsTimestampInfo_get_Timestamp(py::wrapper::Windows::Security::Cryptography::Certificates::CmsTimestampInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CmsTimestampInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CmsTimestampInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CmsTimestampInfo[] = {
        { "_from", (PyCFunction)_from_CmsTimestampInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CmsTimestampInfo[] = {
        { const_cast<char*>("certificates"), (getter)CmsTimestampInfo_get_Certificates, nullptr, nullptr, nullptr },
        { const_cast<char*>("signing_certificate"), (getter)CmsTimestampInfo_get_SigningCertificate, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)CmsTimestampInfo_get_Timestamp, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CmsTimestampInfo[] = 
    {
        { Py_tp_new, _new_CmsTimestampInfo },
        { Py_tp_dealloc, _dealloc_CmsTimestampInfo },
        { Py_tp_methods, _methods_CmsTimestampInfo },
        { Py_tp_getset, _getset_CmsTimestampInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CmsTimestampInfo =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.CmsTimestampInfo",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CmsTimestampInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CmsTimestampInfo
    };

    // ----- KeyAlgorithmNames class --------------------
    constexpr const char* const _type_name_KeyAlgorithmNames = "KeyAlgorithmNames";

    static PyObject* _new_KeyAlgorithmNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KeyAlgorithmNames);
        return nullptr;
    }

    static PyObject* KeyAlgorithmNames_get_Dsa(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Dsa());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdh256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdh256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdh384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdh384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdh521(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdh521());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdsa256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdsa256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdsa384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdsa384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdsa521(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdsa521());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Rsa(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Rsa());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdh(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdsa(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdsa());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyAlgorithmNames[] = {
        { "get_dsa", (PyCFunction)KeyAlgorithmNames_get_Dsa, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdh256", (PyCFunction)KeyAlgorithmNames_get_Ecdh256, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdh384", (PyCFunction)KeyAlgorithmNames_get_Ecdh384, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdh521", (PyCFunction)KeyAlgorithmNames_get_Ecdh521, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdsa256", (PyCFunction)KeyAlgorithmNames_get_Ecdsa256, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdsa384", (PyCFunction)KeyAlgorithmNames_get_Ecdsa384, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdsa521", (PyCFunction)KeyAlgorithmNames_get_Ecdsa521, METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa", (PyCFunction)KeyAlgorithmNames_get_Rsa, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdh", (PyCFunction)KeyAlgorithmNames_get_Ecdh, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdsa", (PyCFunction)KeyAlgorithmNames_get_Ecdsa, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_KeyAlgorithmNames[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_KeyAlgorithmNames[] = 
    {
        { Py_tp_new, _new_KeyAlgorithmNames },
        { Py_tp_methods, _methods_KeyAlgorithmNames },
        { Py_tp_getset, _getset_KeyAlgorithmNames },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_KeyAlgorithmNames =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.KeyAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyAlgorithmNames
    };

    // ----- KeyAttestationHelper class --------------------
    constexpr const char* const _type_name_KeyAttestationHelper = "KeyAttestationHelper";

    static PyObject* _new_KeyAttestationHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KeyAttestationHelper);
        return nullptr;
    }

    static PyObject* KeyAttestationHelper_DecryptTpmAttestationCredentialAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAttestationHelper::DecryptTpmAttestationCredentialAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAttestationHelper::DecryptTpmAttestationCredentialAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyAttestationHelper_GetTpmAttestationCredentialId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAttestationHelper::GetTpmAttestationCredentialId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyAttestationHelper[] = {
        { "decrypt_tpm_attestation_credential_async", (PyCFunction)KeyAttestationHelper_DecryptTpmAttestationCredentialAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_tpm_attestation_credential_id", (PyCFunction)KeyAttestationHelper_GetTpmAttestationCredentialId, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_KeyAttestationHelper[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_KeyAttestationHelper[] = 
    {
        { Py_tp_new, _new_KeyAttestationHelper },
        { Py_tp_methods, _methods_KeyAttestationHelper },
        { Py_tp_getset, _getset_KeyAttestationHelper },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_KeyAttestationHelper =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.KeyAttestationHelper",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyAttestationHelper
    };

    // ----- KeyStorageProviderNames class --------------------
    constexpr const char* const _type_name_KeyStorageProviderNames = "KeyStorageProviderNames";

    static PyObject* _new_KeyStorageProviderNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KeyStorageProviderNames);
        return nullptr;
    }

    static PyObject* KeyStorageProviderNames_get_PlatformKeyStorageProvider(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames::PlatformKeyStorageProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyStorageProviderNames_get_SmartcardKeyStorageProvider(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames::SmartcardKeyStorageProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyStorageProviderNames_get_SoftwareKeyStorageProvider(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames::SoftwareKeyStorageProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyStorageProviderNames_get_PassportKeyStorageProvider(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames::PassportKeyStorageProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyStorageProviderNames[] = {
        { "get_platform_key_storage_provider", (PyCFunction)KeyStorageProviderNames_get_PlatformKeyStorageProvider, METH_NOARGS | METH_STATIC, nullptr },
        { "get_smartcard_key_storage_provider", (PyCFunction)KeyStorageProviderNames_get_SmartcardKeyStorageProvider, METH_NOARGS | METH_STATIC, nullptr },
        { "get_software_key_storage_provider", (PyCFunction)KeyStorageProviderNames_get_SoftwareKeyStorageProvider, METH_NOARGS | METH_STATIC, nullptr },
        { "get_passport_key_storage_provider", (PyCFunction)KeyStorageProviderNames_get_PassportKeyStorageProvider, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_KeyStorageProviderNames[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_KeyStorageProviderNames[] = 
    {
        { Py_tp_new, _new_KeyStorageProviderNames },
        { Py_tp_methods, _methods_KeyStorageProviderNames },
        { Py_tp_getset, _getset_KeyStorageProviderNames },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_KeyStorageProviderNames =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.KeyStorageProviderNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyStorageProviderNames
    };

    // ----- PfxImportParameters class --------------------
    constexpr const char* const _type_name_PfxImportParameters = "PfxImportParameters";

    static PyObject* _new_PfxImportParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PfxImportParameters(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PfxImportParameters_get_ReaderName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReaderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_ReaderName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ReaderName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_KeyStorageProviderName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyStorageProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_KeyStorageProviderName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.KeyStorageProviderName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_KeyProtectionLevel(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_KeyProtectionLevel(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(arg);

            self->obj.KeyProtectionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_InstallOptions(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstallOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_InstallOptions(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(arg);

            self->obj.InstallOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_Exportable(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Exportable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_Exportable(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(arg);

            self->obj.Exportable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_ContainerNamePrefix(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContainerNamePrefix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_ContainerNamePrefix(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContainerNamePrefix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_PfxImportParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PfxImportParameters[] = {
        { "_from", (PyCFunction)_from_PfxImportParameters, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PfxImportParameters[] = {
        { const_cast<char*>("reader_name"), (getter)PfxImportParameters_get_ReaderName, (setter)PfxImportParameters_put_ReaderName, nullptr, nullptr },
        { const_cast<char*>("key_storage_provider_name"), (getter)PfxImportParameters_get_KeyStorageProviderName, (setter)PfxImportParameters_put_KeyStorageProviderName, nullptr, nullptr },
        { const_cast<char*>("key_protection_level"), (getter)PfxImportParameters_get_KeyProtectionLevel, (setter)PfxImportParameters_put_KeyProtectionLevel, nullptr, nullptr },
        { const_cast<char*>("install_options"), (getter)PfxImportParameters_get_InstallOptions, (setter)PfxImportParameters_put_InstallOptions, nullptr, nullptr },
        { const_cast<char*>("friendly_name"), (getter)PfxImportParameters_get_FriendlyName, (setter)PfxImportParameters_put_FriendlyName, nullptr, nullptr },
        { const_cast<char*>("exportable"), (getter)PfxImportParameters_get_Exportable, (setter)PfxImportParameters_put_Exportable, nullptr, nullptr },
        { const_cast<char*>("container_name_prefix"), (getter)PfxImportParameters_get_ContainerNamePrefix, (setter)PfxImportParameters_put_ContainerNamePrefix, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PfxImportParameters[] = 
    {
        { Py_tp_new, _new_PfxImportParameters },
        { Py_tp_dealloc, _dealloc_PfxImportParameters },
        { Py_tp_methods, _methods_PfxImportParameters },
        { Py_tp_getset, _getset_PfxImportParameters },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PfxImportParameters =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.PfxImportParameters",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PfxImportParameters
    };

    // ----- StandardCertificateStoreNames class --------------------
    constexpr const char* const _type_name_StandardCertificateStoreNames = "StandardCertificateStoreNames";

    static PyObject* _new_StandardCertificateStoreNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StandardCertificateStoreNames);
        return nullptr;
    }

    static PyObject* StandardCertificateStoreNames_get_IntermediateCertificationAuthorities(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames::IntermediateCertificationAuthorities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardCertificateStoreNames_get_Personal(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames::Personal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardCertificateStoreNames_get_TrustedRootCertificationAuthorities(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames::TrustedRootCertificationAuthorities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StandardCertificateStoreNames[] = {
        { "get_intermediate_certification_authorities", (PyCFunction)StandardCertificateStoreNames_get_IntermediateCertificationAuthorities, METH_NOARGS | METH_STATIC, nullptr },
        { "get_personal", (PyCFunction)StandardCertificateStoreNames_get_Personal, METH_NOARGS | METH_STATIC, nullptr },
        { "get_trusted_root_certification_authorities", (PyCFunction)StandardCertificateStoreNames_get_TrustedRootCertificationAuthorities, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StandardCertificateStoreNames[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_StandardCertificateStoreNames[] = 
    {
        { Py_tp_new, _new_StandardCertificateStoreNames },
        { Py_tp_methods, _methods_StandardCertificateStoreNames },
        { Py_tp_getset, _getset_StandardCertificateStoreNames },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StandardCertificateStoreNames =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.StandardCertificateStoreNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StandardCertificateStoreNames
    };

    // ----- SubjectAlternativeNameInfo class --------------------
    constexpr const char* const _type_name_SubjectAlternativeNameInfo = "SubjectAlternativeNameInfo";

    static PyObject* _new_SubjectAlternativeNameInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SubjectAlternativeNameInfo(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SubjectAlternativeNameInfo_get_DistinguishedName(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DistinguishedName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_DnsName(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DnsName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_EmailName(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EmailName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_IPAddress(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IPAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_PrincipalName(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrincipalName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_Url(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Url());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_DistinguishedNames(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DistinguishedNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_DnsNames(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DnsNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_EmailNames(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EmailNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_Extension(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Extension());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_IPAddresses(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IPAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_PrincipalNames(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrincipalNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_Urls(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Urls());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SubjectAlternativeNameInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SubjectAlternativeNameInfo[] = {
        { "_from", (PyCFunction)_from_SubjectAlternativeNameInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SubjectAlternativeNameInfo[] = {
        { const_cast<char*>("distinguished_name"), (getter)SubjectAlternativeNameInfo_get_DistinguishedName, nullptr, nullptr, nullptr },
        { const_cast<char*>("dns_name"), (getter)SubjectAlternativeNameInfo_get_DnsName, nullptr, nullptr, nullptr },
        { const_cast<char*>("email_name"), (getter)SubjectAlternativeNameInfo_get_EmailName, nullptr, nullptr, nullptr },
        { const_cast<char*>("ip_address"), (getter)SubjectAlternativeNameInfo_get_IPAddress, nullptr, nullptr, nullptr },
        { const_cast<char*>("principal_name"), (getter)SubjectAlternativeNameInfo_get_PrincipalName, nullptr, nullptr, nullptr },
        { const_cast<char*>("url"), (getter)SubjectAlternativeNameInfo_get_Url, nullptr, nullptr, nullptr },
        { const_cast<char*>("distinguished_names"), (getter)SubjectAlternativeNameInfo_get_DistinguishedNames, nullptr, nullptr, nullptr },
        { const_cast<char*>("dns_names"), (getter)SubjectAlternativeNameInfo_get_DnsNames, nullptr, nullptr, nullptr },
        { const_cast<char*>("email_names"), (getter)SubjectAlternativeNameInfo_get_EmailNames, nullptr, nullptr, nullptr },
        { const_cast<char*>("extension"), (getter)SubjectAlternativeNameInfo_get_Extension, nullptr, nullptr, nullptr },
        { const_cast<char*>("ip_addresses"), (getter)SubjectAlternativeNameInfo_get_IPAddresses, nullptr, nullptr, nullptr },
        { const_cast<char*>("principal_names"), (getter)SubjectAlternativeNameInfo_get_PrincipalNames, nullptr, nullptr, nullptr },
        { const_cast<char*>("urls"), (getter)SubjectAlternativeNameInfo_get_Urls, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SubjectAlternativeNameInfo[] = 
    {
        { Py_tp_new, _new_SubjectAlternativeNameInfo },
        { Py_tp_dealloc, _dealloc_SubjectAlternativeNameInfo },
        { Py_tp_methods, _methods_SubjectAlternativeNameInfo },
        { Py_tp_getset, _getset_SubjectAlternativeNameInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SubjectAlternativeNameInfo =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.SubjectAlternativeNameInfo",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SubjectAlternativeNameInfo
    };

    // ----- UserCertificateEnrollmentManager class --------------------
    constexpr const char* const _type_name_UserCertificateEnrollmentManager = "UserCertificateEnrollmentManager";

    static PyObject* _new_UserCertificateEnrollmentManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UserCertificateEnrollmentManager);
        return nullptr;
    }

    static void _dealloc_UserCertificateEnrollmentManager(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UserCertificateEnrollmentManager_CreateRequestAsync(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties>(args, 0);

                return py::convert(self->obj.CreateRequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserCertificateEnrollmentManager_ImportPfxDataAsync(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters>(args, 2);

                return py::convert(self->obj.ImportPfxDataAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);

                return py::convert(self->obj.ImportPfxDataAsync(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);

                return py::convert(self->obj.ImportPfxDataAsync(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserCertificateEnrollmentManager_InstallCertificateAsync(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 1);

                return py::convert(self->obj.InstallCertificateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_UserCertificateEnrollmentManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserCertificateEnrollmentManager[] = {
        { "create_request_async", (PyCFunction)UserCertificateEnrollmentManager_CreateRequestAsync, METH_VARARGS, nullptr },
        { "import_pfx_data_async", (PyCFunction)UserCertificateEnrollmentManager_ImportPfxDataAsync, METH_VARARGS, nullptr },
        { "install_certificate_async", (PyCFunction)UserCertificateEnrollmentManager_InstallCertificateAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_UserCertificateEnrollmentManager, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UserCertificateEnrollmentManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_UserCertificateEnrollmentManager[] = 
    {
        { Py_tp_new, _new_UserCertificateEnrollmentManager },
        { Py_tp_dealloc, _dealloc_UserCertificateEnrollmentManager },
        { Py_tp_methods, _methods_UserCertificateEnrollmentManager },
        { Py_tp_getset, _getset_UserCertificateEnrollmentManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UserCertificateEnrollmentManager =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.UserCertificateEnrollmentManager",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserCertificateEnrollmentManager
    };

    // ----- UserCertificateStore class --------------------
    constexpr const char* const _type_name_UserCertificateStore = "UserCertificateStore";

    static PyObject* _new_UserCertificateStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UserCertificateStore);
        return nullptr;
    }

    static void _dealloc_UserCertificateStore(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateStore* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UserCertificateStore_RequestAddAsync(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);

                return py::convert(self->obj.RequestAddAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserCertificateStore_RequestDeleteAsync(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);

                return py::convert(self->obj.RequestDeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserCertificateStore_get_Name(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateStore* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UserCertificateStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::UserCertificateStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserCertificateStore[] = {
        { "request_add_async", (PyCFunction)UserCertificateStore_RequestAddAsync, METH_VARARGS, nullptr },
        { "request_delete_async", (PyCFunction)UserCertificateStore_RequestDeleteAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_UserCertificateStore, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UserCertificateStore[] = {
        { const_cast<char*>("name"), (getter)UserCertificateStore_get_Name, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UserCertificateStore[] = 
    {
        { Py_tp_new, _new_UserCertificateStore },
        { Py_tp_dealloc, _dealloc_UserCertificateStore },
        { Py_tp_methods, _methods_UserCertificateStore },
        { Py_tp_getset, _getset_UserCertificateStore },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UserCertificateStore =
    {
        "_winrt_Windows_Security_Cryptography_Certificates.UserCertificateStore",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserCertificateStore
    };

    // ----- Windows.Security.Cryptography.Certificates Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::Certificate>::python_type = py::register_python_type(module, _type_name_Certificate, &_type_spec_Certificate, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateChain>::python_type = py::register_python_type(module, _type_name_CertificateChain, &_type_spec_CertificateChain, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager>::python_type = py::register_python_type(module, _type_name_CertificateEnrollmentManager, &_type_spec_CertificateEnrollmentManager, nullptr);
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateExtension>::python_type = py::register_python_type(module, _type_name_CertificateExtension, &_type_spec_CertificateExtension, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateKeyUsages>::python_type = py::register_python_type(module, _type_name_CertificateKeyUsages, &_type_spec_CertificateKeyUsages, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateQuery>::python_type = py::register_python_type(module, _type_name_CertificateQuery, &_type_spec_CertificateQuery, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties>::python_type = py::register_python_type(module, _type_name_CertificateRequestProperties, &_type_spec_CertificateRequestProperties, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateStore>::python_type = py::register_python_type(module, _type_name_CertificateStore, &_type_spec_CertificateStore, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateStores>::python_type = py::register_python_type(module, _type_name_CertificateStores, &_type_spec_CertificateStores, nullptr);
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::ChainBuildingParameters>::python_type = py::register_python_type(module, _type_name_ChainBuildingParameters, &_type_spec_ChainBuildingParameters, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::ChainValidationParameters>::python_type = py::register_python_type(module, _type_name_ChainValidationParameters, &_type_spec_ChainValidationParameters, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CmsAttachedSignature>::python_type = py::register_python_type(module, _type_name_CmsAttachedSignature, &_type_spec_CmsAttachedSignature, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CmsDetachedSignature>::python_type = py::register_python_type(module, _type_name_CmsDetachedSignature, &_type_spec_CmsDetachedSignature, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo>::python_type = py::register_python_type(module, _type_name_CmsSignerInfo, &_type_spec_CmsSignerInfo, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CmsTimestampInfo>::python_type = py::register_python_type(module, _type_name_CmsTimestampInfo, &_type_spec_CmsTimestampInfo, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames>::python_type = py::register_python_type(module, _type_name_KeyAlgorithmNames, &_type_spec_KeyAlgorithmNames, nullptr);
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::KeyAttestationHelper>::python_type = py::register_python_type(module, _type_name_KeyAttestationHelper, &_type_spec_KeyAttestationHelper, nullptr);
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames>::python_type = py::register_python_type(module, _type_name_KeyStorageProviderNames, &_type_spec_KeyStorageProviderNames, nullptr);
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters>::python_type = py::register_python_type(module, _type_name_PfxImportParameters, &_type_spec_PfxImportParameters, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames>::python_type = py::register_python_type(module, _type_name_StandardCertificateStoreNames, &_type_spec_StandardCertificateStoreNames, nullptr);
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo>::python_type = py::register_python_type(module, _type_name_SubjectAlternativeNameInfo, &_type_spec_SubjectAlternativeNameInfo, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager>::python_type = py::register_python_type(module, _type_name_UserCertificateEnrollmentManager, &_type_spec_UserCertificateEnrollmentManager, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::UserCertificateStore>::python_type = py::register_python_type(module, _type_name_UserCertificateStore, &_type_spec_UserCertificateStore, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Security.Cryptography.Certificates");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Security_Cryptography_Certificates",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Security::Cryptography::Certificates

PyMODINIT_FUNC
PyInit__winrt_Windows_Security_Cryptography_Certificates (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Security::Cryptography::Certificates::module_def);
}
