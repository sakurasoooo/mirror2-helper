// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.ApplicationModel.Chat.h"

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatConversation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatConversationReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageAttachment>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageBlocking>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChange>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeTracker>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageStore>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageTransport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageValidationResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatQueryOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatSearchReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatSyncConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatSyncManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsTransport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsTransportConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::IChatItem>::python_type;

namespace py::cpp::Windows::ApplicationModel::Chat
{
    // ----- ChatCapabilities class --------------------
    constexpr const char* const _type_name_ChatCapabilities = "ChatCapabilities";

    static PyObject* _new_ChatCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatCapabilities);
        return nullptr;
    }

    static void _dealloc_ChatCapabilities(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatCapabilities_get_IsChatCapable(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsChatCapable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatCapabilities_get_IsFileTransferCapable(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsFileTransferCapable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatCapabilities_get_IsGeoLocationPushCapable(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsGeoLocationPushCapable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatCapabilities_get_IsIntegratedMessagingCapable(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsIntegratedMessagingCapable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatCapabilities_get_IsOnline(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOnline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatCapabilities[] = {
        { "_from", (PyCFunction)_from_ChatCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatCapabilities[] = {
        { const_cast<char*>("is_chat_capable"), (getter)ChatCapabilities_get_IsChatCapable, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_file_transfer_capable"), (getter)ChatCapabilities_get_IsFileTransferCapable, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_geo_location_push_capable"), (getter)ChatCapabilities_get_IsGeoLocationPushCapable, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_integrated_messaging_capable"), (getter)ChatCapabilities_get_IsIntegratedMessagingCapable, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_online"), (getter)ChatCapabilities_get_IsOnline, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatCapabilities[] = 
    {
        { Py_tp_new, _new_ChatCapabilities },
        { Py_tp_dealloc, _dealloc_ChatCapabilities },
        { Py_tp_methods, _methods_ChatCapabilities },
        { Py_tp_getset, _getset_ChatCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatCapabilities =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatCapabilities",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatCapabilities
    };

    // ----- ChatCapabilitiesManager class --------------------
    constexpr const char* const _type_name_ChatCapabilitiesManager = "ChatCapabilitiesManager";

    static PyObject* _new_ChatCapabilitiesManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatCapabilitiesManager);
        return nullptr;
    }

    static PyObject* ChatCapabilitiesManager_GetCachedCapabilitiesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager::GetCachedCapabilitiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager::GetCachedCapabilitiesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatCapabilitiesManager_GetCapabilitiesFromNetworkAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager::GetCapabilitiesFromNetworkAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager::GetCapabilitiesFromNetworkAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatCapabilitiesManager[] = {
        { "get_cached_capabilities_async", (PyCFunction)ChatCapabilitiesManager_GetCachedCapabilitiesAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_capabilities_from_network_async", (PyCFunction)ChatCapabilitiesManager_GetCapabilitiesFromNetworkAsync, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatCapabilitiesManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatCapabilitiesManager[] = 
    {
        { Py_tp_new, _new_ChatCapabilitiesManager },
        { Py_tp_methods, _methods_ChatCapabilitiesManager },
        { Py_tp_getset, _getset_ChatCapabilitiesManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatCapabilitiesManager =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatCapabilitiesManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatCapabilitiesManager
    };

    // ----- ChatConversation class --------------------
    constexpr const char* const _type_name_ChatConversation = "ChatConversation";

    static PyObject* _new_ChatConversation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatConversation);
        return nullptr;
    }

    static void _dealloc_ChatConversation(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatConversation_DeleteAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_GetMessageReader(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetMessageReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_MarkMessagesAsReadAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.MarkMessagesAsReadAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert(self->obj.MarkMessagesAsReadAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_NotifyLocalParticipantComposing(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.NotifyLocalParticipantComposing(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_NotifyRemoteParticipantComposing(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.NotifyRemoteParticipantComposing(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_SaveAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.SaveAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_Subject(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversation_put_Subject(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subject(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversation_get_IsConversationMuted(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsConversationMuted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversation_put_IsConversationMuted(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsConversationMuted(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversation_get_HasUnreadMessages(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasUnreadMessages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_Id(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_MostRecentMessageId(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MostRecentMessageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_Participants(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Participants());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_ThreadingInfo(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ThreadingInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_CanModifyParticipants(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanModifyParticipants());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversation_put_CanModifyParticipants(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanModifyParticipants(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversation_get_ItemKind(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ItemKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_add_RemoteParticipantComposingChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Chat::ChatConversation, winrt::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs>>(arg);

            return py::convert(self->obj.RemoteParticipantComposingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_remove_RemoteParticipantComposingChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RemoteParticipantComposingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatConversation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatConversation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatConversation[] = {
        { "delete_async", (PyCFunction)ChatConversation_DeleteAsync, METH_VARARGS, nullptr },
        { "get_message_reader", (PyCFunction)ChatConversation_GetMessageReader, METH_VARARGS, nullptr },
        { "mark_messages_as_read_async", (PyCFunction)ChatConversation_MarkMessagesAsReadAsync, METH_VARARGS, nullptr },
        { "notify_local_participant_composing", (PyCFunction)ChatConversation_NotifyLocalParticipantComposing, METH_VARARGS, nullptr },
        { "notify_remote_participant_composing", (PyCFunction)ChatConversation_NotifyRemoteParticipantComposing, METH_VARARGS, nullptr },
        { "save_async", (PyCFunction)ChatConversation_SaveAsync, METH_VARARGS, nullptr },
        { "add_remote_participant_composing_changed", (PyCFunction)ChatConversation_add_RemoteParticipantComposingChanged, METH_O, nullptr },
        { "remove_remote_participant_composing_changed", (PyCFunction)ChatConversation_remove_RemoteParticipantComposingChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ChatConversation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatConversation[] = {
        { const_cast<char*>("subject"), (getter)ChatConversation_get_Subject, (setter)ChatConversation_put_Subject, nullptr, nullptr },
        { const_cast<char*>("is_conversation_muted"), (getter)ChatConversation_get_IsConversationMuted, (setter)ChatConversation_put_IsConversationMuted, nullptr, nullptr },
        { const_cast<char*>("has_unread_messages"), (getter)ChatConversation_get_HasUnreadMessages, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)ChatConversation_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("most_recent_message_id"), (getter)ChatConversation_get_MostRecentMessageId, nullptr, nullptr, nullptr },
        { const_cast<char*>("participants"), (getter)ChatConversation_get_Participants, nullptr, nullptr, nullptr },
        { const_cast<char*>("threading_info"), (getter)ChatConversation_get_ThreadingInfo, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_modify_participants"), (getter)ChatConversation_get_CanModifyParticipants, (setter)ChatConversation_put_CanModifyParticipants, nullptr, nullptr },
        { const_cast<char*>("item_kind"), (getter)ChatConversation_get_ItemKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatConversation[] = 
    {
        { Py_tp_new, _new_ChatConversation },
        { Py_tp_dealloc, _dealloc_ChatConversation },
        { Py_tp_methods, _methods_ChatConversation },
        { Py_tp_getset, _getset_ChatConversation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatConversation =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatConversation",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatConversation
    };

    // ----- ChatConversationReader class --------------------
    constexpr const char* const _type_name_ChatConversationReader = "ChatConversationReader";

    static PyObject* _new_ChatConversationReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatConversationReader);
        return nullptr;
    }

    static void _dealloc_ChatConversationReader(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatConversationReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.ReadBatchAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ChatConversationReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatConversationReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatConversationReader[] = {
        { "read_batch_async", (PyCFunction)ChatConversationReader_ReadBatchAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ChatConversationReader, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatConversationReader[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatConversationReader[] = 
    {
        { Py_tp_new, _new_ChatConversationReader },
        { Py_tp_dealloc, _dealloc_ChatConversationReader },
        { Py_tp_methods, _methods_ChatConversationReader },
        { Py_tp_getset, _getset_ChatConversationReader },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatConversationReader =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatConversationReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatConversationReader
    };

    // ----- ChatConversationThreadingInfo class --------------------
    constexpr const char* const _type_name_ChatConversationThreadingInfo = "ChatConversationThreadingInfo";

    static PyObject* _new_ChatConversationThreadingInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatConversationThreadingInfo(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatConversationThreadingInfo_get_Kind(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversationThreadingInfo_put_Kind(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingKind>(arg);

            self->obj.Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversationThreadingInfo_get_Custom(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Custom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversationThreadingInfo_put_Custom(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Custom(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversationThreadingInfo_get_ConversationId(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConversationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversationThreadingInfo_put_ConversationId(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ConversationId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversationThreadingInfo_get_ContactId(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversationThreadingInfo_put_ContactId(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContactId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversationThreadingInfo_get_Participants(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Participants());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatConversationThreadingInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatConversationThreadingInfo[] = {
        { "_from", (PyCFunction)_from_ChatConversationThreadingInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatConversationThreadingInfo[] = {
        { const_cast<char*>("kind"), (getter)ChatConversationThreadingInfo_get_Kind, (setter)ChatConversationThreadingInfo_put_Kind, nullptr, nullptr },
        { const_cast<char*>("custom"), (getter)ChatConversationThreadingInfo_get_Custom, (setter)ChatConversationThreadingInfo_put_Custom, nullptr, nullptr },
        { const_cast<char*>("conversation_id"), (getter)ChatConversationThreadingInfo_get_ConversationId, (setter)ChatConversationThreadingInfo_put_ConversationId, nullptr, nullptr },
        { const_cast<char*>("contact_id"), (getter)ChatConversationThreadingInfo_get_ContactId, (setter)ChatConversationThreadingInfo_put_ContactId, nullptr, nullptr },
        { const_cast<char*>("participants"), (getter)ChatConversationThreadingInfo_get_Participants, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatConversationThreadingInfo[] = 
    {
        { Py_tp_new, _new_ChatConversationThreadingInfo },
        { Py_tp_dealloc, _dealloc_ChatConversationThreadingInfo },
        { Py_tp_methods, _methods_ChatConversationThreadingInfo },
        { Py_tp_getset, _getset_ChatConversationThreadingInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatConversationThreadingInfo =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatConversationThreadingInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatConversationThreadingInfo
    };

    // ----- ChatMessage class --------------------
    constexpr const char* const _type_name_ChatMessage = "ChatMessage";

    static PyObject* _new_ChatMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Chat::ChatMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatMessage(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessage_get_ItemKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ItemKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_IsIncoming(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsIncoming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsIncoming(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsIncoming(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_IsForwardingDisabled(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsForwardingDisabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsForwardingDisabled(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsForwardingDisabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_TransportId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_TransportId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TransportId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_Status(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_Status(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessageStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_From(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_From(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.From(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_Body(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_Body(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Body(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_Subject(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_Subject(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subject(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_IsRead(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsRead(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRead(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_NetworkTimestamp(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_NetworkTimestamp(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.NetworkTimestamp(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_LocalTimestamp(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_LocalTimestamp(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.LocalTimestamp(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_RecipientSendStatuses(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RecipientSendStatuses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_Recipients(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Recipients());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_TransportFriendlyName(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportFriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_Attachments(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Attachments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_Id(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_IsSeen(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSeen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsSeen(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSeen(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_MessageKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_MessageKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessageKind>(arg);

            self->obj.MessageKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_IsReceivedDuringQuietHours(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReceivedDuringQuietHours());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsReceivedDuringQuietHours(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsReceivedDuringQuietHours(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_IsAutoReply(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAutoReply());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsAutoReply(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAutoReply(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_EstimatedDownloadSize(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EstimatedDownloadSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_EstimatedDownloadSize(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.EstimatedDownloadSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_ThreadingInfo(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ThreadingInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_ThreadingInfo(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo>(arg);

            self->obj.ThreadingInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_ShouldSuppressNotification(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShouldSuppressNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_ShouldSuppressNotification(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldSuppressNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_RemoteId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_RemoteId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_MessageOperatorKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageOperatorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_MessageOperatorKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessageOperatorKind>(arg);

            self->obj.MessageOperatorKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_IsReplyDisabled(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReplyDisabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_IsSimMessage(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSimMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_RecipientsDeliveryInfos(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RecipientsDeliveryInfos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_SyncId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SyncId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_SyncId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SyncId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ChatMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessage[] = {
        { "_from", (PyCFunction)_from_ChatMessage, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatMessage[] = {
        { const_cast<char*>("item_kind"), (getter)ChatMessage_get_ItemKind, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_incoming"), (getter)ChatMessage_get_IsIncoming, (setter)ChatMessage_put_IsIncoming, nullptr, nullptr },
        { const_cast<char*>("is_forwarding_disabled"), (getter)ChatMessage_get_IsForwardingDisabled, (setter)ChatMessage_put_IsForwardingDisabled, nullptr, nullptr },
        { const_cast<char*>("transport_id"), (getter)ChatMessage_get_TransportId, (setter)ChatMessage_put_TransportId, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)ChatMessage_get_Status, (setter)ChatMessage_put_Status, nullptr, nullptr },
        { const_cast<char*>("from"), (getter)ChatMessage_get_From, (setter)ChatMessage_put_From, nullptr, nullptr },
        { const_cast<char*>("body"), (getter)ChatMessage_get_Body, (setter)ChatMessage_put_Body, nullptr, nullptr },
        { const_cast<char*>("subject"), (getter)ChatMessage_get_Subject, (setter)ChatMessage_put_Subject, nullptr, nullptr },
        { const_cast<char*>("is_read"), (getter)ChatMessage_get_IsRead, (setter)ChatMessage_put_IsRead, nullptr, nullptr },
        { const_cast<char*>("network_timestamp"), (getter)ChatMessage_get_NetworkTimestamp, (setter)ChatMessage_put_NetworkTimestamp, nullptr, nullptr },
        { const_cast<char*>("local_timestamp"), (getter)ChatMessage_get_LocalTimestamp, (setter)ChatMessage_put_LocalTimestamp, nullptr, nullptr },
        { const_cast<char*>("recipient_send_statuses"), (getter)ChatMessage_get_RecipientSendStatuses, nullptr, nullptr, nullptr },
        { const_cast<char*>("recipients"), (getter)ChatMessage_get_Recipients, nullptr, nullptr, nullptr },
        { const_cast<char*>("transport_friendly_name"), (getter)ChatMessage_get_TransportFriendlyName, nullptr, nullptr, nullptr },
        { const_cast<char*>("attachments"), (getter)ChatMessage_get_Attachments, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)ChatMessage_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_seen"), (getter)ChatMessage_get_IsSeen, (setter)ChatMessage_put_IsSeen, nullptr, nullptr },
        { const_cast<char*>("message_kind"), (getter)ChatMessage_get_MessageKind, (setter)ChatMessage_put_MessageKind, nullptr, nullptr },
        { const_cast<char*>("is_received_during_quiet_hours"), (getter)ChatMessage_get_IsReceivedDuringQuietHours, (setter)ChatMessage_put_IsReceivedDuringQuietHours, nullptr, nullptr },
        { const_cast<char*>("is_auto_reply"), (getter)ChatMessage_get_IsAutoReply, (setter)ChatMessage_put_IsAutoReply, nullptr, nullptr },
        { const_cast<char*>("estimated_download_size"), (getter)ChatMessage_get_EstimatedDownloadSize, (setter)ChatMessage_put_EstimatedDownloadSize, nullptr, nullptr },
        { const_cast<char*>("threading_info"), (getter)ChatMessage_get_ThreadingInfo, (setter)ChatMessage_put_ThreadingInfo, nullptr, nullptr },
        { const_cast<char*>("should_suppress_notification"), (getter)ChatMessage_get_ShouldSuppressNotification, (setter)ChatMessage_put_ShouldSuppressNotification, nullptr, nullptr },
        { const_cast<char*>("remote_id"), (getter)ChatMessage_get_RemoteId, (setter)ChatMessage_put_RemoteId, nullptr, nullptr },
        { const_cast<char*>("message_operator_kind"), (getter)ChatMessage_get_MessageOperatorKind, (setter)ChatMessage_put_MessageOperatorKind, nullptr, nullptr },
        { const_cast<char*>("is_reply_disabled"), (getter)ChatMessage_get_IsReplyDisabled, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_sim_message"), (getter)ChatMessage_get_IsSimMessage, nullptr, nullptr, nullptr },
        { const_cast<char*>("recipients_delivery_infos"), (getter)ChatMessage_get_RecipientsDeliveryInfos, nullptr, nullptr, nullptr },
        { const_cast<char*>("sync_id"), (getter)ChatMessage_get_SyncId, (setter)ChatMessage_put_SyncId, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatMessage[] = 
    {
        { Py_tp_new, _new_ChatMessage },
        { Py_tp_dealloc, _dealloc_ChatMessage },
        { Py_tp_methods, _methods_ChatMessage },
        { Py_tp_getset, _getset_ChatMessage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatMessage =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatMessage",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessage
    };

    // ----- ChatMessageAttachment class --------------------
    constexpr const char* const _type_name_ChatMessageAttachment = "ChatMessageAttachment";

    static PyObject* _new_ChatMessageAttachment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 1);

                winrt::Windows::ApplicationModel::Chat::ChatMessageAttachment instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatMessageAttachment(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageAttachment_get_Text(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_Text(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_MimeType(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MimeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_MimeType(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MimeType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_GroupId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.GroupId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_GroupId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.GroupId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_DataStreamReference(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DataStreamReference());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_DataStreamReference(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.DataStreamReference(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_TransferProgress(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransferProgress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_TransferProgress(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.TransferProgress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_Thumbnail(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_Thumbnail(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Thumbnail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_OriginalFileName(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OriginalFileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_OriginalFileName(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.OriginalFileName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ChatMessageAttachment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageAttachment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageAttachment[] = {
        { "_from", (PyCFunction)_from_ChatMessageAttachment, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatMessageAttachment[] = {
        { const_cast<char*>("text"), (getter)ChatMessageAttachment_get_Text, (setter)ChatMessageAttachment_put_Text, nullptr, nullptr },
        { const_cast<char*>("mime_type"), (getter)ChatMessageAttachment_get_MimeType, (setter)ChatMessageAttachment_put_MimeType, nullptr, nullptr },
        { const_cast<char*>("group_id"), (getter)ChatMessageAttachment_get_GroupId, (setter)ChatMessageAttachment_put_GroupId, nullptr, nullptr },
        { const_cast<char*>("data_stream_reference"), (getter)ChatMessageAttachment_get_DataStreamReference, (setter)ChatMessageAttachment_put_DataStreamReference, nullptr, nullptr },
        { const_cast<char*>("transfer_progress"), (getter)ChatMessageAttachment_get_TransferProgress, (setter)ChatMessageAttachment_put_TransferProgress, nullptr, nullptr },
        { const_cast<char*>("thumbnail"), (getter)ChatMessageAttachment_get_Thumbnail, (setter)ChatMessageAttachment_put_Thumbnail, nullptr, nullptr },
        { const_cast<char*>("original_file_name"), (getter)ChatMessageAttachment_get_OriginalFileName, (setter)ChatMessageAttachment_put_OriginalFileName, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatMessageAttachment[] = 
    {
        { Py_tp_new, _new_ChatMessageAttachment },
        { Py_tp_dealloc, _dealloc_ChatMessageAttachment },
        { Py_tp_methods, _methods_ChatMessageAttachment },
        { Py_tp_getset, _getset_ChatMessageAttachment },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatMessageAttachment =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatMessageAttachment",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageAttachment
    };

    // ----- ChatMessageBlocking class --------------------
    constexpr const char* const _type_name_ChatMessageBlocking = "ChatMessageBlocking";

    static PyObject* _new_ChatMessageBlocking(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageBlocking);
        return nullptr;
    }

    static PyObject* ChatMessageBlocking_MarkMessageAsBlockedAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatMessageBlocking::MarkMessageAsBlockedAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageBlocking[] = {
        { "mark_message_as_blocked_async", (PyCFunction)ChatMessageBlocking_MarkMessageAsBlockedAsync, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatMessageBlocking[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatMessageBlocking[] = 
    {
        { Py_tp_new, _new_ChatMessageBlocking },
        { Py_tp_methods, _methods_ChatMessageBlocking },
        { Py_tp_getset, _getset_ChatMessageBlocking },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatMessageBlocking =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatMessageBlocking",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageBlocking
    };

    // ----- ChatMessageChange class --------------------
    constexpr const char* const _type_name_ChatMessageChange = "ChatMessageChange";

    static PyObject* _new_ChatMessageChange(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageChange);
        return nullptr;
    }

    static void _dealloc_ChatMessageChange(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChange* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageChange_get_ChangeType(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageChange_get_Message(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageChange[] = {
        { "_from", (PyCFunction)_from_ChatMessageChange, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatMessageChange[] = {
        { const_cast<char*>("change_type"), (getter)ChatMessageChange_get_ChangeType, nullptr, nullptr, nullptr },
        { const_cast<char*>("message"), (getter)ChatMessageChange_get_Message, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatMessageChange[] = 
    {
        { Py_tp_new, _new_ChatMessageChange },
        { Py_tp_dealloc, _dealloc_ChatMessageChange },
        { Py_tp_methods, _methods_ChatMessageChange },
        { Py_tp_getset, _getset_ChatMessageChange },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatMessageChange =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatMessageChange",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageChange
    };

    // ----- ChatMessageChangeReader class --------------------
    constexpr const char* const _type_name_ChatMessageChangeReader = "ChatMessageChangeReader";

    static PyObject* _new_ChatMessageChangeReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageChangeReader);
        return nullptr;
    }

    static void _dealloc_ChatMessageChangeReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageChangeReader_AcceptChanges(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.AcceptChanges();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageChangeReader_AcceptChangesThrough(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessageChange>(args, 0);

                self->obj.AcceptChangesThrough(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageChangeReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageChangeReader[] = {
        { "accept_changes", (PyCFunction)ChatMessageChangeReader_AcceptChanges, METH_VARARGS, nullptr },
        { "accept_changes_through", (PyCFunction)ChatMessageChangeReader_AcceptChangesThrough, METH_VARARGS, nullptr },
        { "read_batch_async", (PyCFunction)ChatMessageChangeReader_ReadBatchAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ChatMessageChangeReader, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatMessageChangeReader[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatMessageChangeReader[] = 
    {
        { Py_tp_new, _new_ChatMessageChangeReader },
        { Py_tp_dealloc, _dealloc_ChatMessageChangeReader },
        { Py_tp_methods, _methods_ChatMessageChangeReader },
        { Py_tp_getset, _getset_ChatMessageChangeReader },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatMessageChangeReader =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatMessageChangeReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageChangeReader
    };

    // ----- ChatMessageChangeTracker class --------------------
    constexpr const char* const _type_name_ChatMessageChangeTracker = "ChatMessageChangeTracker";

    static PyObject* _new_ChatMessageChangeTracker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageChangeTracker);
        return nullptr;
    }

    static void _dealloc_ChatMessageChangeTracker(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeTracker* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageChangeTracker_Enable(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Enable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageChangeTracker_GetChangeReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetChangeReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageChangeTracker_Reset(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeTracker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageChangeTracker[] = {
        { "enable", (PyCFunction)ChatMessageChangeTracker_Enable, METH_VARARGS, nullptr },
        { "get_change_reader", (PyCFunction)ChatMessageChangeTracker_GetChangeReader, METH_VARARGS, nullptr },
        { "reset", (PyCFunction)ChatMessageChangeTracker_Reset, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ChatMessageChangeTracker, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatMessageChangeTracker[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatMessageChangeTracker[] = 
    {
        { Py_tp_new, _new_ChatMessageChangeTracker },
        { Py_tp_dealloc, _dealloc_ChatMessageChangeTracker },
        { Py_tp_methods, _methods_ChatMessageChangeTracker },
        { Py_tp_getset, _getset_ChatMessageChangeTracker },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatMessageChangeTracker =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatMessageChangeTracker",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeTracker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageChangeTracker
    };

    // ----- ChatMessageChangedDeferral class --------------------
    constexpr const char* const _type_name_ChatMessageChangedDeferral = "ChatMessageChangedDeferral";

    static PyObject* _new_ChatMessageChangedDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageChangedDeferral);
        return nullptr;
    }

    static void _dealloc_ChatMessageChangedDeferral(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageChangedDeferral_Complete(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageChangedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageChangedDeferral[] = {
        { "complete", (PyCFunction)ChatMessageChangedDeferral_Complete, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ChatMessageChangedDeferral, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatMessageChangedDeferral[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatMessageChangedDeferral[] = 
    {
        { Py_tp_new, _new_ChatMessageChangedDeferral },
        { Py_tp_dealloc, _dealloc_ChatMessageChangedDeferral },
        { Py_tp_methods, _methods_ChatMessageChangedDeferral },
        { Py_tp_getset, _getset_ChatMessageChangedDeferral },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatMessageChangedDeferral =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatMessageChangedDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageChangedDeferral
    };

    // ----- ChatMessageChangedEventArgs class --------------------
    constexpr const char* const _type_name_ChatMessageChangedEventArgs = "ChatMessageChangedEventArgs";

    static PyObject* _new_ChatMessageChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_ChatMessageChangedEventArgs(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageChangedEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageChangedEventArgs[] = {
        { "get_deferral", (PyCFunction)ChatMessageChangedEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ChatMessageChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatMessageChangedEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatMessageChangedEventArgs[] = 
    {
        { Py_tp_new, _new_ChatMessageChangedEventArgs },
        { Py_tp_dealloc, _dealloc_ChatMessageChangedEventArgs },
        { Py_tp_methods, _methods_ChatMessageChangedEventArgs },
        { Py_tp_getset, _getset_ChatMessageChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatMessageChangedEventArgs =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatMessageChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageChangedEventArgs
    };

    // ----- ChatMessageManager class --------------------
    constexpr const char* const _type_name_ChatMessageManager = "ChatMessageManager";

    static PyObject* _new_ChatMessageManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageManager);
        return nullptr;
    }

    static PyObject* ChatMessageManager_GetTransportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatMessageManager::GetTransportAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_GetTransportsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatMessageManager::GetTransportsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_RegisterTransportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatMessageManager::RegisterTransportAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatMessageManager::RequestStoreAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_RequestSyncManagerAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatMessageManager::RequestSyncManagerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_ShowComposeSmsMessageAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessage>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatMessageManager::ShowComposeSmsMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_ShowSmsSettings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Chat::ChatMessageManager::ShowSmsSettings();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageManager[] = {
        { "get_transport_async", (PyCFunction)ChatMessageManager_GetTransportAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_transports_async", (PyCFunction)ChatMessageManager_GetTransportsAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "register_transport_async", (PyCFunction)ChatMessageManager_RegisterTransportAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "request_store_async", (PyCFunction)ChatMessageManager_RequestStoreAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "request_sync_manager_async", (PyCFunction)ChatMessageManager_RequestSyncManagerAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "show_compose_sms_message_async", (PyCFunction)ChatMessageManager_ShowComposeSmsMessageAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "show_sms_settings", (PyCFunction)ChatMessageManager_ShowSmsSettings, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatMessageManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatMessageManager[] = 
    {
        { Py_tp_new, _new_ChatMessageManager },
        { Py_tp_methods, _methods_ChatMessageManager },
        { Py_tp_getset, _getset_ChatMessageManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatMessageManager =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatMessageManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageManager
    };

    // ----- ChatMessageNotificationTriggerDetails class --------------------
    constexpr const char* const _type_name_ChatMessageNotificationTriggerDetails = "ChatMessageNotificationTriggerDetails";

    static PyObject* _new_ChatMessageNotificationTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageNotificationTriggerDetails);
        return nullptr;
    }

    static void _dealloc_ChatMessageNotificationTriggerDetails(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageNotificationTriggerDetails_get_ChatMessage(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChatMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageNotificationTriggerDetails_get_ShouldDisplayToast(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShouldDisplayToast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageNotificationTriggerDetails_get_ShouldUpdateActionCenter(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShouldUpdateActionCenter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageNotificationTriggerDetails_get_ShouldUpdateBadge(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShouldUpdateBadge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageNotificationTriggerDetails_get_ShouldUpdateDetailText(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShouldUpdateDetailText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageNotificationTriggerDetails[] = {
        { "_from", (PyCFunction)_from_ChatMessageNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatMessageNotificationTriggerDetails[] = {
        { const_cast<char*>("chat_message"), (getter)ChatMessageNotificationTriggerDetails_get_ChatMessage, nullptr, nullptr, nullptr },
        { const_cast<char*>("should_display_toast"), (getter)ChatMessageNotificationTriggerDetails_get_ShouldDisplayToast, nullptr, nullptr, nullptr },
        { const_cast<char*>("should_update_action_center"), (getter)ChatMessageNotificationTriggerDetails_get_ShouldUpdateActionCenter, nullptr, nullptr, nullptr },
        { const_cast<char*>("should_update_badge"), (getter)ChatMessageNotificationTriggerDetails_get_ShouldUpdateBadge, nullptr, nullptr, nullptr },
        { const_cast<char*>("should_update_detail_text"), (getter)ChatMessageNotificationTriggerDetails_get_ShouldUpdateDetailText, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatMessageNotificationTriggerDetails[] = 
    {
        { Py_tp_new, _new_ChatMessageNotificationTriggerDetails },
        { Py_tp_dealloc, _dealloc_ChatMessageNotificationTriggerDetails },
        { Py_tp_methods, _methods_ChatMessageNotificationTriggerDetails },
        { Py_tp_getset, _getset_ChatMessageNotificationTriggerDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatMessageNotificationTriggerDetails =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatMessageNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageNotificationTriggerDetails
    };

    // ----- ChatMessageReader class --------------------
    constexpr const char* const _type_name_ChatMessageReader = "ChatMessageReader";

    static PyObject* _new_ChatMessageReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageReader);
        return nullptr;
    }

    static void _dealloc_ChatMessageReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.ReadBatchAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageReader[] = {
        { "read_batch_async", (PyCFunction)ChatMessageReader_ReadBatchAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ChatMessageReader, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatMessageReader[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatMessageReader[] = 
    {
        { Py_tp_new, _new_ChatMessageReader },
        { Py_tp_dealloc, _dealloc_ChatMessageReader },
        { Py_tp_methods, _methods_ChatMessageReader },
        { Py_tp_getset, _getset_ChatMessageReader },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatMessageReader =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatMessageReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageReader
    };

    // ----- ChatMessageStore class --------------------
    constexpr const char* const _type_name_ChatMessageStore = "ChatMessageStore";

    static PyObject* _new_ChatMessageStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageStore);
        return nullptr;
    }

    static void _dealloc_ChatMessageStore(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageStore_DeleteMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeleteMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_DownloadMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DownloadMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_ForwardMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(self->obj.ForwardMessageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetConversationAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetConversationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(self->obj.GetConversationAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetConversationFromThreadingInfoAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo>(args, 0);

                return py::convert(self->obj.GetConversationFromThreadingInfoAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetConversationReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConversationReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetConversationReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetMessageByRemoteIdAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetMessageByRemoteIdAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetMessageBySyncIdAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetMessageBySyncIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetMessageReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetMessageReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(self->obj.GetMessageReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetSearchReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatQueryOptions>(args, 0);

                return py::convert(self->obj.GetSearchReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetUnseenCountAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetUnseenCountAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetUnseenCountAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_MarkAsSeenAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.MarkAsSeenAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.MarkAsSeenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_MarkMessageReadAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.MarkMessageReadAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_RetrySendMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RetrySendMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_SaveMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessage>(args, 0);

                return py::convert(self->obj.SaveMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_SendMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessage>(args, 0);

                return py::convert(self->obj.SendMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_TryCancelDownloadMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryCancelDownloadMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_TryCancelSendMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryCancelSendMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_ValidateMessage(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessage>(args, 0);

                return py::convert(self->obj.ValidateMessage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_get_ChangeTracker(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeTracker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_add_MessageChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Chat::ChatMessageStore, winrt::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs>>(arg);

            return py::convert(self->obj.MessageChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_remove_MessageChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_add_StoreChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Chat::ChatMessageStore, winrt::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs>>(arg);

            return py::convert(self->obj.StoreChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_remove_StoreChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StoreChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageStore[] = {
        { "delete_message_async", (PyCFunction)ChatMessageStore_DeleteMessageAsync, METH_VARARGS, nullptr },
        { "download_message_async", (PyCFunction)ChatMessageStore_DownloadMessageAsync, METH_VARARGS, nullptr },
        { "forward_message_async", (PyCFunction)ChatMessageStore_ForwardMessageAsync, METH_VARARGS, nullptr },
        { "get_conversation_async", (PyCFunction)ChatMessageStore_GetConversationAsync, METH_VARARGS, nullptr },
        { "get_conversation_from_threading_info_async", (PyCFunction)ChatMessageStore_GetConversationFromThreadingInfoAsync, METH_VARARGS, nullptr },
        { "get_conversation_reader", (PyCFunction)ChatMessageStore_GetConversationReader, METH_VARARGS, nullptr },
        { "get_message_async", (PyCFunction)ChatMessageStore_GetMessageAsync, METH_VARARGS, nullptr },
        { "get_message_by_remote_id_async", (PyCFunction)ChatMessageStore_GetMessageByRemoteIdAsync, METH_VARARGS, nullptr },
        { "get_message_by_sync_id_async", (PyCFunction)ChatMessageStore_GetMessageBySyncIdAsync, METH_VARARGS, nullptr },
        { "get_message_reader", (PyCFunction)ChatMessageStore_GetMessageReader, METH_VARARGS, nullptr },
        { "get_search_reader", (PyCFunction)ChatMessageStore_GetSearchReader, METH_VARARGS, nullptr },
        { "get_unseen_count_async", (PyCFunction)ChatMessageStore_GetUnseenCountAsync, METH_VARARGS, nullptr },
        { "mark_as_seen_async", (PyCFunction)ChatMessageStore_MarkAsSeenAsync, METH_VARARGS, nullptr },
        { "mark_message_read_async", (PyCFunction)ChatMessageStore_MarkMessageReadAsync, METH_VARARGS, nullptr },
        { "retry_send_message_async", (PyCFunction)ChatMessageStore_RetrySendMessageAsync, METH_VARARGS, nullptr },
        { "save_message_async", (PyCFunction)ChatMessageStore_SaveMessageAsync, METH_VARARGS, nullptr },
        { "send_message_async", (PyCFunction)ChatMessageStore_SendMessageAsync, METH_VARARGS, nullptr },
        { "try_cancel_download_message_async", (PyCFunction)ChatMessageStore_TryCancelDownloadMessageAsync, METH_VARARGS, nullptr },
        { "try_cancel_send_message_async", (PyCFunction)ChatMessageStore_TryCancelSendMessageAsync, METH_VARARGS, nullptr },
        { "validate_message", (PyCFunction)ChatMessageStore_ValidateMessage, METH_VARARGS, nullptr },
        { "add_message_changed", (PyCFunction)ChatMessageStore_add_MessageChanged, METH_O, nullptr },
        { "remove_message_changed", (PyCFunction)ChatMessageStore_remove_MessageChanged, METH_O, nullptr },
        { "add_store_changed", (PyCFunction)ChatMessageStore_add_StoreChanged, METH_O, nullptr },
        { "remove_store_changed", (PyCFunction)ChatMessageStore_remove_StoreChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ChatMessageStore, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatMessageStore[] = {
        { const_cast<char*>("change_tracker"), (getter)ChatMessageStore_get_ChangeTracker, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatMessageStore[] = 
    {
        { Py_tp_new, _new_ChatMessageStore },
        { Py_tp_dealloc, _dealloc_ChatMessageStore },
        { Py_tp_methods, _methods_ChatMessageStore },
        { Py_tp_getset, _getset_ChatMessageStore },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatMessageStore =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatMessageStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageStore
    };

    // ----- ChatMessageStoreChangedEventArgs class --------------------
    constexpr const char* const _type_name_ChatMessageStoreChangedEventArgs = "ChatMessageStoreChangedEventArgs";

    static PyObject* _new_ChatMessageStoreChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageStoreChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_ChatMessageStoreChangedEventArgs(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageStoreChangedEventArgs_get_Id(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageStoreChangedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageStoreChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageStoreChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_ChatMessageStoreChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatMessageStoreChangedEventArgs[] = {
        { const_cast<char*>("id"), (getter)ChatMessageStoreChangedEventArgs_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)ChatMessageStoreChangedEventArgs_get_Kind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatMessageStoreChangedEventArgs[] = 
    {
        { Py_tp_new, _new_ChatMessageStoreChangedEventArgs },
        { Py_tp_dealloc, _dealloc_ChatMessageStoreChangedEventArgs },
        { Py_tp_methods, _methods_ChatMessageStoreChangedEventArgs },
        { Py_tp_getset, _getset_ChatMessageStoreChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatMessageStoreChangedEventArgs =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatMessageStoreChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageStoreChangedEventArgs
    };

    // ----- ChatMessageTransport class --------------------
    constexpr const char* const _type_name_ChatMessageTransport = "ChatMessageTransport";

    static PyObject* _new_ChatMessageTransport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageTransport);
        return nullptr;
    }

    static void _dealloc_ChatMessageTransport(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageTransport_RequestSetAsNotificationProviderAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestSetAsNotificationProviderAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_IsActive(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_IsAppSetAsNotificationProvider(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAppSetAsNotificationProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_TransportFriendlyName(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportFriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_TransportId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_Configuration(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_TransportKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageTransport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageTransport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageTransport[] = {
        { "request_set_as_notification_provider_async", (PyCFunction)ChatMessageTransport_RequestSetAsNotificationProviderAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ChatMessageTransport, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatMessageTransport[] = {
        { const_cast<char*>("is_active"), (getter)ChatMessageTransport_get_IsActive, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_app_set_as_notification_provider"), (getter)ChatMessageTransport_get_IsAppSetAsNotificationProvider, nullptr, nullptr, nullptr },
        { const_cast<char*>("transport_friendly_name"), (getter)ChatMessageTransport_get_TransportFriendlyName, nullptr, nullptr, nullptr },
        { const_cast<char*>("transport_id"), (getter)ChatMessageTransport_get_TransportId, nullptr, nullptr, nullptr },
        { const_cast<char*>("configuration"), (getter)ChatMessageTransport_get_Configuration, nullptr, nullptr, nullptr },
        { const_cast<char*>("transport_kind"), (getter)ChatMessageTransport_get_TransportKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatMessageTransport[] = 
    {
        { Py_tp_new, _new_ChatMessageTransport },
        { Py_tp_dealloc, _dealloc_ChatMessageTransport },
        { Py_tp_methods, _methods_ChatMessageTransport },
        { Py_tp_getset, _getset_ChatMessageTransport },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatMessageTransport =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatMessageTransport",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageTransport
    };

    // ----- ChatMessageTransportConfiguration class --------------------
    constexpr const char* const _type_name_ChatMessageTransportConfiguration = "ChatMessageTransportConfiguration";

    static PyObject* _new_ChatMessageTransportConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageTransportConfiguration);
        return nullptr;
    }

    static void _dealloc_ChatMessageTransportConfiguration(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageTransportConfiguration_get_ExtendedProperties(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransportConfiguration_get_MaxAttachmentCount(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxAttachmentCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransportConfiguration_get_MaxMessageSizeInKilobytes(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxMessageSizeInKilobytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransportConfiguration_get_MaxRecipientCount(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxRecipientCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransportConfiguration_get_SupportedVideoFormat(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedVideoFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageTransportConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageTransportConfiguration[] = {
        { "_from", (PyCFunction)_from_ChatMessageTransportConfiguration, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatMessageTransportConfiguration[] = {
        { const_cast<char*>("extended_properties"), (getter)ChatMessageTransportConfiguration_get_ExtendedProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_attachment_count"), (getter)ChatMessageTransportConfiguration_get_MaxAttachmentCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_message_size_in_kilobytes"), (getter)ChatMessageTransportConfiguration_get_MaxMessageSizeInKilobytes, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_recipient_count"), (getter)ChatMessageTransportConfiguration_get_MaxRecipientCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_video_format"), (getter)ChatMessageTransportConfiguration_get_SupportedVideoFormat, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatMessageTransportConfiguration[] = 
    {
        { Py_tp_new, _new_ChatMessageTransportConfiguration },
        { Py_tp_dealloc, _dealloc_ChatMessageTransportConfiguration },
        { Py_tp_methods, _methods_ChatMessageTransportConfiguration },
        { Py_tp_getset, _getset_ChatMessageTransportConfiguration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatMessageTransportConfiguration =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatMessageTransportConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageTransportConfiguration
    };

    // ----- ChatMessageValidationResult class --------------------
    constexpr const char* const _type_name_ChatMessageValidationResult = "ChatMessageValidationResult";

    static PyObject* _new_ChatMessageValidationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageValidationResult);
        return nullptr;
    }

    static void _dealloc_ChatMessageValidationResult(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageValidationResult_get_MaxPartCount(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPartCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageValidationResult_get_PartCount(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PartCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageValidationResult_get_RemainingCharacterCountInPart(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemainingCharacterCountInPart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageValidationResult_get_Status(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageValidationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageValidationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageValidationResult[] = {
        { "_from", (PyCFunction)_from_ChatMessageValidationResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatMessageValidationResult[] = {
        { const_cast<char*>("max_part_count"), (getter)ChatMessageValidationResult_get_MaxPartCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("part_count"), (getter)ChatMessageValidationResult_get_PartCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("remaining_character_count_in_part"), (getter)ChatMessageValidationResult_get_RemainingCharacterCountInPart, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)ChatMessageValidationResult_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatMessageValidationResult[] = 
    {
        { Py_tp_new, _new_ChatMessageValidationResult },
        { Py_tp_dealloc, _dealloc_ChatMessageValidationResult },
        { Py_tp_methods, _methods_ChatMessageValidationResult },
        { Py_tp_getset, _getset_ChatMessageValidationResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatMessageValidationResult =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatMessageValidationResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageValidationResult
    };

    // ----- ChatQueryOptions class --------------------
    constexpr const char* const _type_name_ChatQueryOptions = "ChatQueryOptions";

    static PyObject* _new_ChatQueryOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Chat::ChatQueryOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatQueryOptions(py::wrapper::Windows::ApplicationModel::Chat::ChatQueryOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatQueryOptions_get_SearchString(py::wrapper::Windows::ApplicationModel::Chat::ChatQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SearchString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatQueryOptions_put_SearchString(py::wrapper::Windows::ApplicationModel::Chat::ChatQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SearchString(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ChatQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatQueryOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatQueryOptions[] = {
        { "_from", (PyCFunction)_from_ChatQueryOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatQueryOptions[] = {
        { const_cast<char*>("search_string"), (getter)ChatQueryOptions_get_SearchString, (setter)ChatQueryOptions_put_SearchString, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatQueryOptions[] = 
    {
        { Py_tp_new, _new_ChatQueryOptions },
        { Py_tp_dealloc, _dealloc_ChatQueryOptions },
        { Py_tp_methods, _methods_ChatQueryOptions },
        { Py_tp_getset, _getset_ChatQueryOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatQueryOptions =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatQueryOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatQueryOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatQueryOptions
    };

    // ----- ChatRecipientDeliveryInfo class --------------------
    constexpr const char* const _type_name_ChatRecipientDeliveryInfo = "ChatRecipientDeliveryInfo";

    static PyObject* _new_ChatRecipientDeliveryInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatRecipientDeliveryInfo(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatRecipientDeliveryInfo_get_TransportAddress(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatRecipientDeliveryInfo_put_TransportAddress(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TransportAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_ReadTime(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReadTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatRecipientDeliveryInfo_put_ReadTime(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ReadTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_DeliveryTime(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeliveryTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatRecipientDeliveryInfo_put_DeliveryTime(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.DeliveryTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_IsErrorPermanent(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsErrorPermanent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_Status(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_TransportErrorCode(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_TransportErrorCodeCategory(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportErrorCodeCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_TransportInterpretedErrorCode(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportInterpretedErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatRecipientDeliveryInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatRecipientDeliveryInfo[] = {
        { "_from", (PyCFunction)_from_ChatRecipientDeliveryInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatRecipientDeliveryInfo[] = {
        { const_cast<char*>("transport_address"), (getter)ChatRecipientDeliveryInfo_get_TransportAddress, (setter)ChatRecipientDeliveryInfo_put_TransportAddress, nullptr, nullptr },
        { const_cast<char*>("read_time"), (getter)ChatRecipientDeliveryInfo_get_ReadTime, (setter)ChatRecipientDeliveryInfo_put_ReadTime, nullptr, nullptr },
        { const_cast<char*>("delivery_time"), (getter)ChatRecipientDeliveryInfo_get_DeliveryTime, (setter)ChatRecipientDeliveryInfo_put_DeliveryTime, nullptr, nullptr },
        { const_cast<char*>("is_error_permanent"), (getter)ChatRecipientDeliveryInfo_get_IsErrorPermanent, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)ChatRecipientDeliveryInfo_get_Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("transport_error_code"), (getter)ChatRecipientDeliveryInfo_get_TransportErrorCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("transport_error_code_category"), (getter)ChatRecipientDeliveryInfo_get_TransportErrorCodeCategory, nullptr, nullptr, nullptr },
        { const_cast<char*>("transport_interpreted_error_code"), (getter)ChatRecipientDeliveryInfo_get_TransportInterpretedErrorCode, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatRecipientDeliveryInfo[] = 
    {
        { Py_tp_new, _new_ChatRecipientDeliveryInfo },
        { Py_tp_dealloc, _dealloc_ChatRecipientDeliveryInfo },
        { Py_tp_methods, _methods_ChatRecipientDeliveryInfo },
        { Py_tp_getset, _getset_ChatRecipientDeliveryInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatRecipientDeliveryInfo =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatRecipientDeliveryInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatRecipientDeliveryInfo
    };

    // ----- ChatSearchReader class --------------------
    constexpr const char* const _type_name_ChatSearchReader = "ChatSearchReader";

    static PyObject* _new_ChatSearchReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatSearchReader);
        return nullptr;
    }

    static void _dealloc_ChatSearchReader(py::wrapper::Windows::ApplicationModel::Chat::ChatSearchReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatSearchReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatSearchReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.ReadBatchAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ChatSearchReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatSearchReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatSearchReader[] = {
        { "read_batch_async", (PyCFunction)ChatSearchReader_ReadBatchAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ChatSearchReader, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatSearchReader[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatSearchReader[] = 
    {
        { Py_tp_new, _new_ChatSearchReader },
        { Py_tp_dealloc, _dealloc_ChatSearchReader },
        { Py_tp_methods, _methods_ChatSearchReader },
        { Py_tp_getset, _getset_ChatSearchReader },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatSearchReader =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatSearchReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatSearchReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatSearchReader
    };

    // ----- ChatSyncConfiguration class --------------------
    constexpr const char* const _type_name_ChatSyncConfiguration = "ChatSyncConfiguration";

    static PyObject* _new_ChatSyncConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatSyncConfiguration);
        return nullptr;
    }

    static void _dealloc_ChatSyncConfiguration(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatSyncConfiguration_get_RestoreHistorySpan(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RestoreHistorySpan());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatSyncConfiguration_put_RestoreHistorySpan(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatRestoreHistorySpan>(arg);

            self->obj.RestoreHistorySpan(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatSyncConfiguration_get_IsSyncEnabled(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSyncEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatSyncConfiguration_put_IsSyncEnabled(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSyncEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ChatSyncConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatSyncConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatSyncConfiguration[] = {
        { "_from", (PyCFunction)_from_ChatSyncConfiguration, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatSyncConfiguration[] = {
        { const_cast<char*>("restore_history_span"), (getter)ChatSyncConfiguration_get_RestoreHistorySpan, (setter)ChatSyncConfiguration_put_RestoreHistorySpan, nullptr, nullptr },
        { const_cast<char*>("is_sync_enabled"), (getter)ChatSyncConfiguration_get_IsSyncEnabled, (setter)ChatSyncConfiguration_put_IsSyncEnabled, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatSyncConfiguration[] = 
    {
        { Py_tp_new, _new_ChatSyncConfiguration },
        { Py_tp_dealloc, _dealloc_ChatSyncConfiguration },
        { Py_tp_methods, _methods_ChatSyncConfiguration },
        { Py_tp_getset, _getset_ChatSyncConfiguration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatSyncConfiguration =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatSyncConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatSyncConfiguration
    };

    // ----- ChatSyncManager class --------------------
    constexpr const char* const _type_name_ChatSyncManager = "ChatSyncManager";

    static PyObject* _new_ChatSyncManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatSyncManager);
        return nullptr;
    }

    static void _dealloc_ChatSyncManager(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatSyncManager_AssociateAccountAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Credentials::WebAccount>(args, 0);

                return py::convert(self->obj.AssociateAccountAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatSyncManager_IsAccountAssociated(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Credentials::WebAccount>(args, 0);

                return py::convert(self->obj.IsAccountAssociated(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatSyncManager_SetConfigurationAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatSyncConfiguration>(args, 0);

                return py::convert(self->obj.SetConfigurationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatSyncManager_StartSync(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.StartSync();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatSyncManager_UnassociateAccountAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.UnassociateAccountAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatSyncManager_get_Configuration(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatSyncManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatSyncManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatSyncManager[] = {
        { "associate_account_async", (PyCFunction)ChatSyncManager_AssociateAccountAsync, METH_VARARGS, nullptr },
        { "is_account_associated", (PyCFunction)ChatSyncManager_IsAccountAssociated, METH_VARARGS, nullptr },
        { "set_configuration_async", (PyCFunction)ChatSyncManager_SetConfigurationAsync, METH_VARARGS, nullptr },
        { "start_sync", (PyCFunction)ChatSyncManager_StartSync, METH_VARARGS, nullptr },
        { "unassociate_account_async", (PyCFunction)ChatSyncManager_UnassociateAccountAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ChatSyncManager, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatSyncManager[] = {
        { const_cast<char*>("configuration"), (getter)ChatSyncManager_get_Configuration, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatSyncManager[] = 
    {
        { Py_tp_new, _new_ChatSyncManager },
        { Py_tp_dealloc, _dealloc_ChatSyncManager },
        { Py_tp_methods, _methods_ChatSyncManager },
        { Py_tp_getset, _getset_ChatSyncManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatSyncManager =
    {
        "_winrt_Windows_ApplicationModel_Chat.ChatSyncManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatSyncManager
    };

    // ----- RcsEndUserMessage class --------------------
    constexpr const char* const _type_name_RcsEndUserMessage = "RcsEndUserMessage";

    static PyObject* _new_RcsEndUserMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RcsEndUserMessage);
        return nullptr;
    }

    static void _dealloc_RcsEndUserMessage(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RcsEndUserMessage_SendResponseAsync(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>(args, 0);

                return py::convert(self->obj.SendResponseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_SendResponseWithPinAsync(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.SendResponseWithPinAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_get_Actions(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Actions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_get_IsPinRequired(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPinRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_get_Text(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_get_Title(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_get_TransportId(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RcsEndUserMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessage[] = {
        { "send_response_async", (PyCFunction)RcsEndUserMessage_SendResponseAsync, METH_VARARGS, nullptr },
        { "send_response_with_pin_async", (PyCFunction)RcsEndUserMessage_SendResponseWithPinAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_RcsEndUserMessage, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RcsEndUserMessage[] = {
        { const_cast<char*>("actions"), (getter)RcsEndUserMessage_get_Actions, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_pin_required"), (getter)RcsEndUserMessage_get_IsPinRequired, nullptr, nullptr, nullptr },
        { const_cast<char*>("text"), (getter)RcsEndUserMessage_get_Text, nullptr, nullptr, nullptr },
        { const_cast<char*>("title"), (getter)RcsEndUserMessage_get_Title, nullptr, nullptr, nullptr },
        { const_cast<char*>("transport_id"), (getter)RcsEndUserMessage_get_TransportId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RcsEndUserMessage[] = 
    {
        { Py_tp_new, _new_RcsEndUserMessage },
        { Py_tp_dealloc, _dealloc_RcsEndUserMessage },
        { Py_tp_methods, _methods_RcsEndUserMessage },
        { Py_tp_getset, _getset_RcsEndUserMessage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RcsEndUserMessage =
    {
        "_winrt_Windows_ApplicationModel_Chat.RcsEndUserMessage",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessage
    };

    // ----- RcsEndUserMessageAction class --------------------
    constexpr const char* const _type_name_RcsEndUserMessageAction = "RcsEndUserMessageAction";

    static PyObject* _new_RcsEndUserMessageAction(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RcsEndUserMessageAction);
        return nullptr;
    }

    static void _dealloc_RcsEndUserMessageAction(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAction* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RcsEndUserMessageAction_get_Label(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAction* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RcsEndUserMessageAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessageAction[] = {
        { "_from", (PyCFunction)_from_RcsEndUserMessageAction, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RcsEndUserMessageAction[] = {
        { const_cast<char*>("label"), (getter)RcsEndUserMessageAction_get_Label, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RcsEndUserMessageAction[] = 
    {
        { Py_tp_new, _new_RcsEndUserMessageAction },
        { Py_tp_dealloc, _dealloc_RcsEndUserMessageAction },
        { Py_tp_methods, _methods_RcsEndUserMessageAction },
        { Py_tp_getset, _getset_RcsEndUserMessageAction },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RcsEndUserMessageAction =
    {
        "_winrt_Windows_ApplicationModel_Chat.RcsEndUserMessageAction",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessageAction
    };

    // ----- RcsEndUserMessageAvailableEventArgs class --------------------
    constexpr const char* const _type_name_RcsEndUserMessageAvailableEventArgs = "RcsEndUserMessageAvailableEventArgs";

    static PyObject* _new_RcsEndUserMessageAvailableEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RcsEndUserMessageAvailableEventArgs);
        return nullptr;
    }

    static void _dealloc_RcsEndUserMessageAvailableEventArgs(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RcsEndUserMessageAvailableEventArgs_get_IsMessageAvailable(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsMessageAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessageAvailableEventArgs_get_Message(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RcsEndUserMessageAvailableEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessageAvailableEventArgs[] = {
        { "_from", (PyCFunction)_from_RcsEndUserMessageAvailableEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RcsEndUserMessageAvailableEventArgs[] = {
        { const_cast<char*>("is_message_available"), (getter)RcsEndUserMessageAvailableEventArgs_get_IsMessageAvailable, nullptr, nullptr, nullptr },
        { const_cast<char*>("message"), (getter)RcsEndUserMessageAvailableEventArgs_get_Message, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RcsEndUserMessageAvailableEventArgs[] = 
    {
        { Py_tp_new, _new_RcsEndUserMessageAvailableEventArgs },
        { Py_tp_dealloc, _dealloc_RcsEndUserMessageAvailableEventArgs },
        { Py_tp_methods, _methods_RcsEndUserMessageAvailableEventArgs },
        { Py_tp_getset, _getset_RcsEndUserMessageAvailableEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RcsEndUserMessageAvailableEventArgs =
    {
        "_winrt_Windows_ApplicationModel_Chat.RcsEndUserMessageAvailableEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessageAvailableEventArgs
    };

    // ----- RcsEndUserMessageAvailableTriggerDetails class --------------------
    constexpr const char* const _type_name_RcsEndUserMessageAvailableTriggerDetails = "RcsEndUserMessageAvailableTriggerDetails";

    static PyObject* _new_RcsEndUserMessageAvailableTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RcsEndUserMessageAvailableTriggerDetails);
        return nullptr;
    }

    static void _dealloc_RcsEndUserMessageAvailableTriggerDetails(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RcsEndUserMessageAvailableTriggerDetails_get_Text(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessageAvailableTriggerDetails_get_Title(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RcsEndUserMessageAvailableTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessageAvailableTriggerDetails[] = {
        { "_from", (PyCFunction)_from_RcsEndUserMessageAvailableTriggerDetails, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RcsEndUserMessageAvailableTriggerDetails[] = {
        { const_cast<char*>("text"), (getter)RcsEndUserMessageAvailableTriggerDetails_get_Text, nullptr, nullptr, nullptr },
        { const_cast<char*>("title"), (getter)RcsEndUserMessageAvailableTriggerDetails_get_Title, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RcsEndUserMessageAvailableTriggerDetails[] = 
    {
        { Py_tp_new, _new_RcsEndUserMessageAvailableTriggerDetails },
        { Py_tp_dealloc, _dealloc_RcsEndUserMessageAvailableTriggerDetails },
        { Py_tp_methods, _methods_RcsEndUserMessageAvailableTriggerDetails },
        { Py_tp_getset, _getset_RcsEndUserMessageAvailableTriggerDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RcsEndUserMessageAvailableTriggerDetails =
    {
        "_winrt_Windows_ApplicationModel_Chat.RcsEndUserMessageAvailableTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessageAvailableTriggerDetails
    };

    // ----- RcsEndUserMessageManager class --------------------
    constexpr const char* const _type_name_RcsEndUserMessageManager = "RcsEndUserMessageManager";

    static PyObject* _new_RcsEndUserMessageManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RcsEndUserMessageManager);
        return nullptr;
    }

    static void _dealloc_RcsEndUserMessageManager(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RcsEndUserMessageManager_add_MessageAvailableChanged(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageManager, winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs>>(arg);

            return py::convert(self->obj.MessageAvailableChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessageManager_remove_MessageAvailableChanged(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageAvailableChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RcsEndUserMessageManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessageManager[] = {
        { "add_message_available_changed", (PyCFunction)RcsEndUserMessageManager_add_MessageAvailableChanged, METH_O, nullptr },
        { "remove_message_available_changed", (PyCFunction)RcsEndUserMessageManager_remove_MessageAvailableChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_RcsEndUserMessageManager, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RcsEndUserMessageManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_RcsEndUserMessageManager[] = 
    {
        { Py_tp_new, _new_RcsEndUserMessageManager },
        { Py_tp_dealloc, _dealloc_RcsEndUserMessageManager },
        { Py_tp_methods, _methods_RcsEndUserMessageManager },
        { Py_tp_getset, _getset_RcsEndUserMessageManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RcsEndUserMessageManager =
    {
        "_winrt_Windows_ApplicationModel_Chat.RcsEndUserMessageManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessageManager
    };

    // ----- RcsManager class --------------------
    constexpr const char* const _type_name_RcsManager = "RcsManager";

    static PyObject* _new_RcsManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RcsManager);
        return nullptr;
    }

    static PyObject* RcsManager_GetEndUserMessageManager(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Chat::RcsManager::GetEndUserMessageManager());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsManager_GetTransportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Chat::RcsManager::GetTransportAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsManager_GetTransportsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Chat::RcsManager::GetTransportsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsManager_LeaveConversationAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatConversation>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Chat::RcsManager::LeaveConversationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsManager_add_TransportListChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::ApplicationModel::Chat::RcsManager::TransportListChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsManager_remove_TransportListChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::ApplicationModel::Chat::RcsManager::TransportListChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsManager[] = {
        { "get_end_user_message_manager", (PyCFunction)RcsManager_GetEndUserMessageManager, METH_VARARGS | METH_STATIC, nullptr },
        { "get_transport_async", (PyCFunction)RcsManager_GetTransportAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_transports_async", (PyCFunction)RcsManager_GetTransportsAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "leave_conversation_async", (PyCFunction)RcsManager_LeaveConversationAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "add_transport_list_changed", (PyCFunction)RcsManager_add_TransportListChanged, METH_O | METH_STATIC, nullptr },
        { "remove_transport_list_changed", (PyCFunction)RcsManager_remove_TransportListChanged, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RcsManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_RcsManager[] = 
    {
        { Py_tp_new, _new_RcsManager },
        { Py_tp_methods, _methods_RcsManager },
        { Py_tp_getset, _getset_RcsManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RcsManager =
    {
        "_winrt_Windows_ApplicationModel_Chat.RcsManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsManager
    };

    // ----- RcsServiceKindSupportedChangedEventArgs class --------------------
    constexpr const char* const _type_name_RcsServiceKindSupportedChangedEventArgs = "RcsServiceKindSupportedChangedEventArgs";

    static PyObject* _new_RcsServiceKindSupportedChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RcsServiceKindSupportedChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_RcsServiceKindSupportedChangedEventArgs(py::wrapper::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RcsServiceKindSupportedChangedEventArgs_get_ServiceKind(py::wrapper::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RcsServiceKindSupportedChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsServiceKindSupportedChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_RcsServiceKindSupportedChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RcsServiceKindSupportedChangedEventArgs[] = {
        { const_cast<char*>("service_kind"), (getter)RcsServiceKindSupportedChangedEventArgs_get_ServiceKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RcsServiceKindSupportedChangedEventArgs[] = 
    {
        { Py_tp_new, _new_RcsServiceKindSupportedChangedEventArgs },
        { Py_tp_dealloc, _dealloc_RcsServiceKindSupportedChangedEventArgs },
        { Py_tp_methods, _methods_RcsServiceKindSupportedChangedEventArgs },
        { Py_tp_getset, _getset_RcsServiceKindSupportedChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RcsServiceKindSupportedChangedEventArgs =
    {
        "_winrt_Windows_ApplicationModel_Chat.RcsServiceKindSupportedChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsServiceKindSupportedChangedEventArgs
    };

    // ----- RcsTransport class --------------------
    constexpr const char* const _type_name_RcsTransport = "RcsTransport";

    static PyObject* _new_RcsTransport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RcsTransport);
        return nullptr;
    }

    static void _dealloc_RcsTransport(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RcsTransport_IsServiceKindSupported(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::RcsServiceKind>(args, 0);

                return py::convert(self->obj.IsServiceKindSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsTransport_IsStoreAndForwardEnabled(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::RcsServiceKind>(args, 0);

                return py::convert(self->obj.IsStoreAndForwardEnabled(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsTransport_get_Configuration(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_get_ExtendedProperties(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_get_IsActive(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_get_TransportFriendlyName(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportFriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_get_TransportId(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_add_ServiceKindSupportedChanged(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Chat::RcsTransport, winrt::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs>>(arg);

            return py::convert(self->obj.ServiceKindSupportedChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_remove_ServiceKindSupportedChanged(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ServiceKindSupportedChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RcsTransport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsTransport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsTransport[] = {
        { "is_service_kind_supported", (PyCFunction)RcsTransport_IsServiceKindSupported, METH_VARARGS, nullptr },
        { "is_store_and_forward_enabled", (PyCFunction)RcsTransport_IsStoreAndForwardEnabled, METH_VARARGS, nullptr },
        { "add_service_kind_supported_changed", (PyCFunction)RcsTransport_add_ServiceKindSupportedChanged, METH_O, nullptr },
        { "remove_service_kind_supported_changed", (PyCFunction)RcsTransport_remove_ServiceKindSupportedChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_RcsTransport, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RcsTransport[] = {
        { const_cast<char*>("configuration"), (getter)RcsTransport_get_Configuration, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_properties"), (getter)RcsTransport_get_ExtendedProperties, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_active"), (getter)RcsTransport_get_IsActive, nullptr, nullptr, nullptr },
        { const_cast<char*>("transport_friendly_name"), (getter)RcsTransport_get_TransportFriendlyName, nullptr, nullptr, nullptr },
        { const_cast<char*>("transport_id"), (getter)RcsTransport_get_TransportId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RcsTransport[] = 
    {
        { Py_tp_new, _new_RcsTransport },
        { Py_tp_dealloc, _dealloc_RcsTransport },
        { Py_tp_methods, _methods_RcsTransport },
        { Py_tp_getset, _getset_RcsTransport },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RcsTransport =
    {
        "_winrt_Windows_ApplicationModel_Chat.RcsTransport",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsTransport
    };

    // ----- RcsTransportConfiguration class --------------------
    constexpr const char* const _type_name_RcsTransportConfiguration = "RcsTransportConfiguration";

    static PyObject* _new_RcsTransportConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RcsTransportConfiguration);
        return nullptr;
    }

    static void _dealloc_RcsTransportConfiguration(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RcsTransportConfiguration_get_MaxAttachmentCount(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxAttachmentCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransportConfiguration_get_MaxFileSizeInKilobytes(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxFileSizeInKilobytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransportConfiguration_get_MaxGroupMessageSizeInKilobytes(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxGroupMessageSizeInKilobytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransportConfiguration_get_MaxMessageSizeInKilobytes(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxMessageSizeInKilobytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransportConfiguration_get_MaxRecipientCount(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxRecipientCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransportConfiguration_get_WarningFileSizeInKilobytes(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WarningFileSizeInKilobytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RcsTransportConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsTransportConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsTransportConfiguration[] = {
        { "_from", (PyCFunction)_from_RcsTransportConfiguration, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RcsTransportConfiguration[] = {
        { const_cast<char*>("max_attachment_count"), (getter)RcsTransportConfiguration_get_MaxAttachmentCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_file_size_in_kilobytes"), (getter)RcsTransportConfiguration_get_MaxFileSizeInKilobytes, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_group_message_size_in_kilobytes"), (getter)RcsTransportConfiguration_get_MaxGroupMessageSizeInKilobytes, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_message_size_in_kilobytes"), (getter)RcsTransportConfiguration_get_MaxMessageSizeInKilobytes, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_recipient_count"), (getter)RcsTransportConfiguration_get_MaxRecipientCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("warning_file_size_in_kilobytes"), (getter)RcsTransportConfiguration_get_WarningFileSizeInKilobytes, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RcsTransportConfiguration[] = 
    {
        { Py_tp_new, _new_RcsTransportConfiguration },
        { Py_tp_dealloc, _dealloc_RcsTransportConfiguration },
        { Py_tp_methods, _methods_RcsTransportConfiguration },
        { Py_tp_getset, _getset_RcsTransportConfiguration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RcsTransportConfiguration =
    {
        "_winrt_Windows_ApplicationModel_Chat.RcsTransportConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsTransportConfiguration
    };

    // ----- RemoteParticipantComposingChangedEventArgs class --------------------
    constexpr const char* const _type_name_RemoteParticipantComposingChangedEventArgs = "RemoteParticipantComposingChangedEventArgs";

    static PyObject* _new_RemoteParticipantComposingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RemoteParticipantComposingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_RemoteParticipantComposingChangedEventArgs(py::wrapper::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RemoteParticipantComposingChangedEventArgs_get_IsComposing(py::wrapper::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsComposing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteParticipantComposingChangedEventArgs_get_ParticipantAddress(py::wrapper::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ParticipantAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteParticipantComposingChangedEventArgs_get_TransportId(py::wrapper::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RemoteParticipantComposingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteParticipantComposingChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_RemoteParticipantComposingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RemoteParticipantComposingChangedEventArgs[] = {
        { const_cast<char*>("is_composing"), (getter)RemoteParticipantComposingChangedEventArgs_get_IsComposing, nullptr, nullptr, nullptr },
        { const_cast<char*>("participant_address"), (getter)RemoteParticipantComposingChangedEventArgs_get_ParticipantAddress, nullptr, nullptr, nullptr },
        { const_cast<char*>("transport_id"), (getter)RemoteParticipantComposingChangedEventArgs_get_TransportId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RemoteParticipantComposingChangedEventArgs[] = 
    {
        { Py_tp_new, _new_RemoteParticipantComposingChangedEventArgs },
        { Py_tp_dealloc, _dealloc_RemoteParticipantComposingChangedEventArgs },
        { Py_tp_methods, _methods_RemoteParticipantComposingChangedEventArgs },
        { Py_tp_getset, _getset_RemoteParticipantComposingChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RemoteParticipantComposingChangedEventArgs =
    {
        "_winrt_Windows_ApplicationModel_Chat.RemoteParticipantComposingChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteParticipantComposingChangedEventArgs
    };

    // ----- IChatItem interface --------------------
    constexpr const char* const _type_name_IChatItem = "IChatItem";

    static PyObject* _new_IChatItem(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IChatItem);
        return nullptr;
    }

    static void _dealloc_IChatItem(py::wrapper::Windows::ApplicationModel::Chat::IChatItem* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IChatItem_get_ItemKind(py::wrapper::Windows::ApplicationModel::Chat::IChatItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ItemKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IChatItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::IChatItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IChatItem[] = {
        { "_from", (PyCFunction)_from_IChatItem, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IChatItem[] = {
        { const_cast<char*>("item_kind"), (getter)IChatItem_get_ItemKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IChatItem[] = 
    {
        { Py_tp_new, _new_IChatItem },
        { Py_tp_dealloc, _dealloc_IChatItem },
        { Py_tp_methods, _methods_IChatItem },
        { Py_tp_getset, _getset_IChatItem },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IChatItem =
    {
        "_winrt_Windows_ApplicationModel_Chat.IChatItem",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::IChatItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IChatItem
    };

    // ----- Windows.ApplicationModel.Chat Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatCapabilities>::python_type = py::register_python_type(module, _type_name_ChatCapabilities, &_type_spec_ChatCapabilities, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager>::python_type = py::register_python_type(module, _type_name_ChatCapabilitiesManager, &_type_spec_ChatCapabilitiesManager, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatConversation>::python_type = py::register_python_type(module, _type_name_ChatConversation, &_type_spec_ChatConversation, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatConversationReader>::python_type = py::register_python_type(module, _type_name_ChatConversationReader, &_type_spec_ChatConversationReader, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo>::python_type = py::register_python_type(module, _type_name_ChatConversationThreadingInfo, &_type_spec_ChatConversationThreadingInfo, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessage>::python_type = py::register_python_type(module, _type_name_ChatMessage, &_type_spec_ChatMessage, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageAttachment>::python_type = py::register_python_type(module, _type_name_ChatMessageAttachment, &_type_spec_ChatMessageAttachment, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageBlocking>::python_type = py::register_python_type(module, _type_name_ChatMessageBlocking, &_type_spec_ChatMessageBlocking, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChange>::python_type = py::register_python_type(module, _type_name_ChatMessageChange, &_type_spec_ChatMessageChange, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeReader>::python_type = py::register_python_type(module, _type_name_ChatMessageChangeReader, &_type_spec_ChatMessageChangeReader, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeTracker>::python_type = py::register_python_type(module, _type_name_ChatMessageChangeTracker, &_type_spec_ChatMessageChangeTracker, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral>::python_type = py::register_python_type(module, _type_name_ChatMessageChangedDeferral, &_type_spec_ChatMessageChangedDeferral, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs>::python_type = py::register_python_type(module, _type_name_ChatMessageChangedEventArgs, &_type_spec_ChatMessageChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageManager>::python_type = py::register_python_type(module, _type_name_ChatMessageManager, &_type_spec_ChatMessageManager, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails>::python_type = py::register_python_type(module, _type_name_ChatMessageNotificationTriggerDetails, &_type_spec_ChatMessageNotificationTriggerDetails, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageReader>::python_type = py::register_python_type(module, _type_name_ChatMessageReader, &_type_spec_ChatMessageReader, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageStore>::python_type = py::register_python_type(module, _type_name_ChatMessageStore, &_type_spec_ChatMessageStore, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs>::python_type = py::register_python_type(module, _type_name_ChatMessageStoreChangedEventArgs, &_type_spec_ChatMessageStoreChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageTransport>::python_type = py::register_python_type(module, _type_name_ChatMessageTransport, &_type_spec_ChatMessageTransport, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration>::python_type = py::register_python_type(module, _type_name_ChatMessageTransportConfiguration, &_type_spec_ChatMessageTransportConfiguration, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageValidationResult>::python_type = py::register_python_type(module, _type_name_ChatMessageValidationResult, &_type_spec_ChatMessageValidationResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatQueryOptions>::python_type = py::register_python_type(module, _type_name_ChatQueryOptions, &_type_spec_ChatQueryOptions, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo>::python_type = py::register_python_type(module, _type_name_ChatRecipientDeliveryInfo, &_type_spec_ChatRecipientDeliveryInfo, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatSearchReader>::python_type = py::register_python_type(module, _type_name_ChatSearchReader, &_type_spec_ChatSearchReader, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatSyncConfiguration>::python_type = py::register_python_type(module, _type_name_ChatSyncConfiguration, &_type_spec_ChatSyncConfiguration, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatSyncManager>::python_type = py::register_python_type(module, _type_name_ChatSyncManager, &_type_spec_ChatSyncManager, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessage>::python_type = py::register_python_type(module, _type_name_RcsEndUserMessage, &_type_spec_RcsEndUserMessage, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>::python_type = py::register_python_type(module, _type_name_RcsEndUserMessageAction, &_type_spec_RcsEndUserMessageAction, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs>::python_type = py::register_python_type(module, _type_name_RcsEndUserMessageAvailableEventArgs, &_type_spec_RcsEndUserMessageAvailableEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails>::python_type = py::register_python_type(module, _type_name_RcsEndUserMessageAvailableTriggerDetails, &_type_spec_RcsEndUserMessageAvailableTriggerDetails, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageManager>::python_type = py::register_python_type(module, _type_name_RcsEndUserMessageManager, &_type_spec_RcsEndUserMessageManager, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsManager>::python_type = py::register_python_type(module, _type_name_RcsManager, &_type_spec_RcsManager, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs>::python_type = py::register_python_type(module, _type_name_RcsServiceKindSupportedChangedEventArgs, &_type_spec_RcsServiceKindSupportedChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsTransport>::python_type = py::register_python_type(module, _type_name_RcsTransport, &_type_spec_RcsTransport, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsTransportConfiguration>::python_type = py::register_python_type(module, _type_name_RcsTransportConfiguration, &_type_spec_RcsTransportConfiguration, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs>::python_type = py::register_python_type(module, _type_name_RemoteParticipantComposingChangedEventArgs, &_type_spec_RemoteParticipantComposingChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::IChatItem>::python_type = py::register_python_type(module, _type_name_IChatItem, &_type_spec_IChatItem, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.Chat");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_ApplicationModel_Chat",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::ApplicationModel::Chat

PyMODINIT_FUNC
PyInit__winrt_Windows_ApplicationModel_Chat (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::ApplicationModel::Chat::module_def);
}
