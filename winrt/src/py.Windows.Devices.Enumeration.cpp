// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Devices.Enumeration.h"

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceAccessInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceInformationCollection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceInformationCustomPairing>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceInformationPairing>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceInformationUpdate>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DevicePairingResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DevicePicker>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DevicePickerAppearance>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DevicePickerFilter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceSelectedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceThumbnail>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceUnpairingResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceWatcher>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceWatcherEvent>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::EnclosureLocation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Enumeration::IDevicePairingSettings>::python_type;

namespace py::cpp::Windows::Devices::Enumeration
{
    // ----- DeviceAccessChangedEventArgs class --------------------
    constexpr const char* const _type_name_DeviceAccessChangedEventArgs = "DeviceAccessChangedEventArgs";

    static PyObject* _new_DeviceAccessChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DeviceAccessChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_DeviceAccessChangedEventArgs(py::wrapper::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeviceAccessChangedEventArgs_get_Status(py::wrapper::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceAccessChangedEventArgs_get_Id(py::wrapper::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DeviceAccessChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceAccessChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_DeviceAccessChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeviceAccessChangedEventArgs[] = {
        { const_cast<char*>("status"), (getter)DeviceAccessChangedEventArgs_get_Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)DeviceAccessChangedEventArgs_get_Id, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DeviceAccessChangedEventArgs[] = 
    {
        { Py_tp_new, _new_DeviceAccessChangedEventArgs },
        { Py_tp_dealloc, _dealloc_DeviceAccessChangedEventArgs },
        { Py_tp_methods, _methods_DeviceAccessChangedEventArgs },
        { Py_tp_getset, _getset_DeviceAccessChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeviceAccessChangedEventArgs =
    {
        "_winrt_Windows_Devices_Enumeration.DeviceAccessChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceAccessChangedEventArgs
    };

    // ----- DeviceAccessInformation class --------------------
    constexpr const char* const _type_name_DeviceAccessInformation = "DeviceAccessInformation";

    static PyObject* _new_DeviceAccessInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DeviceAccessInformation);
        return nullptr;
    }

    static void _dealloc_DeviceAccessInformation(py::wrapper::Windows::Devices::Enumeration::DeviceAccessInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeviceAccessInformation_CreateFromDeviceClass(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceClass>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceAccessInformation::CreateFromDeviceClass(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceAccessInformation_CreateFromDeviceClassId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceAccessInformation::CreateFromDeviceClassId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceAccessInformation_CreateFromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceAccessInformation::CreateFromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceAccessInformation_get_CurrentStatus(py::wrapper::Windows::Devices::Enumeration::DeviceAccessInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceAccessInformation_add_AccessChanged(py::wrapper::Windows::Devices::Enumeration::DeviceAccessInformation* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DeviceAccessInformation, winrt::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs>>(arg);

            return py::convert(self->obj.AccessChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceAccessInformation_remove_AccessChanged(py::wrapper::Windows::Devices::Enumeration::DeviceAccessInformation* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AccessChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DeviceAccessInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceAccessInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceAccessInformation[] = {
        { "create_from_device_class", (PyCFunction)DeviceAccessInformation_CreateFromDeviceClass, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_device_class_id", (PyCFunction)DeviceAccessInformation_CreateFromDeviceClassId, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_id", (PyCFunction)DeviceAccessInformation_CreateFromId, METH_VARARGS | METH_STATIC, nullptr },
        { "add_access_changed", (PyCFunction)DeviceAccessInformation_add_AccessChanged, METH_O, nullptr },
        { "remove_access_changed", (PyCFunction)DeviceAccessInformation_remove_AccessChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_DeviceAccessInformation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeviceAccessInformation[] = {
        { const_cast<char*>("current_status"), (getter)DeviceAccessInformation_get_CurrentStatus, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DeviceAccessInformation[] = 
    {
        { Py_tp_new, _new_DeviceAccessInformation },
        { Py_tp_dealloc, _dealloc_DeviceAccessInformation },
        { Py_tp_methods, _methods_DeviceAccessInformation },
        { Py_tp_getset, _getset_DeviceAccessInformation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeviceAccessInformation =
    {
        "_winrt_Windows_Devices_Enumeration.DeviceAccessInformation",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceAccessInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceAccessInformation
    };

    // ----- DeviceConnectionChangeTriggerDetails class --------------------
    constexpr const char* const _type_name_DeviceConnectionChangeTriggerDetails = "DeviceConnectionChangeTriggerDetails";

    static PyObject* _new_DeviceConnectionChangeTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DeviceConnectionChangeTriggerDetails);
        return nullptr;
    }

    static void _dealloc_DeviceConnectionChangeTriggerDetails(py::wrapper::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeviceConnectionChangeTriggerDetails_get_DeviceId(py::wrapper::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DeviceConnectionChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceConnectionChangeTriggerDetails[] = {
        { "_from", (PyCFunction)_from_DeviceConnectionChangeTriggerDetails, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeviceConnectionChangeTriggerDetails[] = {
        { const_cast<char*>("device_id"), (getter)DeviceConnectionChangeTriggerDetails_get_DeviceId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DeviceConnectionChangeTriggerDetails[] = 
    {
        { Py_tp_new, _new_DeviceConnectionChangeTriggerDetails },
        { Py_tp_dealloc, _dealloc_DeviceConnectionChangeTriggerDetails },
        { Py_tp_methods, _methods_DeviceConnectionChangeTriggerDetails },
        { Py_tp_getset, _getset_DeviceConnectionChangeTriggerDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeviceConnectionChangeTriggerDetails =
    {
        "_winrt_Windows_Devices_Enumeration.DeviceConnectionChangeTriggerDetails",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceConnectionChangeTriggerDetails
    };

    // ----- DeviceDisconnectButtonClickedEventArgs class --------------------
    constexpr const char* const _type_name_DeviceDisconnectButtonClickedEventArgs = "DeviceDisconnectButtonClickedEventArgs";

    static PyObject* _new_DeviceDisconnectButtonClickedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DeviceDisconnectButtonClickedEventArgs);
        return nullptr;
    }

    static void _dealloc_DeviceDisconnectButtonClickedEventArgs(py::wrapper::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeviceDisconnectButtonClickedEventArgs_get_Device(py::wrapper::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DeviceDisconnectButtonClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceDisconnectButtonClickedEventArgs[] = {
        { "_from", (PyCFunction)_from_DeviceDisconnectButtonClickedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeviceDisconnectButtonClickedEventArgs[] = {
        { const_cast<char*>("device"), (getter)DeviceDisconnectButtonClickedEventArgs_get_Device, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DeviceDisconnectButtonClickedEventArgs[] = 
    {
        { Py_tp_new, _new_DeviceDisconnectButtonClickedEventArgs },
        { Py_tp_dealloc, _dealloc_DeviceDisconnectButtonClickedEventArgs },
        { Py_tp_methods, _methods_DeviceDisconnectButtonClickedEventArgs },
        { Py_tp_getset, _getset_DeviceDisconnectButtonClickedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeviceDisconnectButtonClickedEventArgs =
    {
        "_winrt_Windows_Devices_Enumeration.DeviceDisconnectButtonClickedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceDisconnectButtonClickedEventArgs
    };

    // ----- DeviceInformation class --------------------
    constexpr const char* const _type_name_DeviceInformation = "DeviceInformation";

    static PyObject* _new_DeviceInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DeviceInformation);
        return nullptr;
    }

    static void _dealloc_DeviceInformation(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeviceInformation_CreateFromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::CreateFromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::CreateFromIdAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformationKind>(args, 2);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::CreateFromIdAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceClass>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::CreateWatcher(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::CreateWatcher(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformationKind>(args, 2);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::CreateWatcher(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_FindAllAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::FindAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceClass>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::FindAllAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::FindAllAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformationKind>(args, 2);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::FindAllAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_GetAqsFilterFromDeviceClass(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceClass>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformation::GetAqsFilterFromDeviceClass(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_GetGlyphThumbnailAsync(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetGlyphThumbnailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_GetThumbnailAsync(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetThumbnailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_Update(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformationUpdate>(args, 0);

                self->obj.Update(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_EnclosureLocation(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EnclosureLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_Id(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_IsDefault(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDefault());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_IsEnabled(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_Name(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_Properties(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_Kind(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformation_get_Pairing(py::wrapper::Windows::Devices::Enumeration::DeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pairing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DeviceInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceInformation[] = {
        { "create_from_id_async", (PyCFunction)DeviceInformation_CreateFromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "create_watcher", (PyCFunction)DeviceInformation_CreateWatcher, METH_VARARGS | METH_STATIC, nullptr },
        { "find_all_async", (PyCFunction)DeviceInformation_FindAllAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_aqs_filter_from_device_class", (PyCFunction)DeviceInformation_GetAqsFilterFromDeviceClass, METH_VARARGS | METH_STATIC, nullptr },
        { "get_glyph_thumbnail_async", (PyCFunction)DeviceInformation_GetGlyphThumbnailAsync, METH_VARARGS, nullptr },
        { "get_thumbnail_async", (PyCFunction)DeviceInformation_GetThumbnailAsync, METH_VARARGS, nullptr },
        { "update", (PyCFunction)DeviceInformation_Update, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DeviceInformation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeviceInformation[] = {
        { const_cast<char*>("enclosure_location"), (getter)DeviceInformation_get_EnclosureLocation, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)DeviceInformation_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_default"), (getter)DeviceInformation_get_IsDefault, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_enabled"), (getter)DeviceInformation_get_IsEnabled, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)DeviceInformation_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)DeviceInformation_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)DeviceInformation_get_Kind, nullptr, nullptr, nullptr },
        { const_cast<char*>("pairing"), (getter)DeviceInformation_get_Pairing, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DeviceInformation[] = 
    {
        { Py_tp_new, _new_DeviceInformation },
        { Py_tp_dealloc, _dealloc_DeviceInformation },
        { Py_tp_methods, _methods_DeviceInformation },
        { Py_tp_getset, _getset_DeviceInformation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeviceInformation =
    {
        "_winrt_Windows_Devices_Enumeration.DeviceInformation",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceInformation
    };

    // ----- DeviceInformationCollection class --------------------
    constexpr const char* const _type_name_DeviceInformationCollection = "DeviceInformationCollection";

    static PyObject* _new_DeviceInformationCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DeviceInformationCollection);
        return nullptr;
    }

    static void _dealloc_DeviceInformationCollection(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeviceInformationCollection_First(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationCollection_GetAt(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationCollection_GetMany(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Devices::Enumeration::DeviceInformation>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Devices::Enumeration::DeviceInformation> param1 ( param1_count, py::empty_instance<winrt::Windows::Devices::Enumeration::DeviceInformation>::get() );

                auto return_value = self->obj.GetMany(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationCollection_IndexOf(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationCollection_get_Size(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DeviceInformationCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceInformationCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_DeviceInformationCollection(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_DeviceInformationCollection(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_DeviceInformationCollection(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceInformationCollection[] = {
        { "first", (PyCFunction)DeviceInformationCollection_First, METH_VARARGS, nullptr },
        { "get_at", (PyCFunction)DeviceInformationCollection_GetAt, METH_VARARGS, nullptr },
        { "get_many", (PyCFunction)DeviceInformationCollection_GetMany, METH_VARARGS, nullptr },
        { "index_of", (PyCFunction)DeviceInformationCollection_IndexOf, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DeviceInformationCollection, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeviceInformationCollection[] = {
        { const_cast<char*>("size"), (getter)DeviceInformationCollection_get_Size, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DeviceInformationCollection[] = 
    {
        { Py_tp_new, _new_DeviceInformationCollection },
        { Py_tp_dealloc, _dealloc_DeviceInformationCollection },
        { Py_tp_methods, _methods_DeviceInformationCollection },
        { Py_tp_getset, _getset_DeviceInformationCollection },
        { Py_tp_iter, _iterator_DeviceInformationCollection },
        { Py_sq_length, _seq_length_DeviceInformationCollection },
        { Py_sq_item, _seq_item_DeviceInformationCollection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeviceInformationCollection =
    {
        "_winrt_Windows_Devices_Enumeration.DeviceInformationCollection",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceInformationCollection
    };

    // ----- DeviceInformationCustomPairing class --------------------
    constexpr const char* const _type_name_DeviceInformationCustomPairing = "DeviceInformationCustomPairing";

    static PyObject* _new_DeviceInformationCustomPairing(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DeviceInformationCustomPairing);
        return nullptr;
    }

    static void _dealloc_DeviceInformationCustomPairing(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCustomPairing* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeviceInformationCustomPairing_PairAsync(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCustomPairing* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingKinds>(args, 0);

                return py::convert(self->obj.PairAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingKinds>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingProtectionLevel>(args, 1);

                return py::convert(self->obj.PairAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingKinds>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingProtectionLevel>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::IDevicePairingSettings>(args, 2);

                return py::convert(self->obj.PairAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationCustomPairing_add_PairingRequested(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCustomPairing* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DeviceInformationCustomPairing, winrt::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs>>(arg);

            return py::convert(self->obj.PairingRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformationCustomPairing_remove_PairingRequested(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCustomPairing* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PairingRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DeviceInformationCustomPairing(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceInformationCustomPairing>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceInformationCustomPairing[] = {
        { "pair_async", (PyCFunction)DeviceInformationCustomPairing_PairAsync, METH_VARARGS, nullptr },
        { "add_pairing_requested", (PyCFunction)DeviceInformationCustomPairing_add_PairingRequested, METH_O, nullptr },
        { "remove_pairing_requested", (PyCFunction)DeviceInformationCustomPairing_remove_PairingRequested, METH_O, nullptr },
        { "_from", (PyCFunction)_from_DeviceInformationCustomPairing, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeviceInformationCustomPairing[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_DeviceInformationCustomPairing[] = 
    {
        { Py_tp_new, _new_DeviceInformationCustomPairing },
        { Py_tp_dealloc, _dealloc_DeviceInformationCustomPairing },
        { Py_tp_methods, _methods_DeviceInformationCustomPairing },
        { Py_tp_getset, _getset_DeviceInformationCustomPairing },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeviceInformationCustomPairing =
    {
        "_winrt_Windows_Devices_Enumeration.DeviceInformationCustomPairing",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceInformationCustomPairing),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceInformationCustomPairing
    };

    // ----- DeviceInformationPairing class --------------------
    constexpr const char* const _type_name_DeviceInformationPairing = "DeviceInformationPairing";

    static PyObject* _new_DeviceInformationPairing(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DeviceInformationPairing);
        return nullptr;
    }

    static void _dealloc_DeviceInformationPairing(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeviceInformationPairing_PairAsync(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.PairAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingProtectionLevel>(args, 0);

                return py::convert(self->obj.PairAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingProtectionLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Enumeration::IDevicePairingSettings>(args, 1);

                return py::convert(self->obj.PairAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationPairing_TryRegisterForAllInboundPairingRequests(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingKinds>(args, 0);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformationPairing::TryRegisterForAllInboundPairingRequests(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationPairing_TryRegisterForAllInboundPairingRequestsWithProtectionLevel(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingKinds>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePairingProtectionLevel>(args, 1);

                return py::convert(winrt::Windows::Devices::Enumeration::DeviceInformationPairing::TryRegisterForAllInboundPairingRequestsWithProtectionLevel(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationPairing_UnpairAsync(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.UnpairAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceInformationPairing_get_CanPair(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanPair());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformationPairing_get_IsPaired(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformationPairing_get_Custom(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Custom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformationPairing_get_ProtectionLevel(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DeviceInformationPairing(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceInformationPairing>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceInformationPairing[] = {
        { "pair_async", (PyCFunction)DeviceInformationPairing_PairAsync, METH_VARARGS, nullptr },
        { "try_register_for_all_inbound_pairing_requests", (PyCFunction)DeviceInformationPairing_TryRegisterForAllInboundPairingRequests, METH_VARARGS | METH_STATIC, nullptr },
        { "try_register_for_all_inbound_pairing_requests_with_protection_level", (PyCFunction)DeviceInformationPairing_TryRegisterForAllInboundPairingRequestsWithProtectionLevel, METH_VARARGS | METH_STATIC, nullptr },
        { "unpair_async", (PyCFunction)DeviceInformationPairing_UnpairAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DeviceInformationPairing, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeviceInformationPairing[] = {
        { const_cast<char*>("can_pair"), (getter)DeviceInformationPairing_get_CanPair, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_paired"), (getter)DeviceInformationPairing_get_IsPaired, nullptr, nullptr, nullptr },
        { const_cast<char*>("custom"), (getter)DeviceInformationPairing_get_Custom, nullptr, nullptr, nullptr },
        { const_cast<char*>("protection_level"), (getter)DeviceInformationPairing_get_ProtectionLevel, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DeviceInformationPairing[] = 
    {
        { Py_tp_new, _new_DeviceInformationPairing },
        { Py_tp_dealloc, _dealloc_DeviceInformationPairing },
        { Py_tp_methods, _methods_DeviceInformationPairing },
        { Py_tp_getset, _getset_DeviceInformationPairing },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeviceInformationPairing =
    {
        "_winrt_Windows_Devices_Enumeration.DeviceInformationPairing",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceInformationPairing),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceInformationPairing
    };

    // ----- DeviceInformationUpdate class --------------------
    constexpr const char* const _type_name_DeviceInformationUpdate = "DeviceInformationUpdate";

    static PyObject* _new_DeviceInformationUpdate(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DeviceInformationUpdate);
        return nullptr;
    }

    static void _dealloc_DeviceInformationUpdate(py::wrapper::Windows::Devices::Enumeration::DeviceInformationUpdate* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeviceInformationUpdate_get_Id(py::wrapper::Windows::Devices::Enumeration::DeviceInformationUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformationUpdate_get_Properties(py::wrapper::Windows::Devices::Enumeration::DeviceInformationUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceInformationUpdate_get_Kind(py::wrapper::Windows::Devices::Enumeration::DeviceInformationUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DeviceInformationUpdate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceInformationUpdate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceInformationUpdate[] = {
        { "_from", (PyCFunction)_from_DeviceInformationUpdate, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeviceInformationUpdate[] = {
        { const_cast<char*>("id"), (getter)DeviceInformationUpdate_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)DeviceInformationUpdate_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)DeviceInformationUpdate_get_Kind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DeviceInformationUpdate[] = 
    {
        { Py_tp_new, _new_DeviceInformationUpdate },
        { Py_tp_dealloc, _dealloc_DeviceInformationUpdate },
        { Py_tp_methods, _methods_DeviceInformationUpdate },
        { Py_tp_getset, _getset_DeviceInformationUpdate },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeviceInformationUpdate =
    {
        "_winrt_Windows_Devices_Enumeration.DeviceInformationUpdate",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceInformationUpdate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceInformationUpdate
    };

    // ----- DevicePairingRequestedEventArgs class --------------------
    constexpr const char* const _type_name_DevicePairingRequestedEventArgs = "DevicePairingRequestedEventArgs";

    static PyObject* _new_DevicePairingRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DevicePairingRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_DevicePairingRequestedEventArgs(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DevicePairingRequestedEventArgs_Accept(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Accept();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Accept(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DevicePairingRequestedEventArgs_AcceptWithPasswordCredential(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(args, 0);

                self->obj.AcceptWithPasswordCredential(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DevicePairingRequestedEventArgs_GetDeferral(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DevicePairingRequestedEventArgs_get_DeviceInformation(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePairingRequestedEventArgs_get_PairingKind(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PairingKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePairingRequestedEventArgs_get_Pin(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DevicePairingRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DevicePairingRequestedEventArgs[] = {
        { "accept", (PyCFunction)DevicePairingRequestedEventArgs_Accept, METH_VARARGS, nullptr },
        { "accept_with_password_credential", (PyCFunction)DevicePairingRequestedEventArgs_AcceptWithPasswordCredential, METH_VARARGS, nullptr },
        { "get_deferral", (PyCFunction)DevicePairingRequestedEventArgs_GetDeferral, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DevicePairingRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DevicePairingRequestedEventArgs[] = {
        { const_cast<char*>("device_information"), (getter)DevicePairingRequestedEventArgs_get_DeviceInformation, nullptr, nullptr, nullptr },
        { const_cast<char*>("pairing_kind"), (getter)DevicePairingRequestedEventArgs_get_PairingKind, nullptr, nullptr, nullptr },
        { const_cast<char*>("pin"), (getter)DevicePairingRequestedEventArgs_get_Pin, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DevicePairingRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_DevicePairingRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_DevicePairingRequestedEventArgs },
        { Py_tp_methods, _methods_DevicePairingRequestedEventArgs },
        { Py_tp_getset, _getset_DevicePairingRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DevicePairingRequestedEventArgs =
    {
        "_winrt_Windows_Devices_Enumeration.DevicePairingRequestedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DevicePairingRequestedEventArgs
    };

    // ----- DevicePairingResult class --------------------
    constexpr const char* const _type_name_DevicePairingResult = "DevicePairingResult";

    static PyObject* _new_DevicePairingResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DevicePairingResult);
        return nullptr;
    }

    static void _dealloc_DevicePairingResult(py::wrapper::Windows::Devices::Enumeration::DevicePairingResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DevicePairingResult_get_ProtectionLevelUsed(py::wrapper::Windows::Devices::Enumeration::DevicePairingResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtectionLevelUsed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePairingResult_get_Status(py::wrapper::Windows::Devices::Enumeration::DevicePairingResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DevicePairingResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DevicePairingResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DevicePairingResult[] = {
        { "_from", (PyCFunction)_from_DevicePairingResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DevicePairingResult[] = {
        { const_cast<char*>("protection_level_used"), (getter)DevicePairingResult_get_ProtectionLevelUsed, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)DevicePairingResult_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DevicePairingResult[] = 
    {
        { Py_tp_new, _new_DevicePairingResult },
        { Py_tp_dealloc, _dealloc_DevicePairingResult },
        { Py_tp_methods, _methods_DevicePairingResult },
        { Py_tp_getset, _getset_DevicePairingResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DevicePairingResult =
    {
        "_winrt_Windows_Devices_Enumeration.DevicePairingResult",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DevicePairingResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DevicePairingResult
    };

    // ----- DevicePicker class --------------------
    constexpr const char* const _type_name_DevicePicker = "DevicePicker";

    static PyObject* _new_DevicePicker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Enumeration::DevicePicker instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DevicePicker(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DevicePicker_Hide(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Hide();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DevicePicker_PickSingleDeviceAsync(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert(self->obj.PickSingleDeviceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 1);

                return py::convert(self->obj.PickSingleDeviceAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DevicePicker_SetDisplayStatus(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DevicePickerDisplayStatusOptions>(args, 2);

                self->obj.SetDisplayStatus(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DevicePicker_Show(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                self->obj.Show(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 1);

                self->obj.Show(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DevicePicker_get_Appearance(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Appearance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_get_Filter(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Filter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_get_RequestedProperties(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_add_DevicePickerDismissed(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DevicePicker, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.DevicePickerDismissed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_remove_DevicePickerDismissed(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DevicePickerDismissed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_add_DeviceSelected(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DevicePicker, winrt::Windows::Devices::Enumeration::DeviceSelectedEventArgs>>(arg);

            return py::convert(self->obj.DeviceSelected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_remove_DeviceSelected(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DeviceSelected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_add_DisconnectButtonClicked(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DevicePicker, winrt::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs>>(arg);

            return py::convert(self->obj.DisconnectButtonClicked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePicker_remove_DisconnectButtonClicked(py::wrapper::Windows::Devices::Enumeration::DevicePicker* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DisconnectButtonClicked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DevicePicker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DevicePicker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DevicePicker[] = {
        { "hide", (PyCFunction)DevicePicker_Hide, METH_VARARGS, nullptr },
        { "pick_single_device_async", (PyCFunction)DevicePicker_PickSingleDeviceAsync, METH_VARARGS, nullptr },
        { "set_display_status", (PyCFunction)DevicePicker_SetDisplayStatus, METH_VARARGS, nullptr },
        { "show", (PyCFunction)DevicePicker_Show, METH_VARARGS, nullptr },
        { "add_device_picker_dismissed", (PyCFunction)DevicePicker_add_DevicePickerDismissed, METH_O, nullptr },
        { "remove_device_picker_dismissed", (PyCFunction)DevicePicker_remove_DevicePickerDismissed, METH_O, nullptr },
        { "add_device_selected", (PyCFunction)DevicePicker_add_DeviceSelected, METH_O, nullptr },
        { "remove_device_selected", (PyCFunction)DevicePicker_remove_DeviceSelected, METH_O, nullptr },
        { "add_disconnect_button_clicked", (PyCFunction)DevicePicker_add_DisconnectButtonClicked, METH_O, nullptr },
        { "remove_disconnect_button_clicked", (PyCFunction)DevicePicker_remove_DisconnectButtonClicked, METH_O, nullptr },
        { "_from", (PyCFunction)_from_DevicePicker, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DevicePicker[] = {
        { const_cast<char*>("appearance"), (getter)DevicePicker_get_Appearance, nullptr, nullptr, nullptr },
        { const_cast<char*>("filter"), (getter)DevicePicker_get_Filter, nullptr, nullptr, nullptr },
        { const_cast<char*>("requested_properties"), (getter)DevicePicker_get_RequestedProperties, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DevicePicker[] = 
    {
        { Py_tp_new, _new_DevicePicker },
        { Py_tp_dealloc, _dealloc_DevicePicker },
        { Py_tp_methods, _methods_DevicePicker },
        { Py_tp_getset, _getset_DevicePicker },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DevicePicker =
    {
        "_winrt_Windows_Devices_Enumeration.DevicePicker",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DevicePicker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DevicePicker
    };

    // ----- DevicePickerAppearance class --------------------
    constexpr const char* const _type_name_DevicePickerAppearance = "DevicePickerAppearance";

    static PyObject* _new_DevicePickerAppearance(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DevicePickerAppearance);
        return nullptr;
    }

    static void _dealloc_DevicePickerAppearance(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DevicePickerAppearance_get_Title(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DevicePickerAppearance_put_Title(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DevicePickerAppearance_get_SelectedForegroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SelectedForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DevicePickerAppearance_put_SelectedForegroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.SelectedForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DevicePickerAppearance_get_SelectedBackgroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SelectedBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DevicePickerAppearance_put_SelectedBackgroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.SelectedBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DevicePickerAppearance_get_SelectedAccentColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SelectedAccentColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DevicePickerAppearance_put_SelectedAccentColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.SelectedAccentColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DevicePickerAppearance_get_ForegroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DevicePickerAppearance_put_ForegroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.ForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DevicePickerAppearance_get_BackgroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DevicePickerAppearance_put_BackgroundColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.BackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DevicePickerAppearance_get_AccentColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccentColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DevicePickerAppearance_put_AccentColor(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.AccentColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_DevicePickerAppearance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DevicePickerAppearance>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DevicePickerAppearance[] = {
        { "_from", (PyCFunction)_from_DevicePickerAppearance, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DevicePickerAppearance[] = {
        { const_cast<char*>("title"), (getter)DevicePickerAppearance_get_Title, (setter)DevicePickerAppearance_put_Title, nullptr, nullptr },
        { const_cast<char*>("selected_foreground_color"), (getter)DevicePickerAppearance_get_SelectedForegroundColor, (setter)DevicePickerAppearance_put_SelectedForegroundColor, nullptr, nullptr },
        { const_cast<char*>("selected_background_color"), (getter)DevicePickerAppearance_get_SelectedBackgroundColor, (setter)DevicePickerAppearance_put_SelectedBackgroundColor, nullptr, nullptr },
        { const_cast<char*>("selected_accent_color"), (getter)DevicePickerAppearance_get_SelectedAccentColor, (setter)DevicePickerAppearance_put_SelectedAccentColor, nullptr, nullptr },
        { const_cast<char*>("foreground_color"), (getter)DevicePickerAppearance_get_ForegroundColor, (setter)DevicePickerAppearance_put_ForegroundColor, nullptr, nullptr },
        { const_cast<char*>("background_color"), (getter)DevicePickerAppearance_get_BackgroundColor, (setter)DevicePickerAppearance_put_BackgroundColor, nullptr, nullptr },
        { const_cast<char*>("accent_color"), (getter)DevicePickerAppearance_get_AccentColor, (setter)DevicePickerAppearance_put_AccentColor, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DevicePickerAppearance[] = 
    {
        { Py_tp_new, _new_DevicePickerAppearance },
        { Py_tp_dealloc, _dealloc_DevicePickerAppearance },
        { Py_tp_methods, _methods_DevicePickerAppearance },
        { Py_tp_getset, _getset_DevicePickerAppearance },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DevicePickerAppearance =
    {
        "_winrt_Windows_Devices_Enumeration.DevicePickerAppearance",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DevicePickerAppearance),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DevicePickerAppearance
    };

    // ----- DevicePickerFilter class --------------------
    constexpr const char* const _type_name_DevicePickerFilter = "DevicePickerFilter";

    static PyObject* _new_DevicePickerFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DevicePickerFilter);
        return nullptr;
    }

    static void _dealloc_DevicePickerFilter(py::wrapper::Windows::Devices::Enumeration::DevicePickerFilter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DevicePickerFilter_get_SupportedDeviceClasses(py::wrapper::Windows::Devices::Enumeration::DevicePickerFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedDeviceClasses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePickerFilter_get_SupportedDeviceSelectors(py::wrapper::Windows::Devices::Enumeration::DevicePickerFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedDeviceSelectors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DevicePickerFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DevicePickerFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DevicePickerFilter[] = {
        { "_from", (PyCFunction)_from_DevicePickerFilter, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DevicePickerFilter[] = {
        { const_cast<char*>("supported_device_classes"), (getter)DevicePickerFilter_get_SupportedDeviceClasses, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_device_selectors"), (getter)DevicePickerFilter_get_SupportedDeviceSelectors, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DevicePickerFilter[] = 
    {
        { Py_tp_new, _new_DevicePickerFilter },
        { Py_tp_dealloc, _dealloc_DevicePickerFilter },
        { Py_tp_methods, _methods_DevicePickerFilter },
        { Py_tp_getset, _getset_DevicePickerFilter },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DevicePickerFilter =
    {
        "_winrt_Windows_Devices_Enumeration.DevicePickerFilter",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DevicePickerFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DevicePickerFilter
    };

    // ----- DeviceSelectedEventArgs class --------------------
    constexpr const char* const _type_name_DeviceSelectedEventArgs = "DeviceSelectedEventArgs";

    static PyObject* _new_DeviceSelectedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DeviceSelectedEventArgs);
        return nullptr;
    }

    static void _dealloc_DeviceSelectedEventArgs(py::wrapper::Windows::Devices::Enumeration::DeviceSelectedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeviceSelectedEventArgs_get_SelectedDevice(py::wrapper::Windows::Devices::Enumeration::DeviceSelectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SelectedDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DeviceSelectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceSelectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceSelectedEventArgs[] = {
        { "_from", (PyCFunction)_from_DeviceSelectedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeviceSelectedEventArgs[] = {
        { const_cast<char*>("selected_device"), (getter)DeviceSelectedEventArgs_get_SelectedDevice, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DeviceSelectedEventArgs[] = 
    {
        { Py_tp_new, _new_DeviceSelectedEventArgs },
        { Py_tp_dealloc, _dealloc_DeviceSelectedEventArgs },
        { Py_tp_methods, _methods_DeviceSelectedEventArgs },
        { Py_tp_getset, _getset_DeviceSelectedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeviceSelectedEventArgs =
    {
        "_winrt_Windows_Devices_Enumeration.DeviceSelectedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceSelectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceSelectedEventArgs
    };

    // ----- DeviceThumbnail class --------------------
    constexpr const char* const _type_name_DeviceThumbnail = "DeviceThumbnail";

    static PyObject* _new_DeviceThumbnail(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DeviceThumbnail);
        return nullptr;
    }

    static void _dealloc_DeviceThumbnail(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeviceThumbnail_CloneStream(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CloneStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_Close(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_FlushAsync(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_GetInputStreamAt(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetInputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_GetOutputStreamAt(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetOutputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_ReadAsync(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_Seek(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_WriteAsync(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_get_ContentType(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_get_Size(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceThumbnail_put_Size(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceThumbnail_get_CanRead(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_get_CanWrite(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceThumbnail_get_Position(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DeviceThumbnail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceThumbnail>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_DeviceThumbnail(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_DeviceThumbnail(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceThumbnail[] = {
        { "clone_stream", (PyCFunction)DeviceThumbnail_CloneStream, METH_VARARGS, nullptr },
        { "close", (PyCFunction)DeviceThumbnail_Close, METH_VARARGS, nullptr },
        { "flush_async", (PyCFunction)DeviceThumbnail_FlushAsync, METH_VARARGS, nullptr },
        { "get_input_stream_at", (PyCFunction)DeviceThumbnail_GetInputStreamAt, METH_VARARGS, nullptr },
        { "get_output_stream_at", (PyCFunction)DeviceThumbnail_GetOutputStreamAt, METH_VARARGS, nullptr },
        { "read_async", (PyCFunction)DeviceThumbnail_ReadAsync, METH_VARARGS, nullptr },
        { "seek", (PyCFunction)DeviceThumbnail_Seek, METH_VARARGS, nullptr },
        { "write_async", (PyCFunction)DeviceThumbnail_WriteAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DeviceThumbnail, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_DeviceThumbnail, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_DeviceThumbnail, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeviceThumbnail[] = {
        { const_cast<char*>("content_type"), (getter)DeviceThumbnail_get_ContentType, nullptr, nullptr, nullptr },
        { const_cast<char*>("size"), (getter)DeviceThumbnail_get_Size, (setter)DeviceThumbnail_put_Size, nullptr, nullptr },
        { const_cast<char*>("can_read"), (getter)DeviceThumbnail_get_CanRead, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_write"), (getter)DeviceThumbnail_get_CanWrite, nullptr, nullptr, nullptr },
        { const_cast<char*>("position"), (getter)DeviceThumbnail_get_Position, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DeviceThumbnail[] = 
    {
        { Py_tp_new, _new_DeviceThumbnail },
        { Py_tp_dealloc, _dealloc_DeviceThumbnail },
        { Py_tp_methods, _methods_DeviceThumbnail },
        { Py_tp_getset, _getset_DeviceThumbnail },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeviceThumbnail =
    {
        "_winrt_Windows_Devices_Enumeration.DeviceThumbnail",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceThumbnail),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceThumbnail
    };

    // ----- DeviceUnpairingResult class --------------------
    constexpr const char* const _type_name_DeviceUnpairingResult = "DeviceUnpairingResult";

    static PyObject* _new_DeviceUnpairingResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DeviceUnpairingResult);
        return nullptr;
    }

    static void _dealloc_DeviceUnpairingResult(py::wrapper::Windows::Devices::Enumeration::DeviceUnpairingResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeviceUnpairingResult_get_Status(py::wrapper::Windows::Devices::Enumeration::DeviceUnpairingResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DeviceUnpairingResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceUnpairingResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceUnpairingResult[] = {
        { "_from", (PyCFunction)_from_DeviceUnpairingResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeviceUnpairingResult[] = {
        { const_cast<char*>("status"), (getter)DeviceUnpairingResult_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DeviceUnpairingResult[] = 
    {
        { Py_tp_new, _new_DeviceUnpairingResult },
        { Py_tp_dealloc, _dealloc_DeviceUnpairingResult },
        { Py_tp_methods, _methods_DeviceUnpairingResult },
        { Py_tp_getset, _getset_DeviceUnpairingResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeviceUnpairingResult =
    {
        "_winrt_Windows_Devices_Enumeration.DeviceUnpairingResult",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceUnpairingResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceUnpairingResult
    };

    // ----- DeviceWatcher class --------------------
    constexpr const char* const _type_name_DeviceWatcher = "DeviceWatcher";

    static PyObject* _new_DeviceWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DeviceWatcher);
        return nullptr;
    }

    static void _dealloc_DeviceWatcher(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeviceWatcher_GetBackgroundTrigger(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Enumeration::DeviceWatcherEventKind>>(args, 0);

                return py::convert(self->obj.GetBackgroundTrigger(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_Start(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_Stop(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_get_Status(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_add_Added(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DeviceWatcher, winrt::Windows::Devices::Enumeration::DeviceInformation>>(arg);

            return py::convert(self->obj.Added(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_remove_Added(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Added(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_add_EnumerationCompleted(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DeviceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_remove_EnumerationCompleted(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_add_Removed(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DeviceWatcher, winrt::Windows::Devices::Enumeration::DeviceInformationUpdate>>(arg);

            return py::convert(self->obj.Removed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_remove_Removed(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Removed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_add_Stopped(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DeviceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_remove_Stopped(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_add_Updated(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Enumeration::DeviceWatcher, winrt::Windows::Devices::Enumeration::DeviceInformationUpdate>>(arg);

            return py::convert(self->obj.Updated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcher_remove_Updated(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Updated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DeviceWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceWatcher[] = {
        { "get_background_trigger", (PyCFunction)DeviceWatcher_GetBackgroundTrigger, METH_VARARGS, nullptr },
        { "start", (PyCFunction)DeviceWatcher_Start, METH_VARARGS, nullptr },
        { "stop", (PyCFunction)DeviceWatcher_Stop, METH_VARARGS, nullptr },
        { "add_added", (PyCFunction)DeviceWatcher_add_Added, METH_O, nullptr },
        { "remove_added", (PyCFunction)DeviceWatcher_remove_Added, METH_O, nullptr },
        { "add_enumeration_completed", (PyCFunction)DeviceWatcher_add_EnumerationCompleted, METH_O, nullptr },
        { "remove_enumeration_completed", (PyCFunction)DeviceWatcher_remove_EnumerationCompleted, METH_O, nullptr },
        { "add_removed", (PyCFunction)DeviceWatcher_add_Removed, METH_O, nullptr },
        { "remove_removed", (PyCFunction)DeviceWatcher_remove_Removed, METH_O, nullptr },
        { "add_stopped", (PyCFunction)DeviceWatcher_add_Stopped, METH_O, nullptr },
        { "remove_stopped", (PyCFunction)DeviceWatcher_remove_Stopped, METH_O, nullptr },
        { "add_updated", (PyCFunction)DeviceWatcher_add_Updated, METH_O, nullptr },
        { "remove_updated", (PyCFunction)DeviceWatcher_remove_Updated, METH_O, nullptr },
        { "_from", (PyCFunction)_from_DeviceWatcher, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeviceWatcher[] = {
        { const_cast<char*>("status"), (getter)DeviceWatcher_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DeviceWatcher[] = 
    {
        { Py_tp_new, _new_DeviceWatcher },
        { Py_tp_dealloc, _dealloc_DeviceWatcher },
        { Py_tp_methods, _methods_DeviceWatcher },
        { Py_tp_getset, _getset_DeviceWatcher },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeviceWatcher =
    {
        "_winrt_Windows_Devices_Enumeration.DeviceWatcher",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceWatcher
    };

    // ----- DeviceWatcherEvent class --------------------
    constexpr const char* const _type_name_DeviceWatcherEvent = "DeviceWatcherEvent";

    static PyObject* _new_DeviceWatcherEvent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DeviceWatcherEvent);
        return nullptr;
    }

    static void _dealloc_DeviceWatcherEvent(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherEvent* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeviceWatcherEvent_get_DeviceInformation(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherEvent* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcherEvent_get_DeviceInformationUpdate(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherEvent* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceInformationUpdate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceWatcherEvent_get_Kind(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherEvent* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DeviceWatcherEvent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceWatcherEvent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceWatcherEvent[] = {
        { "_from", (PyCFunction)_from_DeviceWatcherEvent, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeviceWatcherEvent[] = {
        { const_cast<char*>("device_information"), (getter)DeviceWatcherEvent_get_DeviceInformation, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_information_update"), (getter)DeviceWatcherEvent_get_DeviceInformationUpdate, nullptr, nullptr, nullptr },
        { const_cast<char*>("kind"), (getter)DeviceWatcherEvent_get_Kind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DeviceWatcherEvent[] = 
    {
        { Py_tp_new, _new_DeviceWatcherEvent },
        { Py_tp_dealloc, _dealloc_DeviceWatcherEvent },
        { Py_tp_methods, _methods_DeviceWatcherEvent },
        { Py_tp_getset, _getset_DeviceWatcherEvent },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeviceWatcherEvent =
    {
        "_winrt_Windows_Devices_Enumeration.DeviceWatcherEvent",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherEvent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceWatcherEvent
    };

    // ----- DeviceWatcherTriggerDetails class --------------------
    constexpr const char* const _type_name_DeviceWatcherTriggerDetails = "DeviceWatcherTriggerDetails";

    static PyObject* _new_DeviceWatcherTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DeviceWatcherTriggerDetails);
        return nullptr;
    }

    static void _dealloc_DeviceWatcherTriggerDetails(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeviceWatcherTriggerDetails_get_DeviceWatcherEvents(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceWatcherEvents());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DeviceWatcherTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceWatcherTriggerDetails[] = {
        { "_from", (PyCFunction)_from_DeviceWatcherTriggerDetails, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeviceWatcherTriggerDetails[] = {
        { const_cast<char*>("device_watcher_events"), (getter)DeviceWatcherTriggerDetails_get_DeviceWatcherEvents, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DeviceWatcherTriggerDetails[] = 
    {
        { Py_tp_new, _new_DeviceWatcherTriggerDetails },
        { Py_tp_dealloc, _dealloc_DeviceWatcherTriggerDetails },
        { Py_tp_methods, _methods_DeviceWatcherTriggerDetails },
        { Py_tp_getset, _getset_DeviceWatcherTriggerDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeviceWatcherTriggerDetails =
    {
        "_winrt_Windows_Devices_Enumeration.DeviceWatcherTriggerDetails",
        sizeof(py::wrapper::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceWatcherTriggerDetails
    };

    // ----- EnclosureLocation class --------------------
    constexpr const char* const _type_name_EnclosureLocation = "EnclosureLocation";

    static PyObject* _new_EnclosureLocation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EnclosureLocation);
        return nullptr;
    }

    static void _dealloc_EnclosureLocation(py::wrapper::Windows::Devices::Enumeration::EnclosureLocation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EnclosureLocation_get_InDock(py::wrapper::Windows::Devices::Enumeration::EnclosureLocation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InDock());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EnclosureLocation_get_InLid(py::wrapper::Windows::Devices::Enumeration::EnclosureLocation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InLid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EnclosureLocation_get_Panel(py::wrapper::Windows::Devices::Enumeration::EnclosureLocation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Panel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EnclosureLocation_get_RotationAngleInDegreesClockwise(py::wrapper::Windows::Devices::Enumeration::EnclosureLocation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RotationAngleInDegreesClockwise());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EnclosureLocation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::EnclosureLocation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EnclosureLocation[] = {
        { "_from", (PyCFunction)_from_EnclosureLocation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EnclosureLocation[] = {
        { const_cast<char*>("in_dock"), (getter)EnclosureLocation_get_InDock, nullptr, nullptr, nullptr },
        { const_cast<char*>("in_lid"), (getter)EnclosureLocation_get_InLid, nullptr, nullptr, nullptr },
        { const_cast<char*>("panel"), (getter)EnclosureLocation_get_Panel, nullptr, nullptr, nullptr },
        { const_cast<char*>("rotation_angle_in_degrees_clockwise"), (getter)EnclosureLocation_get_RotationAngleInDegreesClockwise, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_EnclosureLocation[] = 
    {
        { Py_tp_new, _new_EnclosureLocation },
        { Py_tp_dealloc, _dealloc_EnclosureLocation },
        { Py_tp_methods, _methods_EnclosureLocation },
        { Py_tp_getset, _getset_EnclosureLocation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EnclosureLocation =
    {
        "_winrt_Windows_Devices_Enumeration.EnclosureLocation",
        sizeof(py::wrapper::Windows::Devices::Enumeration::EnclosureLocation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EnclosureLocation
    };

    // ----- IDevicePairingSettings interface --------------------
    constexpr const char* const _type_name_IDevicePairingSettings = "IDevicePairingSettings";

    static PyObject* _new_IDevicePairingSettings(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IDevicePairingSettings);
        return nullptr;
    }

    static void _dealloc_IDevicePairingSettings(py::wrapper::Windows::Devices::Enumeration::IDevicePairingSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_IDevicePairingSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Enumeration::IDevicePairingSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDevicePairingSettings[] = {
        { "_from", (PyCFunction)_from_IDevicePairingSettings, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IDevicePairingSettings[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IDevicePairingSettings[] = 
    {
        { Py_tp_new, _new_IDevicePairingSettings },
        { Py_tp_dealloc, _dealloc_IDevicePairingSettings },
        { Py_tp_methods, _methods_IDevicePairingSettings },
        { Py_tp_getset, _getset_IDevicePairingSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IDevicePairingSettings =
    {
        "_winrt_Windows_Devices_Enumeration.IDevicePairingSettings",
        sizeof(py::wrapper::Windows::Devices::Enumeration::IDevicePairingSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDevicePairingSettings
    };

    // ----- Windows.Devices.Enumeration Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceAccessChangedEventArgs>::python_type = py::register_python_type(module, _type_name_DeviceAccessChangedEventArgs, &_type_spec_DeviceAccessChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceAccessInformation>::python_type = py::register_python_type(module, _type_name_DeviceAccessInformation, &_type_spec_DeviceAccessInformation, bases.get());
            py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceConnectionChangeTriggerDetails>::python_type = py::register_python_type(module, _type_name_DeviceConnectionChangeTriggerDetails, &_type_spec_DeviceConnectionChangeTriggerDetails, bases.get());
            py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceDisconnectButtonClickedEventArgs>::python_type = py::register_python_type(module, _type_name_DeviceDisconnectButtonClickedEventArgs, &_type_spec_DeviceDisconnectButtonClickedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceInformation>::python_type = py::register_python_type(module, _type_name_DeviceInformation, &_type_spec_DeviceInformation, bases.get());
            py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceInformationCollection>::python_type = py::register_python_type(module, _type_name_DeviceInformationCollection, &_type_spec_DeviceInformationCollection, bases.get());
            py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceInformationCustomPairing>::python_type = py::register_python_type(module, _type_name_DeviceInformationCustomPairing, &_type_spec_DeviceInformationCustomPairing, bases.get());
            py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceInformationPairing>::python_type = py::register_python_type(module, _type_name_DeviceInformationPairing, &_type_spec_DeviceInformationPairing, bases.get());
            py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceInformationUpdate>::python_type = py::register_python_type(module, _type_name_DeviceInformationUpdate, &_type_spec_DeviceInformationUpdate, bases.get());
            py::winrt_type<winrt::Windows::Devices::Enumeration::DevicePairingRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_DevicePairingRequestedEventArgs, &_type_spec_DevicePairingRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Enumeration::DevicePairingResult>::python_type = py::register_python_type(module, _type_name_DevicePairingResult, &_type_spec_DevicePairingResult, bases.get());
            py::winrt_type<winrt::Windows::Devices::Enumeration::DevicePicker>::python_type = py::register_python_type(module, _type_name_DevicePicker, &_type_spec_DevicePicker, bases.get());
            py::winrt_type<winrt::Windows::Devices::Enumeration::DevicePickerAppearance>::python_type = py::register_python_type(module, _type_name_DevicePickerAppearance, &_type_spec_DevicePickerAppearance, bases.get());
            py::winrt_type<winrt::Windows::Devices::Enumeration::DevicePickerFilter>::python_type = py::register_python_type(module, _type_name_DevicePickerFilter, &_type_spec_DevicePickerFilter, bases.get());
            py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceSelectedEventArgs>::python_type = py::register_python_type(module, _type_name_DeviceSelectedEventArgs, &_type_spec_DeviceSelectedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceThumbnail>::python_type = py::register_python_type(module, _type_name_DeviceThumbnail, &_type_spec_DeviceThumbnail, bases.get());
            py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceUnpairingResult>::python_type = py::register_python_type(module, _type_name_DeviceUnpairingResult, &_type_spec_DeviceUnpairingResult, bases.get());
            py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceWatcher>::python_type = py::register_python_type(module, _type_name_DeviceWatcher, &_type_spec_DeviceWatcher, bases.get());
            py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceWatcherEvent>::python_type = py::register_python_type(module, _type_name_DeviceWatcherEvent, &_type_spec_DeviceWatcherEvent, bases.get());
            py::winrt_type<winrt::Windows::Devices::Enumeration::DeviceWatcherTriggerDetails>::python_type = py::register_python_type(module, _type_name_DeviceWatcherTriggerDetails, &_type_spec_DeviceWatcherTriggerDetails, bases.get());
            py::winrt_type<winrt::Windows::Devices::Enumeration::EnclosureLocation>::python_type = py::register_python_type(module, _type_name_EnclosureLocation, &_type_spec_EnclosureLocation, bases.get());
            py::winrt_type<winrt::Windows::Devices::Enumeration::IDevicePairingSettings>::python_type = py::register_python_type(module, _type_name_IDevicePairingSettings, &_type_spec_IDevicePairingSettings, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Devices.Enumeration");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Devices_Enumeration",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Devices::Enumeration

PyMODINIT_FUNC
PyInit__winrt_Windows_Devices_Enumeration (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Devices::Enumeration::module_def);
}
