// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Devices.PointOfService.h"

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScanner>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerReport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeSymbologies>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeSymbologyAttributes>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerCloseAlarm>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerClosedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerEventSource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerStatus>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedCashDrawer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedJournalPrinter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedPosPrinter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedReceiptPrinter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedSlipPrinter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::JournalPrintJob>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::JournalPrinterCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplay>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayAttributes>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayCursor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayCursorAttributes>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayCustomGlyphs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayMarquee>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayStoredBitmap>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayWindow>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderEncryptionAlgorithms>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderReport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackData>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterCharacterSetIds>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterFontProperty>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterStatus>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ReceiptPrintJob>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ReceiptPrinterCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::SlipPrintJob>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::SlipPrinterCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::UnifiedPosErrorData>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::IPosPrinterJob>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::IReceiptOrSlipJob>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::SizeUInt32>::python_type;

PyObject* py::converter<winrt::Windows::Devices::PointOfService::SizeUInt32>::convert(winrt::Windows::Devices::PointOfService::SizeUInt32 instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Devices::PointOfService::SizeUInt32>());
}
winrt::Windows::Devices::PointOfService::SizeUInt32 py::converter<winrt::Windows::Devices::PointOfService::SizeUInt32>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Devices::PointOfService::SizeUInt32>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Devices::PointOfService::SizeUInt32>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Devices::PointOfService::SizeUInt32 return_value{};

    PyObject* py_Width = PyDict_GetItemString(obj, "width");
    if (!py_Width) { throw winrt::hresult_invalid_argument(); }
    return_value.Width = converter<uint32_t>::convert_to(py_Width);

    PyObject* py_Height = PyDict_GetItemString(obj, "height");
    if (!py_Height) { throw winrt::hresult_invalid_argument(); }
    return_value.Height = converter<uint32_t>::convert_to(py_Height);

    return return_value;
}

namespace py::cpp::Windows::Devices::PointOfService
{
    // ----- BarcodeScanner class --------------------
    constexpr const char* const _type_name_BarcodeScanner = "BarcodeScanner";

    static PyObject* _new_BarcodeScanner(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BarcodeScanner);
        return nullptr;
    }

    static void _dealloc_BarcodeScanner(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BarcodeScanner_CheckHealthAsync(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel>(args, 0);

                return py::convert(self->obj.CheckHealthAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_ClaimScannerAsync(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClaimScannerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_Close(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::BarcodeScanner::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::BarcodeScanner::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::BarcodeScanner::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::BarcodeScanner::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_GetSupportedProfiles(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSupportedProfiles());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_GetSupportedSymbologiesAsync(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSupportedSymbologiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_IsProfileSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsProfileSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_IsSymbologySupportedAsync(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.IsSymbologySupportedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_RetrieveStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.RetrieveStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_get_VideoDeviceId(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_add_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::BarcodeScanner, winrt::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs>>(arg);

            return py::convert(self->obj.StatusUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_remove_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BarcodeScanner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScanner>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_BarcodeScanner(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_BarcodeScanner(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScanner[] = {
        { "check_health_async", (PyCFunction)BarcodeScanner_CheckHealthAsync, METH_VARARGS, nullptr },
        { "claim_scanner_async", (PyCFunction)BarcodeScanner_ClaimScannerAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)BarcodeScanner_Close, METH_VARARGS, nullptr },
        { "from_id_async", (PyCFunction)BarcodeScanner_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_async", (PyCFunction)BarcodeScanner_GetDefaultAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)BarcodeScanner_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "get_supported_profiles", (PyCFunction)BarcodeScanner_GetSupportedProfiles, METH_VARARGS, nullptr },
        { "get_supported_symbologies_async", (PyCFunction)BarcodeScanner_GetSupportedSymbologiesAsync, METH_VARARGS, nullptr },
        { "is_profile_supported", (PyCFunction)BarcodeScanner_IsProfileSupported, METH_VARARGS, nullptr },
        { "is_symbology_supported_async", (PyCFunction)BarcodeScanner_IsSymbologySupportedAsync, METH_VARARGS, nullptr },
        { "retrieve_statistics_async", (PyCFunction)BarcodeScanner_RetrieveStatisticsAsync, METH_VARARGS, nullptr },
        { "add_status_updated", (PyCFunction)BarcodeScanner_add_StatusUpdated, METH_O, nullptr },
        { "remove_status_updated", (PyCFunction)BarcodeScanner_remove_StatusUpdated, METH_O, nullptr },
        { "_from", (PyCFunction)_from_BarcodeScanner, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_BarcodeScanner, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_BarcodeScanner, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BarcodeScanner[] = {
        { const_cast<char*>("capabilities"), (getter)BarcodeScanner_get_Capabilities, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)BarcodeScanner_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("video_device_id"), (getter)BarcodeScanner_get_VideoDeviceId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BarcodeScanner[] = 
    {
        { Py_tp_new, _new_BarcodeScanner },
        { Py_tp_dealloc, _dealloc_BarcodeScanner },
        { Py_tp_methods, _methods_BarcodeScanner },
        { Py_tp_getset, _getset_BarcodeScanner },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BarcodeScanner =
    {
        "_winrt_Windows_Devices_PointOfService.BarcodeScanner",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScanner
    };

    // ----- BarcodeScannerCapabilities class --------------------
    constexpr const char* const _type_name_BarcodeScannerCapabilities = "BarcodeScannerCapabilities";

    static PyObject* _new_BarcodeScannerCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BarcodeScannerCapabilities);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerCapabilities(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BarcodeScannerCapabilities_get_IsImagePreviewSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsImagePreviewSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerCapabilities_get_IsStatisticsReportingSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatisticsReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerCapabilities_get_IsStatisticsUpdatingSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatisticsUpdatingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerCapabilities_get_PowerReportingType(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerReportingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerCapabilities_get_IsSoftwareTriggerSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSoftwareTriggerSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerCapabilities_get_IsVideoPreviewSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVideoPreviewSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BarcodeScannerCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerCapabilities[] = {
        { "_from", (PyCFunction)_from_BarcodeScannerCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BarcodeScannerCapabilities[] = {
        { const_cast<char*>("is_image_preview_supported"), (getter)BarcodeScannerCapabilities_get_IsImagePreviewSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_statistics_reporting_supported"), (getter)BarcodeScannerCapabilities_get_IsStatisticsReportingSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_statistics_updating_supported"), (getter)BarcodeScannerCapabilities_get_IsStatisticsUpdatingSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("power_reporting_type"), (getter)BarcodeScannerCapabilities_get_PowerReportingType, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_software_trigger_supported"), (getter)BarcodeScannerCapabilities_get_IsSoftwareTriggerSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_video_preview_supported"), (getter)BarcodeScannerCapabilities_get_IsVideoPreviewSupported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BarcodeScannerCapabilities[] = 
    {
        { Py_tp_new, _new_BarcodeScannerCapabilities },
        { Py_tp_dealloc, _dealloc_BarcodeScannerCapabilities },
        { Py_tp_methods, _methods_BarcodeScannerCapabilities },
        { Py_tp_getset, _getset_BarcodeScannerCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BarcodeScannerCapabilities =
    {
        "_winrt_Windows_Devices_PointOfService.BarcodeScannerCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerCapabilities
    };

    // ----- BarcodeScannerDataReceivedEventArgs class --------------------
    constexpr const char* const _type_name_BarcodeScannerDataReceivedEventArgs = "BarcodeScannerDataReceivedEventArgs";

    static PyObject* _new_BarcodeScannerDataReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BarcodeScannerDataReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerDataReceivedEventArgs(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BarcodeScannerDataReceivedEventArgs_get_Report(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Report());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BarcodeScannerDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerDataReceivedEventArgs[] = {
        { "_from", (PyCFunction)_from_BarcodeScannerDataReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BarcodeScannerDataReceivedEventArgs[] = {
        { const_cast<char*>("report"), (getter)BarcodeScannerDataReceivedEventArgs_get_Report, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BarcodeScannerDataReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_BarcodeScannerDataReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_BarcodeScannerDataReceivedEventArgs },
        { Py_tp_methods, _methods_BarcodeScannerDataReceivedEventArgs },
        { Py_tp_getset, _getset_BarcodeScannerDataReceivedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BarcodeScannerDataReceivedEventArgs =
    {
        "_winrt_Windows_Devices_PointOfService.BarcodeScannerDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerDataReceivedEventArgs
    };

    // ----- BarcodeScannerErrorOccurredEventArgs class --------------------
    constexpr const char* const _type_name_BarcodeScannerErrorOccurredEventArgs = "BarcodeScannerErrorOccurredEventArgs";

    static PyObject* _new_BarcodeScannerErrorOccurredEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BarcodeScannerErrorOccurredEventArgs);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerErrorOccurredEventArgs(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BarcodeScannerErrorOccurredEventArgs_get_ErrorData(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerErrorOccurredEventArgs_get_IsRetriable(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRetriable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerErrorOccurredEventArgs_get_PartialInputData(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PartialInputData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BarcodeScannerErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerErrorOccurredEventArgs[] = {
        { "_from", (PyCFunction)_from_BarcodeScannerErrorOccurredEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BarcodeScannerErrorOccurredEventArgs[] = {
        { const_cast<char*>("error_data"), (getter)BarcodeScannerErrorOccurredEventArgs_get_ErrorData, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_retriable"), (getter)BarcodeScannerErrorOccurredEventArgs_get_IsRetriable, nullptr, nullptr, nullptr },
        { const_cast<char*>("partial_input_data"), (getter)BarcodeScannerErrorOccurredEventArgs_get_PartialInputData, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BarcodeScannerErrorOccurredEventArgs[] = 
    {
        { Py_tp_new, _new_BarcodeScannerErrorOccurredEventArgs },
        { Py_tp_dealloc, _dealloc_BarcodeScannerErrorOccurredEventArgs },
        { Py_tp_methods, _methods_BarcodeScannerErrorOccurredEventArgs },
        { Py_tp_getset, _getset_BarcodeScannerErrorOccurredEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BarcodeScannerErrorOccurredEventArgs =
    {
        "_winrt_Windows_Devices_PointOfService.BarcodeScannerErrorOccurredEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerErrorOccurredEventArgs
    };

    // ----- BarcodeScannerImagePreviewReceivedEventArgs class --------------------
    constexpr const char* const _type_name_BarcodeScannerImagePreviewReceivedEventArgs = "BarcodeScannerImagePreviewReceivedEventArgs";

    static PyObject* _new_BarcodeScannerImagePreviewReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BarcodeScannerImagePreviewReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerImagePreviewReceivedEventArgs(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BarcodeScannerImagePreviewReceivedEventArgs_get_Preview(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Preview());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BarcodeScannerImagePreviewReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerImagePreviewReceivedEventArgs[] = {
        { "_from", (PyCFunction)_from_BarcodeScannerImagePreviewReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BarcodeScannerImagePreviewReceivedEventArgs[] = {
        { const_cast<char*>("preview"), (getter)BarcodeScannerImagePreviewReceivedEventArgs_get_Preview, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BarcodeScannerImagePreviewReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_BarcodeScannerImagePreviewReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_BarcodeScannerImagePreviewReceivedEventArgs },
        { Py_tp_methods, _methods_BarcodeScannerImagePreviewReceivedEventArgs },
        { Py_tp_getset, _getset_BarcodeScannerImagePreviewReceivedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BarcodeScannerImagePreviewReceivedEventArgs =
    {
        "_winrt_Windows_Devices_PointOfService.BarcodeScannerImagePreviewReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerImagePreviewReceivedEventArgs
    };

    // ----- BarcodeScannerReport class --------------------
    constexpr const char* const _type_name_BarcodeScannerReport = "BarcodeScannerReport";

    static PyObject* _new_BarcodeScannerReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                winrt::Windows::Devices::PointOfService::BarcodeScannerReport instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BarcodeScannerReport(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerReport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BarcodeScannerReport_get_ScanData(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScanData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerReport_get_ScanDataLabel(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScanDataLabel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerReport_get_ScanDataType(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScanDataType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BarcodeScannerReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerReport[] = {
        { "_from", (PyCFunction)_from_BarcodeScannerReport, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BarcodeScannerReport[] = {
        { const_cast<char*>("scan_data"), (getter)BarcodeScannerReport_get_ScanData, nullptr, nullptr, nullptr },
        { const_cast<char*>("scan_data_label"), (getter)BarcodeScannerReport_get_ScanDataLabel, nullptr, nullptr, nullptr },
        { const_cast<char*>("scan_data_type"), (getter)BarcodeScannerReport_get_ScanDataType, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BarcodeScannerReport[] = 
    {
        { Py_tp_new, _new_BarcodeScannerReport },
        { Py_tp_dealloc, _dealloc_BarcodeScannerReport },
        { Py_tp_methods, _methods_BarcodeScannerReport },
        { Py_tp_getset, _getset_BarcodeScannerReport },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BarcodeScannerReport =
    {
        "_winrt_Windows_Devices_PointOfService.BarcodeScannerReport",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerReport
    };

    // ----- BarcodeScannerStatusUpdatedEventArgs class --------------------
    constexpr const char* const _type_name_BarcodeScannerStatusUpdatedEventArgs = "BarcodeScannerStatusUpdatedEventArgs";

    static PyObject* _new_BarcodeScannerStatusUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BarcodeScannerStatusUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerStatusUpdatedEventArgs(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BarcodeScannerStatusUpdatedEventArgs_get_ExtendedStatus(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerStatusUpdatedEventArgs_get_Status(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BarcodeScannerStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerStatusUpdatedEventArgs[] = {
        { "_from", (PyCFunction)_from_BarcodeScannerStatusUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BarcodeScannerStatusUpdatedEventArgs[] = {
        { const_cast<char*>("extended_status"), (getter)BarcodeScannerStatusUpdatedEventArgs_get_ExtendedStatus, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)BarcodeScannerStatusUpdatedEventArgs_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BarcodeScannerStatusUpdatedEventArgs[] = 
    {
        { Py_tp_new, _new_BarcodeScannerStatusUpdatedEventArgs },
        { Py_tp_dealloc, _dealloc_BarcodeScannerStatusUpdatedEventArgs },
        { Py_tp_methods, _methods_BarcodeScannerStatusUpdatedEventArgs },
        { Py_tp_getset, _getset_BarcodeScannerStatusUpdatedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BarcodeScannerStatusUpdatedEventArgs =
    {
        "_winrt_Windows_Devices_PointOfService.BarcodeScannerStatusUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerStatusUpdatedEventArgs
    };

    // ----- BarcodeSymbologies class --------------------
    constexpr const char* const _type_name_BarcodeSymbologies = "BarcodeSymbologies";

    static PyObject* _new_BarcodeSymbologies(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BarcodeSymbologies);
        return nullptr;
    }

    static PyObject* BarcodeSymbologies_GetName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::GetName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code11(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code11());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_AusPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::AusPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Aztec(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Aztec());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_CanPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::CanPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ccab(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ccab());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ccc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ccc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_ChinaPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::ChinaPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Codabar(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Codabar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Codablock128(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Codablock128());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_CodablockA(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::CodablockA());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_CodablockF(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::CodablockF());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_DutchKix(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::DutchKix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code128(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code128());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code16k(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code16k());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code32(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code32());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code39(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code39());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code39Ex(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code39Ex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code49(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code49());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code93(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code93());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code93Ex(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code93Ex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_DataCode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::DataCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_DataMatrix(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::DataMatrix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UsPostNet(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UsPostNet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean13(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean13());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean13Add2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean13Add2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean13Add5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean13Add5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean8Add2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean8Add2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean8Add5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean8Add5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean99(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean99());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean99Add2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean99Add2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean99Add5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean99Add5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Eanv(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Eanv());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_EanvAdd2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::EanvAdd2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_EanvAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::EanvAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_ExtendedBase(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::ExtendedBase());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1128(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1128());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1128Coupon(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1128Coupon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1DatabarType1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1DatabarType1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1DatabarType2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1DatabarType2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1DatabarType3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1DatabarType3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_HanXin(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::HanXin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_InfoMail(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::InfoMail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Isbn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Isbn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_IsbnAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::IsbnAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Isbt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Isbt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ismn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ismn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_IsmnAdd2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::IsmnAdd2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_IsmnAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::IsmnAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Issn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Issn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_IssnAdd2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::IssnAdd2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_IssnAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::IssnAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_ItalianPost25(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::ItalianPost25());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_ItalianPost39(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::ItalianPost39());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_JapanPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::JapanPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_KoreanPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::KoreanPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Maxicode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Maxicode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Micr(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Micr());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_MicroPdf417(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::MicroPdf417());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_MicroQr(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::MicroQr());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_MsTag(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::MsTag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Msi(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Msi());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_OcrA(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::OcrA());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_OcrB(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::OcrB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Pdf417(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Pdf417());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Plessey(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Plessey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Pzn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Pzn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Qr(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Qr());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Sisac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Sisac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_SwedenPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::SwedenPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Telepen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Telepen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfDis(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfDis());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfIata(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfIata());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfInd(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfInd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfInt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfInt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfMat(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfMat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfStd(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfStd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Tlc39(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Tlc39());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Trioptic39(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Trioptic39());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UccEan128(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UccEan128());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UkPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UkPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Unknown(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Unknown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UpcCoupon(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UpcCoupon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Upca(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Upca());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UpcaAdd2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UpcaAdd2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UpcaAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UpcaAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Upce(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Upce());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UpceAdd2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UpceAdd2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UpceAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UpceAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Us4StateFics(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Us4StateFics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UsIntelligent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UsIntelligent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UsIntelligentPkg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UsIntelligentPkg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UsPlanet(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UsPlanet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1DWCode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1DWCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeSymbologies[] = {
        { "get_name", (PyCFunction)BarcodeSymbologies_GetName, METH_VARARGS | METH_STATIC, nullptr },
        { "get_code11", (PyCFunction)BarcodeSymbologies_get_Code11, METH_NOARGS | METH_STATIC, nullptr },
        { "get_aus_post", (PyCFunction)BarcodeSymbologies_get_AusPost, METH_NOARGS | METH_STATIC, nullptr },
        { "get_aztec", (PyCFunction)BarcodeSymbologies_get_Aztec, METH_NOARGS | METH_STATIC, nullptr },
        { "get_can_post", (PyCFunction)BarcodeSymbologies_get_CanPost, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ccab", (PyCFunction)BarcodeSymbologies_get_Ccab, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ccc", (PyCFunction)BarcodeSymbologies_get_Ccc, METH_NOARGS | METH_STATIC, nullptr },
        { "get_china_post", (PyCFunction)BarcodeSymbologies_get_ChinaPost, METH_NOARGS | METH_STATIC, nullptr },
        { "get_codabar", (PyCFunction)BarcodeSymbologies_get_Codabar, METH_NOARGS | METH_STATIC, nullptr },
        { "get_codablock128", (PyCFunction)BarcodeSymbologies_get_Codablock128, METH_NOARGS | METH_STATIC, nullptr },
        { "get_codablock_a", (PyCFunction)BarcodeSymbologies_get_CodablockA, METH_NOARGS | METH_STATIC, nullptr },
        { "get_codablock_f", (PyCFunction)BarcodeSymbologies_get_CodablockF, METH_NOARGS | METH_STATIC, nullptr },
        { "get_dutch_kix", (PyCFunction)BarcodeSymbologies_get_DutchKix, METH_NOARGS | METH_STATIC, nullptr },
        { "get_code128", (PyCFunction)BarcodeSymbologies_get_Code128, METH_NOARGS | METH_STATIC, nullptr },
        { "get_code16k", (PyCFunction)BarcodeSymbologies_get_Code16k, METH_NOARGS | METH_STATIC, nullptr },
        { "get_code32", (PyCFunction)BarcodeSymbologies_get_Code32, METH_NOARGS | METH_STATIC, nullptr },
        { "get_code39", (PyCFunction)BarcodeSymbologies_get_Code39, METH_NOARGS | METH_STATIC, nullptr },
        { "get_code39_ex", (PyCFunction)BarcodeSymbologies_get_Code39Ex, METH_NOARGS | METH_STATIC, nullptr },
        { "get_code49", (PyCFunction)BarcodeSymbologies_get_Code49, METH_NOARGS | METH_STATIC, nullptr },
        { "get_code93", (PyCFunction)BarcodeSymbologies_get_Code93, METH_NOARGS | METH_STATIC, nullptr },
        { "get_code93_ex", (PyCFunction)BarcodeSymbologies_get_Code93Ex, METH_NOARGS | METH_STATIC, nullptr },
        { "get_data_code", (PyCFunction)BarcodeSymbologies_get_DataCode, METH_NOARGS | METH_STATIC, nullptr },
        { "get_data_matrix", (PyCFunction)BarcodeSymbologies_get_DataMatrix, METH_NOARGS | METH_STATIC, nullptr },
        { "get_us_post_net", (PyCFunction)BarcodeSymbologies_get_UsPostNet, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ean13", (PyCFunction)BarcodeSymbologies_get_Ean13, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ean13_add2", (PyCFunction)BarcodeSymbologies_get_Ean13Add2, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ean13_add5", (PyCFunction)BarcodeSymbologies_get_Ean13Add5, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ean8", (PyCFunction)BarcodeSymbologies_get_Ean8, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ean8_add2", (PyCFunction)BarcodeSymbologies_get_Ean8Add2, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ean8_add5", (PyCFunction)BarcodeSymbologies_get_Ean8Add5, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ean99", (PyCFunction)BarcodeSymbologies_get_Ean99, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ean99_add2", (PyCFunction)BarcodeSymbologies_get_Ean99Add2, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ean99_add5", (PyCFunction)BarcodeSymbologies_get_Ean99Add5, METH_NOARGS | METH_STATIC, nullptr },
        { "get_eanv", (PyCFunction)BarcodeSymbologies_get_Eanv, METH_NOARGS | METH_STATIC, nullptr },
        { "get_eanv_add2", (PyCFunction)BarcodeSymbologies_get_EanvAdd2, METH_NOARGS | METH_STATIC, nullptr },
        { "get_eanv_add5", (PyCFunction)BarcodeSymbologies_get_EanvAdd5, METH_NOARGS | METH_STATIC, nullptr },
        { "get_extended_base", (PyCFunction)BarcodeSymbologies_get_ExtendedBase, METH_NOARGS | METH_STATIC, nullptr },
        { "get_gs1128", (PyCFunction)BarcodeSymbologies_get_Gs1128, METH_NOARGS | METH_STATIC, nullptr },
        { "get_gs1128_coupon", (PyCFunction)BarcodeSymbologies_get_Gs1128Coupon, METH_NOARGS | METH_STATIC, nullptr },
        { "get_gs1_databar_type1", (PyCFunction)BarcodeSymbologies_get_Gs1DatabarType1, METH_NOARGS | METH_STATIC, nullptr },
        { "get_gs1_databar_type2", (PyCFunction)BarcodeSymbologies_get_Gs1DatabarType2, METH_NOARGS | METH_STATIC, nullptr },
        { "get_gs1_databar_type3", (PyCFunction)BarcodeSymbologies_get_Gs1DatabarType3, METH_NOARGS | METH_STATIC, nullptr },
        { "get_han_xin", (PyCFunction)BarcodeSymbologies_get_HanXin, METH_NOARGS | METH_STATIC, nullptr },
        { "get_info_mail", (PyCFunction)BarcodeSymbologies_get_InfoMail, METH_NOARGS | METH_STATIC, nullptr },
        { "get_isbn", (PyCFunction)BarcodeSymbologies_get_Isbn, METH_NOARGS | METH_STATIC, nullptr },
        { "get_isbn_add5", (PyCFunction)BarcodeSymbologies_get_IsbnAdd5, METH_NOARGS | METH_STATIC, nullptr },
        { "get_isbt", (PyCFunction)BarcodeSymbologies_get_Isbt, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ismn", (PyCFunction)BarcodeSymbologies_get_Ismn, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ismn_add2", (PyCFunction)BarcodeSymbologies_get_IsmnAdd2, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ismn_add5", (PyCFunction)BarcodeSymbologies_get_IsmnAdd5, METH_NOARGS | METH_STATIC, nullptr },
        { "get_issn", (PyCFunction)BarcodeSymbologies_get_Issn, METH_NOARGS | METH_STATIC, nullptr },
        { "get_issn_add2", (PyCFunction)BarcodeSymbologies_get_IssnAdd2, METH_NOARGS | METH_STATIC, nullptr },
        { "get_issn_add5", (PyCFunction)BarcodeSymbologies_get_IssnAdd5, METH_NOARGS | METH_STATIC, nullptr },
        { "get_italian_post25", (PyCFunction)BarcodeSymbologies_get_ItalianPost25, METH_NOARGS | METH_STATIC, nullptr },
        { "get_italian_post39", (PyCFunction)BarcodeSymbologies_get_ItalianPost39, METH_NOARGS | METH_STATIC, nullptr },
        { "get_japan_post", (PyCFunction)BarcodeSymbologies_get_JapanPost, METH_NOARGS | METH_STATIC, nullptr },
        { "get_korean_post", (PyCFunction)BarcodeSymbologies_get_KoreanPost, METH_NOARGS | METH_STATIC, nullptr },
        { "get_maxicode", (PyCFunction)BarcodeSymbologies_get_Maxicode, METH_NOARGS | METH_STATIC, nullptr },
        { "get_micr", (PyCFunction)BarcodeSymbologies_get_Micr, METH_NOARGS | METH_STATIC, nullptr },
        { "get_micro_pdf417", (PyCFunction)BarcodeSymbologies_get_MicroPdf417, METH_NOARGS | METH_STATIC, nullptr },
        { "get_micro_qr", (PyCFunction)BarcodeSymbologies_get_MicroQr, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ms_tag", (PyCFunction)BarcodeSymbologies_get_MsTag, METH_NOARGS | METH_STATIC, nullptr },
        { "get_msi", (PyCFunction)BarcodeSymbologies_get_Msi, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ocr_a", (PyCFunction)BarcodeSymbologies_get_OcrA, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ocr_b", (PyCFunction)BarcodeSymbologies_get_OcrB, METH_NOARGS | METH_STATIC, nullptr },
        { "get_pdf417", (PyCFunction)BarcodeSymbologies_get_Pdf417, METH_NOARGS | METH_STATIC, nullptr },
        { "get_plessey", (PyCFunction)BarcodeSymbologies_get_Plessey, METH_NOARGS | METH_STATIC, nullptr },
        { "get_pzn", (PyCFunction)BarcodeSymbologies_get_Pzn, METH_NOARGS | METH_STATIC, nullptr },
        { "get_qr", (PyCFunction)BarcodeSymbologies_get_Qr, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sisac", (PyCFunction)BarcodeSymbologies_get_Sisac, METH_NOARGS | METH_STATIC, nullptr },
        { "get_sweden_post", (PyCFunction)BarcodeSymbologies_get_SwedenPost, METH_NOARGS | METH_STATIC, nullptr },
        { "get_telepen", (PyCFunction)BarcodeSymbologies_get_Telepen, METH_NOARGS | METH_STATIC, nullptr },
        { "get_tf_dis", (PyCFunction)BarcodeSymbologies_get_TfDis, METH_NOARGS | METH_STATIC, nullptr },
        { "get_tf_iata", (PyCFunction)BarcodeSymbologies_get_TfIata, METH_NOARGS | METH_STATIC, nullptr },
        { "get_tf_ind", (PyCFunction)BarcodeSymbologies_get_TfInd, METH_NOARGS | METH_STATIC, nullptr },
        { "get_tf_int", (PyCFunction)BarcodeSymbologies_get_TfInt, METH_NOARGS | METH_STATIC, nullptr },
        { "get_tf_mat", (PyCFunction)BarcodeSymbologies_get_TfMat, METH_NOARGS | METH_STATIC, nullptr },
        { "get_tf_std", (PyCFunction)BarcodeSymbologies_get_TfStd, METH_NOARGS | METH_STATIC, nullptr },
        { "get_tlc39", (PyCFunction)BarcodeSymbologies_get_Tlc39, METH_NOARGS | METH_STATIC, nullptr },
        { "get_trioptic39", (PyCFunction)BarcodeSymbologies_get_Trioptic39, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ucc_ean128", (PyCFunction)BarcodeSymbologies_get_UccEan128, METH_NOARGS | METH_STATIC, nullptr },
        { "get_uk_post", (PyCFunction)BarcodeSymbologies_get_UkPost, METH_NOARGS | METH_STATIC, nullptr },
        { "get_unknown", (PyCFunction)BarcodeSymbologies_get_Unknown, METH_NOARGS | METH_STATIC, nullptr },
        { "get_upc_coupon", (PyCFunction)BarcodeSymbologies_get_UpcCoupon, METH_NOARGS | METH_STATIC, nullptr },
        { "get_upca", (PyCFunction)BarcodeSymbologies_get_Upca, METH_NOARGS | METH_STATIC, nullptr },
        { "get_upca_add2", (PyCFunction)BarcodeSymbologies_get_UpcaAdd2, METH_NOARGS | METH_STATIC, nullptr },
        { "get_upca_add5", (PyCFunction)BarcodeSymbologies_get_UpcaAdd5, METH_NOARGS | METH_STATIC, nullptr },
        { "get_upce", (PyCFunction)BarcodeSymbologies_get_Upce, METH_NOARGS | METH_STATIC, nullptr },
        { "get_upce_add2", (PyCFunction)BarcodeSymbologies_get_UpceAdd2, METH_NOARGS | METH_STATIC, nullptr },
        { "get_upce_add5", (PyCFunction)BarcodeSymbologies_get_UpceAdd5, METH_NOARGS | METH_STATIC, nullptr },
        { "get_us4_state_fics", (PyCFunction)BarcodeSymbologies_get_Us4StateFics, METH_NOARGS | METH_STATIC, nullptr },
        { "get_us_intelligent", (PyCFunction)BarcodeSymbologies_get_UsIntelligent, METH_NOARGS | METH_STATIC, nullptr },
        { "get_us_intelligent_pkg", (PyCFunction)BarcodeSymbologies_get_UsIntelligentPkg, METH_NOARGS | METH_STATIC, nullptr },
        { "get_us_planet", (PyCFunction)BarcodeSymbologies_get_UsPlanet, METH_NOARGS | METH_STATIC, nullptr },
        { "get_gs1_d_w_code", (PyCFunction)BarcodeSymbologies_get_Gs1DWCode, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BarcodeSymbologies[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_BarcodeSymbologies[] = 
    {
        { Py_tp_new, _new_BarcodeSymbologies },
        { Py_tp_methods, _methods_BarcodeSymbologies },
        { Py_tp_getset, _getset_BarcodeSymbologies },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BarcodeSymbologies =
    {
        "_winrt_Windows_Devices_PointOfService.BarcodeSymbologies",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeSymbologies
    };

    // ----- BarcodeSymbologyAttributes class --------------------
    constexpr const char* const _type_name_BarcodeSymbologyAttributes = "BarcodeSymbologyAttributes";

    static PyObject* _new_BarcodeSymbologyAttributes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BarcodeSymbologyAttributes);
        return nullptr;
    }

    static void _dealloc_BarcodeSymbologyAttributes(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BarcodeSymbologyAttributes_get_IsCheckDigitValidationEnabled(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCheckDigitValidationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarcodeSymbologyAttributes_put_IsCheckDigitValidationEnabled(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCheckDigitValidationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_IsCheckDigitTransmissionEnabled(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCheckDigitTransmissionEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarcodeSymbologyAttributes_put_IsCheckDigitTransmissionEnabled(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCheckDigitTransmissionEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_DecodeLengthKind(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecodeLengthKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarcodeSymbologyAttributes_put_DecodeLengthKind(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::BarcodeSymbologyDecodeLengthKind>(arg);

            self->obj.DecodeLengthKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_DecodeLength2(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecodeLength2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarcodeSymbologyAttributes_put_DecodeLength2(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DecodeLength2(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_DecodeLength1(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecodeLength1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarcodeSymbologyAttributes_put_DecodeLength1(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DecodeLength1(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_IsCheckDigitTransmissionSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCheckDigitTransmissionSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_IsCheckDigitValidationSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCheckDigitValidationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_IsDecodeLengthSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDecodeLengthSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BarcodeSymbologyAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeSymbologyAttributes>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeSymbologyAttributes[] = {
        { "_from", (PyCFunction)_from_BarcodeSymbologyAttributes, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BarcodeSymbologyAttributes[] = {
        { const_cast<char*>("is_check_digit_validation_enabled"), (getter)BarcodeSymbologyAttributes_get_IsCheckDigitValidationEnabled, (setter)BarcodeSymbologyAttributes_put_IsCheckDigitValidationEnabled, nullptr, nullptr },
        { const_cast<char*>("is_check_digit_transmission_enabled"), (getter)BarcodeSymbologyAttributes_get_IsCheckDigitTransmissionEnabled, (setter)BarcodeSymbologyAttributes_put_IsCheckDigitTransmissionEnabled, nullptr, nullptr },
        { const_cast<char*>("decode_length_kind"), (getter)BarcodeSymbologyAttributes_get_DecodeLengthKind, (setter)BarcodeSymbologyAttributes_put_DecodeLengthKind, nullptr, nullptr },
        { const_cast<char*>("decode_length2"), (getter)BarcodeSymbologyAttributes_get_DecodeLength2, (setter)BarcodeSymbologyAttributes_put_DecodeLength2, nullptr, nullptr },
        { const_cast<char*>("decode_length1"), (getter)BarcodeSymbologyAttributes_get_DecodeLength1, (setter)BarcodeSymbologyAttributes_put_DecodeLength1, nullptr, nullptr },
        { const_cast<char*>("is_check_digit_transmission_supported"), (getter)BarcodeSymbologyAttributes_get_IsCheckDigitTransmissionSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_check_digit_validation_supported"), (getter)BarcodeSymbologyAttributes_get_IsCheckDigitValidationSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_decode_length_supported"), (getter)BarcodeSymbologyAttributes_get_IsDecodeLengthSupported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BarcodeSymbologyAttributes[] = 
    {
        { Py_tp_new, _new_BarcodeSymbologyAttributes },
        { Py_tp_dealloc, _dealloc_BarcodeSymbologyAttributes },
        { Py_tp_methods, _methods_BarcodeSymbologyAttributes },
        { Py_tp_getset, _getset_BarcodeSymbologyAttributes },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BarcodeSymbologyAttributes =
    {
        "_winrt_Windows_Devices_PointOfService.BarcodeSymbologyAttributes",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeSymbologyAttributes
    };

    // ----- CashDrawer class --------------------
    constexpr const char* const _type_name_CashDrawer = "CashDrawer";

    static PyObject* _new_CashDrawer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CashDrawer);
        return nullptr;
    }

    static void _dealloc_CashDrawer(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CashDrawer_CheckHealthAsync(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel>(args, 0);

                return py::convert(self->obj.CheckHealthAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_ClaimDrawerAsync(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClaimDrawerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_Close(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::CashDrawer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::CashDrawer::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::CashDrawer::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::CashDrawer::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_GetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_get_DrawerEventSource(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DrawerEventSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_get_IsDrawerOpen(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDrawerOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_get_Status(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_add_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::CashDrawer, winrt::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs>>(arg);

            return py::convert(self->obj.StatusUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_remove_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CashDrawer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_CashDrawer(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_CashDrawer(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawer[] = {
        { "check_health_async", (PyCFunction)CashDrawer_CheckHealthAsync, METH_VARARGS, nullptr },
        { "claim_drawer_async", (PyCFunction)CashDrawer_ClaimDrawerAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)CashDrawer_Close, METH_VARARGS, nullptr },
        { "from_id_async", (PyCFunction)CashDrawer_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_async", (PyCFunction)CashDrawer_GetDefaultAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)CashDrawer_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "get_statistics_async", (PyCFunction)CashDrawer_GetStatisticsAsync, METH_VARARGS, nullptr },
        { "add_status_updated", (PyCFunction)CashDrawer_add_StatusUpdated, METH_O, nullptr },
        { "remove_status_updated", (PyCFunction)CashDrawer_remove_StatusUpdated, METH_O, nullptr },
        { "_from", (PyCFunction)_from_CashDrawer, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_CashDrawer, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_CashDrawer, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CashDrawer[] = {
        { const_cast<char*>("capabilities"), (getter)CashDrawer_get_Capabilities, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)CashDrawer_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("drawer_event_source"), (getter)CashDrawer_get_DrawerEventSource, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_drawer_open"), (getter)CashDrawer_get_IsDrawerOpen, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)CashDrawer_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CashDrawer[] = 
    {
        { Py_tp_new, _new_CashDrawer },
        { Py_tp_dealloc, _dealloc_CashDrawer },
        { Py_tp_methods, _methods_CashDrawer },
        { Py_tp_getset, _getset_CashDrawer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CashDrawer =
    {
        "_winrt_Windows_Devices_PointOfService.CashDrawer",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawer
    };

    // ----- CashDrawerCapabilities class --------------------
    constexpr const char* const _type_name_CashDrawerCapabilities = "CashDrawerCapabilities";

    static PyObject* _new_CashDrawerCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CashDrawerCapabilities);
        return nullptr;
    }

    static void _dealloc_CashDrawerCapabilities(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CashDrawerCapabilities_get_IsDrawerOpenSensorAvailable(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDrawerOpenSensorAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCapabilities_get_IsStatisticsReportingSupported(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatisticsReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCapabilities_get_IsStatisticsUpdatingSupported(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatisticsUpdatingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCapabilities_get_IsStatusMultiDrawerDetectSupported(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatusMultiDrawerDetectSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCapabilities_get_IsStatusReportingSupported(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatusReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCapabilities_get_PowerReportingType(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerReportingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CashDrawerCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerCapabilities[] = {
        { "_from", (PyCFunction)_from_CashDrawerCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CashDrawerCapabilities[] = {
        { const_cast<char*>("is_drawer_open_sensor_available"), (getter)CashDrawerCapabilities_get_IsDrawerOpenSensorAvailable, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_statistics_reporting_supported"), (getter)CashDrawerCapabilities_get_IsStatisticsReportingSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_statistics_updating_supported"), (getter)CashDrawerCapabilities_get_IsStatisticsUpdatingSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_status_multi_drawer_detect_supported"), (getter)CashDrawerCapabilities_get_IsStatusMultiDrawerDetectSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_status_reporting_supported"), (getter)CashDrawerCapabilities_get_IsStatusReportingSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("power_reporting_type"), (getter)CashDrawerCapabilities_get_PowerReportingType, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CashDrawerCapabilities[] = 
    {
        { Py_tp_new, _new_CashDrawerCapabilities },
        { Py_tp_dealloc, _dealloc_CashDrawerCapabilities },
        { Py_tp_methods, _methods_CashDrawerCapabilities },
        { Py_tp_getset, _getset_CashDrawerCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CashDrawerCapabilities =
    {
        "_winrt_Windows_Devices_PointOfService.CashDrawerCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerCapabilities
    };

    // ----- CashDrawerCloseAlarm class --------------------
    constexpr const char* const _type_name_CashDrawerCloseAlarm = "CashDrawerCloseAlarm";

    static PyObject* _new_CashDrawerCloseAlarm(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CashDrawerCloseAlarm);
        return nullptr;
    }

    static void _dealloc_CashDrawerCloseAlarm(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CashDrawerCloseAlarm_StartAsync(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawerCloseAlarm_get_BeepFrequency(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BeepFrequency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CashDrawerCloseAlarm_put_BeepFrequency(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.BeepFrequency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CashDrawerCloseAlarm_get_BeepDuration(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BeepDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CashDrawerCloseAlarm_put_BeepDuration(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.BeepDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CashDrawerCloseAlarm_get_BeepDelay(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BeepDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CashDrawerCloseAlarm_put_BeepDelay(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.BeepDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CashDrawerCloseAlarm_get_AlarmTimeout(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlarmTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CashDrawerCloseAlarm_put_AlarmTimeout(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.AlarmTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CashDrawerCloseAlarm_add_AlarmTimeoutExpired(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::CashDrawerCloseAlarm, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AlarmTimeoutExpired(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCloseAlarm_remove_AlarmTimeoutExpired(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AlarmTimeoutExpired(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CashDrawerCloseAlarm(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerCloseAlarm>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerCloseAlarm[] = {
        { "start_async", (PyCFunction)CashDrawerCloseAlarm_StartAsync, METH_VARARGS, nullptr },
        { "add_alarm_timeout_expired", (PyCFunction)CashDrawerCloseAlarm_add_AlarmTimeoutExpired, METH_O, nullptr },
        { "remove_alarm_timeout_expired", (PyCFunction)CashDrawerCloseAlarm_remove_AlarmTimeoutExpired, METH_O, nullptr },
        { "_from", (PyCFunction)_from_CashDrawerCloseAlarm, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CashDrawerCloseAlarm[] = {
        { const_cast<char*>("beep_frequency"), (getter)CashDrawerCloseAlarm_get_BeepFrequency, (setter)CashDrawerCloseAlarm_put_BeepFrequency, nullptr, nullptr },
        { const_cast<char*>("beep_duration"), (getter)CashDrawerCloseAlarm_get_BeepDuration, (setter)CashDrawerCloseAlarm_put_BeepDuration, nullptr, nullptr },
        { const_cast<char*>("beep_delay"), (getter)CashDrawerCloseAlarm_get_BeepDelay, (setter)CashDrawerCloseAlarm_put_BeepDelay, nullptr, nullptr },
        { const_cast<char*>("alarm_timeout"), (getter)CashDrawerCloseAlarm_get_AlarmTimeout, (setter)CashDrawerCloseAlarm_put_AlarmTimeout, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CashDrawerCloseAlarm[] = 
    {
        { Py_tp_new, _new_CashDrawerCloseAlarm },
        { Py_tp_dealloc, _dealloc_CashDrawerCloseAlarm },
        { Py_tp_methods, _methods_CashDrawerCloseAlarm },
        { Py_tp_getset, _getset_CashDrawerCloseAlarm },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CashDrawerCloseAlarm =
    {
        "_winrt_Windows_Devices_PointOfService.CashDrawerCloseAlarm",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerCloseAlarm
    };

    // ----- CashDrawerClosedEventArgs class --------------------
    constexpr const char* const _type_name_CashDrawerClosedEventArgs = "CashDrawerClosedEventArgs";

    static PyObject* _new_CashDrawerClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CashDrawerClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_CashDrawerClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::CashDrawerClosedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CashDrawerClosedEventArgs_get_CashDrawer(py::wrapper::Windows::Devices::PointOfService::CashDrawerClosedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CashDrawer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CashDrawerClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerClosedEventArgs[] = {
        { "_from", (PyCFunction)_from_CashDrawerClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CashDrawerClosedEventArgs[] = {
        { const_cast<char*>("cash_drawer"), (getter)CashDrawerClosedEventArgs_get_CashDrawer, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CashDrawerClosedEventArgs[] = 
    {
        { Py_tp_new, _new_CashDrawerClosedEventArgs },
        { Py_tp_dealloc, _dealloc_CashDrawerClosedEventArgs },
        { Py_tp_methods, _methods_CashDrawerClosedEventArgs },
        { Py_tp_getset, _getset_CashDrawerClosedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CashDrawerClosedEventArgs =
    {
        "_winrt_Windows_Devices_PointOfService.CashDrawerClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerClosedEventArgs
    };

    // ----- CashDrawerEventSource class --------------------
    constexpr const char* const _type_name_CashDrawerEventSource = "CashDrawerEventSource";

    static PyObject* _new_CashDrawerEventSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CashDrawerEventSource);
        return nullptr;
    }

    static void _dealloc_CashDrawerEventSource(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CashDrawerEventSource_add_DrawerClosed(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::CashDrawerEventSource, winrt::Windows::Devices::PointOfService::CashDrawerClosedEventArgs>>(arg);

            return py::convert(self->obj.DrawerClosed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerEventSource_remove_DrawerClosed(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DrawerClosed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerEventSource_add_DrawerOpened(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::CashDrawerEventSource, winrt::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs>>(arg);

            return py::convert(self->obj.DrawerOpened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerEventSource_remove_DrawerOpened(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DrawerOpened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CashDrawerEventSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerEventSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerEventSource[] = {
        { "add_drawer_closed", (PyCFunction)CashDrawerEventSource_add_DrawerClosed, METH_O, nullptr },
        { "remove_drawer_closed", (PyCFunction)CashDrawerEventSource_remove_DrawerClosed, METH_O, nullptr },
        { "add_drawer_opened", (PyCFunction)CashDrawerEventSource_add_DrawerOpened, METH_O, nullptr },
        { "remove_drawer_opened", (PyCFunction)CashDrawerEventSource_remove_DrawerOpened, METH_O, nullptr },
        { "_from", (PyCFunction)_from_CashDrawerEventSource, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CashDrawerEventSource[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_CashDrawerEventSource[] = 
    {
        { Py_tp_new, _new_CashDrawerEventSource },
        { Py_tp_dealloc, _dealloc_CashDrawerEventSource },
        { Py_tp_methods, _methods_CashDrawerEventSource },
        { Py_tp_getset, _getset_CashDrawerEventSource },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CashDrawerEventSource =
    {
        "_winrt_Windows_Devices_PointOfService.CashDrawerEventSource",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerEventSource
    };

    // ----- CashDrawerOpenedEventArgs class --------------------
    constexpr const char* const _type_name_CashDrawerOpenedEventArgs = "CashDrawerOpenedEventArgs";

    static PyObject* _new_CashDrawerOpenedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CashDrawerOpenedEventArgs);
        return nullptr;
    }

    static void _dealloc_CashDrawerOpenedEventArgs(py::wrapper::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CashDrawerOpenedEventArgs_get_CashDrawer(py::wrapper::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CashDrawer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CashDrawerOpenedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerOpenedEventArgs[] = {
        { "_from", (PyCFunction)_from_CashDrawerOpenedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CashDrawerOpenedEventArgs[] = {
        { const_cast<char*>("cash_drawer"), (getter)CashDrawerOpenedEventArgs_get_CashDrawer, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CashDrawerOpenedEventArgs[] = 
    {
        { Py_tp_new, _new_CashDrawerOpenedEventArgs },
        { Py_tp_dealloc, _dealloc_CashDrawerOpenedEventArgs },
        { Py_tp_methods, _methods_CashDrawerOpenedEventArgs },
        { Py_tp_getset, _getset_CashDrawerOpenedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CashDrawerOpenedEventArgs =
    {
        "_winrt_Windows_Devices_PointOfService.CashDrawerOpenedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerOpenedEventArgs
    };

    // ----- CashDrawerStatus class --------------------
    constexpr const char* const _type_name_CashDrawerStatus = "CashDrawerStatus";

    static PyObject* _new_CashDrawerStatus(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CashDrawerStatus);
        return nullptr;
    }

    static void _dealloc_CashDrawerStatus(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatus* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CashDrawerStatus_get_ExtendedStatus(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerStatus_get_StatusKind(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StatusKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CashDrawerStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerStatus[] = {
        { "_from", (PyCFunction)_from_CashDrawerStatus, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CashDrawerStatus[] = {
        { const_cast<char*>("extended_status"), (getter)CashDrawerStatus_get_ExtendedStatus, nullptr, nullptr, nullptr },
        { const_cast<char*>("status_kind"), (getter)CashDrawerStatus_get_StatusKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CashDrawerStatus[] = 
    {
        { Py_tp_new, _new_CashDrawerStatus },
        { Py_tp_dealloc, _dealloc_CashDrawerStatus },
        { Py_tp_methods, _methods_CashDrawerStatus },
        { Py_tp_getset, _getset_CashDrawerStatus },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CashDrawerStatus =
    {
        "_winrt_Windows_Devices_PointOfService.CashDrawerStatus",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerStatus
    };

    // ----- CashDrawerStatusUpdatedEventArgs class --------------------
    constexpr const char* const _type_name_CashDrawerStatusUpdatedEventArgs = "CashDrawerStatusUpdatedEventArgs";

    static PyObject* _new_CashDrawerStatusUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CashDrawerStatusUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_CashDrawerStatusUpdatedEventArgs(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CashDrawerStatusUpdatedEventArgs_get_Status(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CashDrawerStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerStatusUpdatedEventArgs[] = {
        { "_from", (PyCFunction)_from_CashDrawerStatusUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CashDrawerStatusUpdatedEventArgs[] = {
        { const_cast<char*>("status"), (getter)CashDrawerStatusUpdatedEventArgs_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CashDrawerStatusUpdatedEventArgs[] = 
    {
        { Py_tp_new, _new_CashDrawerStatusUpdatedEventArgs },
        { Py_tp_dealloc, _dealloc_CashDrawerStatusUpdatedEventArgs },
        { Py_tp_methods, _methods_CashDrawerStatusUpdatedEventArgs },
        { Py_tp_getset, _getset_CashDrawerStatusUpdatedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CashDrawerStatusUpdatedEventArgs =
    {
        "_winrt_Windows_Devices_PointOfService.CashDrawerStatusUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerStatusUpdatedEventArgs
    };

    // ----- ClaimedBarcodeScanner class --------------------
    constexpr const char* const _type_name_ClaimedBarcodeScanner = "ClaimedBarcodeScanner";

    static PyObject* _new_ClaimedBarcodeScanner(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedBarcodeScanner);
        return nullptr;
    }

    static void _dealloc_ClaimedBarcodeScanner(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ClaimedBarcodeScanner_Close(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_DisableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DisableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_EnableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.EnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_GetSymbologyAttributesAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetSymbologyAttributesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_HideVideoPreview(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.HideVideoPreview();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_ResetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.ResetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_RetainDevice(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RetainDevice();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_SetActiveProfileAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetActiveProfileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_SetActiveSymbologiesAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint32_t>>(args, 0);

                return py::convert(self->obj.SetActiveSymbologiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_SetSymbologyAttributesAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::BarcodeSymbologyAttributes>(args, 1);

                return py::convert(self->obj.SetSymbologyAttributesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_ShowVideoPreviewAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ShowVideoPreviewAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_StartSoftwareTriggerAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartSoftwareTriggerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_StopSoftwareTriggerAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StopSoftwareTriggerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_UpdateStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);

                return py::convert(self->obj.UpdateStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_get_IsDisabledOnDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDisabledOnDataReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedBarcodeScanner_put_IsDisabledOnDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDisabledOnDataReceived(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedBarcodeScanner_get_IsDecodeDataEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDecodeDataEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedBarcodeScanner_put_IsDecodeDataEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDecodeDataEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedBarcodeScanner_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_get_IsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_get_IsVideoPreviewShownOnEnable(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVideoPreviewShownOnEnable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedBarcodeScanner_put_IsVideoPreviewShownOnEnable(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsVideoPreviewShownOnEnable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_DataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner, winrt::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs>>(arg);

            return py::convert(self->obj.DataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_DataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_ErrorOccurred(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner, winrt::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs>>(arg);

            return py::convert(self->obj.ErrorOccurred(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_ErrorOccurred(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ErrorOccurred(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_ImagePreviewReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner, winrt::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs>>(arg);

            return py::convert(self->obj.ImagePreviewReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_ImagePreviewReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ImagePreviewReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>>(arg);

            return py::convert(self->obj.ReleaseDeviceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReleaseDeviceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_TriggerPressed(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>>(arg);

            return py::convert(self->obj.TriggerPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_TriggerPressed(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TriggerPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_TriggerReleased(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>>(arg);

            return py::convert(self->obj.TriggerReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_TriggerReleased(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TriggerReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner, winrt::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ClaimedBarcodeScanner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ClaimedBarcodeScanner(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_ClaimedBarcodeScanner(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedBarcodeScanner[] = {
        { "close", (PyCFunction)ClaimedBarcodeScanner_Close, METH_VARARGS, nullptr },
        { "disable_async", (PyCFunction)ClaimedBarcodeScanner_DisableAsync, METH_VARARGS, nullptr },
        { "enable_async", (PyCFunction)ClaimedBarcodeScanner_EnableAsync, METH_VARARGS, nullptr },
        { "get_symbology_attributes_async", (PyCFunction)ClaimedBarcodeScanner_GetSymbologyAttributesAsync, METH_VARARGS, nullptr },
        { "hide_video_preview", (PyCFunction)ClaimedBarcodeScanner_HideVideoPreview, METH_VARARGS, nullptr },
        { "reset_statistics_async", (PyCFunction)ClaimedBarcodeScanner_ResetStatisticsAsync, METH_VARARGS, nullptr },
        { "retain_device", (PyCFunction)ClaimedBarcodeScanner_RetainDevice, METH_VARARGS, nullptr },
        { "set_active_profile_async", (PyCFunction)ClaimedBarcodeScanner_SetActiveProfileAsync, METH_VARARGS, nullptr },
        { "set_active_symbologies_async", (PyCFunction)ClaimedBarcodeScanner_SetActiveSymbologiesAsync, METH_VARARGS, nullptr },
        { "set_symbology_attributes_async", (PyCFunction)ClaimedBarcodeScanner_SetSymbologyAttributesAsync, METH_VARARGS, nullptr },
        { "show_video_preview_async", (PyCFunction)ClaimedBarcodeScanner_ShowVideoPreviewAsync, METH_VARARGS, nullptr },
        { "start_software_trigger_async", (PyCFunction)ClaimedBarcodeScanner_StartSoftwareTriggerAsync, METH_VARARGS, nullptr },
        { "stop_software_trigger_async", (PyCFunction)ClaimedBarcodeScanner_StopSoftwareTriggerAsync, METH_VARARGS, nullptr },
        { "update_statistics_async", (PyCFunction)ClaimedBarcodeScanner_UpdateStatisticsAsync, METH_VARARGS, nullptr },
        { "add_data_received", (PyCFunction)ClaimedBarcodeScanner_add_DataReceived, METH_O, nullptr },
        { "remove_data_received", (PyCFunction)ClaimedBarcodeScanner_remove_DataReceived, METH_O, nullptr },
        { "add_error_occurred", (PyCFunction)ClaimedBarcodeScanner_add_ErrorOccurred, METH_O, nullptr },
        { "remove_error_occurred", (PyCFunction)ClaimedBarcodeScanner_remove_ErrorOccurred, METH_O, nullptr },
        { "add_image_preview_received", (PyCFunction)ClaimedBarcodeScanner_add_ImagePreviewReceived, METH_O, nullptr },
        { "remove_image_preview_received", (PyCFunction)ClaimedBarcodeScanner_remove_ImagePreviewReceived, METH_O, nullptr },
        { "add_release_device_requested", (PyCFunction)ClaimedBarcodeScanner_add_ReleaseDeviceRequested, METH_O, nullptr },
        { "remove_release_device_requested", (PyCFunction)ClaimedBarcodeScanner_remove_ReleaseDeviceRequested, METH_O, nullptr },
        { "add_trigger_pressed", (PyCFunction)ClaimedBarcodeScanner_add_TriggerPressed, METH_O, nullptr },
        { "remove_trigger_pressed", (PyCFunction)ClaimedBarcodeScanner_remove_TriggerPressed, METH_O, nullptr },
        { "add_trigger_released", (PyCFunction)ClaimedBarcodeScanner_add_TriggerReleased, METH_O, nullptr },
        { "remove_trigger_released", (PyCFunction)ClaimedBarcodeScanner_remove_TriggerReleased, METH_O, nullptr },
        { "add_closed", (PyCFunction)ClaimedBarcodeScanner_add_Closed, METH_O, nullptr },
        { "remove_closed", (PyCFunction)ClaimedBarcodeScanner_remove_Closed, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ClaimedBarcodeScanner, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_ClaimedBarcodeScanner, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_ClaimedBarcodeScanner, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ClaimedBarcodeScanner[] = {
        { const_cast<char*>("is_disabled_on_data_received"), (getter)ClaimedBarcodeScanner_get_IsDisabledOnDataReceived, (setter)ClaimedBarcodeScanner_put_IsDisabledOnDataReceived, nullptr, nullptr },
        { const_cast<char*>("is_decode_data_enabled"), (getter)ClaimedBarcodeScanner_get_IsDecodeDataEnabled, (setter)ClaimedBarcodeScanner_put_IsDecodeDataEnabled, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)ClaimedBarcodeScanner_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_enabled"), (getter)ClaimedBarcodeScanner_get_IsEnabled, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_video_preview_shown_on_enable"), (getter)ClaimedBarcodeScanner_get_IsVideoPreviewShownOnEnable, (setter)ClaimedBarcodeScanner_put_IsVideoPreviewShownOnEnable, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ClaimedBarcodeScanner[] = 
    {
        { Py_tp_new, _new_ClaimedBarcodeScanner },
        { Py_tp_dealloc, _dealloc_ClaimedBarcodeScanner },
        { Py_tp_methods, _methods_ClaimedBarcodeScanner },
        { Py_tp_getset, _getset_ClaimedBarcodeScanner },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ClaimedBarcodeScanner =
    {
        "_winrt_Windows_Devices_PointOfService.ClaimedBarcodeScanner",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedBarcodeScanner
    };

    // ----- ClaimedBarcodeScannerClosedEventArgs class --------------------
    constexpr const char* const _type_name_ClaimedBarcodeScannerClosedEventArgs = "ClaimedBarcodeScannerClosedEventArgs";

    static PyObject* _new_ClaimedBarcodeScannerClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedBarcodeScannerClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_ClaimedBarcodeScannerClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ClaimedBarcodeScannerClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedBarcodeScannerClosedEventArgs[] = {
        { "_from", (PyCFunction)_from_ClaimedBarcodeScannerClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ClaimedBarcodeScannerClosedEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ClaimedBarcodeScannerClosedEventArgs[] = 
    {
        { Py_tp_new, _new_ClaimedBarcodeScannerClosedEventArgs },
        { Py_tp_dealloc, _dealloc_ClaimedBarcodeScannerClosedEventArgs },
        { Py_tp_methods, _methods_ClaimedBarcodeScannerClosedEventArgs },
        { Py_tp_getset, _getset_ClaimedBarcodeScannerClosedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ClaimedBarcodeScannerClosedEventArgs =
    {
        "_winrt_Windows_Devices_PointOfService.ClaimedBarcodeScannerClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedBarcodeScannerClosedEventArgs
    };

    // ----- ClaimedCashDrawer class --------------------
    constexpr const char* const _type_name_ClaimedCashDrawer = "ClaimedCashDrawer";

    static PyObject* _new_ClaimedCashDrawer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedCashDrawer);
        return nullptr;
    }

    static void _dealloc_ClaimedCashDrawer(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ClaimedCashDrawer_Close(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_DisableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DisableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_EnableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.EnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_OpenDrawerAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenDrawerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_ResetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.ResetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_RetainDeviceAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RetainDeviceAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_UpdateStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);

                return py::convert(self->obj.UpdateStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_get_CloseAlarm(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CloseAlarm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_get_IsDrawerOpen(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDrawerOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_get_IsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_add_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedCashDrawer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ReleaseDeviceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_remove_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReleaseDeviceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_add_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedCashDrawer, winrt::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_remove_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ClaimedCashDrawer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedCashDrawer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ClaimedCashDrawer(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_ClaimedCashDrawer(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedCashDrawer[] = {
        { "close", (PyCFunction)ClaimedCashDrawer_Close, METH_VARARGS, nullptr },
        { "disable_async", (PyCFunction)ClaimedCashDrawer_DisableAsync, METH_VARARGS, nullptr },
        { "enable_async", (PyCFunction)ClaimedCashDrawer_EnableAsync, METH_VARARGS, nullptr },
        { "open_drawer_async", (PyCFunction)ClaimedCashDrawer_OpenDrawerAsync, METH_VARARGS, nullptr },
        { "reset_statistics_async", (PyCFunction)ClaimedCashDrawer_ResetStatisticsAsync, METH_VARARGS, nullptr },
        { "retain_device_async", (PyCFunction)ClaimedCashDrawer_RetainDeviceAsync, METH_VARARGS, nullptr },
        { "update_statistics_async", (PyCFunction)ClaimedCashDrawer_UpdateStatisticsAsync, METH_VARARGS, nullptr },
        { "add_release_device_requested", (PyCFunction)ClaimedCashDrawer_add_ReleaseDeviceRequested, METH_O, nullptr },
        { "remove_release_device_requested", (PyCFunction)ClaimedCashDrawer_remove_ReleaseDeviceRequested, METH_O, nullptr },
        { "add_closed", (PyCFunction)ClaimedCashDrawer_add_Closed, METH_O, nullptr },
        { "remove_closed", (PyCFunction)ClaimedCashDrawer_remove_Closed, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ClaimedCashDrawer, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_ClaimedCashDrawer, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_ClaimedCashDrawer, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ClaimedCashDrawer[] = {
        { const_cast<char*>("close_alarm"), (getter)ClaimedCashDrawer_get_CloseAlarm, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)ClaimedCashDrawer_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_drawer_open"), (getter)ClaimedCashDrawer_get_IsDrawerOpen, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_enabled"), (getter)ClaimedCashDrawer_get_IsEnabled, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ClaimedCashDrawer[] = 
    {
        { Py_tp_new, _new_ClaimedCashDrawer },
        { Py_tp_dealloc, _dealloc_ClaimedCashDrawer },
        { Py_tp_methods, _methods_ClaimedCashDrawer },
        { Py_tp_getset, _getset_ClaimedCashDrawer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ClaimedCashDrawer =
    {
        "_winrt_Windows_Devices_PointOfService.ClaimedCashDrawer",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedCashDrawer
    };

    // ----- ClaimedCashDrawerClosedEventArgs class --------------------
    constexpr const char* const _type_name_ClaimedCashDrawerClosedEventArgs = "ClaimedCashDrawerClosedEventArgs";

    static PyObject* _new_ClaimedCashDrawerClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedCashDrawerClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_ClaimedCashDrawerClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ClaimedCashDrawerClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedCashDrawerClosedEventArgs[] = {
        { "_from", (PyCFunction)_from_ClaimedCashDrawerClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ClaimedCashDrawerClosedEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ClaimedCashDrawerClosedEventArgs[] = 
    {
        { Py_tp_new, _new_ClaimedCashDrawerClosedEventArgs },
        { Py_tp_dealloc, _dealloc_ClaimedCashDrawerClosedEventArgs },
        { Py_tp_methods, _methods_ClaimedCashDrawerClosedEventArgs },
        { Py_tp_getset, _getset_ClaimedCashDrawerClosedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ClaimedCashDrawerClosedEventArgs =
    {
        "_winrt_Windows_Devices_PointOfService.ClaimedCashDrawerClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedCashDrawerClosedEventArgs
    };

    // ----- ClaimedJournalPrinter class --------------------
    constexpr const char* const _type_name_ClaimedJournalPrinter = "ClaimedJournalPrinter";

    static PyObject* _new_ClaimedJournalPrinter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedJournalPrinter);
        return nullptr;
    }

    static void _dealloc_ClaimedJournalPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ClaimedJournalPrinter_CreateJob(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateJob());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_ValidateData(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ValidateData(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedJournalPrinter_put_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedJournalPrinter_put_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLetterQuality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedJournalPrinter_put_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLetterQuality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorCartridge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedJournalPrinter_put_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterColorCartridge>(arg);

            self->obj.ColorCartridge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedJournalPrinter_put_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharactersPerLine(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsCartridgeEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCartridgeEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsCartridgeRemoved(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCartridgeRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsCoverOpen(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCoverOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsHeadCleaning(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHeadCleaning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsPaperEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsPaperNearEnd(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperNearEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsReadyToPrint(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadyToPrint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_LineWidth(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ClaimedJournalPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedJournalPrinter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedJournalPrinter[] = {
        { "create_job", (PyCFunction)ClaimedJournalPrinter_CreateJob, METH_VARARGS, nullptr },
        { "validate_data", (PyCFunction)ClaimedJournalPrinter_ValidateData, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ClaimedJournalPrinter, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ClaimedJournalPrinter[] = {
        { const_cast<char*>("line_spacing"), (getter)ClaimedJournalPrinter_get_LineSpacing, (setter)ClaimedJournalPrinter_put_LineSpacing, nullptr, nullptr },
        { const_cast<char*>("line_height"), (getter)ClaimedJournalPrinter_get_LineHeight, (setter)ClaimedJournalPrinter_put_LineHeight, nullptr, nullptr },
        { const_cast<char*>("is_letter_quality"), (getter)ClaimedJournalPrinter_get_IsLetterQuality, (setter)ClaimedJournalPrinter_put_IsLetterQuality, nullptr, nullptr },
        { const_cast<char*>("color_cartridge"), (getter)ClaimedJournalPrinter_get_ColorCartridge, (setter)ClaimedJournalPrinter_put_ColorCartridge, nullptr, nullptr },
        { const_cast<char*>("characters_per_line"), (getter)ClaimedJournalPrinter_get_CharactersPerLine, (setter)ClaimedJournalPrinter_put_CharactersPerLine, nullptr, nullptr },
        { const_cast<char*>("is_cartridge_empty"), (getter)ClaimedJournalPrinter_get_IsCartridgeEmpty, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_cartridge_removed"), (getter)ClaimedJournalPrinter_get_IsCartridgeRemoved, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_cover_open"), (getter)ClaimedJournalPrinter_get_IsCoverOpen, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_head_cleaning"), (getter)ClaimedJournalPrinter_get_IsHeadCleaning, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_paper_empty"), (getter)ClaimedJournalPrinter_get_IsPaperEmpty, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_paper_near_end"), (getter)ClaimedJournalPrinter_get_IsPaperNearEnd, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_ready_to_print"), (getter)ClaimedJournalPrinter_get_IsReadyToPrint, nullptr, nullptr, nullptr },
        { const_cast<char*>("line_width"), (getter)ClaimedJournalPrinter_get_LineWidth, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ClaimedJournalPrinter[] = 
    {
        { Py_tp_new, _new_ClaimedJournalPrinter },
        { Py_tp_dealloc, _dealloc_ClaimedJournalPrinter },
        { Py_tp_methods, _methods_ClaimedJournalPrinter },
        { Py_tp_getset, _getset_ClaimedJournalPrinter },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ClaimedJournalPrinter =
    {
        "_winrt_Windows_Devices_PointOfService.ClaimedJournalPrinter",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedJournalPrinter
    };

    // ----- ClaimedLineDisplay class --------------------
    constexpr const char* const _type_name_ClaimedLineDisplay = "ClaimedLineDisplay";

    static PyObject* _new_ClaimedLineDisplay(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedLineDisplay);
        return nullptr;
    }

    static void _dealloc_ClaimedLineDisplay(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ClaimedLineDisplay_CheckHealthAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel>(args, 0);

                return py::convert(self->obj.CheckHealthAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_CheckPowerStatusAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CheckPowerStatusAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_Close(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::ClaimedLineDisplay::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_GetAttributes(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAttributes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::ClaimedLineDisplay::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::ClaimedLineDisplay::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_GetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_RetainDevice(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RetainDevice();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_TryClearDescriptorsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryClearDescriptorsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_TryCreateWindowAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);

                return py::convert(self->obj.TryCreateWindowAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_TrySetDescriptorAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayDescriptorState>(args, 1);

                return py::convert(self->obj.TrySetDescriptorAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_TryStoreStorageFileBitmapAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);

                return py::convert(self->obj.TryStoreStorageFileBitmapAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayHorizontalAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayVerticalAlignment>(args, 2);

                return py::convert(self->obj.TryStoreStorageFileBitmapAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayHorizontalAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayVerticalAlignment>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                return py::convert(self->obj.TryStoreStorageFileBitmapAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_TryUpdateAttributesAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayAttributes>(args, 0);

                return py::convert(self->obj.TryUpdateAttributesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_DefaultWindow(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DefaultWindow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_DeviceControlDescription(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceControlDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_DeviceControlVersion(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceControlVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_DeviceServiceVersion(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceServiceVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_PhysicalDeviceDescription(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhysicalDeviceDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_PhysicalDeviceName(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhysicalDeviceName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_CustomGlyphs(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CustomGlyphs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_MaxBitmapSizeInPixels(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxBitmapSizeInPixels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_SupportedCharacterSets(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedCharacterSets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_SupportedScreenSizesInCharacters(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedScreenSizesInCharacters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_add_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ReleaseDeviceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_remove_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReleaseDeviceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_add_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay, winrt::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs>>(arg);

            return py::convert(self->obj.StatusUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_remove_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_add_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay, winrt::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_remove_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ClaimedLineDisplay(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ClaimedLineDisplay(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_ClaimedLineDisplay(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedLineDisplay[] = {
        { "check_health_async", (PyCFunction)ClaimedLineDisplay_CheckHealthAsync, METH_VARARGS, nullptr },
        { "check_power_status_async", (PyCFunction)ClaimedLineDisplay_CheckPowerStatusAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)ClaimedLineDisplay_Close, METH_VARARGS, nullptr },
        { "from_id_async", (PyCFunction)ClaimedLineDisplay_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_attributes", (PyCFunction)ClaimedLineDisplay_GetAttributes, METH_VARARGS, nullptr },
        { "get_device_selector", (PyCFunction)ClaimedLineDisplay_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "get_statistics_async", (PyCFunction)ClaimedLineDisplay_GetStatisticsAsync, METH_VARARGS, nullptr },
        { "retain_device", (PyCFunction)ClaimedLineDisplay_RetainDevice, METH_VARARGS, nullptr },
        { "try_clear_descriptors_async", (PyCFunction)ClaimedLineDisplay_TryClearDescriptorsAsync, METH_VARARGS, nullptr },
        { "try_create_window_async", (PyCFunction)ClaimedLineDisplay_TryCreateWindowAsync, METH_VARARGS, nullptr },
        { "try_set_descriptor_async", (PyCFunction)ClaimedLineDisplay_TrySetDescriptorAsync, METH_VARARGS, nullptr },
        { "try_store_storage_file_bitmap_async", (PyCFunction)ClaimedLineDisplay_TryStoreStorageFileBitmapAsync, METH_VARARGS, nullptr },
        { "try_update_attributes_async", (PyCFunction)ClaimedLineDisplay_TryUpdateAttributesAsync, METH_VARARGS, nullptr },
        { "add_release_device_requested", (PyCFunction)ClaimedLineDisplay_add_ReleaseDeviceRequested, METH_O, nullptr },
        { "remove_release_device_requested", (PyCFunction)ClaimedLineDisplay_remove_ReleaseDeviceRequested, METH_O, nullptr },
        { "add_status_updated", (PyCFunction)ClaimedLineDisplay_add_StatusUpdated, METH_O, nullptr },
        { "remove_status_updated", (PyCFunction)ClaimedLineDisplay_remove_StatusUpdated, METH_O, nullptr },
        { "add_closed", (PyCFunction)ClaimedLineDisplay_add_Closed, METH_O, nullptr },
        { "remove_closed", (PyCFunction)ClaimedLineDisplay_remove_Closed, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ClaimedLineDisplay, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_ClaimedLineDisplay, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_ClaimedLineDisplay, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ClaimedLineDisplay[] = {
        { const_cast<char*>("capabilities"), (getter)ClaimedLineDisplay_get_Capabilities, nullptr, nullptr, nullptr },
        { const_cast<char*>("default_window"), (getter)ClaimedLineDisplay_get_DefaultWindow, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_control_description"), (getter)ClaimedLineDisplay_get_DeviceControlDescription, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_control_version"), (getter)ClaimedLineDisplay_get_DeviceControlVersion, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)ClaimedLineDisplay_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_service_version"), (getter)ClaimedLineDisplay_get_DeviceServiceVersion, nullptr, nullptr, nullptr },
        { const_cast<char*>("physical_device_description"), (getter)ClaimedLineDisplay_get_PhysicalDeviceDescription, nullptr, nullptr, nullptr },
        { const_cast<char*>("physical_device_name"), (getter)ClaimedLineDisplay_get_PhysicalDeviceName, nullptr, nullptr, nullptr },
        { const_cast<char*>("custom_glyphs"), (getter)ClaimedLineDisplay_get_CustomGlyphs, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_bitmap_size_in_pixels"), (getter)ClaimedLineDisplay_get_MaxBitmapSizeInPixels, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_character_sets"), (getter)ClaimedLineDisplay_get_SupportedCharacterSets, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_screen_sizes_in_characters"), (getter)ClaimedLineDisplay_get_SupportedScreenSizesInCharacters, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ClaimedLineDisplay[] = 
    {
        { Py_tp_new, _new_ClaimedLineDisplay },
        { Py_tp_dealloc, _dealloc_ClaimedLineDisplay },
        { Py_tp_methods, _methods_ClaimedLineDisplay },
        { Py_tp_getset, _getset_ClaimedLineDisplay },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ClaimedLineDisplay =
    {
        "_winrt_Windows_Devices_PointOfService.ClaimedLineDisplay",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedLineDisplay
    };

    // ----- ClaimedLineDisplayClosedEventArgs class --------------------
    constexpr const char* const _type_name_ClaimedLineDisplayClosedEventArgs = "ClaimedLineDisplayClosedEventArgs";

    static PyObject* _new_ClaimedLineDisplayClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedLineDisplayClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_ClaimedLineDisplayClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ClaimedLineDisplayClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedLineDisplayClosedEventArgs[] = {
        { "_from", (PyCFunction)_from_ClaimedLineDisplayClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ClaimedLineDisplayClosedEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ClaimedLineDisplayClosedEventArgs[] = 
    {
        { Py_tp_new, _new_ClaimedLineDisplayClosedEventArgs },
        { Py_tp_dealloc, _dealloc_ClaimedLineDisplayClosedEventArgs },
        { Py_tp_methods, _methods_ClaimedLineDisplayClosedEventArgs },
        { Py_tp_getset, _getset_ClaimedLineDisplayClosedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ClaimedLineDisplayClosedEventArgs =
    {
        "_winrt_Windows_Devices_PointOfService.ClaimedLineDisplayClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedLineDisplayClosedEventArgs
    };

    // ----- ClaimedMagneticStripeReader class --------------------
    constexpr const char* const _type_name_ClaimedMagneticStripeReader = "ClaimedMagneticStripeReader";

    static PyObject* _new_ClaimedMagneticStripeReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedMagneticStripeReader);
        return nullptr;
    }

    static void _dealloc_ClaimedMagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ClaimedMagneticStripeReader_AuthenticateDeviceAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(self->obj.AuthenticateDeviceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_Close(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_DeAuthenticateDeviceAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(self->obj.DeAuthenticateDeviceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_DisableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DisableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_EnableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.EnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_ResetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.ResetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_RetainDevice(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RetainDevice();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_RetrieveDeviceAuthenticationDataAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RetrieveDeviceAuthenticationDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_SetErrorReportingType(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorReportingType>(args, 0);

                self->obj.SetErrorReportingType(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_UpdateKeyAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.UpdateKeyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_UpdateStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);

                return py::convert(self->obj.UpdateStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_TracksToRead(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TracksToRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedMagneticStripeReader_put_TracksToRead(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackIds>(arg);

            self->obj.TracksToRead(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_IsTransmitSentinelsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTransmitSentinelsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedMagneticStripeReader_put_IsTransmitSentinelsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTransmitSentinelsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_IsDisabledOnDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDisabledOnDataReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedMagneticStripeReader_put_IsDisabledOnDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDisabledOnDataReceived(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_IsDecodeDataEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDecodeDataEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedMagneticStripeReader_put_IsDecodeDataEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDecodeDataEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_DataEncryptionAlgorithm(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DataEncryptionAlgorithm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedMagneticStripeReader_put_DataEncryptionAlgorithm(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DataEncryptionAlgorithm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_IsDeviceAuthenticated(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDeviceAuthenticated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_IsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_AamvaCardDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader, winrt::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs>>(arg);

            return py::convert(self->obj.AamvaCardDataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_AamvaCardDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AamvaCardDataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_BankCardDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader, winrt::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs>>(arg);

            return py::convert(self->obj.BankCardDataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_BankCardDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BankCardDataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_ErrorOccurred(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader, winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs>>(arg);

            return py::convert(self->obj.ErrorOccurred(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_ErrorOccurred(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ErrorOccurred(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader>>(arg);

            return py::convert(self->obj.ReleaseDeviceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReleaseDeviceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_VendorSpecificDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader, winrt::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>>(arg);

            return py::convert(self->obj.VendorSpecificDataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_VendorSpecificDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VendorSpecificDataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader, winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ClaimedMagneticStripeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ClaimedMagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_ClaimedMagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedMagneticStripeReader[] = {
        { "authenticate_device_async", (PyCFunction)ClaimedMagneticStripeReader_AuthenticateDeviceAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)ClaimedMagneticStripeReader_Close, METH_VARARGS, nullptr },
        { "de_authenticate_device_async", (PyCFunction)ClaimedMagneticStripeReader_DeAuthenticateDeviceAsync, METH_VARARGS, nullptr },
        { "disable_async", (PyCFunction)ClaimedMagneticStripeReader_DisableAsync, METH_VARARGS, nullptr },
        { "enable_async", (PyCFunction)ClaimedMagneticStripeReader_EnableAsync, METH_VARARGS, nullptr },
        { "reset_statistics_async", (PyCFunction)ClaimedMagneticStripeReader_ResetStatisticsAsync, METH_VARARGS, nullptr },
        { "retain_device", (PyCFunction)ClaimedMagneticStripeReader_RetainDevice, METH_VARARGS, nullptr },
        { "retrieve_device_authentication_data_async", (PyCFunction)ClaimedMagneticStripeReader_RetrieveDeviceAuthenticationDataAsync, METH_VARARGS, nullptr },
        { "set_error_reporting_type", (PyCFunction)ClaimedMagneticStripeReader_SetErrorReportingType, METH_VARARGS, nullptr },
        { "update_key_async", (PyCFunction)ClaimedMagneticStripeReader_UpdateKeyAsync, METH_VARARGS, nullptr },
        { "update_statistics_async", (PyCFunction)ClaimedMagneticStripeReader_UpdateStatisticsAsync, METH_VARARGS, nullptr },
        { "add_aamva_card_data_received", (PyCFunction)ClaimedMagneticStripeReader_add_AamvaCardDataReceived, METH_O, nullptr },
        { "remove_aamva_card_data_received", (PyCFunction)ClaimedMagneticStripeReader_remove_AamvaCardDataReceived, METH_O, nullptr },
        { "add_bank_card_data_received", (PyCFunction)ClaimedMagneticStripeReader_add_BankCardDataReceived, METH_O, nullptr },
        { "remove_bank_card_data_received", (PyCFunction)ClaimedMagneticStripeReader_remove_BankCardDataReceived, METH_O, nullptr },
        { "add_error_occurred", (PyCFunction)ClaimedMagneticStripeReader_add_ErrorOccurred, METH_O, nullptr },
        { "remove_error_occurred", (PyCFunction)ClaimedMagneticStripeReader_remove_ErrorOccurred, METH_O, nullptr },
        { "add_release_device_requested", (PyCFunction)ClaimedMagneticStripeReader_add_ReleaseDeviceRequested, METH_O, nullptr },
        { "remove_release_device_requested", (PyCFunction)ClaimedMagneticStripeReader_remove_ReleaseDeviceRequested, METH_O, nullptr },
        { "add_vendor_specific_data_received", (PyCFunction)ClaimedMagneticStripeReader_add_VendorSpecificDataReceived, METH_O, nullptr },
        { "remove_vendor_specific_data_received", (PyCFunction)ClaimedMagneticStripeReader_remove_VendorSpecificDataReceived, METH_O, nullptr },
        { "add_closed", (PyCFunction)ClaimedMagneticStripeReader_add_Closed, METH_O, nullptr },
        { "remove_closed", (PyCFunction)ClaimedMagneticStripeReader_remove_Closed, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ClaimedMagneticStripeReader, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_ClaimedMagneticStripeReader, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_ClaimedMagneticStripeReader, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ClaimedMagneticStripeReader[] = {
        { const_cast<char*>("tracks_to_read"), (getter)ClaimedMagneticStripeReader_get_TracksToRead, (setter)ClaimedMagneticStripeReader_put_TracksToRead, nullptr, nullptr },
        { const_cast<char*>("is_transmit_sentinels_enabled"), (getter)ClaimedMagneticStripeReader_get_IsTransmitSentinelsEnabled, (setter)ClaimedMagneticStripeReader_put_IsTransmitSentinelsEnabled, nullptr, nullptr },
        { const_cast<char*>("is_disabled_on_data_received"), (getter)ClaimedMagneticStripeReader_get_IsDisabledOnDataReceived, (setter)ClaimedMagneticStripeReader_put_IsDisabledOnDataReceived, nullptr, nullptr },
        { const_cast<char*>("is_decode_data_enabled"), (getter)ClaimedMagneticStripeReader_get_IsDecodeDataEnabled, (setter)ClaimedMagneticStripeReader_put_IsDecodeDataEnabled, nullptr, nullptr },
        { const_cast<char*>("data_encryption_algorithm"), (getter)ClaimedMagneticStripeReader_get_DataEncryptionAlgorithm, (setter)ClaimedMagneticStripeReader_put_DataEncryptionAlgorithm, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)ClaimedMagneticStripeReader_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_device_authenticated"), (getter)ClaimedMagneticStripeReader_get_IsDeviceAuthenticated, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_enabled"), (getter)ClaimedMagneticStripeReader_get_IsEnabled, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ClaimedMagneticStripeReader[] = 
    {
        { Py_tp_new, _new_ClaimedMagneticStripeReader },
        { Py_tp_dealloc, _dealloc_ClaimedMagneticStripeReader },
        { Py_tp_methods, _methods_ClaimedMagneticStripeReader },
        { Py_tp_getset, _getset_ClaimedMagneticStripeReader },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ClaimedMagneticStripeReader =
    {
        "_winrt_Windows_Devices_PointOfService.ClaimedMagneticStripeReader",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedMagneticStripeReader
    };

    // ----- ClaimedMagneticStripeReaderClosedEventArgs class --------------------
    constexpr const char* const _type_name_ClaimedMagneticStripeReaderClosedEventArgs = "ClaimedMagneticStripeReaderClosedEventArgs";

    static PyObject* _new_ClaimedMagneticStripeReaderClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedMagneticStripeReaderClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_ClaimedMagneticStripeReaderClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ClaimedMagneticStripeReaderClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedMagneticStripeReaderClosedEventArgs[] = {
        { "_from", (PyCFunction)_from_ClaimedMagneticStripeReaderClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ClaimedMagneticStripeReaderClosedEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ClaimedMagneticStripeReaderClosedEventArgs[] = 
    {
        { Py_tp_new, _new_ClaimedMagneticStripeReaderClosedEventArgs },
        { Py_tp_dealloc, _dealloc_ClaimedMagneticStripeReaderClosedEventArgs },
        { Py_tp_methods, _methods_ClaimedMagneticStripeReaderClosedEventArgs },
        { Py_tp_getset, _getset_ClaimedMagneticStripeReaderClosedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ClaimedMagneticStripeReaderClosedEventArgs =
    {
        "_winrt_Windows_Devices_PointOfService.ClaimedMagneticStripeReaderClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedMagneticStripeReaderClosedEventArgs
    };

    // ----- ClaimedPosPrinter class --------------------
    constexpr const char* const _type_name_ClaimedPosPrinter = "ClaimedPosPrinter";

    static PyObject* _new_ClaimedPosPrinter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedPosPrinter);
        return nullptr;
    }

    static void _dealloc_ClaimedPosPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ClaimedPosPrinter_Close(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_DisableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DisableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_EnableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.EnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_ResetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.ResetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_RetainDeviceAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RetainDeviceAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_UpdateStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);

                return py::convert(self->obj.UpdateStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_MapMode(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MapMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedPosPrinter_put_MapMode(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterMapMode>(arg);

            self->obj.MapMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedPosPrinter_get_IsCharacterSetMappingEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCharacterSetMappingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedPosPrinter_put_IsCharacterSetMappingEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCharacterSetMappingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedPosPrinter_get_CharacterSet(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharacterSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedPosPrinter_put_CharacterSet(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharacterSet(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedPosPrinter_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_IsCoverOpen(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCoverOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_IsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_Journal(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Journal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_Receipt(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Receipt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_Slip(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Slip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_add_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedPosPrinter, winrt::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs>>(arg);

            return py::convert(self->obj.ReleaseDeviceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_remove_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReleaseDeviceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_add_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedPosPrinter, winrt::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_remove_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ClaimedPosPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedPosPrinter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ClaimedPosPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_ClaimedPosPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedPosPrinter[] = {
        { "close", (PyCFunction)ClaimedPosPrinter_Close, METH_VARARGS, nullptr },
        { "disable_async", (PyCFunction)ClaimedPosPrinter_DisableAsync, METH_VARARGS, nullptr },
        { "enable_async", (PyCFunction)ClaimedPosPrinter_EnableAsync, METH_VARARGS, nullptr },
        { "reset_statistics_async", (PyCFunction)ClaimedPosPrinter_ResetStatisticsAsync, METH_VARARGS, nullptr },
        { "retain_device_async", (PyCFunction)ClaimedPosPrinter_RetainDeviceAsync, METH_VARARGS, nullptr },
        { "update_statistics_async", (PyCFunction)ClaimedPosPrinter_UpdateStatisticsAsync, METH_VARARGS, nullptr },
        { "add_release_device_requested", (PyCFunction)ClaimedPosPrinter_add_ReleaseDeviceRequested, METH_O, nullptr },
        { "remove_release_device_requested", (PyCFunction)ClaimedPosPrinter_remove_ReleaseDeviceRequested, METH_O, nullptr },
        { "add_closed", (PyCFunction)ClaimedPosPrinter_add_Closed, METH_O, nullptr },
        { "remove_closed", (PyCFunction)ClaimedPosPrinter_remove_Closed, METH_O, nullptr },
        { "_from", (PyCFunction)_from_ClaimedPosPrinter, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_ClaimedPosPrinter, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_ClaimedPosPrinter, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ClaimedPosPrinter[] = {
        { const_cast<char*>("map_mode"), (getter)ClaimedPosPrinter_get_MapMode, (setter)ClaimedPosPrinter_put_MapMode, nullptr, nullptr },
        { const_cast<char*>("is_character_set_mapping_enabled"), (getter)ClaimedPosPrinter_get_IsCharacterSetMappingEnabled, (setter)ClaimedPosPrinter_put_IsCharacterSetMappingEnabled, nullptr, nullptr },
        { const_cast<char*>("character_set"), (getter)ClaimedPosPrinter_get_CharacterSet, (setter)ClaimedPosPrinter_put_CharacterSet, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)ClaimedPosPrinter_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_cover_open"), (getter)ClaimedPosPrinter_get_IsCoverOpen, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_enabled"), (getter)ClaimedPosPrinter_get_IsEnabled, nullptr, nullptr, nullptr },
        { const_cast<char*>("journal"), (getter)ClaimedPosPrinter_get_Journal, nullptr, nullptr, nullptr },
        { const_cast<char*>("receipt"), (getter)ClaimedPosPrinter_get_Receipt, nullptr, nullptr, nullptr },
        { const_cast<char*>("slip"), (getter)ClaimedPosPrinter_get_Slip, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ClaimedPosPrinter[] = 
    {
        { Py_tp_new, _new_ClaimedPosPrinter },
        { Py_tp_dealloc, _dealloc_ClaimedPosPrinter },
        { Py_tp_methods, _methods_ClaimedPosPrinter },
        { Py_tp_getset, _getset_ClaimedPosPrinter },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ClaimedPosPrinter =
    {
        "_winrt_Windows_Devices_PointOfService.ClaimedPosPrinter",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedPosPrinter
    };

    // ----- ClaimedPosPrinterClosedEventArgs class --------------------
    constexpr const char* const _type_name_ClaimedPosPrinterClosedEventArgs = "ClaimedPosPrinterClosedEventArgs";

    static PyObject* _new_ClaimedPosPrinterClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedPosPrinterClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_ClaimedPosPrinterClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ClaimedPosPrinterClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedPosPrinterClosedEventArgs[] = {
        { "_from", (PyCFunction)_from_ClaimedPosPrinterClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ClaimedPosPrinterClosedEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ClaimedPosPrinterClosedEventArgs[] = 
    {
        { Py_tp_new, _new_ClaimedPosPrinterClosedEventArgs },
        { Py_tp_dealloc, _dealloc_ClaimedPosPrinterClosedEventArgs },
        { Py_tp_methods, _methods_ClaimedPosPrinterClosedEventArgs },
        { Py_tp_getset, _getset_ClaimedPosPrinterClosedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ClaimedPosPrinterClosedEventArgs =
    {
        "_winrt_Windows_Devices_PointOfService.ClaimedPosPrinterClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedPosPrinterClosedEventArgs
    };

    // ----- ClaimedReceiptPrinter class --------------------
    constexpr const char* const _type_name_ClaimedReceiptPrinter = "ClaimedReceiptPrinter";

    static PyObject* _new_ClaimedReceiptPrinter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedReceiptPrinter);
        return nullptr;
    }

    static void _dealloc_ClaimedReceiptPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ClaimedReceiptPrinter_CreateJob(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateJob());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_ValidateData(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ValidateData(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_LinesToPaperCut(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LinesToPaperCut());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_PageSize(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_PrintArea(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrintArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_SidewaysMaxChars(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SidewaysMaxChars());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_SidewaysMaxLines(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SidewaysMaxLines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedReceiptPrinter_put_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedReceiptPrinter_put_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLetterQuality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedReceiptPrinter_put_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLetterQuality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorCartridge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedReceiptPrinter_put_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterColorCartridge>(arg);

            self->obj.ColorCartridge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedReceiptPrinter_put_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharactersPerLine(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsCartridgeEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCartridgeEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsCartridgeRemoved(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCartridgeRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsCoverOpen(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCoverOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsHeadCleaning(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHeadCleaning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsPaperEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsPaperNearEnd(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperNearEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsReadyToPrint(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadyToPrint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_LineWidth(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ClaimedReceiptPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedReceiptPrinter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedReceiptPrinter[] = {
        { "create_job", (PyCFunction)ClaimedReceiptPrinter_CreateJob, METH_VARARGS, nullptr },
        { "validate_data", (PyCFunction)ClaimedReceiptPrinter_ValidateData, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ClaimedReceiptPrinter, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ClaimedReceiptPrinter[] = {
        { const_cast<char*>("lines_to_paper_cut"), (getter)ClaimedReceiptPrinter_get_LinesToPaperCut, nullptr, nullptr, nullptr },
        { const_cast<char*>("page_size"), (getter)ClaimedReceiptPrinter_get_PageSize, nullptr, nullptr, nullptr },
        { const_cast<char*>("print_area"), (getter)ClaimedReceiptPrinter_get_PrintArea, nullptr, nullptr, nullptr },
        { const_cast<char*>("sideways_max_chars"), (getter)ClaimedReceiptPrinter_get_SidewaysMaxChars, nullptr, nullptr, nullptr },
        { const_cast<char*>("sideways_max_lines"), (getter)ClaimedReceiptPrinter_get_SidewaysMaxLines, nullptr, nullptr, nullptr },
        { const_cast<char*>("line_spacing"), (getter)ClaimedReceiptPrinter_get_LineSpacing, (setter)ClaimedReceiptPrinter_put_LineSpacing, nullptr, nullptr },
        { const_cast<char*>("line_height"), (getter)ClaimedReceiptPrinter_get_LineHeight, (setter)ClaimedReceiptPrinter_put_LineHeight, nullptr, nullptr },
        { const_cast<char*>("is_letter_quality"), (getter)ClaimedReceiptPrinter_get_IsLetterQuality, (setter)ClaimedReceiptPrinter_put_IsLetterQuality, nullptr, nullptr },
        { const_cast<char*>("color_cartridge"), (getter)ClaimedReceiptPrinter_get_ColorCartridge, (setter)ClaimedReceiptPrinter_put_ColorCartridge, nullptr, nullptr },
        { const_cast<char*>("characters_per_line"), (getter)ClaimedReceiptPrinter_get_CharactersPerLine, (setter)ClaimedReceiptPrinter_put_CharactersPerLine, nullptr, nullptr },
        { const_cast<char*>("is_cartridge_empty"), (getter)ClaimedReceiptPrinter_get_IsCartridgeEmpty, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_cartridge_removed"), (getter)ClaimedReceiptPrinter_get_IsCartridgeRemoved, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_cover_open"), (getter)ClaimedReceiptPrinter_get_IsCoverOpen, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_head_cleaning"), (getter)ClaimedReceiptPrinter_get_IsHeadCleaning, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_paper_empty"), (getter)ClaimedReceiptPrinter_get_IsPaperEmpty, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_paper_near_end"), (getter)ClaimedReceiptPrinter_get_IsPaperNearEnd, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_ready_to_print"), (getter)ClaimedReceiptPrinter_get_IsReadyToPrint, nullptr, nullptr, nullptr },
        { const_cast<char*>("line_width"), (getter)ClaimedReceiptPrinter_get_LineWidth, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ClaimedReceiptPrinter[] = 
    {
        { Py_tp_new, _new_ClaimedReceiptPrinter },
        { Py_tp_dealloc, _dealloc_ClaimedReceiptPrinter },
        { Py_tp_methods, _methods_ClaimedReceiptPrinter },
        { Py_tp_getset, _getset_ClaimedReceiptPrinter },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ClaimedReceiptPrinter =
    {
        "_winrt_Windows_Devices_PointOfService.ClaimedReceiptPrinter",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedReceiptPrinter
    };

    // ----- ClaimedSlipPrinter class --------------------
    constexpr const char* const _type_name_ClaimedSlipPrinter = "ClaimedSlipPrinter";

    static PyObject* _new_ClaimedSlipPrinter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedSlipPrinter);
        return nullptr;
    }

    static void _dealloc_ClaimedSlipPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ClaimedSlipPrinter_ChangePrintSide(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterPrintSide>(args, 0);

                self->obj.ChangePrintSide(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_CloseJaws(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.CloseJaws();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_CreateJob(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateJob());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_InsertSlipAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(self->obj.InsertSlipAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_OpenJaws(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.OpenJaws();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_RemoveSlipAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(self->obj.RemoveSlipAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_ValidateData(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ValidateData(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_LinesNearEndToEnd(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LinesNearEndToEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_MaxLines(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxLines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_PageSize(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_PrintArea(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrintArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_PrintSide(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrintSide());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_SidewaysMaxChars(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SidewaysMaxChars());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_SidewaysMaxLines(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SidewaysMaxLines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedSlipPrinter_put_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedSlipPrinter_put_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLetterQuality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedSlipPrinter_put_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLetterQuality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorCartridge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedSlipPrinter_put_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterColorCartridge>(arg);

            self->obj.ColorCartridge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedSlipPrinter_put_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharactersPerLine(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsCartridgeEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCartridgeEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsCartridgeRemoved(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCartridgeRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsCoverOpen(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCoverOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsHeadCleaning(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHeadCleaning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsPaperEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsPaperNearEnd(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperNearEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsReadyToPrint(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadyToPrint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_LineWidth(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ClaimedSlipPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedSlipPrinter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedSlipPrinter[] = {
        { "change_print_side", (PyCFunction)ClaimedSlipPrinter_ChangePrintSide, METH_VARARGS, nullptr },
        { "close_jaws", (PyCFunction)ClaimedSlipPrinter_CloseJaws, METH_VARARGS, nullptr },
        { "create_job", (PyCFunction)ClaimedSlipPrinter_CreateJob, METH_VARARGS, nullptr },
        { "insert_slip_async", (PyCFunction)ClaimedSlipPrinter_InsertSlipAsync, METH_VARARGS, nullptr },
        { "open_jaws", (PyCFunction)ClaimedSlipPrinter_OpenJaws, METH_VARARGS, nullptr },
        { "remove_slip_async", (PyCFunction)ClaimedSlipPrinter_RemoveSlipAsync, METH_VARARGS, nullptr },
        { "validate_data", (PyCFunction)ClaimedSlipPrinter_ValidateData, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ClaimedSlipPrinter, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ClaimedSlipPrinter[] = {
        { const_cast<char*>("lines_near_end_to_end"), (getter)ClaimedSlipPrinter_get_LinesNearEndToEnd, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_lines"), (getter)ClaimedSlipPrinter_get_MaxLines, nullptr, nullptr, nullptr },
        { const_cast<char*>("page_size"), (getter)ClaimedSlipPrinter_get_PageSize, nullptr, nullptr, nullptr },
        { const_cast<char*>("print_area"), (getter)ClaimedSlipPrinter_get_PrintArea, nullptr, nullptr, nullptr },
        { const_cast<char*>("print_side"), (getter)ClaimedSlipPrinter_get_PrintSide, nullptr, nullptr, nullptr },
        { const_cast<char*>("sideways_max_chars"), (getter)ClaimedSlipPrinter_get_SidewaysMaxChars, nullptr, nullptr, nullptr },
        { const_cast<char*>("sideways_max_lines"), (getter)ClaimedSlipPrinter_get_SidewaysMaxLines, nullptr, nullptr, nullptr },
        { const_cast<char*>("line_spacing"), (getter)ClaimedSlipPrinter_get_LineSpacing, (setter)ClaimedSlipPrinter_put_LineSpacing, nullptr, nullptr },
        { const_cast<char*>("line_height"), (getter)ClaimedSlipPrinter_get_LineHeight, (setter)ClaimedSlipPrinter_put_LineHeight, nullptr, nullptr },
        { const_cast<char*>("is_letter_quality"), (getter)ClaimedSlipPrinter_get_IsLetterQuality, (setter)ClaimedSlipPrinter_put_IsLetterQuality, nullptr, nullptr },
        { const_cast<char*>("color_cartridge"), (getter)ClaimedSlipPrinter_get_ColorCartridge, (setter)ClaimedSlipPrinter_put_ColorCartridge, nullptr, nullptr },
        { const_cast<char*>("characters_per_line"), (getter)ClaimedSlipPrinter_get_CharactersPerLine, (setter)ClaimedSlipPrinter_put_CharactersPerLine, nullptr, nullptr },
        { const_cast<char*>("is_cartridge_empty"), (getter)ClaimedSlipPrinter_get_IsCartridgeEmpty, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_cartridge_removed"), (getter)ClaimedSlipPrinter_get_IsCartridgeRemoved, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_cover_open"), (getter)ClaimedSlipPrinter_get_IsCoverOpen, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_head_cleaning"), (getter)ClaimedSlipPrinter_get_IsHeadCleaning, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_paper_empty"), (getter)ClaimedSlipPrinter_get_IsPaperEmpty, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_paper_near_end"), (getter)ClaimedSlipPrinter_get_IsPaperNearEnd, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_ready_to_print"), (getter)ClaimedSlipPrinter_get_IsReadyToPrint, nullptr, nullptr, nullptr },
        { const_cast<char*>("line_width"), (getter)ClaimedSlipPrinter_get_LineWidth, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ClaimedSlipPrinter[] = 
    {
        { Py_tp_new, _new_ClaimedSlipPrinter },
        { Py_tp_dealloc, _dealloc_ClaimedSlipPrinter },
        { Py_tp_methods, _methods_ClaimedSlipPrinter },
        { Py_tp_getset, _getset_ClaimedSlipPrinter },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ClaimedSlipPrinter =
    {
        "_winrt_Windows_Devices_PointOfService.ClaimedSlipPrinter",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedSlipPrinter
    };

    // ----- JournalPrintJob class --------------------
    constexpr const char* const _type_name_JournalPrintJob = "JournalPrintJob";

    static PyObject* _new_JournalPrintJob(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_JournalPrintJob);
        return nullptr;
    }

    static void _dealloc_JournalPrintJob(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* JournalPrintJob_ExecuteAsync(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ExecuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JournalPrintJob_FeedPaperByLine(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JournalPrintJob_FeedPaperByMapModeUnit(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByMapModeUnit(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JournalPrintJob_Print(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Print(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>(args, 1);

                self->obj.Print(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JournalPrintJob_PrintLine(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.PrintLine();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PrintLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_JournalPrintJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::JournalPrintJob>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_JournalPrintJob[] = {
        { "execute_async", (PyCFunction)JournalPrintJob_ExecuteAsync, METH_VARARGS, nullptr },
        { "feed_paper_by_line", (PyCFunction)JournalPrintJob_FeedPaperByLine, METH_VARARGS, nullptr },
        { "feed_paper_by_map_mode_unit", (PyCFunction)JournalPrintJob_FeedPaperByMapModeUnit, METH_VARARGS, nullptr },
        { "print", (PyCFunction)JournalPrintJob_Print, METH_VARARGS, nullptr },
        { "print_line", (PyCFunction)JournalPrintJob_PrintLine, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_JournalPrintJob, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_JournalPrintJob[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_JournalPrintJob[] = 
    {
        { Py_tp_new, _new_JournalPrintJob },
        { Py_tp_dealloc, _dealloc_JournalPrintJob },
        { Py_tp_methods, _methods_JournalPrintJob },
        { Py_tp_getset, _getset_JournalPrintJob },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_JournalPrintJob =
    {
        "_winrt_Windows_Devices_PointOfService.JournalPrintJob",
        sizeof(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_JournalPrintJob
    };

    // ----- JournalPrinterCapabilities class --------------------
    constexpr const char* const _type_name_JournalPrinterCapabilities = "JournalPrinterCapabilities";

    static PyObject* _new_JournalPrinterCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_JournalPrinterCapabilities);
        return nullptr;
    }

    static void _dealloc_JournalPrinterCapabilities(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* JournalPrinterCapabilities_get_CartridgeSensors(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CartridgeSensors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_ColorCartridgeCapabilities(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorCartridgeCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsBoldSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleHighDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsDoubleHighPrintSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleHighPrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsDualColorSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDualColorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsItalicSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsItalicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsPaperEmptySensorSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperEmptySensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsPaperNearEndSensorSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperNearEndSensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsPrinterPresent(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPrinterPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_SupportedCharactersPerLine(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedCharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsReversePaperFeedByLineSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReversePaperFeedByLineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReversePaperFeedByMapModeUnitSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsReverseVideoSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReverseVideoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsStrikethroughSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStrikethroughSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsSubscriptSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSubscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsSuperscriptSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSuperscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_JournalPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::JournalPrinterCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_JournalPrinterCapabilities[] = {
        { "_from", (PyCFunction)_from_JournalPrinterCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_JournalPrinterCapabilities[] = {
        { const_cast<char*>("cartridge_sensors"), (getter)JournalPrinterCapabilities_get_CartridgeSensors, nullptr, nullptr, nullptr },
        { const_cast<char*>("color_cartridge_capabilities"), (getter)JournalPrinterCapabilities_get_ColorCartridgeCapabilities, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_bold_supported"), (getter)JournalPrinterCapabilities_get_IsBoldSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_double_high_double_wide_print_supported"), (getter)JournalPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_double_high_print_supported"), (getter)JournalPrinterCapabilities_get_IsDoubleHighPrintSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_double_wide_print_supported"), (getter)JournalPrinterCapabilities_get_IsDoubleWidePrintSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_dual_color_supported"), (getter)JournalPrinterCapabilities_get_IsDualColorSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_italic_supported"), (getter)JournalPrinterCapabilities_get_IsItalicSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_paper_empty_sensor_supported"), (getter)JournalPrinterCapabilities_get_IsPaperEmptySensorSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_paper_near_end_sensor_supported"), (getter)JournalPrinterCapabilities_get_IsPaperNearEndSensorSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_printer_present"), (getter)JournalPrinterCapabilities_get_IsPrinterPresent, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_underline_supported"), (getter)JournalPrinterCapabilities_get_IsUnderlineSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_characters_per_line"), (getter)JournalPrinterCapabilities_get_SupportedCharactersPerLine, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_reverse_paper_feed_by_line_supported"), (getter)JournalPrinterCapabilities_get_IsReversePaperFeedByLineSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_reverse_paper_feed_by_map_mode_unit_supported"), (getter)JournalPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_reverse_video_supported"), (getter)JournalPrinterCapabilities_get_IsReverseVideoSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_strikethrough_supported"), (getter)JournalPrinterCapabilities_get_IsStrikethroughSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_subscript_supported"), (getter)JournalPrinterCapabilities_get_IsSubscriptSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_superscript_supported"), (getter)JournalPrinterCapabilities_get_IsSuperscriptSupported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_JournalPrinterCapabilities[] = 
    {
        { Py_tp_new, _new_JournalPrinterCapabilities },
        { Py_tp_dealloc, _dealloc_JournalPrinterCapabilities },
        { Py_tp_methods, _methods_JournalPrinterCapabilities },
        { Py_tp_getset, _getset_JournalPrinterCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_JournalPrinterCapabilities =
    {
        "_winrt_Windows_Devices_PointOfService.JournalPrinterCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_JournalPrinterCapabilities
    };

    // ----- LineDisplay class --------------------
    constexpr const char* const _type_name_LineDisplay = "LineDisplay";

    static PyObject* _new_LineDisplay(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplay);
        return nullptr;
    }

    static void _dealloc_LineDisplay(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplay_CheckPowerStatusAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CheckPowerStatusAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_ClaimAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClaimAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_Close(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::LineDisplay::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::LineDisplay::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::LineDisplay::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::LineDisplay::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_DeviceControlDescription(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceControlDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_DeviceControlVersion(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceControlVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_DeviceServiceVersion(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceServiceVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_PhysicalDeviceDescription(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhysicalDeviceDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_PhysicalDeviceName(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhysicalDeviceName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_StatisticsCategorySelector(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::LineDisplay::StatisticsCategorySelector());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LineDisplay(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplay>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LineDisplay(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_LineDisplay(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplay[] = {
        { "check_power_status_async", (PyCFunction)LineDisplay_CheckPowerStatusAsync, METH_VARARGS, nullptr },
        { "claim_async", (PyCFunction)LineDisplay_ClaimAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)LineDisplay_Close, METH_VARARGS, nullptr },
        { "from_id_async", (PyCFunction)LineDisplay_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_async", (PyCFunction)LineDisplay_GetDefaultAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)LineDisplay_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "get_statistics_category_selector", (PyCFunction)LineDisplay_get_StatisticsCategorySelector, METH_NOARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_LineDisplay, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_LineDisplay, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_LineDisplay, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LineDisplay[] = {
        { const_cast<char*>("capabilities"), (getter)LineDisplay_get_Capabilities, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_control_description"), (getter)LineDisplay_get_DeviceControlDescription, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_control_version"), (getter)LineDisplay_get_DeviceControlVersion, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)LineDisplay_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_service_version"), (getter)LineDisplay_get_DeviceServiceVersion, nullptr, nullptr, nullptr },
        { const_cast<char*>("physical_device_description"), (getter)LineDisplay_get_PhysicalDeviceDescription, nullptr, nullptr, nullptr },
        { const_cast<char*>("physical_device_name"), (getter)LineDisplay_get_PhysicalDeviceName, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LineDisplay[] = 
    {
        { Py_tp_new, _new_LineDisplay },
        { Py_tp_dealloc, _dealloc_LineDisplay },
        { Py_tp_methods, _methods_LineDisplay },
        { Py_tp_getset, _getset_LineDisplay },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LineDisplay =
    {
        "_winrt_Windows_Devices_PointOfService.LineDisplay",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplay),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplay
    };

    // ----- LineDisplayAttributes class --------------------
    constexpr const char* const _type_name_LineDisplayAttributes = "LineDisplayAttributes";

    static PyObject* _new_LineDisplayAttributes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplayAttributes);
        return nullptr;
    }

    static void _dealloc_LineDisplayAttributes(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplayAttributes_get_ScreenSizeInCharacters(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScreenSizeInCharacters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_ScreenSizeInCharacters(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.ScreenSizeInCharacters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_IsPowerNotifyEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPowerNotifyEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_IsPowerNotifyEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPowerNotifyEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_IsCharacterSetMappingEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCharacterSetMappingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_IsCharacterSetMappingEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCharacterSetMappingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_CurrentWindow(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentWindow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_CurrentWindow(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayWindow>(arg);

            self->obj.CurrentWindow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_CharacterSet(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharacterSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_CharacterSet(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.CharacterSet(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_Brightness(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Brightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_Brightness(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Brightness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_BlinkRate(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BlinkRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_BlinkRate(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.BlinkRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_LineDisplayAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayAttributes>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayAttributes[] = {
        { "_from", (PyCFunction)_from_LineDisplayAttributes, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LineDisplayAttributes[] = {
        { const_cast<char*>("screen_size_in_characters"), (getter)LineDisplayAttributes_get_ScreenSizeInCharacters, (setter)LineDisplayAttributes_put_ScreenSizeInCharacters, nullptr, nullptr },
        { const_cast<char*>("is_power_notify_enabled"), (getter)LineDisplayAttributes_get_IsPowerNotifyEnabled, (setter)LineDisplayAttributes_put_IsPowerNotifyEnabled, nullptr, nullptr },
        { const_cast<char*>("is_character_set_mapping_enabled"), (getter)LineDisplayAttributes_get_IsCharacterSetMappingEnabled, (setter)LineDisplayAttributes_put_IsCharacterSetMappingEnabled, nullptr, nullptr },
        { const_cast<char*>("current_window"), (getter)LineDisplayAttributes_get_CurrentWindow, (setter)LineDisplayAttributes_put_CurrentWindow, nullptr, nullptr },
        { const_cast<char*>("character_set"), (getter)LineDisplayAttributes_get_CharacterSet, (setter)LineDisplayAttributes_put_CharacterSet, nullptr, nullptr },
        { const_cast<char*>("brightness"), (getter)LineDisplayAttributes_get_Brightness, (setter)LineDisplayAttributes_put_Brightness, nullptr, nullptr },
        { const_cast<char*>("blink_rate"), (getter)LineDisplayAttributes_get_BlinkRate, (setter)LineDisplayAttributes_put_BlinkRate, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LineDisplayAttributes[] = 
    {
        { Py_tp_new, _new_LineDisplayAttributes },
        { Py_tp_dealloc, _dealloc_LineDisplayAttributes },
        { Py_tp_methods, _methods_LineDisplayAttributes },
        { Py_tp_getset, _getset_LineDisplayAttributes },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LineDisplayAttributes =
    {
        "_winrt_Windows_Devices_PointOfService.LineDisplayAttributes",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayAttributes
    };

    // ----- LineDisplayCapabilities class --------------------
    constexpr const char* const _type_name_LineDisplayCapabilities = "LineDisplayCapabilities";

    static PyObject* _new_LineDisplayCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplayCapabilities);
        return nullptr;
    }

    static void _dealloc_LineDisplayCapabilities(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplayCapabilities_get_CanBlink(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanBlink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanChangeBlinkRate(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanChangeBlinkRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanChangeScreenSize(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanChangeScreenSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanDisplayBitmaps(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanDisplayBitmaps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanDisplayCustomGlyphs(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanDisplayCustomGlyphs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanMapCharacterSets(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanMapCharacterSets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanReadCharacterAtCursor(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanReadCharacterAtCursor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanReverse(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanReverse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsBrightnessSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBrightnessSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsCursorSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCursorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsHorizontalMarqueeSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHorizontalMarqueeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsInterCharacterWaitSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInterCharacterWaitSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsStatisticsReportingSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatisticsReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsStatisticsUpdatingSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatisticsUpdatingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsVerticalMarqueeSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVerticalMarqueeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_PowerReportingType(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerReportingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_SupportedDescriptors(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedDescriptors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_SupportedWindows(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedWindows());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LineDisplayCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayCapabilities[] = {
        { "_from", (PyCFunction)_from_LineDisplayCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LineDisplayCapabilities[] = {
        { const_cast<char*>("can_blink"), (getter)LineDisplayCapabilities_get_CanBlink, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_change_blink_rate"), (getter)LineDisplayCapabilities_get_CanChangeBlinkRate, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_change_screen_size"), (getter)LineDisplayCapabilities_get_CanChangeScreenSize, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_display_bitmaps"), (getter)LineDisplayCapabilities_get_CanDisplayBitmaps, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_display_custom_glyphs"), (getter)LineDisplayCapabilities_get_CanDisplayCustomGlyphs, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_map_character_sets"), (getter)LineDisplayCapabilities_get_CanMapCharacterSets, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_read_character_at_cursor"), (getter)LineDisplayCapabilities_get_CanReadCharacterAtCursor, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_reverse"), (getter)LineDisplayCapabilities_get_CanReverse, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_brightness_supported"), (getter)LineDisplayCapabilities_get_IsBrightnessSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_cursor_supported"), (getter)LineDisplayCapabilities_get_IsCursorSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_horizontal_marquee_supported"), (getter)LineDisplayCapabilities_get_IsHorizontalMarqueeSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_inter_character_wait_supported"), (getter)LineDisplayCapabilities_get_IsInterCharacterWaitSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_statistics_reporting_supported"), (getter)LineDisplayCapabilities_get_IsStatisticsReportingSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_statistics_updating_supported"), (getter)LineDisplayCapabilities_get_IsStatisticsUpdatingSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_vertical_marquee_supported"), (getter)LineDisplayCapabilities_get_IsVerticalMarqueeSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("power_reporting_type"), (getter)LineDisplayCapabilities_get_PowerReportingType, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_descriptors"), (getter)LineDisplayCapabilities_get_SupportedDescriptors, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_windows"), (getter)LineDisplayCapabilities_get_SupportedWindows, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LineDisplayCapabilities[] = 
    {
        { Py_tp_new, _new_LineDisplayCapabilities },
        { Py_tp_dealloc, _dealloc_LineDisplayCapabilities },
        { Py_tp_methods, _methods_LineDisplayCapabilities },
        { Py_tp_getset, _getset_LineDisplayCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LineDisplayCapabilities =
    {
        "_winrt_Windows_Devices_PointOfService.LineDisplayCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayCapabilities
    };

    // ----- LineDisplayCursor class --------------------
    constexpr const char* const _type_name_LineDisplayCursor = "LineDisplayCursor";

    static PyObject* _new_LineDisplayCursor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplayCursor);
        return nullptr;
    }

    static void _dealloc_LineDisplayCursor(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplayCursor_GetAttributes(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAttributes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_TryUpdateAttributesAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayCursorAttributes>(args, 0);

                return py::convert(self->obj.TryUpdateAttributesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_CanCustomize(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanCustomize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsBlinkSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBlinkSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsBlockSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBlockSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsHalfBlockSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHalfBlockSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsOtherSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOtherSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsReverseSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReverseSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LineDisplayCursor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayCursor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayCursor[] = {
        { "get_attributes", (PyCFunction)LineDisplayCursor_GetAttributes, METH_VARARGS, nullptr },
        { "try_update_attributes_async", (PyCFunction)LineDisplayCursor_TryUpdateAttributesAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_LineDisplayCursor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LineDisplayCursor[] = {
        { const_cast<char*>("can_customize"), (getter)LineDisplayCursor_get_CanCustomize, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_blink_supported"), (getter)LineDisplayCursor_get_IsBlinkSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_block_supported"), (getter)LineDisplayCursor_get_IsBlockSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_half_block_supported"), (getter)LineDisplayCursor_get_IsHalfBlockSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_other_supported"), (getter)LineDisplayCursor_get_IsOtherSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_reverse_supported"), (getter)LineDisplayCursor_get_IsReverseSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_underline_supported"), (getter)LineDisplayCursor_get_IsUnderlineSupported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LineDisplayCursor[] = 
    {
        { Py_tp_new, _new_LineDisplayCursor },
        { Py_tp_dealloc, _dealloc_LineDisplayCursor },
        { Py_tp_methods, _methods_LineDisplayCursor },
        { Py_tp_getset, _getset_LineDisplayCursor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LineDisplayCursor =
    {
        "_winrt_Windows_Devices_PointOfService.LineDisplayCursor",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayCursor
    };

    // ----- LineDisplayCursorAttributes class --------------------
    constexpr const char* const _type_name_LineDisplayCursorAttributes = "LineDisplayCursorAttributes";

    static PyObject* _new_LineDisplayCursorAttributes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplayCursorAttributes);
        return nullptr;
    }

    static void _dealloc_LineDisplayCursorAttributes(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplayCursorAttributes_get_Position(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayCursorAttributes_put_Position(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayCursorAttributes_get_IsBlinkEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBlinkEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayCursorAttributes_put_IsBlinkEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsBlinkEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayCursorAttributes_get_IsAutoAdvanceEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAutoAdvanceEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayCursorAttributes_put_IsAutoAdvanceEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAutoAdvanceEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayCursorAttributes_get_CursorType(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CursorType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayCursorAttributes_put_CursorType(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayCursorType>(arg);

            self->obj.CursorType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_LineDisplayCursorAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayCursorAttributes>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayCursorAttributes[] = {
        { "_from", (PyCFunction)_from_LineDisplayCursorAttributes, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LineDisplayCursorAttributes[] = {
        { const_cast<char*>("position"), (getter)LineDisplayCursorAttributes_get_Position, (setter)LineDisplayCursorAttributes_put_Position, nullptr, nullptr },
        { const_cast<char*>("is_blink_enabled"), (getter)LineDisplayCursorAttributes_get_IsBlinkEnabled, (setter)LineDisplayCursorAttributes_put_IsBlinkEnabled, nullptr, nullptr },
        { const_cast<char*>("is_auto_advance_enabled"), (getter)LineDisplayCursorAttributes_get_IsAutoAdvanceEnabled, (setter)LineDisplayCursorAttributes_put_IsAutoAdvanceEnabled, nullptr, nullptr },
        { const_cast<char*>("cursor_type"), (getter)LineDisplayCursorAttributes_get_CursorType, (setter)LineDisplayCursorAttributes_put_CursorType, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LineDisplayCursorAttributes[] = 
    {
        { Py_tp_new, _new_LineDisplayCursorAttributes },
        { Py_tp_dealloc, _dealloc_LineDisplayCursorAttributes },
        { Py_tp_methods, _methods_LineDisplayCursorAttributes },
        { Py_tp_getset, _getset_LineDisplayCursorAttributes },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LineDisplayCursorAttributes =
    {
        "_winrt_Windows_Devices_PointOfService.LineDisplayCursorAttributes",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayCursorAttributes
    };

    // ----- LineDisplayCustomGlyphs class --------------------
    constexpr const char* const _type_name_LineDisplayCustomGlyphs = "LineDisplayCustomGlyphs";

    static PyObject* _new_LineDisplayCustomGlyphs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplayCustomGlyphs);
        return nullptr;
    }

    static void _dealloc_LineDisplayCustomGlyphs(py::wrapper::Windows::Devices::PointOfService::LineDisplayCustomGlyphs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplayCustomGlyphs_TryRedefineAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayCustomGlyphs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(self->obj.TryRedefineAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayCustomGlyphs_get_SizeInPixels(py::wrapper::Windows::Devices::PointOfService::LineDisplayCustomGlyphs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SizeInPixels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCustomGlyphs_get_SupportedGlyphCodes(py::wrapper::Windows::Devices::PointOfService::LineDisplayCustomGlyphs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedGlyphCodes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LineDisplayCustomGlyphs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayCustomGlyphs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayCustomGlyphs[] = {
        { "try_redefine_async", (PyCFunction)LineDisplayCustomGlyphs_TryRedefineAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_LineDisplayCustomGlyphs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LineDisplayCustomGlyphs[] = {
        { const_cast<char*>("size_in_pixels"), (getter)LineDisplayCustomGlyphs_get_SizeInPixels, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_glyph_codes"), (getter)LineDisplayCustomGlyphs_get_SupportedGlyphCodes, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LineDisplayCustomGlyphs[] = 
    {
        { Py_tp_new, _new_LineDisplayCustomGlyphs },
        { Py_tp_dealloc, _dealloc_LineDisplayCustomGlyphs },
        { Py_tp_methods, _methods_LineDisplayCustomGlyphs },
        { Py_tp_getset, _getset_LineDisplayCustomGlyphs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LineDisplayCustomGlyphs =
    {
        "_winrt_Windows_Devices_PointOfService.LineDisplayCustomGlyphs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayCustomGlyphs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayCustomGlyphs
    };

    // ----- LineDisplayMarquee class --------------------
    constexpr const char* const _type_name_LineDisplayMarquee = "LineDisplayMarquee";

    static PyObject* _new_LineDisplayMarquee(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplayMarquee);
        return nullptr;
    }

    static void _dealloc_LineDisplayMarquee(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplayMarquee_TryStartScrollingAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayScrollDirection>(args, 0);

                return py::convert(self->obj.TryStartScrollingAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayMarquee_TryStopScrollingAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryStopScrollingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayMarquee_get_ScrollWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScrollWaitInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayMarquee_put_ScrollWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.ScrollWaitInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayMarquee_get_RepeatWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RepeatWaitInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayMarquee_put_RepeatWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.RepeatWaitInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayMarquee_get_Format(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayMarquee_put_Format(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayMarqueeFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_LineDisplayMarquee(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayMarquee>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayMarquee[] = {
        { "try_start_scrolling_async", (PyCFunction)LineDisplayMarquee_TryStartScrollingAsync, METH_VARARGS, nullptr },
        { "try_stop_scrolling_async", (PyCFunction)LineDisplayMarquee_TryStopScrollingAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_LineDisplayMarquee, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LineDisplayMarquee[] = {
        { const_cast<char*>("scroll_wait_interval"), (getter)LineDisplayMarquee_get_ScrollWaitInterval, (setter)LineDisplayMarquee_put_ScrollWaitInterval, nullptr, nullptr },
        { const_cast<char*>("repeat_wait_interval"), (getter)LineDisplayMarquee_get_RepeatWaitInterval, (setter)LineDisplayMarquee_put_RepeatWaitInterval, nullptr, nullptr },
        { const_cast<char*>("format"), (getter)LineDisplayMarquee_get_Format, (setter)LineDisplayMarquee_put_Format, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LineDisplayMarquee[] = 
    {
        { Py_tp_new, _new_LineDisplayMarquee },
        { Py_tp_dealloc, _dealloc_LineDisplayMarquee },
        { Py_tp_methods, _methods_LineDisplayMarquee },
        { Py_tp_getset, _getset_LineDisplayMarquee },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LineDisplayMarquee =
    {
        "_winrt_Windows_Devices_PointOfService.LineDisplayMarquee",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayMarquee
    };

    // ----- LineDisplayStatisticsCategorySelector class --------------------
    constexpr const char* const _type_name_LineDisplayStatisticsCategorySelector = "LineDisplayStatisticsCategorySelector";

    static PyObject* _new_LineDisplayStatisticsCategorySelector(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplayStatisticsCategorySelector);
        return nullptr;
    }

    static void _dealloc_LineDisplayStatisticsCategorySelector(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplayStatisticsCategorySelector_get_AllStatistics(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayStatisticsCategorySelector_get_ManufacturerStatistics(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ManufacturerStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayStatisticsCategorySelector_get_UnifiedPosStatistics(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UnifiedPosStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LineDisplayStatisticsCategorySelector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayStatisticsCategorySelector[] = {
        { "_from", (PyCFunction)_from_LineDisplayStatisticsCategorySelector, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LineDisplayStatisticsCategorySelector[] = {
        { const_cast<char*>("all_statistics"), (getter)LineDisplayStatisticsCategorySelector_get_AllStatistics, nullptr, nullptr, nullptr },
        { const_cast<char*>("manufacturer_statistics"), (getter)LineDisplayStatisticsCategorySelector_get_ManufacturerStatistics, nullptr, nullptr, nullptr },
        { const_cast<char*>("unified_pos_statistics"), (getter)LineDisplayStatisticsCategorySelector_get_UnifiedPosStatistics, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LineDisplayStatisticsCategorySelector[] = 
    {
        { Py_tp_new, _new_LineDisplayStatisticsCategorySelector },
        { Py_tp_dealloc, _dealloc_LineDisplayStatisticsCategorySelector },
        { Py_tp_methods, _methods_LineDisplayStatisticsCategorySelector },
        { Py_tp_getset, _getset_LineDisplayStatisticsCategorySelector },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LineDisplayStatisticsCategorySelector =
    {
        "_winrt_Windows_Devices_PointOfService.LineDisplayStatisticsCategorySelector",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayStatisticsCategorySelector
    };

    // ----- LineDisplayStatusUpdatedEventArgs class --------------------
    constexpr const char* const _type_name_LineDisplayStatusUpdatedEventArgs = "LineDisplayStatusUpdatedEventArgs";

    static PyObject* _new_LineDisplayStatusUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplayStatusUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_LineDisplayStatusUpdatedEventArgs(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplayStatusUpdatedEventArgs_get_Status(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LineDisplayStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayStatusUpdatedEventArgs[] = {
        { "_from", (PyCFunction)_from_LineDisplayStatusUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LineDisplayStatusUpdatedEventArgs[] = {
        { const_cast<char*>("status"), (getter)LineDisplayStatusUpdatedEventArgs_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LineDisplayStatusUpdatedEventArgs[] = 
    {
        { Py_tp_new, _new_LineDisplayStatusUpdatedEventArgs },
        { Py_tp_dealloc, _dealloc_LineDisplayStatusUpdatedEventArgs },
        { Py_tp_methods, _methods_LineDisplayStatusUpdatedEventArgs },
        { Py_tp_getset, _getset_LineDisplayStatusUpdatedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LineDisplayStatusUpdatedEventArgs =
    {
        "_winrt_Windows_Devices_PointOfService.LineDisplayStatusUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayStatusUpdatedEventArgs
    };

    // ----- LineDisplayStoredBitmap class --------------------
    constexpr const char* const _type_name_LineDisplayStoredBitmap = "LineDisplayStoredBitmap";

    static PyObject* _new_LineDisplayStoredBitmap(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplayStoredBitmap);
        return nullptr;
    }

    static void _dealloc_LineDisplayStoredBitmap(py::wrapper::Windows::Devices::PointOfService::LineDisplayStoredBitmap* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplayStoredBitmap_TryDeleteAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayStoredBitmap* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryDeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayStoredBitmap_get_EscapeSequence(py::wrapper::Windows::Devices::PointOfService::LineDisplayStoredBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EscapeSequence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LineDisplayStoredBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayStoredBitmap>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayStoredBitmap[] = {
        { "try_delete_async", (PyCFunction)LineDisplayStoredBitmap_TryDeleteAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_LineDisplayStoredBitmap, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LineDisplayStoredBitmap[] = {
        { const_cast<char*>("escape_sequence"), (getter)LineDisplayStoredBitmap_get_EscapeSequence, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LineDisplayStoredBitmap[] = 
    {
        { Py_tp_new, _new_LineDisplayStoredBitmap },
        { Py_tp_dealloc, _dealloc_LineDisplayStoredBitmap },
        { Py_tp_methods, _methods_LineDisplayStoredBitmap },
        { Py_tp_getset, _getset_LineDisplayStoredBitmap },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LineDisplayStoredBitmap =
    {
        "_winrt_Windows_Devices_PointOfService.LineDisplayStoredBitmap",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayStoredBitmap),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayStoredBitmap
    };

    // ----- LineDisplayWindow class --------------------
    constexpr const char* const _type_name_LineDisplayWindow = "LineDisplayWindow";

    static PyObject* _new_LineDisplayWindow(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplayWindow);
        return nullptr;
    }

    static void _dealloc_LineDisplayWindow(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplayWindow_Close(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_ReadCharacterAtCursorAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadCharacterAtCursorAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryClearTextAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryClearTextAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryDisplayStorageFileBitmapAtCursorAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);

                return py::convert(self->obj.TryDisplayStorageFileBitmapAtCursorAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayHorizontalAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayVerticalAlignment>(args, 2);

                return py::convert(self->obj.TryDisplayStorageFileBitmapAtCursorAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayHorizontalAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayVerticalAlignment>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                return py::convert(self->obj.TryDisplayStorageFileBitmapAtCursorAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryDisplayStorageFileBitmapAtPointAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                return py::convert(self->obj.TryDisplayStorageFileBitmapAtPointAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                return py::convert(self->obj.TryDisplayStorageFileBitmapAtPointAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryDisplayStoredBitmapAtCursorAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayStoredBitmap>(args, 0);

                return py::convert(self->obj.TryDisplayStoredBitmapAtCursorAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryDisplayTextAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryDisplayTextAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayTextAttribute>(args, 1);

                return py::convert(self->obj.TryDisplayTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayTextAttribute>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Point>(args, 2);

                return py::convert(self->obj.TryDisplayTextAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryRefreshAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryRefreshAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryScrollTextAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayScrollDirection>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.TryScrollTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_get_InterCharacterWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterCharacterWaitInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayWindow_put_InterCharacterWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.InterCharacterWaitInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayWindow_get_SizeInCharacters(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SizeInCharacters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_get_Cursor(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Cursor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_get_Marquee(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Marquee());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LineDisplayWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayWindow>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LineDisplayWindow(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_LineDisplayWindow(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayWindow[] = {
        { "close", (PyCFunction)LineDisplayWindow_Close, METH_VARARGS, nullptr },
        { "read_character_at_cursor_async", (PyCFunction)LineDisplayWindow_ReadCharacterAtCursorAsync, METH_VARARGS, nullptr },
        { "try_clear_text_async", (PyCFunction)LineDisplayWindow_TryClearTextAsync, METH_VARARGS, nullptr },
        { "try_display_storage_file_bitmap_at_cursor_async", (PyCFunction)LineDisplayWindow_TryDisplayStorageFileBitmapAtCursorAsync, METH_VARARGS, nullptr },
        { "try_display_storage_file_bitmap_at_point_async", (PyCFunction)LineDisplayWindow_TryDisplayStorageFileBitmapAtPointAsync, METH_VARARGS, nullptr },
        { "try_display_stored_bitmap_at_cursor_async", (PyCFunction)LineDisplayWindow_TryDisplayStoredBitmapAtCursorAsync, METH_VARARGS, nullptr },
        { "try_display_text_async", (PyCFunction)LineDisplayWindow_TryDisplayTextAsync, METH_VARARGS, nullptr },
        { "try_refresh_async", (PyCFunction)LineDisplayWindow_TryRefreshAsync, METH_VARARGS, nullptr },
        { "try_scroll_text_async", (PyCFunction)LineDisplayWindow_TryScrollTextAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_LineDisplayWindow, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_LineDisplayWindow, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_LineDisplayWindow, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LineDisplayWindow[] = {
        { const_cast<char*>("inter_character_wait_interval"), (getter)LineDisplayWindow_get_InterCharacterWaitInterval, (setter)LineDisplayWindow_put_InterCharacterWaitInterval, nullptr, nullptr },
        { const_cast<char*>("size_in_characters"), (getter)LineDisplayWindow_get_SizeInCharacters, nullptr, nullptr, nullptr },
        { const_cast<char*>("cursor"), (getter)LineDisplayWindow_get_Cursor, nullptr, nullptr, nullptr },
        { const_cast<char*>("marquee"), (getter)LineDisplayWindow_get_Marquee, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LineDisplayWindow[] = 
    {
        { Py_tp_new, _new_LineDisplayWindow },
        { Py_tp_dealloc, _dealloc_LineDisplayWindow },
        { Py_tp_methods, _methods_LineDisplayWindow },
        { Py_tp_getset, _getset_LineDisplayWindow },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LineDisplayWindow =
    {
        "_winrt_Windows_Devices_PointOfService.LineDisplayWindow",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayWindow
    };

    // ----- MagneticStripeReader class --------------------
    constexpr const char* const _type_name_MagneticStripeReader = "MagneticStripeReader";

    static PyObject* _new_MagneticStripeReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReader);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MagneticStripeReader_CheckHealthAsync(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel>(args, 0);

                return py::convert(self->obj.CheckHealthAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_ClaimReaderAsync(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClaimReaderAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_Close(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReader::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReader::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReader::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReader::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_GetErrorReportingType(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetErrorReportingType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_RetrieveStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.RetrieveStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_get_DeviceAuthenticationProtocol(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceAuthenticationProtocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_get_SupportedCardTypes(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedCardTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_add_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::MagneticStripeReader, winrt::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs>>(arg);

            return py::convert(self->obj.StatusUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_remove_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MagneticStripeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_MagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReader[] = {
        { "check_health_async", (PyCFunction)MagneticStripeReader_CheckHealthAsync, METH_VARARGS, nullptr },
        { "claim_reader_async", (PyCFunction)MagneticStripeReader_ClaimReaderAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)MagneticStripeReader_Close, METH_VARARGS, nullptr },
        { "from_id_async", (PyCFunction)MagneticStripeReader_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_async", (PyCFunction)MagneticStripeReader_GetDefaultAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)MagneticStripeReader_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "get_error_reporting_type", (PyCFunction)MagneticStripeReader_GetErrorReportingType, METH_VARARGS, nullptr },
        { "retrieve_statistics_async", (PyCFunction)MagneticStripeReader_RetrieveStatisticsAsync, METH_VARARGS, nullptr },
        { "add_status_updated", (PyCFunction)MagneticStripeReader_add_StatusUpdated, METH_O, nullptr },
        { "remove_status_updated", (PyCFunction)MagneticStripeReader_remove_StatusUpdated, METH_O, nullptr },
        { "_from", (PyCFunction)_from_MagneticStripeReader, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_MagneticStripeReader, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_MagneticStripeReader, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MagneticStripeReader[] = {
        { const_cast<char*>("capabilities"), (getter)MagneticStripeReader_get_Capabilities, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_authentication_protocol"), (getter)MagneticStripeReader_get_DeviceAuthenticationProtocol, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)MagneticStripeReader_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_card_types"), (getter)MagneticStripeReader_get_SupportedCardTypes, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MagneticStripeReader[] = 
    {
        { Py_tp_new, _new_MagneticStripeReader },
        { Py_tp_dealloc, _dealloc_MagneticStripeReader },
        { Py_tp_methods, _methods_MagneticStripeReader },
        { Py_tp_getset, _getset_MagneticStripeReader },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MagneticStripeReader =
    {
        "_winrt_Windows_Devices_PointOfService.MagneticStripeReader",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReader
    };

    // ----- MagneticStripeReaderAamvaCardDataReceivedEventArgs class --------------------
    constexpr const char* const _type_name_MagneticStripeReaderAamvaCardDataReceivedEventArgs = "MagneticStripeReaderAamvaCardDataReceivedEventArgs";

    static PyObject* _new_MagneticStripeReaderAamvaCardDataReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReaderAamvaCardDataReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderAamvaCardDataReceivedEventArgs(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Address(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_BirthDate(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BirthDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_City(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.City());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Class(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Class());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Endorsements(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Endorsements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_ExpirationDate(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_EyeColor(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EyeColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_FirstName(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FirstName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Gender(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Gender());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_HairColor(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HairColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Height(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_LicenseNumber(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LicenseNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_PostalCode(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PostalCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Report(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Report());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Restrictions(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Restrictions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_State(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Suffix(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Suffix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Surname(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Surname());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Weight(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Weight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MagneticStripeReaderAamvaCardDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderAamvaCardDataReceivedEventArgs[] = {
        { "_from", (PyCFunction)_from_MagneticStripeReaderAamvaCardDataReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MagneticStripeReaderAamvaCardDataReceivedEventArgs[] = {
        { const_cast<char*>("address"), (getter)MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Address, nullptr, nullptr, nullptr },
        { const_cast<char*>("birth_date"), (getter)MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_BirthDate, nullptr, nullptr, nullptr },
        { const_cast<char*>("city"), (getter)MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_City, nullptr, nullptr, nullptr },
        { const_cast<char*>("class"), (getter)MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Class, nullptr, nullptr, nullptr },
        { const_cast<char*>("endorsements"), (getter)MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Endorsements, nullptr, nullptr, nullptr },
        { const_cast<char*>("expiration_date"), (getter)MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_ExpirationDate, nullptr, nullptr, nullptr },
        { const_cast<char*>("eye_color"), (getter)MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_EyeColor, nullptr, nullptr, nullptr },
        { const_cast<char*>("first_name"), (getter)MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_FirstName, nullptr, nullptr, nullptr },
        { const_cast<char*>("gender"), (getter)MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Gender, nullptr, nullptr, nullptr },
        { const_cast<char*>("hair_color"), (getter)MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_HairColor, nullptr, nullptr, nullptr },
        { const_cast<char*>("height"), (getter)MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Height, nullptr, nullptr, nullptr },
        { const_cast<char*>("license_number"), (getter)MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_LicenseNumber, nullptr, nullptr, nullptr },
        { const_cast<char*>("postal_code"), (getter)MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_PostalCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("report"), (getter)MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Report, nullptr, nullptr, nullptr },
        { const_cast<char*>("restrictions"), (getter)MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Restrictions, nullptr, nullptr, nullptr },
        { const_cast<char*>("state"), (getter)MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_State, nullptr, nullptr, nullptr },
        { const_cast<char*>("suffix"), (getter)MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Suffix, nullptr, nullptr, nullptr },
        { const_cast<char*>("surname"), (getter)MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Surname, nullptr, nullptr, nullptr },
        { const_cast<char*>("weight"), (getter)MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Weight, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderAamvaCardDataReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_MagneticStripeReaderAamvaCardDataReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_MagneticStripeReaderAamvaCardDataReceivedEventArgs },
        { Py_tp_methods, _methods_MagneticStripeReaderAamvaCardDataReceivedEventArgs },
        { Py_tp_getset, _getset_MagneticStripeReaderAamvaCardDataReceivedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MagneticStripeReaderAamvaCardDataReceivedEventArgs =
    {
        "_winrt_Windows_Devices_PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderAamvaCardDataReceivedEventArgs
    };

    // ----- MagneticStripeReaderBankCardDataReceivedEventArgs class --------------------
    constexpr const char* const _type_name_MagneticStripeReaderBankCardDataReceivedEventArgs = "MagneticStripeReaderBankCardDataReceivedEventArgs";

    static PyObject* _new_MagneticStripeReaderBankCardDataReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReaderBankCardDataReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderBankCardDataReceivedEventArgs(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_AccountNumber(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccountNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_ExpirationDate(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_FirstName(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FirstName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_MiddleInitial(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MiddleInitial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_Report(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Report());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_ServiceCode(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_Suffix(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Suffix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_Surname(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Surname());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_Title(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MagneticStripeReaderBankCardDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderBankCardDataReceivedEventArgs[] = {
        { "_from", (PyCFunction)_from_MagneticStripeReaderBankCardDataReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MagneticStripeReaderBankCardDataReceivedEventArgs[] = {
        { const_cast<char*>("account_number"), (getter)MagneticStripeReaderBankCardDataReceivedEventArgs_get_AccountNumber, nullptr, nullptr, nullptr },
        { const_cast<char*>("expiration_date"), (getter)MagneticStripeReaderBankCardDataReceivedEventArgs_get_ExpirationDate, nullptr, nullptr, nullptr },
        { const_cast<char*>("first_name"), (getter)MagneticStripeReaderBankCardDataReceivedEventArgs_get_FirstName, nullptr, nullptr, nullptr },
        { const_cast<char*>("middle_initial"), (getter)MagneticStripeReaderBankCardDataReceivedEventArgs_get_MiddleInitial, nullptr, nullptr, nullptr },
        { const_cast<char*>("report"), (getter)MagneticStripeReaderBankCardDataReceivedEventArgs_get_Report, nullptr, nullptr, nullptr },
        { const_cast<char*>("service_code"), (getter)MagneticStripeReaderBankCardDataReceivedEventArgs_get_ServiceCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("suffix"), (getter)MagneticStripeReaderBankCardDataReceivedEventArgs_get_Suffix, nullptr, nullptr, nullptr },
        { const_cast<char*>("surname"), (getter)MagneticStripeReaderBankCardDataReceivedEventArgs_get_Surname, nullptr, nullptr, nullptr },
        { const_cast<char*>("title"), (getter)MagneticStripeReaderBankCardDataReceivedEventArgs_get_Title, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderBankCardDataReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_MagneticStripeReaderBankCardDataReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_MagneticStripeReaderBankCardDataReceivedEventArgs },
        { Py_tp_methods, _methods_MagneticStripeReaderBankCardDataReceivedEventArgs },
        { Py_tp_getset, _getset_MagneticStripeReaderBankCardDataReceivedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MagneticStripeReaderBankCardDataReceivedEventArgs =
    {
        "_winrt_Windows_Devices_PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderBankCardDataReceivedEventArgs
    };

    // ----- MagneticStripeReaderCapabilities class --------------------
    constexpr const char* const _type_name_MagneticStripeReaderCapabilities = "MagneticStripeReaderCapabilities";

    static PyObject* _new_MagneticStripeReaderCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReaderCapabilities);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderCapabilities(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MagneticStripeReaderCapabilities_get_AuthenticationLevel(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AuthenticationLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_CardAuthentication(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CardAuthentication());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsIsoSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsIsoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsJisOneSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsJisOneSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsJisTwoSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsJisTwoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsStatisticsReportingSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatisticsReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsStatisticsUpdatingSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatisticsUpdatingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsTrackDataMaskingSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTrackDataMaskingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsTransmitSentinelsSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTransmitSentinelsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_PowerReportingType(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerReportingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_SupportedEncryptionAlgorithms(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedEncryptionAlgorithms());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MagneticStripeReaderCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderCapabilities[] = {
        { "_from", (PyCFunction)_from_MagneticStripeReaderCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MagneticStripeReaderCapabilities[] = {
        { const_cast<char*>("authentication_level"), (getter)MagneticStripeReaderCapabilities_get_AuthenticationLevel, nullptr, nullptr, nullptr },
        { const_cast<char*>("card_authentication"), (getter)MagneticStripeReaderCapabilities_get_CardAuthentication, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_iso_supported"), (getter)MagneticStripeReaderCapabilities_get_IsIsoSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_jis_one_supported"), (getter)MagneticStripeReaderCapabilities_get_IsJisOneSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_jis_two_supported"), (getter)MagneticStripeReaderCapabilities_get_IsJisTwoSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_statistics_reporting_supported"), (getter)MagneticStripeReaderCapabilities_get_IsStatisticsReportingSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_statistics_updating_supported"), (getter)MagneticStripeReaderCapabilities_get_IsStatisticsUpdatingSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_track_data_masking_supported"), (getter)MagneticStripeReaderCapabilities_get_IsTrackDataMaskingSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_transmit_sentinels_supported"), (getter)MagneticStripeReaderCapabilities_get_IsTransmitSentinelsSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("power_reporting_type"), (getter)MagneticStripeReaderCapabilities_get_PowerReportingType, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_encryption_algorithms"), (getter)MagneticStripeReaderCapabilities_get_SupportedEncryptionAlgorithms, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderCapabilities[] = 
    {
        { Py_tp_new, _new_MagneticStripeReaderCapabilities },
        { Py_tp_dealloc, _dealloc_MagneticStripeReaderCapabilities },
        { Py_tp_methods, _methods_MagneticStripeReaderCapabilities },
        { Py_tp_getset, _getset_MagneticStripeReaderCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MagneticStripeReaderCapabilities =
    {
        "_winrt_Windows_Devices_PointOfService.MagneticStripeReaderCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderCapabilities
    };

    // ----- MagneticStripeReaderCardTypes class --------------------
    constexpr const char* const _type_name_MagneticStripeReaderCardTypes = "MagneticStripeReaderCardTypes";

    static PyObject* _new_MagneticStripeReaderCardTypes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReaderCardTypes);
        return nullptr;
    }

    static PyObject* MagneticStripeReaderCardTypes_get_Aamva(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes::Aamva());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCardTypes_get_Bank(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes::Bank());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCardTypes_get_ExtendedBase(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes::ExtendedBase());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCardTypes_get_Unknown(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes::Unknown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderCardTypes[] = {
        { "get_aamva", (PyCFunction)MagneticStripeReaderCardTypes_get_Aamva, METH_NOARGS | METH_STATIC, nullptr },
        { "get_bank", (PyCFunction)MagneticStripeReaderCardTypes_get_Bank, METH_NOARGS | METH_STATIC, nullptr },
        { "get_extended_base", (PyCFunction)MagneticStripeReaderCardTypes_get_ExtendedBase, METH_NOARGS | METH_STATIC, nullptr },
        { "get_unknown", (PyCFunction)MagneticStripeReaderCardTypes_get_Unknown, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MagneticStripeReaderCardTypes[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderCardTypes[] = 
    {
        { Py_tp_new, _new_MagneticStripeReaderCardTypes },
        { Py_tp_methods, _methods_MagneticStripeReaderCardTypes },
        { Py_tp_getset, _getset_MagneticStripeReaderCardTypes },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MagneticStripeReaderCardTypes =
    {
        "_winrt_Windows_Devices_PointOfService.MagneticStripeReaderCardTypes",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderCardTypes
    };

    // ----- MagneticStripeReaderEncryptionAlgorithms class --------------------
    constexpr const char* const _type_name_MagneticStripeReaderEncryptionAlgorithms = "MagneticStripeReaderEncryptionAlgorithms";

    static PyObject* _new_MagneticStripeReaderEncryptionAlgorithms(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReaderEncryptionAlgorithms);
        return nullptr;
    }

    static PyObject* MagneticStripeReaderEncryptionAlgorithms_get_ExtendedBase(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderEncryptionAlgorithms::ExtendedBase());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderEncryptionAlgorithms_get_None(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderEncryptionAlgorithms::None());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderEncryptionAlgorithms_get_TripleDesDukpt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderEncryptionAlgorithms::TripleDesDukpt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderEncryptionAlgorithms[] = {
        { "get_extended_base", (PyCFunction)MagneticStripeReaderEncryptionAlgorithms_get_ExtendedBase, METH_NOARGS | METH_STATIC, nullptr },
        { "get_none", (PyCFunction)MagneticStripeReaderEncryptionAlgorithms_get_None, METH_NOARGS | METH_STATIC, nullptr },
        { "get_triple_des_dukpt", (PyCFunction)MagneticStripeReaderEncryptionAlgorithms_get_TripleDesDukpt, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MagneticStripeReaderEncryptionAlgorithms[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderEncryptionAlgorithms[] = 
    {
        { Py_tp_new, _new_MagneticStripeReaderEncryptionAlgorithms },
        { Py_tp_methods, _methods_MagneticStripeReaderEncryptionAlgorithms },
        { Py_tp_getset, _getset_MagneticStripeReaderEncryptionAlgorithms },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MagneticStripeReaderEncryptionAlgorithms =
    {
        "_winrt_Windows_Devices_PointOfService.MagneticStripeReaderEncryptionAlgorithms",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderEncryptionAlgorithms
    };

    // ----- MagneticStripeReaderErrorOccurredEventArgs class --------------------
    constexpr const char* const _type_name_MagneticStripeReaderErrorOccurredEventArgs = "MagneticStripeReaderErrorOccurredEventArgs";

    static PyObject* _new_MagneticStripeReaderErrorOccurredEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReaderErrorOccurredEventArgs);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderErrorOccurredEventArgs(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_ErrorData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_PartialInputData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PartialInputData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_Track1Status(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Track1Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_Track2Status(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Track2Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_Track3Status(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Track3Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_Track4Status(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Track4Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MagneticStripeReaderErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderErrorOccurredEventArgs[] = {
        { "_from", (PyCFunction)_from_MagneticStripeReaderErrorOccurredEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MagneticStripeReaderErrorOccurredEventArgs[] = {
        { const_cast<char*>("error_data"), (getter)MagneticStripeReaderErrorOccurredEventArgs_get_ErrorData, nullptr, nullptr, nullptr },
        { const_cast<char*>("partial_input_data"), (getter)MagneticStripeReaderErrorOccurredEventArgs_get_PartialInputData, nullptr, nullptr, nullptr },
        { const_cast<char*>("track1_status"), (getter)MagneticStripeReaderErrorOccurredEventArgs_get_Track1Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("track2_status"), (getter)MagneticStripeReaderErrorOccurredEventArgs_get_Track2Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("track3_status"), (getter)MagneticStripeReaderErrorOccurredEventArgs_get_Track3Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("track4_status"), (getter)MagneticStripeReaderErrorOccurredEventArgs_get_Track4Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderErrorOccurredEventArgs[] = 
    {
        { Py_tp_new, _new_MagneticStripeReaderErrorOccurredEventArgs },
        { Py_tp_dealloc, _dealloc_MagneticStripeReaderErrorOccurredEventArgs },
        { Py_tp_methods, _methods_MagneticStripeReaderErrorOccurredEventArgs },
        { Py_tp_getset, _getset_MagneticStripeReaderErrorOccurredEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MagneticStripeReaderErrorOccurredEventArgs =
    {
        "_winrt_Windows_Devices_PointOfService.MagneticStripeReaderErrorOccurredEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderErrorOccurredEventArgs
    };

    // ----- MagneticStripeReaderReport class --------------------
    constexpr const char* const _type_name_MagneticStripeReaderReport = "MagneticStripeReaderReport";

    static PyObject* _new_MagneticStripeReaderReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReaderReport);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderReport(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MagneticStripeReaderReport_get_AdditionalSecurityInformation(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdditionalSecurityInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_CardAuthenticationData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CardAuthenticationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_CardAuthenticationDataLength(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CardAuthenticationDataLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_CardType(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CardType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_Properties(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_Track1(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Track1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_Track2(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Track2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_Track3(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Track3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_Track4(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Track4());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MagneticStripeReaderReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderReport[] = {
        { "_from", (PyCFunction)_from_MagneticStripeReaderReport, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MagneticStripeReaderReport[] = {
        { const_cast<char*>("additional_security_information"), (getter)MagneticStripeReaderReport_get_AdditionalSecurityInformation, nullptr, nullptr, nullptr },
        { const_cast<char*>("card_authentication_data"), (getter)MagneticStripeReaderReport_get_CardAuthenticationData, nullptr, nullptr, nullptr },
        { const_cast<char*>("card_authentication_data_length"), (getter)MagneticStripeReaderReport_get_CardAuthenticationDataLength, nullptr, nullptr, nullptr },
        { const_cast<char*>("card_type"), (getter)MagneticStripeReaderReport_get_CardType, nullptr, nullptr, nullptr },
        { const_cast<char*>("properties"), (getter)MagneticStripeReaderReport_get_Properties, nullptr, nullptr, nullptr },
        { const_cast<char*>("track1"), (getter)MagneticStripeReaderReport_get_Track1, nullptr, nullptr, nullptr },
        { const_cast<char*>("track2"), (getter)MagneticStripeReaderReport_get_Track2, nullptr, nullptr, nullptr },
        { const_cast<char*>("track3"), (getter)MagneticStripeReaderReport_get_Track3, nullptr, nullptr, nullptr },
        { const_cast<char*>("track4"), (getter)MagneticStripeReaderReport_get_Track4, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderReport[] = 
    {
        { Py_tp_new, _new_MagneticStripeReaderReport },
        { Py_tp_dealloc, _dealloc_MagneticStripeReaderReport },
        { Py_tp_methods, _methods_MagneticStripeReaderReport },
        { Py_tp_getset, _getset_MagneticStripeReaderReport },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MagneticStripeReaderReport =
    {
        "_winrt_Windows_Devices_PointOfService.MagneticStripeReaderReport",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderReport
    };

    // ----- MagneticStripeReaderStatusUpdatedEventArgs class --------------------
    constexpr const char* const _type_name_MagneticStripeReaderStatusUpdatedEventArgs = "MagneticStripeReaderStatusUpdatedEventArgs";

    static PyObject* _new_MagneticStripeReaderStatusUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReaderStatusUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderStatusUpdatedEventArgs(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MagneticStripeReaderStatusUpdatedEventArgs_get_ExtendedStatus(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderStatusUpdatedEventArgs_get_Status(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MagneticStripeReaderStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderStatusUpdatedEventArgs[] = {
        { "_from", (PyCFunction)_from_MagneticStripeReaderStatusUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MagneticStripeReaderStatusUpdatedEventArgs[] = {
        { const_cast<char*>("extended_status"), (getter)MagneticStripeReaderStatusUpdatedEventArgs_get_ExtendedStatus, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)MagneticStripeReaderStatusUpdatedEventArgs_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderStatusUpdatedEventArgs[] = 
    {
        { Py_tp_new, _new_MagneticStripeReaderStatusUpdatedEventArgs },
        { Py_tp_dealloc, _dealloc_MagneticStripeReaderStatusUpdatedEventArgs },
        { Py_tp_methods, _methods_MagneticStripeReaderStatusUpdatedEventArgs },
        { Py_tp_getset, _getset_MagneticStripeReaderStatusUpdatedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MagneticStripeReaderStatusUpdatedEventArgs =
    {
        "_winrt_Windows_Devices_PointOfService.MagneticStripeReaderStatusUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderStatusUpdatedEventArgs
    };

    // ----- MagneticStripeReaderTrackData class --------------------
    constexpr const char* const _type_name_MagneticStripeReaderTrackData = "MagneticStripeReaderTrackData";

    static PyObject* _new_MagneticStripeReaderTrackData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReaderTrackData);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderTrackData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderTrackData* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MagneticStripeReaderTrackData_get_Data(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderTrackData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderTrackData_get_DiscretionaryData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderTrackData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DiscretionaryData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderTrackData_get_EncryptedData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderTrackData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncryptedData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MagneticStripeReaderTrackData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderTrackData[] = {
        { "_from", (PyCFunction)_from_MagneticStripeReaderTrackData, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MagneticStripeReaderTrackData[] = {
        { const_cast<char*>("data"), (getter)MagneticStripeReaderTrackData_get_Data, nullptr, nullptr, nullptr },
        { const_cast<char*>("discretionary_data"), (getter)MagneticStripeReaderTrackData_get_DiscretionaryData, nullptr, nullptr, nullptr },
        { const_cast<char*>("encrypted_data"), (getter)MagneticStripeReaderTrackData_get_EncryptedData, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderTrackData[] = 
    {
        { Py_tp_new, _new_MagneticStripeReaderTrackData },
        { Py_tp_dealloc, _dealloc_MagneticStripeReaderTrackData },
        { Py_tp_methods, _methods_MagneticStripeReaderTrackData },
        { Py_tp_getset, _getset_MagneticStripeReaderTrackData },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MagneticStripeReaderTrackData =
    {
        "_winrt_Windows_Devices_PointOfService.MagneticStripeReaderTrackData",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderTrackData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderTrackData
    };

    // ----- MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs class --------------------
    constexpr const char* const _type_name_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs = "MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs";

    static PyObject* _new_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs_get_Report(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Report());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs[] = {
        { "_from", (PyCFunction)_from_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs[] = {
        { const_cast<char*>("report"), (getter)MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs_get_Report, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs },
        { Py_tp_methods, _methods_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs },
        { Py_tp_getset, _getset_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs =
    {
        "_winrt_Windows_Devices_PointOfService.MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs
    };

    // ----- PosPrinter class --------------------
    constexpr const char* const _type_name_PosPrinter = "PosPrinter";

    static PyObject* _new_PosPrinter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PosPrinter);
        return nullptr;
    }

    static void _dealloc_PosPrinter(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PosPrinter_CheckHealthAsync(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel>(args, 0);

                return py::convert(self->obj.CheckHealthAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_ClaimPrinterAsync(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClaimPrinterAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_Close(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::PosPrinter::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::PosPrinter::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::PosPrinter::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::PosPrinter::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_GetFontProperty(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFontProperty(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_GetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_Status(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_SupportedCharacterSets(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedCharacterSets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_SupportedTypeFaces(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedTypeFaces());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_SupportedBarcodeSymbologies(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedBarcodeSymbologies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_add_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::PosPrinter, winrt::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs>>(arg);

            return py::convert(self->obj.StatusUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_remove_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PosPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PosPrinter(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_PosPrinter(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinter[] = {
        { "check_health_async", (PyCFunction)PosPrinter_CheckHealthAsync, METH_VARARGS, nullptr },
        { "claim_printer_async", (PyCFunction)PosPrinter_ClaimPrinterAsync, METH_VARARGS, nullptr },
        { "close", (PyCFunction)PosPrinter_Close, METH_VARARGS, nullptr },
        { "from_id_async", (PyCFunction)PosPrinter_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_async", (PyCFunction)PosPrinter_GetDefaultAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)PosPrinter_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "get_font_property", (PyCFunction)PosPrinter_GetFontProperty, METH_VARARGS, nullptr },
        { "get_statistics_async", (PyCFunction)PosPrinter_GetStatisticsAsync, METH_VARARGS, nullptr },
        { "add_status_updated", (PyCFunction)PosPrinter_add_StatusUpdated, METH_O, nullptr },
        { "remove_status_updated", (PyCFunction)PosPrinter_remove_StatusUpdated, METH_O, nullptr },
        { "_from", (PyCFunction)_from_PosPrinter, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_PosPrinter, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_PosPrinter, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PosPrinter[] = {
        { const_cast<char*>("capabilities"), (getter)PosPrinter_get_Capabilities, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)PosPrinter_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)PosPrinter_get_Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_character_sets"), (getter)PosPrinter_get_SupportedCharacterSets, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_type_faces"), (getter)PosPrinter_get_SupportedTypeFaces, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_barcode_symbologies"), (getter)PosPrinter_get_SupportedBarcodeSymbologies, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PosPrinter[] = 
    {
        { Py_tp_new, _new_PosPrinter },
        { Py_tp_dealloc, _dealloc_PosPrinter },
        { Py_tp_methods, _methods_PosPrinter },
        { Py_tp_getset, _getset_PosPrinter },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PosPrinter =
    {
        "_winrt_Windows_Devices_PointOfService.PosPrinter",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinter
    };

    // ----- PosPrinterCapabilities class --------------------
    constexpr const char* const _type_name_PosPrinterCapabilities = "PosPrinterCapabilities";

    static PyObject* _new_PosPrinterCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PosPrinterCapabilities);
        return nullptr;
    }

    static void _dealloc_PosPrinterCapabilities(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PosPrinterCapabilities_get_CanMapCharacterSet(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanMapCharacterSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_DefaultCharacterSet(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DefaultCharacterSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_HasCoverSensor(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasCoverSensor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_IsStatisticsReportingSupported(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatisticsReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_IsStatisticsUpdatingSupported(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatisticsUpdatingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_IsTransactionSupported(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTransactionSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_Journal(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Journal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_PowerReportingType(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerReportingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_Receipt(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Receipt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_Slip(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Slip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PosPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterCapabilities[] = {
        { "_from", (PyCFunction)_from_PosPrinterCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PosPrinterCapabilities[] = {
        { const_cast<char*>("can_map_character_set"), (getter)PosPrinterCapabilities_get_CanMapCharacterSet, nullptr, nullptr, nullptr },
        { const_cast<char*>("default_character_set"), (getter)PosPrinterCapabilities_get_DefaultCharacterSet, nullptr, nullptr, nullptr },
        { const_cast<char*>("has_cover_sensor"), (getter)PosPrinterCapabilities_get_HasCoverSensor, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_statistics_reporting_supported"), (getter)PosPrinterCapabilities_get_IsStatisticsReportingSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_statistics_updating_supported"), (getter)PosPrinterCapabilities_get_IsStatisticsUpdatingSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_transaction_supported"), (getter)PosPrinterCapabilities_get_IsTransactionSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("journal"), (getter)PosPrinterCapabilities_get_Journal, nullptr, nullptr, nullptr },
        { const_cast<char*>("power_reporting_type"), (getter)PosPrinterCapabilities_get_PowerReportingType, nullptr, nullptr, nullptr },
        { const_cast<char*>("receipt"), (getter)PosPrinterCapabilities_get_Receipt, nullptr, nullptr, nullptr },
        { const_cast<char*>("slip"), (getter)PosPrinterCapabilities_get_Slip, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PosPrinterCapabilities[] = 
    {
        { Py_tp_new, _new_PosPrinterCapabilities },
        { Py_tp_dealloc, _dealloc_PosPrinterCapabilities },
        { Py_tp_methods, _methods_PosPrinterCapabilities },
        { Py_tp_getset, _getset_PosPrinterCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PosPrinterCapabilities =
    {
        "_winrt_Windows_Devices_PointOfService.PosPrinterCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterCapabilities
    };

    // ----- PosPrinterCharacterSetIds class --------------------
    constexpr const char* const _type_name_PosPrinterCharacterSetIds = "PosPrinterCharacterSetIds";

    static PyObject* _new_PosPrinterCharacterSetIds(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PosPrinterCharacterSetIds);
        return nullptr;
    }

    static PyObject* PosPrinterCharacterSetIds_get_Ansi(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::PosPrinterCharacterSetIds::Ansi());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCharacterSetIds_get_Ascii(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::PosPrinterCharacterSetIds::Ascii());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCharacterSetIds_get_Utf16LE(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::PosPrinterCharacterSetIds::Utf16LE());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterCharacterSetIds[] = {
        { "get_ansi", (PyCFunction)PosPrinterCharacterSetIds_get_Ansi, METH_NOARGS | METH_STATIC, nullptr },
        { "get_ascii", (PyCFunction)PosPrinterCharacterSetIds_get_Ascii, METH_NOARGS | METH_STATIC, nullptr },
        { "get_utf16_l_e", (PyCFunction)PosPrinterCharacterSetIds_get_Utf16LE, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PosPrinterCharacterSetIds[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PosPrinterCharacterSetIds[] = 
    {
        { Py_tp_new, _new_PosPrinterCharacterSetIds },
        { Py_tp_methods, _methods_PosPrinterCharacterSetIds },
        { Py_tp_getset, _getset_PosPrinterCharacterSetIds },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PosPrinterCharacterSetIds =
    {
        "_winrt_Windows_Devices_PointOfService.PosPrinterCharacterSetIds",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterCharacterSetIds
    };

    // ----- PosPrinterFontProperty class --------------------
    constexpr const char* const _type_name_PosPrinterFontProperty = "PosPrinterFontProperty";

    static PyObject* _new_PosPrinterFontProperty(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PosPrinterFontProperty);
        return nullptr;
    }

    static void _dealloc_PosPrinterFontProperty(py::wrapper::Windows::Devices::PointOfService::PosPrinterFontProperty* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PosPrinterFontProperty_get_CharacterSizes(py::wrapper::Windows::Devices::PointOfService::PosPrinterFontProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharacterSizes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterFontProperty_get_IsScalableToAnySize(py::wrapper::Windows::Devices::PointOfService::PosPrinterFontProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsScalableToAnySize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterFontProperty_get_TypeFace(py::wrapper::Windows::Devices::PointOfService::PosPrinterFontProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TypeFace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PosPrinterFontProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterFontProperty>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterFontProperty[] = {
        { "_from", (PyCFunction)_from_PosPrinterFontProperty, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PosPrinterFontProperty[] = {
        { const_cast<char*>("character_sizes"), (getter)PosPrinterFontProperty_get_CharacterSizes, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_scalable_to_any_size"), (getter)PosPrinterFontProperty_get_IsScalableToAnySize, nullptr, nullptr, nullptr },
        { const_cast<char*>("type_face"), (getter)PosPrinterFontProperty_get_TypeFace, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PosPrinterFontProperty[] = 
    {
        { Py_tp_new, _new_PosPrinterFontProperty },
        { Py_tp_dealloc, _dealloc_PosPrinterFontProperty },
        { Py_tp_methods, _methods_PosPrinterFontProperty },
        { Py_tp_getset, _getset_PosPrinterFontProperty },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PosPrinterFontProperty =
    {
        "_winrt_Windows_Devices_PointOfService.PosPrinterFontProperty",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterFontProperty),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterFontProperty
    };

    // ----- PosPrinterPrintOptions class --------------------
    constexpr const char* const _type_name_PosPrinterPrintOptions = "PosPrinterPrintOptions";

    static PyObject* _new_PosPrinterPrintOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PosPrinterPrintOptions(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PosPrinterPrintOptions_get_Underline(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Underline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Underline(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Underline(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_TypeFace(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TypeFace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_TypeFace(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TypeFace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Superscript(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Superscript());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Superscript(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Superscript(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Subscript(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subscript());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Subscript(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Subscript(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Strikethrough(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Strikethrough());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Strikethrough(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Strikethrough(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_ReverseVideo(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReverseVideo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_ReverseVideo(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ReverseVideo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Italic(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Italic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Italic(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Italic(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_DoubleWide(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DoubleWide());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_DoubleWide(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DoubleWide(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_DoubleHigh(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DoubleHigh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_DoubleHigh(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DoubleHigh(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_CharacterSet(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharacterSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_CharacterSet(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharacterSet(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_CharacterHeight(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharacterHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_CharacterHeight(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharacterHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Bold(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Bold(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bold(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Alignment(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Alignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Alignment(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(arg);

            self->obj.Alignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_PosPrinterPrintOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterPrintOptions[] = {
        { "_from", (PyCFunction)_from_PosPrinterPrintOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PosPrinterPrintOptions[] = {
        { const_cast<char*>("underline"), (getter)PosPrinterPrintOptions_get_Underline, (setter)PosPrinterPrintOptions_put_Underline, nullptr, nullptr },
        { const_cast<char*>("type_face"), (getter)PosPrinterPrintOptions_get_TypeFace, (setter)PosPrinterPrintOptions_put_TypeFace, nullptr, nullptr },
        { const_cast<char*>("superscript"), (getter)PosPrinterPrintOptions_get_Superscript, (setter)PosPrinterPrintOptions_put_Superscript, nullptr, nullptr },
        { const_cast<char*>("subscript"), (getter)PosPrinterPrintOptions_get_Subscript, (setter)PosPrinterPrintOptions_put_Subscript, nullptr, nullptr },
        { const_cast<char*>("strikethrough"), (getter)PosPrinterPrintOptions_get_Strikethrough, (setter)PosPrinterPrintOptions_put_Strikethrough, nullptr, nullptr },
        { const_cast<char*>("reverse_video"), (getter)PosPrinterPrintOptions_get_ReverseVideo, (setter)PosPrinterPrintOptions_put_ReverseVideo, nullptr, nullptr },
        { const_cast<char*>("italic"), (getter)PosPrinterPrintOptions_get_Italic, (setter)PosPrinterPrintOptions_put_Italic, nullptr, nullptr },
        { const_cast<char*>("double_wide"), (getter)PosPrinterPrintOptions_get_DoubleWide, (setter)PosPrinterPrintOptions_put_DoubleWide, nullptr, nullptr },
        { const_cast<char*>("double_high"), (getter)PosPrinterPrintOptions_get_DoubleHigh, (setter)PosPrinterPrintOptions_put_DoubleHigh, nullptr, nullptr },
        { const_cast<char*>("character_set"), (getter)PosPrinterPrintOptions_get_CharacterSet, (setter)PosPrinterPrintOptions_put_CharacterSet, nullptr, nullptr },
        { const_cast<char*>("character_height"), (getter)PosPrinterPrintOptions_get_CharacterHeight, (setter)PosPrinterPrintOptions_put_CharacterHeight, nullptr, nullptr },
        { const_cast<char*>("bold"), (getter)PosPrinterPrintOptions_get_Bold, (setter)PosPrinterPrintOptions_put_Bold, nullptr, nullptr },
        { const_cast<char*>("alignment"), (getter)PosPrinterPrintOptions_get_Alignment, (setter)PosPrinterPrintOptions_put_Alignment, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PosPrinterPrintOptions[] = 
    {
        { Py_tp_new, _new_PosPrinterPrintOptions },
        { Py_tp_dealloc, _dealloc_PosPrinterPrintOptions },
        { Py_tp_methods, _methods_PosPrinterPrintOptions },
        { Py_tp_getset, _getset_PosPrinterPrintOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PosPrinterPrintOptions =
    {
        "_winrt_Windows_Devices_PointOfService.PosPrinterPrintOptions",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterPrintOptions
    };

    // ----- PosPrinterReleaseDeviceRequestedEventArgs class --------------------
    constexpr const char* const _type_name_PosPrinterReleaseDeviceRequestedEventArgs = "PosPrinterReleaseDeviceRequestedEventArgs";

    static PyObject* _new_PosPrinterReleaseDeviceRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PosPrinterReleaseDeviceRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_PosPrinterReleaseDeviceRequestedEventArgs(py::wrapper::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_PosPrinterReleaseDeviceRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterReleaseDeviceRequestedEventArgs[] = {
        { "_from", (PyCFunction)_from_PosPrinterReleaseDeviceRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PosPrinterReleaseDeviceRequestedEventArgs[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PosPrinterReleaseDeviceRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_PosPrinterReleaseDeviceRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_PosPrinterReleaseDeviceRequestedEventArgs },
        { Py_tp_methods, _methods_PosPrinterReleaseDeviceRequestedEventArgs },
        { Py_tp_getset, _getset_PosPrinterReleaseDeviceRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PosPrinterReleaseDeviceRequestedEventArgs =
    {
        "_winrt_Windows_Devices_PointOfService.PosPrinterReleaseDeviceRequestedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterReleaseDeviceRequestedEventArgs
    };

    // ----- PosPrinterStatus class --------------------
    constexpr const char* const _type_name_PosPrinterStatus = "PosPrinterStatus";

    static PyObject* _new_PosPrinterStatus(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PosPrinterStatus);
        return nullptr;
    }

    static void _dealloc_PosPrinterStatus(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatus* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PosPrinterStatus_get_ExtendedStatus(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterStatus_get_StatusKind(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StatusKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PosPrinterStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterStatus[] = {
        { "_from", (PyCFunction)_from_PosPrinterStatus, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PosPrinterStatus[] = {
        { const_cast<char*>("extended_status"), (getter)PosPrinterStatus_get_ExtendedStatus, nullptr, nullptr, nullptr },
        { const_cast<char*>("status_kind"), (getter)PosPrinterStatus_get_StatusKind, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PosPrinterStatus[] = 
    {
        { Py_tp_new, _new_PosPrinterStatus },
        { Py_tp_dealloc, _dealloc_PosPrinterStatus },
        { Py_tp_methods, _methods_PosPrinterStatus },
        { Py_tp_getset, _getset_PosPrinterStatus },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PosPrinterStatus =
    {
        "_winrt_Windows_Devices_PointOfService.PosPrinterStatus",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterStatus
    };

    // ----- PosPrinterStatusUpdatedEventArgs class --------------------
    constexpr const char* const _type_name_PosPrinterStatusUpdatedEventArgs = "PosPrinterStatusUpdatedEventArgs";

    static PyObject* _new_PosPrinterStatusUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PosPrinterStatusUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_PosPrinterStatusUpdatedEventArgs(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PosPrinterStatusUpdatedEventArgs_get_Status(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PosPrinterStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterStatusUpdatedEventArgs[] = {
        { "_from", (PyCFunction)_from_PosPrinterStatusUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PosPrinterStatusUpdatedEventArgs[] = {
        { const_cast<char*>("status"), (getter)PosPrinterStatusUpdatedEventArgs_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PosPrinterStatusUpdatedEventArgs[] = 
    {
        { Py_tp_new, _new_PosPrinterStatusUpdatedEventArgs },
        { Py_tp_dealloc, _dealloc_PosPrinterStatusUpdatedEventArgs },
        { Py_tp_methods, _methods_PosPrinterStatusUpdatedEventArgs },
        { Py_tp_getset, _getset_PosPrinterStatusUpdatedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PosPrinterStatusUpdatedEventArgs =
    {
        "_winrt_Windows_Devices_PointOfService.PosPrinterStatusUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterStatusUpdatedEventArgs
    };

    // ----- ReceiptPrintJob class --------------------
    constexpr const char* const _type_name_ReceiptPrintJob = "ReceiptPrintJob";

    static PyObject* _new_ReceiptPrintJob(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ReceiptPrintJob);
        return nullptr;
    }

    static void _dealloc_ReceiptPrintJob(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ReceiptPrintJob_CutPaper(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.CutPaper();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.CutPaper(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_DrawRuledLine(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineDirection>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineStyle>(args, 3);
                auto param4 = py::convert_to<uint32_t>(args, 4);

                self->obj.DrawRuledLine(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_ExecuteAsync(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ExecuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_FeedPaperByLine(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_FeedPaperByMapModeUnit(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByMapModeUnit(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_MarkFeed(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterMarkFeedKind>(args, 0);

                self->obj.MarkFeed(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_Print(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Print(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>(args, 1);

                self->obj.Print(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintBarcode(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 5);

                self->obj.PrintBarcode(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintBarcodeCustomAlign(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);

                self->obj.PrintBarcodeCustomAlign(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintBitmap(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);

                self->obj.PrintBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.PrintCustomAlignedBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintLine(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.PrintLine();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PrintLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintSavedBitmap(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.PrintSavedBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_SetBarcodeRotation(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);

                self->obj.SetBarcodeRotation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_SetBitmap(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);

                self->obj.SetBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_SetCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_SetPrintArea(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                self->obj.SetPrintArea(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_SetPrintRotation(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.SetPrintRotation(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_StampPaper(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.StampPaper();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ReceiptPrintJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ReceiptPrintJob>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ReceiptPrintJob[] = {
        { "cut_paper", (PyCFunction)ReceiptPrintJob_CutPaper, METH_VARARGS, nullptr },
        { "draw_ruled_line", (PyCFunction)ReceiptPrintJob_DrawRuledLine, METH_VARARGS, nullptr },
        { "execute_async", (PyCFunction)ReceiptPrintJob_ExecuteAsync, METH_VARARGS, nullptr },
        { "feed_paper_by_line", (PyCFunction)ReceiptPrintJob_FeedPaperByLine, METH_VARARGS, nullptr },
        { "feed_paper_by_map_mode_unit", (PyCFunction)ReceiptPrintJob_FeedPaperByMapModeUnit, METH_VARARGS, nullptr },
        { "mark_feed", (PyCFunction)ReceiptPrintJob_MarkFeed, METH_VARARGS, nullptr },
        { "print", (PyCFunction)ReceiptPrintJob_Print, METH_VARARGS, nullptr },
        { "print_barcode", (PyCFunction)ReceiptPrintJob_PrintBarcode, METH_VARARGS, nullptr },
        { "print_barcode_custom_align", (PyCFunction)ReceiptPrintJob_PrintBarcodeCustomAlign, METH_VARARGS, nullptr },
        { "print_bitmap", (PyCFunction)ReceiptPrintJob_PrintBitmap, METH_VARARGS, nullptr },
        { "print_custom_aligned_bitmap", (PyCFunction)ReceiptPrintJob_PrintCustomAlignedBitmap, METH_VARARGS, nullptr },
        { "print_line", (PyCFunction)ReceiptPrintJob_PrintLine, METH_VARARGS, nullptr },
        { "print_saved_bitmap", (PyCFunction)ReceiptPrintJob_PrintSavedBitmap, METH_VARARGS, nullptr },
        { "set_barcode_rotation", (PyCFunction)ReceiptPrintJob_SetBarcodeRotation, METH_VARARGS, nullptr },
        { "set_bitmap", (PyCFunction)ReceiptPrintJob_SetBitmap, METH_VARARGS, nullptr },
        { "set_custom_aligned_bitmap", (PyCFunction)ReceiptPrintJob_SetCustomAlignedBitmap, METH_VARARGS, nullptr },
        { "set_print_area", (PyCFunction)ReceiptPrintJob_SetPrintArea, METH_VARARGS, nullptr },
        { "set_print_rotation", (PyCFunction)ReceiptPrintJob_SetPrintRotation, METH_VARARGS, nullptr },
        { "stamp_paper", (PyCFunction)ReceiptPrintJob_StampPaper, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ReceiptPrintJob, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ReceiptPrintJob[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ReceiptPrintJob[] = 
    {
        { Py_tp_new, _new_ReceiptPrintJob },
        { Py_tp_dealloc, _dealloc_ReceiptPrintJob },
        { Py_tp_methods, _methods_ReceiptPrintJob },
        { Py_tp_getset, _getset_ReceiptPrintJob },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ReceiptPrintJob =
    {
        "_winrt_Windows_Devices_PointOfService.ReceiptPrintJob",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ReceiptPrintJob
    };

    // ----- ReceiptPrinterCapabilities class --------------------
    constexpr const char* const _type_name_ReceiptPrinterCapabilities = "ReceiptPrinterCapabilities";

    static PyObject* _new_ReceiptPrinterCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ReceiptPrinterCapabilities);
        return nullptr;
    }

    static void _dealloc_ReceiptPrinterCapabilities(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ReceiptPrinterCapabilities_get_CartridgeSensors(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CartridgeSensors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_ColorCartridgeCapabilities(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorCartridgeCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsBoldSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleHighDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsDoubleHighPrintSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleHighPrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsDualColorSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDualColorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsItalicSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsItalicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsPaperEmptySensorSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperEmptySensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsPaperNearEndSensorSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperNearEndSensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsPrinterPresent(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPrinterPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_SupportedCharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedCharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_Is180RotationSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Is180RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsBarcodeSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBarcodeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsBitmapSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBitmapSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsLeft90RotationSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLeft90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsPrintAreaSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPrintAreaSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsRight90RotationSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRight90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_RuledLineCapabilities(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RuledLineCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_SupportedBarcodeRotations(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedBarcodeRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_SupportedBitmapRotations(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedBitmapRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_CanCutPaper(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanCutPaper());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsStampSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStampSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_MarkFeedCapabilities(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MarkFeedCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsReversePaperFeedByLineSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReversePaperFeedByLineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReversePaperFeedByMapModeUnitSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsReverseVideoSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReverseVideoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsStrikethroughSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStrikethroughSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsSubscriptSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSubscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsSuperscriptSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSuperscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ReceiptPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ReceiptPrinterCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ReceiptPrinterCapabilities[] = {
        { "_from", (PyCFunction)_from_ReceiptPrinterCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ReceiptPrinterCapabilities[] = {
        { const_cast<char*>("cartridge_sensors"), (getter)ReceiptPrinterCapabilities_get_CartridgeSensors, nullptr, nullptr, nullptr },
        { const_cast<char*>("color_cartridge_capabilities"), (getter)ReceiptPrinterCapabilities_get_ColorCartridgeCapabilities, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_bold_supported"), (getter)ReceiptPrinterCapabilities_get_IsBoldSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_double_high_double_wide_print_supported"), (getter)ReceiptPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_double_high_print_supported"), (getter)ReceiptPrinterCapabilities_get_IsDoubleHighPrintSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_double_wide_print_supported"), (getter)ReceiptPrinterCapabilities_get_IsDoubleWidePrintSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_dual_color_supported"), (getter)ReceiptPrinterCapabilities_get_IsDualColorSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_italic_supported"), (getter)ReceiptPrinterCapabilities_get_IsItalicSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_paper_empty_sensor_supported"), (getter)ReceiptPrinterCapabilities_get_IsPaperEmptySensorSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_paper_near_end_sensor_supported"), (getter)ReceiptPrinterCapabilities_get_IsPaperNearEndSensorSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_printer_present"), (getter)ReceiptPrinterCapabilities_get_IsPrinterPresent, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_underline_supported"), (getter)ReceiptPrinterCapabilities_get_IsUnderlineSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_characters_per_line"), (getter)ReceiptPrinterCapabilities_get_SupportedCharactersPerLine, nullptr, nullptr, nullptr },
        { const_cast<char*>("is180_rotation_supported"), (getter)ReceiptPrinterCapabilities_get_Is180RotationSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_barcode_supported"), (getter)ReceiptPrinterCapabilities_get_IsBarcodeSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_bitmap_supported"), (getter)ReceiptPrinterCapabilities_get_IsBitmapSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_left90_rotation_supported"), (getter)ReceiptPrinterCapabilities_get_IsLeft90RotationSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_print_area_supported"), (getter)ReceiptPrinterCapabilities_get_IsPrintAreaSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_right90_rotation_supported"), (getter)ReceiptPrinterCapabilities_get_IsRight90RotationSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("ruled_line_capabilities"), (getter)ReceiptPrinterCapabilities_get_RuledLineCapabilities, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_barcode_rotations"), (getter)ReceiptPrinterCapabilities_get_SupportedBarcodeRotations, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_bitmap_rotations"), (getter)ReceiptPrinterCapabilities_get_SupportedBitmapRotations, nullptr, nullptr, nullptr },
        { const_cast<char*>("can_cut_paper"), (getter)ReceiptPrinterCapabilities_get_CanCutPaper, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_stamp_supported"), (getter)ReceiptPrinterCapabilities_get_IsStampSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("mark_feed_capabilities"), (getter)ReceiptPrinterCapabilities_get_MarkFeedCapabilities, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_reverse_paper_feed_by_line_supported"), (getter)ReceiptPrinterCapabilities_get_IsReversePaperFeedByLineSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_reverse_paper_feed_by_map_mode_unit_supported"), (getter)ReceiptPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_reverse_video_supported"), (getter)ReceiptPrinterCapabilities_get_IsReverseVideoSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_strikethrough_supported"), (getter)ReceiptPrinterCapabilities_get_IsStrikethroughSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_subscript_supported"), (getter)ReceiptPrinterCapabilities_get_IsSubscriptSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_superscript_supported"), (getter)ReceiptPrinterCapabilities_get_IsSuperscriptSupported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ReceiptPrinterCapabilities[] = 
    {
        { Py_tp_new, _new_ReceiptPrinterCapabilities },
        { Py_tp_dealloc, _dealloc_ReceiptPrinterCapabilities },
        { Py_tp_methods, _methods_ReceiptPrinterCapabilities },
        { Py_tp_getset, _getset_ReceiptPrinterCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ReceiptPrinterCapabilities =
    {
        "_winrt_Windows_Devices_PointOfService.ReceiptPrinterCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ReceiptPrinterCapabilities
    };

    // ----- SlipPrintJob class --------------------
    constexpr const char* const _type_name_SlipPrintJob = "SlipPrintJob";

    static PyObject* _new_SlipPrintJob(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SlipPrintJob);
        return nullptr;
    }

    static void _dealloc_SlipPrintJob(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SlipPrintJob_DrawRuledLine(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineDirection>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineStyle>(args, 3);
                auto param4 = py::convert_to<uint32_t>(args, 4);

                self->obj.DrawRuledLine(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_ExecuteAsync(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ExecuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_FeedPaperByLine(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_FeedPaperByMapModeUnit(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByMapModeUnit(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_Print(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Print(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>(args, 1);

                self->obj.Print(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintBarcode(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 5);

                self->obj.PrintBarcode(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintBarcodeCustomAlign(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);

                self->obj.PrintBarcodeCustomAlign(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintBitmap(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);

                self->obj.PrintBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.PrintCustomAlignedBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintLine(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.PrintLine();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PrintLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintSavedBitmap(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.PrintSavedBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_SetBarcodeRotation(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);

                self->obj.SetBarcodeRotation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_SetBitmap(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);

                self->obj.SetBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_SetCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_SetPrintArea(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                self->obj.SetPrintArea(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_SetPrintRotation(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.SetPrintRotation(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_SlipPrintJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::SlipPrintJob>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SlipPrintJob[] = {
        { "draw_ruled_line", (PyCFunction)SlipPrintJob_DrawRuledLine, METH_VARARGS, nullptr },
        { "execute_async", (PyCFunction)SlipPrintJob_ExecuteAsync, METH_VARARGS, nullptr },
        { "feed_paper_by_line", (PyCFunction)SlipPrintJob_FeedPaperByLine, METH_VARARGS, nullptr },
        { "feed_paper_by_map_mode_unit", (PyCFunction)SlipPrintJob_FeedPaperByMapModeUnit, METH_VARARGS, nullptr },
        { "print", (PyCFunction)SlipPrintJob_Print, METH_VARARGS, nullptr },
        { "print_barcode", (PyCFunction)SlipPrintJob_PrintBarcode, METH_VARARGS, nullptr },
        { "print_barcode_custom_align", (PyCFunction)SlipPrintJob_PrintBarcodeCustomAlign, METH_VARARGS, nullptr },
        { "print_bitmap", (PyCFunction)SlipPrintJob_PrintBitmap, METH_VARARGS, nullptr },
        { "print_custom_aligned_bitmap", (PyCFunction)SlipPrintJob_PrintCustomAlignedBitmap, METH_VARARGS, nullptr },
        { "print_line", (PyCFunction)SlipPrintJob_PrintLine, METH_VARARGS, nullptr },
        { "print_saved_bitmap", (PyCFunction)SlipPrintJob_PrintSavedBitmap, METH_VARARGS, nullptr },
        { "set_barcode_rotation", (PyCFunction)SlipPrintJob_SetBarcodeRotation, METH_VARARGS, nullptr },
        { "set_bitmap", (PyCFunction)SlipPrintJob_SetBitmap, METH_VARARGS, nullptr },
        { "set_custom_aligned_bitmap", (PyCFunction)SlipPrintJob_SetCustomAlignedBitmap, METH_VARARGS, nullptr },
        { "set_print_area", (PyCFunction)SlipPrintJob_SetPrintArea, METH_VARARGS, nullptr },
        { "set_print_rotation", (PyCFunction)SlipPrintJob_SetPrintRotation, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_SlipPrintJob, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SlipPrintJob[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_SlipPrintJob[] = 
    {
        { Py_tp_new, _new_SlipPrintJob },
        { Py_tp_dealloc, _dealloc_SlipPrintJob },
        { Py_tp_methods, _methods_SlipPrintJob },
        { Py_tp_getset, _getset_SlipPrintJob },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SlipPrintJob =
    {
        "_winrt_Windows_Devices_PointOfService.SlipPrintJob",
        sizeof(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SlipPrintJob
    };

    // ----- SlipPrinterCapabilities class --------------------
    constexpr const char* const _type_name_SlipPrinterCapabilities = "SlipPrinterCapabilities";

    static PyObject* _new_SlipPrinterCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SlipPrinterCapabilities);
        return nullptr;
    }

    static void _dealloc_SlipPrinterCapabilities(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SlipPrinterCapabilities_get_CartridgeSensors(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CartridgeSensors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_ColorCartridgeCapabilities(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorCartridgeCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsBoldSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleHighDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsDoubleHighPrintSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleHighPrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsDualColorSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDualColorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsItalicSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsItalicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsPaperEmptySensorSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperEmptySensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsPaperNearEndSensorSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperNearEndSensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsPrinterPresent(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPrinterPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_SupportedCharactersPerLine(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedCharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_Is180RotationSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Is180RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsBarcodeSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBarcodeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsBitmapSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBitmapSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsLeft90RotationSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLeft90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsPrintAreaSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPrintAreaSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsRight90RotationSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRight90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_RuledLineCapabilities(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RuledLineCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_SupportedBarcodeRotations(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedBarcodeRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_SupportedBitmapRotations(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedBitmapRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsBothSidesPrintingSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBothSidesPrintingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsFullLengthSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsFullLengthSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsReversePaperFeedByLineSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReversePaperFeedByLineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReversePaperFeedByMapModeUnitSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsReverseVideoSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReverseVideoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsStrikethroughSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStrikethroughSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsSubscriptSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSubscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsSuperscriptSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSuperscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SlipPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::SlipPrinterCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SlipPrinterCapabilities[] = {
        { "_from", (PyCFunction)_from_SlipPrinterCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SlipPrinterCapabilities[] = {
        { const_cast<char*>("cartridge_sensors"), (getter)SlipPrinterCapabilities_get_CartridgeSensors, nullptr, nullptr, nullptr },
        { const_cast<char*>("color_cartridge_capabilities"), (getter)SlipPrinterCapabilities_get_ColorCartridgeCapabilities, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_bold_supported"), (getter)SlipPrinterCapabilities_get_IsBoldSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_double_high_double_wide_print_supported"), (getter)SlipPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_double_high_print_supported"), (getter)SlipPrinterCapabilities_get_IsDoubleHighPrintSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_double_wide_print_supported"), (getter)SlipPrinterCapabilities_get_IsDoubleWidePrintSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_dual_color_supported"), (getter)SlipPrinterCapabilities_get_IsDualColorSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_italic_supported"), (getter)SlipPrinterCapabilities_get_IsItalicSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_paper_empty_sensor_supported"), (getter)SlipPrinterCapabilities_get_IsPaperEmptySensorSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_paper_near_end_sensor_supported"), (getter)SlipPrinterCapabilities_get_IsPaperNearEndSensorSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_printer_present"), (getter)SlipPrinterCapabilities_get_IsPrinterPresent, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_underline_supported"), (getter)SlipPrinterCapabilities_get_IsUnderlineSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_characters_per_line"), (getter)SlipPrinterCapabilities_get_SupportedCharactersPerLine, nullptr, nullptr, nullptr },
        { const_cast<char*>("is180_rotation_supported"), (getter)SlipPrinterCapabilities_get_Is180RotationSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_barcode_supported"), (getter)SlipPrinterCapabilities_get_IsBarcodeSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_bitmap_supported"), (getter)SlipPrinterCapabilities_get_IsBitmapSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_left90_rotation_supported"), (getter)SlipPrinterCapabilities_get_IsLeft90RotationSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_print_area_supported"), (getter)SlipPrinterCapabilities_get_IsPrintAreaSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_right90_rotation_supported"), (getter)SlipPrinterCapabilities_get_IsRight90RotationSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("ruled_line_capabilities"), (getter)SlipPrinterCapabilities_get_RuledLineCapabilities, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_barcode_rotations"), (getter)SlipPrinterCapabilities_get_SupportedBarcodeRotations, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_bitmap_rotations"), (getter)SlipPrinterCapabilities_get_SupportedBitmapRotations, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_both_sides_printing_supported"), (getter)SlipPrinterCapabilities_get_IsBothSidesPrintingSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_full_length_supported"), (getter)SlipPrinterCapabilities_get_IsFullLengthSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_reverse_paper_feed_by_line_supported"), (getter)SlipPrinterCapabilities_get_IsReversePaperFeedByLineSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_reverse_paper_feed_by_map_mode_unit_supported"), (getter)SlipPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_reverse_video_supported"), (getter)SlipPrinterCapabilities_get_IsReverseVideoSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_strikethrough_supported"), (getter)SlipPrinterCapabilities_get_IsStrikethroughSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_subscript_supported"), (getter)SlipPrinterCapabilities_get_IsSubscriptSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_superscript_supported"), (getter)SlipPrinterCapabilities_get_IsSuperscriptSupported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SlipPrinterCapabilities[] = 
    {
        { Py_tp_new, _new_SlipPrinterCapabilities },
        { Py_tp_dealloc, _dealloc_SlipPrinterCapabilities },
        { Py_tp_methods, _methods_SlipPrinterCapabilities },
        { Py_tp_getset, _getset_SlipPrinterCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SlipPrinterCapabilities =
    {
        "_winrt_Windows_Devices_PointOfService.SlipPrinterCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SlipPrinterCapabilities
    };

    // ----- UnifiedPosErrorData class --------------------
    constexpr const char* const _type_name_UnifiedPosErrorData = "UnifiedPosErrorData";

    static PyObject* _new_UnifiedPosErrorData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosErrorSeverity>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosErrorReason>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                winrt::Windows::Devices::PointOfService::UnifiedPosErrorData instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UnifiedPosErrorData(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UnifiedPosErrorData_get_ExtendedReason(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UnifiedPosErrorData_get_Message(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UnifiedPosErrorData_get_Reason(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UnifiedPosErrorData_get_Severity(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Severity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UnifiedPosErrorData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::UnifiedPosErrorData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UnifiedPosErrorData[] = {
        { "_from", (PyCFunction)_from_UnifiedPosErrorData, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UnifiedPosErrorData[] = {
        { const_cast<char*>("extended_reason"), (getter)UnifiedPosErrorData_get_ExtendedReason, nullptr, nullptr, nullptr },
        { const_cast<char*>("message"), (getter)UnifiedPosErrorData_get_Message, nullptr, nullptr, nullptr },
        { const_cast<char*>("reason"), (getter)UnifiedPosErrorData_get_Reason, nullptr, nullptr, nullptr },
        { const_cast<char*>("severity"), (getter)UnifiedPosErrorData_get_Severity, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UnifiedPosErrorData[] = 
    {
        { Py_tp_new, _new_UnifiedPosErrorData },
        { Py_tp_dealloc, _dealloc_UnifiedPosErrorData },
        { Py_tp_methods, _methods_UnifiedPosErrorData },
        { Py_tp_getset, _getset_UnifiedPosErrorData },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UnifiedPosErrorData =
    {
        "_winrt_Windows_Devices_PointOfService.UnifiedPosErrorData",
        sizeof(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UnifiedPosErrorData
    };

    // ----- ICashDrawerEventSourceEventArgs interface --------------------
    constexpr const char* const _type_name_ICashDrawerEventSourceEventArgs = "ICashDrawerEventSourceEventArgs";

    static PyObject* _new_ICashDrawerEventSourceEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ICashDrawerEventSourceEventArgs);
        return nullptr;
    }

    static void _dealloc_ICashDrawerEventSourceEventArgs(py::wrapper::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ICashDrawerEventSourceEventArgs_get_CashDrawer(py::wrapper::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CashDrawer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ICashDrawerEventSourceEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICashDrawerEventSourceEventArgs[] = {
        { "_from", (PyCFunction)_from_ICashDrawerEventSourceEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ICashDrawerEventSourceEventArgs[] = {
        { const_cast<char*>("cash_drawer"), (getter)ICashDrawerEventSourceEventArgs_get_CashDrawer, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ICashDrawerEventSourceEventArgs[] = 
    {
        { Py_tp_new, _new_ICashDrawerEventSourceEventArgs },
        { Py_tp_dealloc, _dealloc_ICashDrawerEventSourceEventArgs },
        { Py_tp_methods, _methods_ICashDrawerEventSourceEventArgs },
        { Py_tp_getset, _getset_ICashDrawerEventSourceEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ICashDrawerEventSourceEventArgs =
    {
        "_winrt_Windows_Devices_PointOfService.ICashDrawerEventSourceEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICashDrawerEventSourceEventArgs
    };

    // ----- ICommonClaimedPosPrinterStation interface --------------------
    constexpr const char* const _type_name_ICommonClaimedPosPrinterStation = "ICommonClaimedPosPrinterStation";

    static PyObject* _new_ICommonClaimedPosPrinterStation(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ICommonClaimedPosPrinterStation);
        return nullptr;
    }

    static void _dealloc_ICommonClaimedPosPrinterStation(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ICommonClaimedPosPrinterStation_ValidateData(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ValidateData(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICommonClaimedPosPrinterStation_put_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharactersPerLine(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorCartridge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICommonClaimedPosPrinterStation_put_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterColorCartridge>(arg);

            self->obj.ColorCartridge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsCartridgeEmpty(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCartridgeEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsCartridgeRemoved(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCartridgeRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsCoverOpen(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCoverOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsHeadCleaning(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHeadCleaning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLetterQuality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICommonClaimedPosPrinterStation_put_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLetterQuality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsPaperEmpty(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsPaperNearEnd(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperNearEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsReadyToPrint(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadyToPrint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_LineHeight(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICommonClaimedPosPrinterStation_put_LineHeight(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICommonClaimedPosPrinterStation_put_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_LineWidth(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ICommonClaimedPosPrinterStation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICommonClaimedPosPrinterStation[] = {
        { "validate_data", (PyCFunction)ICommonClaimedPosPrinterStation_ValidateData, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ICommonClaimedPosPrinterStation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ICommonClaimedPosPrinterStation[] = {
        { const_cast<char*>("characters_per_line"), (getter)ICommonClaimedPosPrinterStation_get_CharactersPerLine, (setter)ICommonClaimedPosPrinterStation_put_CharactersPerLine, nullptr, nullptr },
        { const_cast<char*>("color_cartridge"), (getter)ICommonClaimedPosPrinterStation_get_ColorCartridge, (setter)ICommonClaimedPosPrinterStation_put_ColorCartridge, nullptr, nullptr },
        { const_cast<char*>("is_cartridge_empty"), (getter)ICommonClaimedPosPrinterStation_get_IsCartridgeEmpty, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_cartridge_removed"), (getter)ICommonClaimedPosPrinterStation_get_IsCartridgeRemoved, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_cover_open"), (getter)ICommonClaimedPosPrinterStation_get_IsCoverOpen, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_head_cleaning"), (getter)ICommonClaimedPosPrinterStation_get_IsHeadCleaning, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_letter_quality"), (getter)ICommonClaimedPosPrinterStation_get_IsLetterQuality, (setter)ICommonClaimedPosPrinterStation_put_IsLetterQuality, nullptr, nullptr },
        { const_cast<char*>("is_paper_empty"), (getter)ICommonClaimedPosPrinterStation_get_IsPaperEmpty, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_paper_near_end"), (getter)ICommonClaimedPosPrinterStation_get_IsPaperNearEnd, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_ready_to_print"), (getter)ICommonClaimedPosPrinterStation_get_IsReadyToPrint, nullptr, nullptr, nullptr },
        { const_cast<char*>("line_height"), (getter)ICommonClaimedPosPrinterStation_get_LineHeight, (setter)ICommonClaimedPosPrinterStation_put_LineHeight, nullptr, nullptr },
        { const_cast<char*>("line_spacing"), (getter)ICommonClaimedPosPrinterStation_get_LineSpacing, (setter)ICommonClaimedPosPrinterStation_put_LineSpacing, nullptr, nullptr },
        { const_cast<char*>("line_width"), (getter)ICommonClaimedPosPrinterStation_get_LineWidth, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ICommonClaimedPosPrinterStation[] = 
    {
        { Py_tp_new, _new_ICommonClaimedPosPrinterStation },
        { Py_tp_dealloc, _dealloc_ICommonClaimedPosPrinterStation },
        { Py_tp_methods, _methods_ICommonClaimedPosPrinterStation },
        { Py_tp_getset, _getset_ICommonClaimedPosPrinterStation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ICommonClaimedPosPrinterStation =
    {
        "_winrt_Windows_Devices_PointOfService.ICommonClaimedPosPrinterStation",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICommonClaimedPosPrinterStation
    };

    // ----- ICommonPosPrintStationCapabilities interface --------------------
    constexpr const char* const _type_name_ICommonPosPrintStationCapabilities = "ICommonPosPrintStationCapabilities";

    static PyObject* _new_ICommonPosPrintStationCapabilities(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ICommonPosPrintStationCapabilities);
        return nullptr;
    }

    static void _dealloc_ICommonPosPrintStationCapabilities(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_CartridgeSensors(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CartridgeSensors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_ColorCartridgeCapabilities(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorCartridgeCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsBoldSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsDoubleHighDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleHighDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsDoubleHighPrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleHighPrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsDualColorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDualColorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsItalicSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsItalicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsPaperEmptySensorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperEmptySensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsPaperNearEndSensorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperNearEndSensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsPrinterPresent(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPrinterPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_SupportedCharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedCharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ICommonPosPrintStationCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICommonPosPrintStationCapabilities[] = {
        { "_from", (PyCFunction)_from_ICommonPosPrintStationCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ICommonPosPrintStationCapabilities[] = {
        { const_cast<char*>("cartridge_sensors"), (getter)ICommonPosPrintStationCapabilities_get_CartridgeSensors, nullptr, nullptr, nullptr },
        { const_cast<char*>("color_cartridge_capabilities"), (getter)ICommonPosPrintStationCapabilities_get_ColorCartridgeCapabilities, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_bold_supported"), (getter)ICommonPosPrintStationCapabilities_get_IsBoldSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_double_high_double_wide_print_supported"), (getter)ICommonPosPrintStationCapabilities_get_IsDoubleHighDoubleWidePrintSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_double_high_print_supported"), (getter)ICommonPosPrintStationCapabilities_get_IsDoubleHighPrintSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_double_wide_print_supported"), (getter)ICommonPosPrintStationCapabilities_get_IsDoubleWidePrintSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_dual_color_supported"), (getter)ICommonPosPrintStationCapabilities_get_IsDualColorSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_italic_supported"), (getter)ICommonPosPrintStationCapabilities_get_IsItalicSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_paper_empty_sensor_supported"), (getter)ICommonPosPrintStationCapabilities_get_IsPaperEmptySensorSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_paper_near_end_sensor_supported"), (getter)ICommonPosPrintStationCapabilities_get_IsPaperNearEndSensorSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_printer_present"), (getter)ICommonPosPrintStationCapabilities_get_IsPrinterPresent, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_underline_supported"), (getter)ICommonPosPrintStationCapabilities_get_IsUnderlineSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_characters_per_line"), (getter)ICommonPosPrintStationCapabilities_get_SupportedCharactersPerLine, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ICommonPosPrintStationCapabilities[] = 
    {
        { Py_tp_new, _new_ICommonPosPrintStationCapabilities },
        { Py_tp_dealloc, _dealloc_ICommonPosPrintStationCapabilities },
        { Py_tp_methods, _methods_ICommonPosPrintStationCapabilities },
        { Py_tp_getset, _getset_ICommonPosPrintStationCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ICommonPosPrintStationCapabilities =
    {
        "_winrt_Windows_Devices_PointOfService.ICommonPosPrintStationCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICommonPosPrintStationCapabilities
    };

    // ----- ICommonReceiptSlipCapabilities interface --------------------
    constexpr const char* const _type_name_ICommonReceiptSlipCapabilities = "ICommonReceiptSlipCapabilities";

    static PyObject* _new_ICommonReceiptSlipCapabilities(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ICommonReceiptSlipCapabilities);
        return nullptr;
    }

    static void _dealloc_ICommonReceiptSlipCapabilities(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_Is180RotationSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Is180RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsBarcodeSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBarcodeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsBitmapSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBitmapSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsLeft90RotationSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLeft90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsPrintAreaSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPrintAreaSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsRight90RotationSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRight90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_RuledLineCapabilities(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RuledLineCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_SupportedBarcodeRotations(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedBarcodeRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_SupportedBitmapRotations(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedBitmapRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_CartridgeSensors(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CartridgeSensors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_ColorCartridgeCapabilities(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorCartridgeCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsBoldSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsDoubleHighDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleHighDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsDoubleHighPrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleHighPrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsDualColorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDualColorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsItalicSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsItalicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsPaperEmptySensorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperEmptySensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsPaperNearEndSensorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperNearEndSensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsPrinterPresent(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPrinterPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_SupportedCharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedCharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ICommonReceiptSlipCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICommonReceiptSlipCapabilities[] = {
        { "_from", (PyCFunction)_from_ICommonReceiptSlipCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ICommonReceiptSlipCapabilities[] = {
        { const_cast<char*>("is180_rotation_supported"), (getter)ICommonReceiptSlipCapabilities_get_Is180RotationSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_barcode_supported"), (getter)ICommonReceiptSlipCapabilities_get_IsBarcodeSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_bitmap_supported"), (getter)ICommonReceiptSlipCapabilities_get_IsBitmapSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_left90_rotation_supported"), (getter)ICommonReceiptSlipCapabilities_get_IsLeft90RotationSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_print_area_supported"), (getter)ICommonReceiptSlipCapabilities_get_IsPrintAreaSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_right90_rotation_supported"), (getter)ICommonReceiptSlipCapabilities_get_IsRight90RotationSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("ruled_line_capabilities"), (getter)ICommonReceiptSlipCapabilities_get_RuledLineCapabilities, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_barcode_rotations"), (getter)ICommonReceiptSlipCapabilities_get_SupportedBarcodeRotations, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_bitmap_rotations"), (getter)ICommonReceiptSlipCapabilities_get_SupportedBitmapRotations, nullptr, nullptr, nullptr },
        { const_cast<char*>("cartridge_sensors"), (getter)ICommonReceiptSlipCapabilities_get_CartridgeSensors, nullptr, nullptr, nullptr },
        { const_cast<char*>("color_cartridge_capabilities"), (getter)ICommonReceiptSlipCapabilities_get_ColorCartridgeCapabilities, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_bold_supported"), (getter)ICommonReceiptSlipCapabilities_get_IsBoldSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_double_high_double_wide_print_supported"), (getter)ICommonReceiptSlipCapabilities_get_IsDoubleHighDoubleWidePrintSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_double_high_print_supported"), (getter)ICommonReceiptSlipCapabilities_get_IsDoubleHighPrintSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_double_wide_print_supported"), (getter)ICommonReceiptSlipCapabilities_get_IsDoubleWidePrintSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_dual_color_supported"), (getter)ICommonReceiptSlipCapabilities_get_IsDualColorSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_italic_supported"), (getter)ICommonReceiptSlipCapabilities_get_IsItalicSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_paper_empty_sensor_supported"), (getter)ICommonReceiptSlipCapabilities_get_IsPaperEmptySensorSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_paper_near_end_sensor_supported"), (getter)ICommonReceiptSlipCapabilities_get_IsPaperNearEndSensorSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_printer_present"), (getter)ICommonReceiptSlipCapabilities_get_IsPrinterPresent, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_underline_supported"), (getter)ICommonReceiptSlipCapabilities_get_IsUnderlineSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_characters_per_line"), (getter)ICommonReceiptSlipCapabilities_get_SupportedCharactersPerLine, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ICommonReceiptSlipCapabilities[] = 
    {
        { Py_tp_new, _new_ICommonReceiptSlipCapabilities },
        { Py_tp_dealloc, _dealloc_ICommonReceiptSlipCapabilities },
        { Py_tp_methods, _methods_ICommonReceiptSlipCapabilities },
        { Py_tp_getset, _getset_ICommonReceiptSlipCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ICommonReceiptSlipCapabilities =
    {
        "_winrt_Windows_Devices_PointOfService.ICommonReceiptSlipCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICommonReceiptSlipCapabilities
    };

    // ----- IPosPrinterJob interface --------------------
    constexpr const char* const _type_name_IPosPrinterJob = "IPosPrinterJob";

    static PyObject* _new_IPosPrinterJob(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IPosPrinterJob);
        return nullptr;
    }

    static void _dealloc_IPosPrinterJob(py::wrapper::Windows::Devices::PointOfService::IPosPrinterJob* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IPosPrinterJob_ExecuteAsync(py::wrapper::Windows::Devices::PointOfService::IPosPrinterJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ExecuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPosPrinterJob_Print(py::wrapper::Windows::Devices::PointOfService::IPosPrinterJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Print(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPosPrinterJob_PrintLine(py::wrapper::Windows::Devices::PointOfService::IPosPrinterJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.PrintLine();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PrintLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IPosPrinterJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::IPosPrinterJob>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPosPrinterJob[] = {
        { "execute_async", (PyCFunction)IPosPrinterJob_ExecuteAsync, METH_VARARGS, nullptr },
        { "print", (PyCFunction)IPosPrinterJob_Print, METH_VARARGS, nullptr },
        { "print_line", (PyCFunction)IPosPrinterJob_PrintLine, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IPosPrinterJob, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IPosPrinterJob[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IPosPrinterJob[] = 
    {
        { Py_tp_new, _new_IPosPrinterJob },
        { Py_tp_dealloc, _dealloc_IPosPrinterJob },
        { Py_tp_methods, _methods_IPosPrinterJob },
        { Py_tp_getset, _getset_IPosPrinterJob },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IPosPrinterJob =
    {
        "_winrt_Windows_Devices_PointOfService.IPosPrinterJob",
        sizeof(py::wrapper::Windows::Devices::PointOfService::IPosPrinterJob),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPosPrinterJob
    };

    // ----- IReceiptOrSlipJob interface --------------------
    constexpr const char* const _type_name_IReceiptOrSlipJob = "IReceiptOrSlipJob";

    static PyObject* _new_IReceiptOrSlipJob(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IReceiptOrSlipJob);
        return nullptr;
    }

    static void _dealloc_IReceiptOrSlipJob(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IReceiptOrSlipJob_DrawRuledLine(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineDirection>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineStyle>(args, 3);
                auto param4 = py::convert_to<uint32_t>(args, 4);

                self->obj.DrawRuledLine(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_ExecuteAsync(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ExecuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_Print(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Print(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintBarcode(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 5);

                self->obj.PrintBarcode(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintBarcodeCustomAlign(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);

                self->obj.PrintBarcodeCustomAlign(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintBitmap(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);

                self->obj.PrintBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.PrintCustomAlignedBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintLine(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.PrintLine();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PrintLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintSavedBitmap(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.PrintSavedBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_SetBarcodeRotation(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);

                self->obj.SetBarcodeRotation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_SetBitmap(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);

                self->obj.SetBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_SetCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_SetPrintArea(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                self->obj.SetPrintArea(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_SetPrintRotation(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.SetPrintRotation(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IReceiptOrSlipJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::IReceiptOrSlipJob>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IReceiptOrSlipJob[] = {
        { "draw_ruled_line", (PyCFunction)IReceiptOrSlipJob_DrawRuledLine, METH_VARARGS, nullptr },
        { "print_barcode", (PyCFunction)IReceiptOrSlipJob_PrintBarcode, METH_VARARGS, nullptr },
        { "print_barcode_custom_align", (PyCFunction)IReceiptOrSlipJob_PrintBarcodeCustomAlign, METH_VARARGS, nullptr },
        { "print_bitmap", (PyCFunction)IReceiptOrSlipJob_PrintBitmap, METH_VARARGS, nullptr },
        { "print_custom_aligned_bitmap", (PyCFunction)IReceiptOrSlipJob_PrintCustomAlignedBitmap, METH_VARARGS, nullptr },
        { "print_saved_bitmap", (PyCFunction)IReceiptOrSlipJob_PrintSavedBitmap, METH_VARARGS, nullptr },
        { "set_barcode_rotation", (PyCFunction)IReceiptOrSlipJob_SetBarcodeRotation, METH_VARARGS, nullptr },
        { "set_bitmap", (PyCFunction)IReceiptOrSlipJob_SetBitmap, METH_VARARGS, nullptr },
        { "set_custom_aligned_bitmap", (PyCFunction)IReceiptOrSlipJob_SetCustomAlignedBitmap, METH_VARARGS, nullptr },
        { "set_print_area", (PyCFunction)IReceiptOrSlipJob_SetPrintArea, METH_VARARGS, nullptr },
        { "set_print_rotation", (PyCFunction)IReceiptOrSlipJob_SetPrintRotation, METH_VARARGS, nullptr },
        { "execute_async", (PyCFunction)IReceiptOrSlipJob_ExecuteAsync, METH_VARARGS, nullptr },
        { "print", (PyCFunction)IReceiptOrSlipJob_Print, METH_VARARGS, nullptr },
        { "print_line", (PyCFunction)IReceiptOrSlipJob_PrintLine, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IReceiptOrSlipJob, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IReceiptOrSlipJob[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IReceiptOrSlipJob[] = 
    {
        { Py_tp_new, _new_IReceiptOrSlipJob },
        { Py_tp_dealloc, _dealloc_IReceiptOrSlipJob },
        { Py_tp_methods, _methods_IReceiptOrSlipJob },
        { Py_tp_getset, _getset_IReceiptOrSlipJob },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IReceiptOrSlipJob =
    {
        "_winrt_Windows_Devices_PointOfService.IReceiptOrSlipJob",
        sizeof(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IReceiptOrSlipJob
    };

    // ----- SizeUInt32 struct --------------------
    constexpr const char* const _type_name_SizeUInt32 = "SizeUInt32";

    PyObject* _new_SizeUInt32(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Devices::PointOfService::SizeUInt32 return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Devices::PointOfService::SizeUInt32>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint32_t _Width{};
        uint32_t _Height{};

        static const char* kwlist[] = {"width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "II", const_cast<char**>(kwlist), &_Width, &_Height))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Devices::PointOfService::SizeUInt32 return_value{ _Width, _Height };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_SizeUInt32(py::wrapper::Windows::Devices::PointOfService::SizeUInt32* self)
    {
    }

    static PyObject* SizeUInt32_get_Width(py::wrapper::Windows::Devices::PointOfService::SizeUInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SizeUInt32_set_Width(py::wrapper::Windows::Devices::PointOfService::SizeUInt32* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SizeUInt32_get_Height(py::wrapper::Windows::Devices::PointOfService::SizeUInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SizeUInt32_set_Height(py::wrapper::Windows::Devices::PointOfService::SizeUInt32* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_SizeUInt32[] = {
        { const_cast<char*>("width"), (getter)SizeUInt32_get_Width, (setter)SizeUInt32_set_Width, nullptr, nullptr },
        { const_cast<char*>("height"), (getter)SizeUInt32_get_Height, (setter)SizeUInt32_set_Height, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SizeUInt32[] = 
    {
        { Py_tp_new, _new_SizeUInt32 },
        { Py_tp_dealloc, _dealloc_SizeUInt32 },
        { Py_tp_getset, _getset_SizeUInt32 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SizeUInt32 =
    {
        "_winrt_Windows_Devices_PointOfService.SizeUInt32",
        sizeof(py::wrapper::Windows::Devices::PointOfService::SizeUInt32),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SizeUInt32
    };

    // ----- Windows.Devices.PointOfService Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScanner>::python_type = py::register_python_type(module, _type_name_BarcodeScanner, &_type_spec_BarcodeScanner, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerCapabilities>::python_type = py::register_python_type(module, _type_name_BarcodeScannerCapabilities, &_type_spec_BarcodeScannerCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_BarcodeScannerDataReceivedEventArgs, &_type_spec_BarcodeScannerDataReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs>::python_type = py::register_python_type(module, _type_name_BarcodeScannerErrorOccurredEventArgs, &_type_spec_BarcodeScannerErrorOccurredEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_BarcodeScannerImagePreviewReceivedEventArgs, &_type_spec_BarcodeScannerImagePreviewReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerReport>::python_type = py::register_python_type(module, _type_name_BarcodeScannerReport, &_type_spec_BarcodeScannerReport, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs>::python_type = py::register_python_type(module, _type_name_BarcodeScannerStatusUpdatedEventArgs, &_type_spec_BarcodeScannerStatusUpdatedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeSymbologies>::python_type = py::register_python_type(module, _type_name_BarcodeSymbologies, &_type_spec_BarcodeSymbologies, nullptr);
            py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeSymbologyAttributes>::python_type = py::register_python_type(module, _type_name_BarcodeSymbologyAttributes, &_type_spec_BarcodeSymbologyAttributes, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawer>::python_type = py::register_python_type(module, _type_name_CashDrawer, &_type_spec_CashDrawer, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerCapabilities>::python_type = py::register_python_type(module, _type_name_CashDrawerCapabilities, &_type_spec_CashDrawerCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerCloseAlarm>::python_type = py::register_python_type(module, _type_name_CashDrawerCloseAlarm, &_type_spec_CashDrawerCloseAlarm, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerClosedEventArgs>::python_type = py::register_python_type(module, _type_name_CashDrawerClosedEventArgs, &_type_spec_CashDrawerClosedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerEventSource>::python_type = py::register_python_type(module, _type_name_CashDrawerEventSource, &_type_spec_CashDrawerEventSource, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs>::python_type = py::register_python_type(module, _type_name_CashDrawerOpenedEventArgs, &_type_spec_CashDrawerOpenedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerStatus>::python_type = py::register_python_type(module, _type_name_CashDrawerStatus, &_type_spec_CashDrawerStatus, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs>::python_type = py::register_python_type(module, _type_name_CashDrawerStatusUpdatedEventArgs, &_type_spec_CashDrawerStatusUpdatedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>::python_type = py::register_python_type(module, _type_name_ClaimedBarcodeScanner, &_type_spec_ClaimedBarcodeScanner, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs>::python_type = py::register_python_type(module, _type_name_ClaimedBarcodeScannerClosedEventArgs, &_type_spec_ClaimedBarcodeScannerClosedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedCashDrawer>::python_type = py::register_python_type(module, _type_name_ClaimedCashDrawer, &_type_spec_ClaimedCashDrawer, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs>::python_type = py::register_python_type(module, _type_name_ClaimedCashDrawerClosedEventArgs, &_type_spec_ClaimedCashDrawerClosedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedJournalPrinter>::python_type = py::register_python_type(module, _type_name_ClaimedJournalPrinter, &_type_spec_ClaimedJournalPrinter, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay>::python_type = py::register_python_type(module, _type_name_ClaimedLineDisplay, &_type_spec_ClaimedLineDisplay, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs>::python_type = py::register_python_type(module, _type_name_ClaimedLineDisplayClosedEventArgs, &_type_spec_ClaimedLineDisplayClosedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader>::python_type = py::register_python_type(module, _type_name_ClaimedMagneticStripeReader, &_type_spec_ClaimedMagneticStripeReader, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs>::python_type = py::register_python_type(module, _type_name_ClaimedMagneticStripeReaderClosedEventArgs, &_type_spec_ClaimedMagneticStripeReaderClosedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedPosPrinter>::python_type = py::register_python_type(module, _type_name_ClaimedPosPrinter, &_type_spec_ClaimedPosPrinter, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs>::python_type = py::register_python_type(module, _type_name_ClaimedPosPrinterClosedEventArgs, &_type_spec_ClaimedPosPrinterClosedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedReceiptPrinter>::python_type = py::register_python_type(module, _type_name_ClaimedReceiptPrinter, &_type_spec_ClaimedReceiptPrinter, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedSlipPrinter>::python_type = py::register_python_type(module, _type_name_ClaimedSlipPrinter, &_type_spec_ClaimedSlipPrinter, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::JournalPrintJob>::python_type = py::register_python_type(module, _type_name_JournalPrintJob, &_type_spec_JournalPrintJob, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::JournalPrinterCapabilities>::python_type = py::register_python_type(module, _type_name_JournalPrinterCapabilities, &_type_spec_JournalPrinterCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplay>::python_type = py::register_python_type(module, _type_name_LineDisplay, &_type_spec_LineDisplay, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayAttributes>::python_type = py::register_python_type(module, _type_name_LineDisplayAttributes, &_type_spec_LineDisplayAttributes, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayCapabilities>::python_type = py::register_python_type(module, _type_name_LineDisplayCapabilities, &_type_spec_LineDisplayCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayCursor>::python_type = py::register_python_type(module, _type_name_LineDisplayCursor, &_type_spec_LineDisplayCursor, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayCursorAttributes>::python_type = py::register_python_type(module, _type_name_LineDisplayCursorAttributes, &_type_spec_LineDisplayCursorAttributes, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayCustomGlyphs>::python_type = py::register_python_type(module, _type_name_LineDisplayCustomGlyphs, &_type_spec_LineDisplayCustomGlyphs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayMarquee>::python_type = py::register_python_type(module, _type_name_LineDisplayMarquee, &_type_spec_LineDisplayMarquee, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector>::python_type = py::register_python_type(module, _type_name_LineDisplayStatisticsCategorySelector, &_type_spec_LineDisplayStatisticsCategorySelector, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs>::python_type = py::register_python_type(module, _type_name_LineDisplayStatusUpdatedEventArgs, &_type_spec_LineDisplayStatusUpdatedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayStoredBitmap>::python_type = py::register_python_type(module, _type_name_LineDisplayStoredBitmap, &_type_spec_LineDisplayStoredBitmap, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayWindow>::python_type = py::register_python_type(module, _type_name_LineDisplayWindow, &_type_spec_LineDisplayWindow, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReader>::python_type = py::register_python_type(module, _type_name_MagneticStripeReader, &_type_spec_MagneticStripeReader, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_MagneticStripeReaderAamvaCardDataReceivedEventArgs, &_type_spec_MagneticStripeReaderAamvaCardDataReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_MagneticStripeReaderBankCardDataReceivedEventArgs, &_type_spec_MagneticStripeReaderBankCardDataReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities>::python_type = py::register_python_type(module, _type_name_MagneticStripeReaderCapabilities, &_type_spec_MagneticStripeReaderCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes>::python_type = py::register_python_type(module, _type_name_MagneticStripeReaderCardTypes, &_type_spec_MagneticStripeReaderCardTypes, nullptr);
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderEncryptionAlgorithms>::python_type = py::register_python_type(module, _type_name_MagneticStripeReaderEncryptionAlgorithms, &_type_spec_MagneticStripeReaderEncryptionAlgorithms, nullptr);
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs>::python_type = py::register_python_type(module, _type_name_MagneticStripeReaderErrorOccurredEventArgs, &_type_spec_MagneticStripeReaderErrorOccurredEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderReport>::python_type = py::register_python_type(module, _type_name_MagneticStripeReaderReport, &_type_spec_MagneticStripeReaderReport, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs>::python_type = py::register_python_type(module, _type_name_MagneticStripeReaderStatusUpdatedEventArgs, &_type_spec_MagneticStripeReaderStatusUpdatedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackData>::python_type = py::register_python_type(module, _type_name_MagneticStripeReaderTrackData, &_type_spec_MagneticStripeReaderTrackData, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs, &_type_spec_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinter>::python_type = py::register_python_type(module, _type_name_PosPrinter, &_type_spec_PosPrinter, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterCapabilities>::python_type = py::register_python_type(module, _type_name_PosPrinterCapabilities, &_type_spec_PosPrinterCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterCharacterSetIds>::python_type = py::register_python_type(module, _type_name_PosPrinterCharacterSetIds, &_type_spec_PosPrinterCharacterSetIds, nullptr);
            py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterFontProperty>::python_type = py::register_python_type(module, _type_name_PosPrinterFontProperty, &_type_spec_PosPrinterFontProperty, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>::python_type = py::register_python_type(module, _type_name_PosPrinterPrintOptions, &_type_spec_PosPrinterPrintOptions, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_PosPrinterReleaseDeviceRequestedEventArgs, &_type_spec_PosPrinterReleaseDeviceRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterStatus>::python_type = py::register_python_type(module, _type_name_PosPrinterStatus, &_type_spec_PosPrinterStatus, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs>::python_type = py::register_python_type(module, _type_name_PosPrinterStatusUpdatedEventArgs, &_type_spec_PosPrinterStatusUpdatedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ReceiptPrintJob>::python_type = py::register_python_type(module, _type_name_ReceiptPrintJob, &_type_spec_ReceiptPrintJob, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ReceiptPrinterCapabilities>::python_type = py::register_python_type(module, _type_name_ReceiptPrinterCapabilities, &_type_spec_ReceiptPrinterCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::SlipPrintJob>::python_type = py::register_python_type(module, _type_name_SlipPrintJob, &_type_spec_SlipPrintJob, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::SlipPrinterCapabilities>::python_type = py::register_python_type(module, _type_name_SlipPrinterCapabilities, &_type_spec_SlipPrinterCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::UnifiedPosErrorData>::python_type = py::register_python_type(module, _type_name_UnifiedPosErrorData, &_type_spec_UnifiedPosErrorData, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs>::python_type = py::register_python_type(module, _type_name_ICashDrawerEventSourceEventArgs, &_type_spec_ICashDrawerEventSourceEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation>::python_type = py::register_python_type(module, _type_name_ICommonClaimedPosPrinterStation, &_type_spec_ICommonClaimedPosPrinterStation, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities>::python_type = py::register_python_type(module, _type_name_ICommonPosPrintStationCapabilities, &_type_spec_ICommonPosPrintStationCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities>::python_type = py::register_python_type(module, _type_name_ICommonReceiptSlipCapabilities, &_type_spec_ICommonReceiptSlipCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::IPosPrinterJob>::python_type = py::register_python_type(module, _type_name_IPosPrinterJob, &_type_spec_IPosPrinterJob, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::IReceiptOrSlipJob>::python_type = py::register_python_type(module, _type_name_IReceiptOrSlipJob, &_type_spec_IReceiptOrSlipJob, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::SizeUInt32>::python_type = py::register_python_type(module, _type_name_SizeUInt32, &_type_spec_SizeUInt32, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Devices.PointOfService");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Devices_PointOfService",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Devices::PointOfService

PyMODINIT_FUNC
PyInit__winrt_Windows_Devices_PointOfService (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Devices::PointOfService::module_def);
}
