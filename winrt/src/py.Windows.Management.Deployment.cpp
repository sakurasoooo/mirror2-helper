// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Management.Deployment.h"

PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::AddPackageOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::AppInstallerManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::AutoUpdateSettingsOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::DeploymentResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::PackageAllUserProvisioningOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::PackageManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::PackageManagerDebugSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::PackageUserInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::PackageVolume>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::RegisterPackageOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::StagePackageOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::DeploymentProgress>::python_type;

PyObject* py::converter<winrt::Windows::Management::Deployment::DeploymentProgress>::convert(winrt::Windows::Management::Deployment::DeploymentProgress instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Management::Deployment::DeploymentProgress>());
}
winrt::Windows::Management::Deployment::DeploymentProgress py::converter<winrt::Windows::Management::Deployment::DeploymentProgress>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Management::Deployment::DeploymentProgress>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Management::Deployment::DeploymentProgress>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Management::Deployment::DeploymentProgress return_value{};

    PyObject* py_state = PyDict_GetItemString(obj, "state");
    if (!py_state) { throw winrt::hresult_invalid_argument(); }
    return_value.state = converter<winrt::Windows::Management::Deployment::DeploymentProgressState>::convert_to(py_state);

    PyObject* py_percentage = PyDict_GetItemString(obj, "percentage");
    if (!py_percentage) { throw winrt::hresult_invalid_argument(); }
    return_value.percentage = converter<uint32_t>::convert_to(py_percentage);

    return return_value;
}

namespace py::cpp::Windows::Management::Deployment
{
    // ----- AddPackageOptions class --------------------
    constexpr const char* const _type_name_AddPackageOptions = "AddPackageOptions";

    static PyObject* _new_AddPackageOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::AddPackageOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AddPackageOptions(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AddPackageOptions_get_TargetVolume(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TargetVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_TargetVolume(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(arg);

            self->obj.TargetVolume(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_StubPackageOption(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StubPackageOption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_StubPackageOption(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Management::Deployment::StubPackageOption>(arg);

            self->obj.StubPackageOption(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_StageInPlace(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StageInPlace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_StageInPlace(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StageInPlace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_RetainFilesOnFailure(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RetainFilesOnFailure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_RetainFilesOnFailure(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RetainFilesOnFailure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_RequiredContentGroupOnly(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequiredContentGroupOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_RequiredContentGroupOnly(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RequiredContentGroupOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_InstallAllResources(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstallAllResources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_InstallAllResources(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.InstallAllResources(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForceUpdateFromAnyVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceUpdateFromAnyVersion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_ForceTargetAppShutdown(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForceTargetAppShutdown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_ForceTargetAppShutdown(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceTargetAppShutdown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_ForceAppShutdown(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForceAppShutdown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_ForceAppShutdown(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceAppShutdown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_ExternalLocationUri(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExternalLocationUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_ExternalLocationUri(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ExternalLocationUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_DeveloperMode(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeveloperMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_DeveloperMode(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DeveloperMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_DeferRegistrationWhenPackagesAreInUse(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeferRegistrationWhenPackagesAreInUse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_DeferRegistrationWhenPackagesAreInUse(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DeferRegistrationWhenPackagesAreInUse(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_AllowUnsigned(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowUnsigned());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_AllowUnsigned(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowUnsigned(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_DependencyPackageUris(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DependencyPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AddPackageOptions_get_OptionalPackageFamilyNames(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OptionalPackageFamilyNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AddPackageOptions_get_OptionalPackageUris(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OptionalPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AddPackageOptions_get_RelatedPackageUris(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelatedPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AddPackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::AddPackageOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AddPackageOptions[] = {
        { "_from", (PyCFunction)_from_AddPackageOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AddPackageOptions[] = {
        { const_cast<char*>("target_volume"), (getter)AddPackageOptions_get_TargetVolume, (setter)AddPackageOptions_put_TargetVolume, nullptr, nullptr },
        { const_cast<char*>("stub_package_option"), (getter)AddPackageOptions_get_StubPackageOption, (setter)AddPackageOptions_put_StubPackageOption, nullptr, nullptr },
        { const_cast<char*>("stage_in_place"), (getter)AddPackageOptions_get_StageInPlace, (setter)AddPackageOptions_put_StageInPlace, nullptr, nullptr },
        { const_cast<char*>("retain_files_on_failure"), (getter)AddPackageOptions_get_RetainFilesOnFailure, (setter)AddPackageOptions_put_RetainFilesOnFailure, nullptr, nullptr },
        { const_cast<char*>("required_content_group_only"), (getter)AddPackageOptions_get_RequiredContentGroupOnly, (setter)AddPackageOptions_put_RequiredContentGroupOnly, nullptr, nullptr },
        { const_cast<char*>("install_all_resources"), (getter)AddPackageOptions_get_InstallAllResources, (setter)AddPackageOptions_put_InstallAllResources, nullptr, nullptr },
        { const_cast<char*>("force_update_from_any_version"), (getter)AddPackageOptions_get_ForceUpdateFromAnyVersion, (setter)AddPackageOptions_put_ForceUpdateFromAnyVersion, nullptr, nullptr },
        { const_cast<char*>("force_target_app_shutdown"), (getter)AddPackageOptions_get_ForceTargetAppShutdown, (setter)AddPackageOptions_put_ForceTargetAppShutdown, nullptr, nullptr },
        { const_cast<char*>("force_app_shutdown"), (getter)AddPackageOptions_get_ForceAppShutdown, (setter)AddPackageOptions_put_ForceAppShutdown, nullptr, nullptr },
        { const_cast<char*>("external_location_uri"), (getter)AddPackageOptions_get_ExternalLocationUri, (setter)AddPackageOptions_put_ExternalLocationUri, nullptr, nullptr },
        { const_cast<char*>("developer_mode"), (getter)AddPackageOptions_get_DeveloperMode, (setter)AddPackageOptions_put_DeveloperMode, nullptr, nullptr },
        { const_cast<char*>("defer_registration_when_packages_are_in_use"), (getter)AddPackageOptions_get_DeferRegistrationWhenPackagesAreInUse, (setter)AddPackageOptions_put_DeferRegistrationWhenPackagesAreInUse, nullptr, nullptr },
        { const_cast<char*>("allow_unsigned"), (getter)AddPackageOptions_get_AllowUnsigned, (setter)AddPackageOptions_put_AllowUnsigned, nullptr, nullptr },
        { const_cast<char*>("dependency_package_uris"), (getter)AddPackageOptions_get_DependencyPackageUris, nullptr, nullptr, nullptr },
        { const_cast<char*>("optional_package_family_names"), (getter)AddPackageOptions_get_OptionalPackageFamilyNames, nullptr, nullptr, nullptr },
        { const_cast<char*>("optional_package_uris"), (getter)AddPackageOptions_get_OptionalPackageUris, nullptr, nullptr, nullptr },
        { const_cast<char*>("related_package_uris"), (getter)AddPackageOptions_get_RelatedPackageUris, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AddPackageOptions[] = 
    {
        { Py_tp_new, _new_AddPackageOptions },
        { Py_tp_dealloc, _dealloc_AddPackageOptions },
        { Py_tp_methods, _methods_AddPackageOptions },
        { Py_tp_getset, _getset_AddPackageOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AddPackageOptions =
    {
        "_winrt_Windows_Management_Deployment.AddPackageOptions",
        sizeof(py::wrapper::Windows::Management::Deployment::AddPackageOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AddPackageOptions
    };

    // ----- AppInstallerManager class --------------------
    constexpr const char* const _type_name_AppInstallerManager = "AppInstallerManager";

    static PyObject* _new_AppInstallerManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppInstallerManager);
        return nullptr;
    }

    static void _dealloc_AppInstallerManager(py::wrapper::Windows::Management::Deployment::AppInstallerManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppInstallerManager_ClearAutoUpdateSettings(py::wrapper::Windows::Management::Deployment::AppInstallerManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ClearAutoUpdateSettings(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstallerManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Management::Deployment::AppInstallerManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstallerManager_GetForSystem(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Management::Deployment::AppInstallerManager::GetForSystem());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstallerManager_PauseAutoUpdatesUntil(py::wrapper::Windows::Management::Deployment::AppInstallerManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                self->obj.PauseAutoUpdatesUntil(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstallerManager_SetAutoUpdateSettings(py::wrapper::Windows::Management::Deployment::AppInstallerManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::AutoUpdateSettingsOptions>(args, 1);

                self->obj.SetAutoUpdateSettings(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_AppInstallerManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::AppInstallerManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppInstallerManager[] = {
        { "clear_auto_update_settings", (PyCFunction)AppInstallerManager_ClearAutoUpdateSettings, METH_VARARGS, nullptr },
        { "get_default", (PyCFunction)AppInstallerManager_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_system", (PyCFunction)AppInstallerManager_GetForSystem, METH_VARARGS | METH_STATIC, nullptr },
        { "pause_auto_updates_until", (PyCFunction)AppInstallerManager_PauseAutoUpdatesUntil, METH_VARARGS, nullptr },
        { "set_auto_update_settings", (PyCFunction)AppInstallerManager_SetAutoUpdateSettings, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AppInstallerManager, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppInstallerManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_AppInstallerManager[] = 
    {
        { Py_tp_new, _new_AppInstallerManager },
        { Py_tp_dealloc, _dealloc_AppInstallerManager },
        { Py_tp_methods, _methods_AppInstallerManager },
        { Py_tp_getset, _getset_AppInstallerManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppInstallerManager =
    {
        "_winrt_Windows_Management_Deployment.AppInstallerManager",
        sizeof(py::wrapper::Windows::Management::Deployment::AppInstallerManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppInstallerManager
    };

    // ----- AutoUpdateSettingsOptions class --------------------
    constexpr const char* const _type_name_AutoUpdateSettingsOptions = "AutoUpdateSettingsOptions";

    static PyObject* _new_AutoUpdateSettingsOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::AutoUpdateSettingsOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AutoUpdateSettingsOptions(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AutoUpdateSettingsOptions_CreateFromAppInstallerInfo(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::AppInstallerInfo>(args, 0);

                return py::convert(winrt::Windows::Management::Deployment::AutoUpdateSettingsOptions::CreateFromAppInstallerInfo(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_Version(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_Version(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::PackageVersion>(arg);

            self->obj.Version(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_UpdateBlocksActivation(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateBlocksActivation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_UpdateBlocksActivation(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.UpdateBlocksActivation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_ShowPrompt(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShowPrompt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_ShowPrompt(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowPrompt(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_OnLaunch(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OnLaunch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_OnLaunch(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.OnLaunch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_IsAutoRepairEnabled(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAutoRepairEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_IsAutoRepairEnabled(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAutoRepairEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_HoursBetweenUpdateChecks(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HoursBetweenUpdateChecks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_HoursBetweenUpdateChecks(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.HoursBetweenUpdateChecks(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForceUpdateFromAnyVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceUpdateFromAnyVersion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_AutomaticBackgroundTask(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutomaticBackgroundTask());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_AutomaticBackgroundTask(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutomaticBackgroundTask(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_AppInstallerUri(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppInstallerUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_AppInstallerUri(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.AppInstallerUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_DependencyPackageUris(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DependencyPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_OptionalPackageUris(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OptionalPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_RepairUris(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RepairUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_UpdateUris(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AutoUpdateSettingsOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::AutoUpdateSettingsOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutoUpdateSettingsOptions[] = {
        { "create_from_app_installer_info", (PyCFunction)AutoUpdateSettingsOptions_CreateFromAppInstallerInfo, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_AutoUpdateSettingsOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AutoUpdateSettingsOptions[] = {
        { const_cast<char*>("version"), (getter)AutoUpdateSettingsOptions_get_Version, (setter)AutoUpdateSettingsOptions_put_Version, nullptr, nullptr },
        { const_cast<char*>("update_blocks_activation"), (getter)AutoUpdateSettingsOptions_get_UpdateBlocksActivation, (setter)AutoUpdateSettingsOptions_put_UpdateBlocksActivation, nullptr, nullptr },
        { const_cast<char*>("show_prompt"), (getter)AutoUpdateSettingsOptions_get_ShowPrompt, (setter)AutoUpdateSettingsOptions_put_ShowPrompt, nullptr, nullptr },
        { const_cast<char*>("on_launch"), (getter)AutoUpdateSettingsOptions_get_OnLaunch, (setter)AutoUpdateSettingsOptions_put_OnLaunch, nullptr, nullptr },
        { const_cast<char*>("is_auto_repair_enabled"), (getter)AutoUpdateSettingsOptions_get_IsAutoRepairEnabled, (setter)AutoUpdateSettingsOptions_put_IsAutoRepairEnabled, nullptr, nullptr },
        { const_cast<char*>("hours_between_update_checks"), (getter)AutoUpdateSettingsOptions_get_HoursBetweenUpdateChecks, (setter)AutoUpdateSettingsOptions_put_HoursBetweenUpdateChecks, nullptr, nullptr },
        { const_cast<char*>("force_update_from_any_version"), (getter)AutoUpdateSettingsOptions_get_ForceUpdateFromAnyVersion, (setter)AutoUpdateSettingsOptions_put_ForceUpdateFromAnyVersion, nullptr, nullptr },
        { const_cast<char*>("automatic_background_task"), (getter)AutoUpdateSettingsOptions_get_AutomaticBackgroundTask, (setter)AutoUpdateSettingsOptions_put_AutomaticBackgroundTask, nullptr, nullptr },
        { const_cast<char*>("app_installer_uri"), (getter)AutoUpdateSettingsOptions_get_AppInstallerUri, (setter)AutoUpdateSettingsOptions_put_AppInstallerUri, nullptr, nullptr },
        { const_cast<char*>("dependency_package_uris"), (getter)AutoUpdateSettingsOptions_get_DependencyPackageUris, nullptr, nullptr, nullptr },
        { const_cast<char*>("optional_package_uris"), (getter)AutoUpdateSettingsOptions_get_OptionalPackageUris, nullptr, nullptr, nullptr },
        { const_cast<char*>("repair_uris"), (getter)AutoUpdateSettingsOptions_get_RepairUris, nullptr, nullptr, nullptr },
        { const_cast<char*>("update_uris"), (getter)AutoUpdateSettingsOptions_get_UpdateUris, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AutoUpdateSettingsOptions[] = 
    {
        { Py_tp_new, _new_AutoUpdateSettingsOptions },
        { Py_tp_dealloc, _dealloc_AutoUpdateSettingsOptions },
        { Py_tp_methods, _methods_AutoUpdateSettingsOptions },
        { Py_tp_getset, _getset_AutoUpdateSettingsOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AutoUpdateSettingsOptions =
    {
        "_winrt_Windows_Management_Deployment.AutoUpdateSettingsOptions",
        sizeof(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutoUpdateSettingsOptions
    };

    // ----- DeploymentResult class --------------------
    constexpr const char* const _type_name_DeploymentResult = "DeploymentResult";

    static PyObject* _new_DeploymentResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DeploymentResult);
        return nullptr;
    }

    static void _dealloc_DeploymentResult(py::wrapper::Windows::Management::Deployment::DeploymentResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeploymentResult_get_ActivityId(py::wrapper::Windows::Management::Deployment::DeploymentResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeploymentResult_get_ErrorText(py::wrapper::Windows::Management::Deployment::DeploymentResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeploymentResult_get_ExtendedErrorCode(py::wrapper::Windows::Management::Deployment::DeploymentResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeploymentResult_get_IsRegistered(py::wrapper::Windows::Management::Deployment::DeploymentResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRegistered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DeploymentResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::DeploymentResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeploymentResult[] = {
        { "_from", (PyCFunction)_from_DeploymentResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeploymentResult[] = {
        { const_cast<char*>("activity_id"), (getter)DeploymentResult_get_ActivityId, nullptr, nullptr, nullptr },
        { const_cast<char*>("error_text"), (getter)DeploymentResult_get_ErrorText, nullptr, nullptr, nullptr },
        { const_cast<char*>("extended_error_code"), (getter)DeploymentResult_get_ExtendedErrorCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_registered"), (getter)DeploymentResult_get_IsRegistered, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DeploymentResult[] = 
    {
        { Py_tp_new, _new_DeploymentResult },
        { Py_tp_dealloc, _dealloc_DeploymentResult },
        { Py_tp_methods, _methods_DeploymentResult },
        { Py_tp_getset, _getset_DeploymentResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeploymentResult =
    {
        "_winrt_Windows_Management_Deployment.DeploymentResult",
        sizeof(py::wrapper::Windows::Management::Deployment::DeploymentResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeploymentResult
    };

    // ----- PackageAllUserProvisioningOptions class --------------------
    constexpr const char* const _type_name_PackageAllUserProvisioningOptions = "PackageAllUserProvisioningOptions";

    static PyObject* _new_PackageAllUserProvisioningOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::PackageAllUserProvisioningOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PackageAllUserProvisioningOptions(py::wrapper::Windows::Management::Deployment::PackageAllUserProvisioningOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageAllUserProvisioningOptions_get_OptionalPackageFamilyNames(py::wrapper::Windows::Management::Deployment::PackageAllUserProvisioningOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OptionalPackageFamilyNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageAllUserProvisioningOptions_get_ProjectionOrderPackageFamilyNames(py::wrapper::Windows::Management::Deployment::PackageAllUserProvisioningOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProjectionOrderPackageFamilyNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageAllUserProvisioningOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::PackageAllUserProvisioningOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageAllUserProvisioningOptions[] = {
        { "_from", (PyCFunction)_from_PackageAllUserProvisioningOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PackageAllUserProvisioningOptions[] = {
        { const_cast<char*>("optional_package_family_names"), (getter)PackageAllUserProvisioningOptions_get_OptionalPackageFamilyNames, nullptr, nullptr, nullptr },
        { const_cast<char*>("projection_order_package_family_names"), (getter)PackageAllUserProvisioningOptions_get_ProjectionOrderPackageFamilyNames, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageAllUserProvisioningOptions[] = 
    {
        { Py_tp_new, _new_PackageAllUserProvisioningOptions },
        { Py_tp_dealloc, _dealloc_PackageAllUserProvisioningOptions },
        { Py_tp_methods, _methods_PackageAllUserProvisioningOptions },
        { Py_tp_getset, _getset_PackageAllUserProvisioningOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageAllUserProvisioningOptions =
    {
        "_winrt_Windows_Management_Deployment.PackageAllUserProvisioningOptions",
        sizeof(py::wrapper::Windows::Management::Deployment::PackageAllUserProvisioningOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageAllUserProvisioningOptions
    };

    // ----- PackageManager class --------------------
    constexpr const char* const _type_name_PackageManager = "PackageManager";

    static PyObject* _new_PackageManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::PackageManager instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PackageManager(py::wrapper::Windows::Management::Deployment::PackageManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageManager_AddPackageAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);

                return py::convert(self->obj.AddPackageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);

                return py::convert(self->obj.AddPackageAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 5);

                return py::convert(self->obj.AddPackageAsync(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 5);
                auto param6 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 6);

                return py::convert(self->obj.AddPackageAsync(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_AddPackageByAppInstallerFileAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::AddPackageByAppInstallerOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 2);

                return py::convert(self->obj.AddPackageByAppInstallerFileAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_AddPackageByUriAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::AddPackageOptions>(args, 1);

                return py::convert(self->obj.AddPackageByUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_AddPackageVolumeAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.AddPackageVolumeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_CleanupPackageForUserAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CleanupPackageForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_ClearPackageStatus(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageStatus>(args, 1);

                self->obj.ClearPackageStatus(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_DeprovisionPackageForAllUsersAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeprovisionPackageForAllUsersAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackage(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindPackage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackageForUser(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.FindPackageForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackageVolume(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindPackageVolume(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackageVolumes(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindPackageVolumes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackages(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindPackages());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindPackages(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.FindPackages(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackagesForUser(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindPackagesForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.FindPackagesForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.FindPackagesForUser(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackagesForUserWithPackageTypes(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 1);

                return py::convert(self->obj.FindPackagesForUserWithPackageTypes(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 2);

                return py::convert(self->obj.FindPackagesForUserWithPackageTypes(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 3);

                return py::convert(self->obj.FindPackagesForUserWithPackageTypes(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackagesWithPackageTypes(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 0);

                return py::convert(self->obj.FindPackagesWithPackageTypes(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 1);

                return py::convert(self->obj.FindPackagesWithPackageTypes(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 2);

                return py::convert(self->obj.FindPackagesWithPackageTypes(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindProvisionedPackages(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindProvisionedPackages());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindUsers(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindUsers(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_GetDefaultPackageVolume(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDefaultPackageVolume());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_GetPackageStubPreference(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetPackageStubPreference(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_GetPackageVolumesAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPackageVolumesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_MovePackageToVolumeAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 2);

                return py::convert(self->obj.MovePackageToVolumeAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_ProvisionPackageForAllUsersAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ProvisionPackageForAllUsersAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageAllUserProvisioningOptions>(args, 1);

                return py::convert(self->obj.ProvisionPackageForAllUsersAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RegisterPackageAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);

                return py::convert(self->obj.RegisterPackageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);

                return py::convert(self->obj.RegisterPackageAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RegisterPackageByFamilyNameAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 4);

                return py::convert(self->obj.RegisterPackageByFamilyNameAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RegisterPackageByFullNameAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);

                return py::convert(self->obj.RegisterPackageByFullNameAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RegisterPackageByUriAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::RegisterPackageOptions>(args, 1);

                return py::convert(self->obj.RegisterPackageByUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RegisterPackagesByFullNameAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::RegisterPackageOptions>(args, 1);

                return py::convert(self->obj.RegisterPackagesByFullNameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RemovePackageAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RemovePackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::RemovalOptions>(args, 1);

                return py::convert(self->obj.RemovePackageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RemovePackageVolumeAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 0);

                return py::convert(self->obj.RemovePackageVolumeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RequestAddPackageAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 5);

                return py::convert(self->obj.RequestAddPackageAsync(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 5);
                auto param6 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 6);

                return py::convert(self->obj.RequestAddPackageAsync(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RequestAddPackageByAppInstallerFileAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::AddPackageByAppInstallerOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 2);

                return py::convert(self->obj.RequestAddPackageByAppInstallerFileAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_SetDefaultPackageVolume(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 0);

                self->obj.SetDefaultPackageVolume(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_SetPackageState(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageState>(args, 1);

                self->obj.SetPackageState(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_SetPackageStatus(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageStatus>(args, 1);

                self->obj.SetPackageStatus(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_SetPackageStubPreference(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageStubPreference>(args, 1);

                self->obj.SetPackageStubPreference(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_SetPackageVolumeOfflineAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 0);

                return py::convert(self->obj.SetPackageVolumeOfflineAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_SetPackageVolumeOnlineAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 0);

                return py::convert(self->obj.SetPackageVolumeOnlineAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_StagePackageAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);

                return py::convert(self->obj.StagePackageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);

                return py::convert(self->obj.StagePackageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);

                return py::convert(self->obj.StagePackageAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 5);

                return py::convert(self->obj.StagePackageAsync(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 5);
                auto param6 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 6);

                return py::convert(self->obj.StagePackageAsync(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_StagePackageByUriAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::StagePackageOptions>(args, 1);

                return py::convert(self->obj.StagePackageByUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_StageUserDataAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.StageUserDataAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 1);

                return py::convert(self->obj.StageUserDataAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_UpdatePackageAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);

                return py::convert(self->obj.UpdatePackageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_get_DebugSettings(py::wrapper::Windows::Management::Deployment::PackageManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DebugSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::PackageManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageManager[] = {
        { "add_package_async", (PyCFunction)PackageManager_AddPackageAsync, METH_VARARGS, nullptr },
        { "add_package_by_app_installer_file_async", (PyCFunction)PackageManager_AddPackageByAppInstallerFileAsync, METH_VARARGS, nullptr },
        { "add_package_by_uri_async", (PyCFunction)PackageManager_AddPackageByUriAsync, METH_VARARGS, nullptr },
        { "add_package_volume_async", (PyCFunction)PackageManager_AddPackageVolumeAsync, METH_VARARGS, nullptr },
        { "cleanup_package_for_user_async", (PyCFunction)PackageManager_CleanupPackageForUserAsync, METH_VARARGS, nullptr },
        { "clear_package_status", (PyCFunction)PackageManager_ClearPackageStatus, METH_VARARGS, nullptr },
        { "deprovision_package_for_all_users_async", (PyCFunction)PackageManager_DeprovisionPackageForAllUsersAsync, METH_VARARGS, nullptr },
        { "find_package", (PyCFunction)PackageManager_FindPackage, METH_VARARGS, nullptr },
        { "find_package_for_user", (PyCFunction)PackageManager_FindPackageForUser, METH_VARARGS, nullptr },
        { "find_package_volume", (PyCFunction)PackageManager_FindPackageVolume, METH_VARARGS, nullptr },
        { "find_package_volumes", (PyCFunction)PackageManager_FindPackageVolumes, METH_VARARGS, nullptr },
        { "find_packages", (PyCFunction)PackageManager_FindPackages, METH_VARARGS, nullptr },
        { "find_packages_for_user", (PyCFunction)PackageManager_FindPackagesForUser, METH_VARARGS, nullptr },
        { "find_packages_for_user_with_package_types", (PyCFunction)PackageManager_FindPackagesForUserWithPackageTypes, METH_VARARGS, nullptr },
        { "find_packages_with_package_types", (PyCFunction)PackageManager_FindPackagesWithPackageTypes, METH_VARARGS, nullptr },
        { "find_provisioned_packages", (PyCFunction)PackageManager_FindProvisionedPackages, METH_VARARGS, nullptr },
        { "find_users", (PyCFunction)PackageManager_FindUsers, METH_VARARGS, nullptr },
        { "get_default_package_volume", (PyCFunction)PackageManager_GetDefaultPackageVolume, METH_VARARGS, nullptr },
        { "get_package_stub_preference", (PyCFunction)PackageManager_GetPackageStubPreference, METH_VARARGS, nullptr },
        { "get_package_volumes_async", (PyCFunction)PackageManager_GetPackageVolumesAsync, METH_VARARGS, nullptr },
        { "move_package_to_volume_async", (PyCFunction)PackageManager_MovePackageToVolumeAsync, METH_VARARGS, nullptr },
        { "provision_package_for_all_users_async", (PyCFunction)PackageManager_ProvisionPackageForAllUsersAsync, METH_VARARGS, nullptr },
        { "register_package_async", (PyCFunction)PackageManager_RegisterPackageAsync, METH_VARARGS, nullptr },
        { "register_package_by_family_name_async", (PyCFunction)PackageManager_RegisterPackageByFamilyNameAsync, METH_VARARGS, nullptr },
        { "register_package_by_full_name_async", (PyCFunction)PackageManager_RegisterPackageByFullNameAsync, METH_VARARGS, nullptr },
        { "register_package_by_uri_async", (PyCFunction)PackageManager_RegisterPackageByUriAsync, METH_VARARGS, nullptr },
        { "register_packages_by_full_name_async", (PyCFunction)PackageManager_RegisterPackagesByFullNameAsync, METH_VARARGS, nullptr },
        { "remove_package_async", (PyCFunction)PackageManager_RemovePackageAsync, METH_VARARGS, nullptr },
        { "remove_package_volume_async", (PyCFunction)PackageManager_RemovePackageVolumeAsync, METH_VARARGS, nullptr },
        { "request_add_package_async", (PyCFunction)PackageManager_RequestAddPackageAsync, METH_VARARGS, nullptr },
        { "request_add_package_by_app_installer_file_async", (PyCFunction)PackageManager_RequestAddPackageByAppInstallerFileAsync, METH_VARARGS, nullptr },
        { "set_default_package_volume", (PyCFunction)PackageManager_SetDefaultPackageVolume, METH_VARARGS, nullptr },
        { "set_package_state", (PyCFunction)PackageManager_SetPackageState, METH_VARARGS, nullptr },
        { "set_package_status", (PyCFunction)PackageManager_SetPackageStatus, METH_VARARGS, nullptr },
        { "set_package_stub_preference", (PyCFunction)PackageManager_SetPackageStubPreference, METH_VARARGS, nullptr },
        { "set_package_volume_offline_async", (PyCFunction)PackageManager_SetPackageVolumeOfflineAsync, METH_VARARGS, nullptr },
        { "set_package_volume_online_async", (PyCFunction)PackageManager_SetPackageVolumeOnlineAsync, METH_VARARGS, nullptr },
        { "stage_package_async", (PyCFunction)PackageManager_StagePackageAsync, METH_VARARGS, nullptr },
        { "stage_package_by_uri_async", (PyCFunction)PackageManager_StagePackageByUriAsync, METH_VARARGS, nullptr },
        { "stage_user_data_async", (PyCFunction)PackageManager_StageUserDataAsync, METH_VARARGS, nullptr },
        { "update_package_async", (PyCFunction)PackageManager_UpdatePackageAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PackageManager, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PackageManager[] = {
        { const_cast<char*>("debug_settings"), (getter)PackageManager_get_DebugSettings, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageManager[] = 
    {
        { Py_tp_new, _new_PackageManager },
        { Py_tp_dealloc, _dealloc_PackageManager },
        { Py_tp_methods, _methods_PackageManager },
        { Py_tp_getset, _getset_PackageManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageManager =
    {
        "_winrt_Windows_Management_Deployment.PackageManager",
        sizeof(py::wrapper::Windows::Management::Deployment::PackageManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageManager
    };

    // ----- PackageManagerDebugSettings class --------------------
    constexpr const char* const _type_name_PackageManagerDebugSettings = "PackageManagerDebugSettings";

    static PyObject* _new_PackageManagerDebugSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageManagerDebugSettings);
        return nullptr;
    }

    static void _dealloc_PackageManagerDebugSettings(py::wrapper::Windows::Management::Deployment::PackageManagerDebugSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageManagerDebugSettings_SetContentGroupStateAsync(py::wrapper::Windows::Management::Deployment::PackageManagerDebugSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::PackageContentGroupState>(args, 2);

                return py::convert(self->obj.SetContentGroupStateAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::PackageContentGroupState>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);

                return py::convert(self->obj.SetContentGroupStateAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_PackageManagerDebugSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::PackageManagerDebugSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageManagerDebugSettings[] = {
        { "set_content_group_state_async", (PyCFunction)PackageManagerDebugSettings_SetContentGroupStateAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PackageManagerDebugSettings, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PackageManagerDebugSettings[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageManagerDebugSettings[] = 
    {
        { Py_tp_new, _new_PackageManagerDebugSettings },
        { Py_tp_dealloc, _dealloc_PackageManagerDebugSettings },
        { Py_tp_methods, _methods_PackageManagerDebugSettings },
        { Py_tp_getset, _getset_PackageManagerDebugSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageManagerDebugSettings =
    {
        "_winrt_Windows_Management_Deployment.PackageManagerDebugSettings",
        sizeof(py::wrapper::Windows::Management::Deployment::PackageManagerDebugSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageManagerDebugSettings
    };

    // ----- PackageUserInformation class --------------------
    constexpr const char* const _type_name_PackageUserInformation = "PackageUserInformation";

    static PyObject* _new_PackageUserInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageUserInformation);
        return nullptr;
    }

    static void _dealloc_PackageUserInformation(py::wrapper::Windows::Management::Deployment::PackageUserInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageUserInformation_get_InstallState(py::wrapper::Windows::Management::Deployment::PackageUserInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstallState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUserInformation_get_UserSecurityId(py::wrapper::Windows::Management::Deployment::PackageUserInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserSecurityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageUserInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::PackageUserInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageUserInformation[] = {
        { "_from", (PyCFunction)_from_PackageUserInformation, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PackageUserInformation[] = {
        { const_cast<char*>("install_state"), (getter)PackageUserInformation_get_InstallState, nullptr, nullptr, nullptr },
        { const_cast<char*>("user_security_id"), (getter)PackageUserInformation_get_UserSecurityId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageUserInformation[] = 
    {
        { Py_tp_new, _new_PackageUserInformation },
        { Py_tp_dealloc, _dealloc_PackageUserInformation },
        { Py_tp_methods, _methods_PackageUserInformation },
        { Py_tp_getset, _getset_PackageUserInformation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageUserInformation =
    {
        "_winrt_Windows_Management_Deployment.PackageUserInformation",
        sizeof(py::wrapper::Windows::Management::Deployment::PackageUserInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageUserInformation
    };

    // ----- PackageVolume class --------------------
    constexpr const char* const _type_name_PackageVolume = "PackageVolume";

    static PyObject* _new_PackageVolume(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageVolume);
        return nullptr;
    }

    static void _dealloc_PackageVolume(py::wrapper::Windows::Management::Deployment::PackageVolume* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageVolume_FindPackage(py::wrapper::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindPackage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_FindPackageForUser(py::wrapper::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.FindPackageForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_FindPackages(py::wrapper::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindPackages());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindPackages(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.FindPackages(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_FindPackagesForUser(py::wrapper::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindPackagesForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.FindPackagesForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.FindPackagesForUser(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_FindPackagesForUserWithPackageTypes(py::wrapper::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 1);

                return py::convert(self->obj.FindPackagesForUserWithPackageTypes(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.FindPackagesForUserWithPackageTypes(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.FindPackagesForUserWithPackageTypes(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_FindPackagesWithPackageTypes(py::wrapper::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 0);

                return py::convert(self->obj.FindPackagesWithPackageTypes(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.FindPackagesWithPackageTypes(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.FindPackagesWithPackageTypes(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_GetAvailableSpaceAsync(py::wrapper::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAvailableSpaceAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_IsOffline(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOffline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_IsSystemVolume(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSystemVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_MountPoint(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MountPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_Name(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_PackageStorePath(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageStorePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_SupportsHardLinks(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportsHardLinks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_IsAppxInstallSupported(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAppxInstallSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_IsFullTrustPackageSupported(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsFullTrustPackageSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageVolume(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::PackageVolume>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageVolume[] = {
        { "find_package", (PyCFunction)PackageVolume_FindPackage, METH_VARARGS, nullptr },
        { "find_package_for_user", (PyCFunction)PackageVolume_FindPackageForUser, METH_VARARGS, nullptr },
        { "find_packages", (PyCFunction)PackageVolume_FindPackages, METH_VARARGS, nullptr },
        { "find_packages_for_user", (PyCFunction)PackageVolume_FindPackagesForUser, METH_VARARGS, nullptr },
        { "find_packages_for_user_with_package_types", (PyCFunction)PackageVolume_FindPackagesForUserWithPackageTypes, METH_VARARGS, nullptr },
        { "find_packages_with_package_types", (PyCFunction)PackageVolume_FindPackagesWithPackageTypes, METH_VARARGS, nullptr },
        { "get_available_space_async", (PyCFunction)PackageVolume_GetAvailableSpaceAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_PackageVolume, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PackageVolume[] = {
        { const_cast<char*>("is_offline"), (getter)PackageVolume_get_IsOffline, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_system_volume"), (getter)PackageVolume_get_IsSystemVolume, nullptr, nullptr, nullptr },
        { const_cast<char*>("mount_point"), (getter)PackageVolume_get_MountPoint, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)PackageVolume_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("package_store_path"), (getter)PackageVolume_get_PackageStorePath, nullptr, nullptr, nullptr },
        { const_cast<char*>("supports_hard_links"), (getter)PackageVolume_get_SupportsHardLinks, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_appx_install_supported"), (getter)PackageVolume_get_IsAppxInstallSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_full_trust_package_supported"), (getter)PackageVolume_get_IsFullTrustPackageSupported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PackageVolume[] = 
    {
        { Py_tp_new, _new_PackageVolume },
        { Py_tp_dealloc, _dealloc_PackageVolume },
        { Py_tp_methods, _methods_PackageVolume },
        { Py_tp_getset, _getset_PackageVolume },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageVolume =
    {
        "_winrt_Windows_Management_Deployment.PackageVolume",
        sizeof(py::wrapper::Windows::Management::Deployment::PackageVolume),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageVolume
    };

    // ----- RegisterPackageOptions class --------------------
    constexpr const char* const _type_name_RegisterPackageOptions = "RegisterPackageOptions";

    static PyObject* _new_RegisterPackageOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::RegisterPackageOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RegisterPackageOptions(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RegisterPackageOptions_get_StageInPlace(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StageInPlace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_StageInPlace(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StageInPlace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_InstallAllResources(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstallAllResources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_InstallAllResources(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.InstallAllResources(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForceUpdateFromAnyVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceUpdateFromAnyVersion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_ForceTargetAppShutdown(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForceTargetAppShutdown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_ForceTargetAppShutdown(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceTargetAppShutdown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_ForceAppShutdown(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForceAppShutdown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_ForceAppShutdown(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceAppShutdown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_ExternalLocationUri(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExternalLocationUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_ExternalLocationUri(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ExternalLocationUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_DeveloperMode(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeveloperMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_DeveloperMode(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DeveloperMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_DeferRegistrationWhenPackagesAreInUse(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeferRegistrationWhenPackagesAreInUse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_DeferRegistrationWhenPackagesAreInUse(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DeferRegistrationWhenPackagesAreInUse(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_AppDataVolume(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppDataVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_AppDataVolume(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(arg);

            self->obj.AppDataVolume(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_AllowUnsigned(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowUnsigned());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_AllowUnsigned(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowUnsigned(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_DependencyPackageUris(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DependencyPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RegisterPackageOptions_get_OptionalPackageFamilyNames(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OptionalPackageFamilyNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RegisterPackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::RegisterPackageOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RegisterPackageOptions[] = {
        { "_from", (PyCFunction)_from_RegisterPackageOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RegisterPackageOptions[] = {
        { const_cast<char*>("stage_in_place"), (getter)RegisterPackageOptions_get_StageInPlace, (setter)RegisterPackageOptions_put_StageInPlace, nullptr, nullptr },
        { const_cast<char*>("install_all_resources"), (getter)RegisterPackageOptions_get_InstallAllResources, (setter)RegisterPackageOptions_put_InstallAllResources, nullptr, nullptr },
        { const_cast<char*>("force_update_from_any_version"), (getter)RegisterPackageOptions_get_ForceUpdateFromAnyVersion, (setter)RegisterPackageOptions_put_ForceUpdateFromAnyVersion, nullptr, nullptr },
        { const_cast<char*>("force_target_app_shutdown"), (getter)RegisterPackageOptions_get_ForceTargetAppShutdown, (setter)RegisterPackageOptions_put_ForceTargetAppShutdown, nullptr, nullptr },
        { const_cast<char*>("force_app_shutdown"), (getter)RegisterPackageOptions_get_ForceAppShutdown, (setter)RegisterPackageOptions_put_ForceAppShutdown, nullptr, nullptr },
        { const_cast<char*>("external_location_uri"), (getter)RegisterPackageOptions_get_ExternalLocationUri, (setter)RegisterPackageOptions_put_ExternalLocationUri, nullptr, nullptr },
        { const_cast<char*>("developer_mode"), (getter)RegisterPackageOptions_get_DeveloperMode, (setter)RegisterPackageOptions_put_DeveloperMode, nullptr, nullptr },
        { const_cast<char*>("defer_registration_when_packages_are_in_use"), (getter)RegisterPackageOptions_get_DeferRegistrationWhenPackagesAreInUse, (setter)RegisterPackageOptions_put_DeferRegistrationWhenPackagesAreInUse, nullptr, nullptr },
        { const_cast<char*>("app_data_volume"), (getter)RegisterPackageOptions_get_AppDataVolume, (setter)RegisterPackageOptions_put_AppDataVolume, nullptr, nullptr },
        { const_cast<char*>("allow_unsigned"), (getter)RegisterPackageOptions_get_AllowUnsigned, (setter)RegisterPackageOptions_put_AllowUnsigned, nullptr, nullptr },
        { const_cast<char*>("dependency_package_uris"), (getter)RegisterPackageOptions_get_DependencyPackageUris, nullptr, nullptr, nullptr },
        { const_cast<char*>("optional_package_family_names"), (getter)RegisterPackageOptions_get_OptionalPackageFamilyNames, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RegisterPackageOptions[] = 
    {
        { Py_tp_new, _new_RegisterPackageOptions },
        { Py_tp_dealloc, _dealloc_RegisterPackageOptions },
        { Py_tp_methods, _methods_RegisterPackageOptions },
        { Py_tp_getset, _getset_RegisterPackageOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RegisterPackageOptions =
    {
        "_winrt_Windows_Management_Deployment.RegisterPackageOptions",
        sizeof(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RegisterPackageOptions
    };

    // ----- StagePackageOptions class --------------------
    constexpr const char* const _type_name_StagePackageOptions = "StagePackageOptions";

    static PyObject* _new_StagePackageOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::StagePackageOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StagePackageOptions(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StagePackageOptions_get_TargetVolume(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TargetVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_TargetVolume(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(arg);

            self->obj.TargetVolume(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_StubPackageOption(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StubPackageOption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_StubPackageOption(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Management::Deployment::StubPackageOption>(arg);

            self->obj.StubPackageOption(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_StageInPlace(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StageInPlace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_StageInPlace(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StageInPlace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_RequiredContentGroupOnly(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequiredContentGroupOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_RequiredContentGroupOnly(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RequiredContentGroupOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_InstallAllResources(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstallAllResources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_InstallAllResources(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.InstallAllResources(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForceUpdateFromAnyVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceUpdateFromAnyVersion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_ExternalLocationUri(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExternalLocationUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_ExternalLocationUri(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ExternalLocationUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_DeveloperMode(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeveloperMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_DeveloperMode(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DeveloperMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_AllowUnsigned(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowUnsigned());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_AllowUnsigned(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowUnsigned(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_DependencyPackageUris(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DependencyPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StagePackageOptions_get_OptionalPackageFamilyNames(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OptionalPackageFamilyNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StagePackageOptions_get_OptionalPackageUris(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OptionalPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StagePackageOptions_get_RelatedPackageUris(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelatedPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StagePackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::StagePackageOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StagePackageOptions[] = {
        { "_from", (PyCFunction)_from_StagePackageOptions, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StagePackageOptions[] = {
        { const_cast<char*>("target_volume"), (getter)StagePackageOptions_get_TargetVolume, (setter)StagePackageOptions_put_TargetVolume, nullptr, nullptr },
        { const_cast<char*>("stub_package_option"), (getter)StagePackageOptions_get_StubPackageOption, (setter)StagePackageOptions_put_StubPackageOption, nullptr, nullptr },
        { const_cast<char*>("stage_in_place"), (getter)StagePackageOptions_get_StageInPlace, (setter)StagePackageOptions_put_StageInPlace, nullptr, nullptr },
        { const_cast<char*>("required_content_group_only"), (getter)StagePackageOptions_get_RequiredContentGroupOnly, (setter)StagePackageOptions_put_RequiredContentGroupOnly, nullptr, nullptr },
        { const_cast<char*>("install_all_resources"), (getter)StagePackageOptions_get_InstallAllResources, (setter)StagePackageOptions_put_InstallAllResources, nullptr, nullptr },
        { const_cast<char*>("force_update_from_any_version"), (getter)StagePackageOptions_get_ForceUpdateFromAnyVersion, (setter)StagePackageOptions_put_ForceUpdateFromAnyVersion, nullptr, nullptr },
        { const_cast<char*>("external_location_uri"), (getter)StagePackageOptions_get_ExternalLocationUri, (setter)StagePackageOptions_put_ExternalLocationUri, nullptr, nullptr },
        { const_cast<char*>("developer_mode"), (getter)StagePackageOptions_get_DeveloperMode, (setter)StagePackageOptions_put_DeveloperMode, nullptr, nullptr },
        { const_cast<char*>("allow_unsigned"), (getter)StagePackageOptions_get_AllowUnsigned, (setter)StagePackageOptions_put_AllowUnsigned, nullptr, nullptr },
        { const_cast<char*>("dependency_package_uris"), (getter)StagePackageOptions_get_DependencyPackageUris, nullptr, nullptr, nullptr },
        { const_cast<char*>("optional_package_family_names"), (getter)StagePackageOptions_get_OptionalPackageFamilyNames, nullptr, nullptr, nullptr },
        { const_cast<char*>("optional_package_uris"), (getter)StagePackageOptions_get_OptionalPackageUris, nullptr, nullptr, nullptr },
        { const_cast<char*>("related_package_uris"), (getter)StagePackageOptions_get_RelatedPackageUris, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_StagePackageOptions[] = 
    {
        { Py_tp_new, _new_StagePackageOptions },
        { Py_tp_dealloc, _dealloc_StagePackageOptions },
        { Py_tp_methods, _methods_StagePackageOptions },
        { Py_tp_getset, _getset_StagePackageOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StagePackageOptions =
    {
        "_winrt_Windows_Management_Deployment.StagePackageOptions",
        sizeof(py::wrapper::Windows::Management::Deployment::StagePackageOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StagePackageOptions
    };

    // ----- DeploymentProgress struct --------------------
    constexpr const char* const _type_name_DeploymentProgress = "DeploymentProgress";

    PyObject* _new_DeploymentProgress(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Management::Deployment::DeploymentProgress return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Management::Deployment::DeploymentProgress>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        int32_t _state{};
        uint32_t _percentage{};

        static const char* kwlist[] = {"state", "percentage", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "iI", const_cast<char**>(kwlist), &_state, &_percentage))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Management::Deployment::DeploymentProgress return_value{ static_cast<winrt::Windows::Management::Deployment::DeploymentProgressState>(_state), _percentage };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_DeploymentProgress(py::wrapper::Windows::Management::Deployment::DeploymentProgress* self)
    {
    }

    static PyObject* DeploymentProgress_get_state(py::wrapper::Windows::Management::Deployment::DeploymentProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.state);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeploymentProgress_set_state(py::wrapper::Windows::Management::Deployment::DeploymentProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.state = py::converter<winrt::Windows::Management::Deployment::DeploymentProgressState>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeploymentProgress_get_percentage(py::wrapper::Windows::Management::Deployment::DeploymentProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.percentage);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeploymentProgress_set_percentage(py::wrapper::Windows::Management::Deployment::DeploymentProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.percentage = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_DeploymentProgress[] = {
        { const_cast<char*>("state"), (getter)DeploymentProgress_get_state, (setter)DeploymentProgress_set_state, nullptr, nullptr },
        { const_cast<char*>("percentage"), (getter)DeploymentProgress_get_percentage, (setter)DeploymentProgress_set_percentage, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DeploymentProgress[] = 
    {
        { Py_tp_new, _new_DeploymentProgress },
        { Py_tp_dealloc, _dealloc_DeploymentProgress },
        { Py_tp_getset, _getset_DeploymentProgress },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeploymentProgress =
    {
        "_winrt_Windows_Management_Deployment.DeploymentProgress",
        sizeof(py::wrapper::Windows::Management::Deployment::DeploymentProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeploymentProgress
    };

    // ----- Windows.Management.Deployment Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Management::Deployment::AddPackageOptions>::python_type = py::register_python_type(module, _type_name_AddPackageOptions, &_type_spec_AddPackageOptions, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::AppInstallerManager>::python_type = py::register_python_type(module, _type_name_AppInstallerManager, &_type_spec_AppInstallerManager, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::AutoUpdateSettingsOptions>::python_type = py::register_python_type(module, _type_name_AutoUpdateSettingsOptions, &_type_spec_AutoUpdateSettingsOptions, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::DeploymentResult>::python_type = py::register_python_type(module, _type_name_DeploymentResult, &_type_spec_DeploymentResult, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::PackageAllUserProvisioningOptions>::python_type = py::register_python_type(module, _type_name_PackageAllUserProvisioningOptions, &_type_spec_PackageAllUserProvisioningOptions, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::PackageManager>::python_type = py::register_python_type(module, _type_name_PackageManager, &_type_spec_PackageManager, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::PackageManagerDebugSettings>::python_type = py::register_python_type(module, _type_name_PackageManagerDebugSettings, &_type_spec_PackageManagerDebugSettings, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::PackageUserInformation>::python_type = py::register_python_type(module, _type_name_PackageUserInformation, &_type_spec_PackageUserInformation, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::PackageVolume>::python_type = py::register_python_type(module, _type_name_PackageVolume, &_type_spec_PackageVolume, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::RegisterPackageOptions>::python_type = py::register_python_type(module, _type_name_RegisterPackageOptions, &_type_spec_RegisterPackageOptions, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::StagePackageOptions>::python_type = py::register_python_type(module, _type_name_StagePackageOptions, &_type_spec_StagePackageOptions, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::DeploymentProgress>::python_type = py::register_python_type(module, _type_name_DeploymentProgress, &_type_spec_DeploymentProgress, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Management.Deployment");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Management_Deployment",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Management::Deployment

PyMODINIT_FUNC
PyInit__winrt_Windows_Management_Deployment (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Management::Deployment::module_def);
}
