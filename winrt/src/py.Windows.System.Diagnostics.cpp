// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.System.Diagnostics.h"

PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::DiagnosticActionResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::DiagnosticInvoker>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::ProcessCpuUsage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::ProcessCpuUsageReport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::ProcessDiskUsage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::ProcessDiskUsageReport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::ProcessMemoryUsage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::ProcessMemoryUsageReport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::SystemCpuUsage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::SystemCpuUsageReport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::SystemDiagnosticInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::SystemMemoryUsage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::SystemMemoryUsageReport>::python_type;

namespace py::cpp::Windows::System::Diagnostics
{
    // ----- DiagnosticActionResult class --------------------
    constexpr const char* const _type_name_DiagnosticActionResult = "DiagnosticActionResult";

    static PyObject* _new_DiagnosticActionResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DiagnosticActionResult);
        return nullptr;
    }

    static void _dealloc_DiagnosticActionResult(py::wrapper::Windows::System::Diagnostics::DiagnosticActionResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DiagnosticActionResult_get_ExtendedError(py::wrapper::Windows::System::Diagnostics::DiagnosticActionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DiagnosticActionResult_get_Results(py::wrapper::Windows::System::Diagnostics::DiagnosticActionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Results());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DiagnosticActionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::DiagnosticActionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DiagnosticActionResult[] = {
        { "_from", (PyCFunction)_from_DiagnosticActionResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DiagnosticActionResult[] = {
        { const_cast<char*>("extended_error"), (getter)DiagnosticActionResult_get_ExtendedError, nullptr, nullptr, nullptr },
        { const_cast<char*>("results"), (getter)DiagnosticActionResult_get_Results, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DiagnosticActionResult[] = 
    {
        { Py_tp_new, _new_DiagnosticActionResult },
        { Py_tp_dealloc, _dealloc_DiagnosticActionResult },
        { Py_tp_methods, _methods_DiagnosticActionResult },
        { Py_tp_getset, _getset_DiagnosticActionResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DiagnosticActionResult =
    {
        "_winrt_Windows_System_Diagnostics.DiagnosticActionResult",
        sizeof(py::wrapper::Windows::System::Diagnostics::DiagnosticActionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DiagnosticActionResult
    };

    // ----- DiagnosticInvoker class --------------------
    constexpr const char* const _type_name_DiagnosticInvoker = "DiagnosticInvoker";

    static PyObject* _new_DiagnosticInvoker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DiagnosticInvoker);
        return nullptr;
    }

    static void _dealloc_DiagnosticInvoker(py::wrapper::Windows::System::Diagnostics::DiagnosticInvoker* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DiagnosticInvoker_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::System::Diagnostics::DiagnosticInvoker::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DiagnosticInvoker_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::System::Diagnostics::DiagnosticInvoker::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DiagnosticInvoker_RunDiagnosticActionAsync(py::wrapper::Windows::System::Diagnostics::DiagnosticInvoker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Json::JsonObject>(args, 0);

                return py::convert(self->obj.RunDiagnosticActionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DiagnosticInvoker_RunDiagnosticActionFromStringAsync(py::wrapper::Windows::System::Diagnostics::DiagnosticInvoker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RunDiagnosticActionFromStringAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DiagnosticInvoker_get_IsSupported(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::System::Diagnostics::DiagnosticInvoker::IsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DiagnosticInvoker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::DiagnosticInvoker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DiagnosticInvoker[] = {
        { "get_default", (PyCFunction)DiagnosticInvoker_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", (PyCFunction)DiagnosticInvoker_GetForUser, METH_VARARGS | METH_STATIC, nullptr },
        { "run_diagnostic_action_async", (PyCFunction)DiagnosticInvoker_RunDiagnosticActionAsync, METH_VARARGS, nullptr },
        { "run_diagnostic_action_from_string_async", (PyCFunction)DiagnosticInvoker_RunDiagnosticActionFromStringAsync, METH_VARARGS, nullptr },
        { "get_is_supported", (PyCFunction)DiagnosticInvoker_get_IsSupported, METH_NOARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_DiagnosticInvoker, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DiagnosticInvoker[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_DiagnosticInvoker[] = 
    {
        { Py_tp_new, _new_DiagnosticInvoker },
        { Py_tp_dealloc, _dealloc_DiagnosticInvoker },
        { Py_tp_methods, _methods_DiagnosticInvoker },
        { Py_tp_getset, _getset_DiagnosticInvoker },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DiagnosticInvoker =
    {
        "_winrt_Windows_System_Diagnostics.DiagnosticInvoker",
        sizeof(py::wrapper::Windows::System::Diagnostics::DiagnosticInvoker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DiagnosticInvoker
    };

    // ----- ProcessCpuUsage class --------------------
    constexpr const char* const _type_name_ProcessCpuUsage = "ProcessCpuUsage";

    static PyObject* _new_ProcessCpuUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProcessCpuUsage);
        return nullptr;
    }

    static void _dealloc_ProcessCpuUsage(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProcessCpuUsage_GetReport(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ProcessCpuUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessCpuUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessCpuUsage[] = {
        { "get_report", (PyCFunction)ProcessCpuUsage_GetReport, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ProcessCpuUsage, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ProcessCpuUsage[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ProcessCpuUsage[] = 
    {
        { Py_tp_new, _new_ProcessCpuUsage },
        { Py_tp_dealloc, _dealloc_ProcessCpuUsage },
        { Py_tp_methods, _methods_ProcessCpuUsage },
        { Py_tp_getset, _getset_ProcessCpuUsage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProcessCpuUsage =
    {
        "_winrt_Windows_System_Diagnostics.ProcessCpuUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessCpuUsage
    };

    // ----- ProcessCpuUsageReport class --------------------
    constexpr const char* const _type_name_ProcessCpuUsageReport = "ProcessCpuUsageReport";

    static PyObject* _new_ProcessCpuUsageReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProcessCpuUsageReport);
        return nullptr;
    }

    static void _dealloc_ProcessCpuUsageReport(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsageReport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProcessCpuUsageReport_get_KernelTime(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KernelTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessCpuUsageReport_get_UserTime(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProcessCpuUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessCpuUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessCpuUsageReport[] = {
        { "_from", (PyCFunction)_from_ProcessCpuUsageReport, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ProcessCpuUsageReport[] = {
        { const_cast<char*>("kernel_time"), (getter)ProcessCpuUsageReport_get_KernelTime, nullptr, nullptr, nullptr },
        { const_cast<char*>("user_time"), (getter)ProcessCpuUsageReport_get_UserTime, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ProcessCpuUsageReport[] = 
    {
        { Py_tp_new, _new_ProcessCpuUsageReport },
        { Py_tp_dealloc, _dealloc_ProcessCpuUsageReport },
        { Py_tp_methods, _methods_ProcessCpuUsageReport },
        { Py_tp_getset, _getset_ProcessCpuUsageReport },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProcessCpuUsageReport =
    {
        "_winrt_Windows_System_Diagnostics.ProcessCpuUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessCpuUsageReport
    };

    // ----- ProcessDiagnosticInfo class --------------------
    constexpr const char* const _type_name_ProcessDiagnosticInfo = "ProcessDiagnosticInfo";

    static PyObject* _new_ProcessDiagnosticInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProcessDiagnosticInfo);
        return nullptr;
    }

    static void _dealloc_ProcessDiagnosticInfo(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProcessDiagnosticInfo_GetAppDiagnosticInfos(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAppDiagnosticInfos());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_GetForCurrentProcess(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo::GetForCurrentProcess());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_GetForProcesses(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo::GetForProcesses());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_TryGetForProcessId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo::TryGetForProcessId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_CpuUsage(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CpuUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_DiskUsage(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DiskUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_ExecutableFileName(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExecutableFileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_MemoryUsage(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MemoryUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_Parent(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Parent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_ProcessId(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProcessId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_ProcessStartTime(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProcessStartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_IsPackaged(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPackaged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProcessDiagnosticInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessDiagnosticInfo[] = {
        { "get_app_diagnostic_infos", (PyCFunction)ProcessDiagnosticInfo_GetAppDiagnosticInfos, METH_VARARGS, nullptr },
        { "get_for_current_process", (PyCFunction)ProcessDiagnosticInfo_GetForCurrentProcess, METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_processes", (PyCFunction)ProcessDiagnosticInfo_GetForProcesses, METH_VARARGS | METH_STATIC, nullptr },
        { "try_get_for_process_id", (PyCFunction)ProcessDiagnosticInfo_TryGetForProcessId, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_ProcessDiagnosticInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ProcessDiagnosticInfo[] = {
        { const_cast<char*>("cpu_usage"), (getter)ProcessDiagnosticInfo_get_CpuUsage, nullptr, nullptr, nullptr },
        { const_cast<char*>("disk_usage"), (getter)ProcessDiagnosticInfo_get_DiskUsage, nullptr, nullptr, nullptr },
        { const_cast<char*>("executable_file_name"), (getter)ProcessDiagnosticInfo_get_ExecutableFileName, nullptr, nullptr, nullptr },
        { const_cast<char*>("memory_usage"), (getter)ProcessDiagnosticInfo_get_MemoryUsage, nullptr, nullptr, nullptr },
        { const_cast<char*>("parent"), (getter)ProcessDiagnosticInfo_get_Parent, nullptr, nullptr, nullptr },
        { const_cast<char*>("process_id"), (getter)ProcessDiagnosticInfo_get_ProcessId, nullptr, nullptr, nullptr },
        { const_cast<char*>("process_start_time"), (getter)ProcessDiagnosticInfo_get_ProcessStartTime, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_packaged"), (getter)ProcessDiagnosticInfo_get_IsPackaged, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ProcessDiagnosticInfo[] = 
    {
        { Py_tp_new, _new_ProcessDiagnosticInfo },
        { Py_tp_dealloc, _dealloc_ProcessDiagnosticInfo },
        { Py_tp_methods, _methods_ProcessDiagnosticInfo },
        { Py_tp_getset, _getset_ProcessDiagnosticInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProcessDiagnosticInfo =
    {
        "_winrt_Windows_System_Diagnostics.ProcessDiagnosticInfo",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessDiagnosticInfo
    };

    // ----- ProcessDiskUsage class --------------------
    constexpr const char* const _type_name_ProcessDiskUsage = "ProcessDiskUsage";

    static PyObject* _new_ProcessDiskUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProcessDiskUsage);
        return nullptr;
    }

    static void _dealloc_ProcessDiskUsage(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProcessDiskUsage_GetReport(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ProcessDiskUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessDiskUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessDiskUsage[] = {
        { "get_report", (PyCFunction)ProcessDiskUsage_GetReport, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ProcessDiskUsage, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ProcessDiskUsage[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ProcessDiskUsage[] = 
    {
        { Py_tp_new, _new_ProcessDiskUsage },
        { Py_tp_dealloc, _dealloc_ProcessDiskUsage },
        { Py_tp_methods, _methods_ProcessDiskUsage },
        { Py_tp_getset, _getset_ProcessDiskUsage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProcessDiskUsage =
    {
        "_winrt_Windows_System_Diagnostics.ProcessDiskUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessDiskUsage
    };

    // ----- ProcessDiskUsageReport class --------------------
    constexpr const char* const _type_name_ProcessDiskUsageReport = "ProcessDiskUsageReport";

    static PyObject* _new_ProcessDiskUsageReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProcessDiskUsageReport);
        return nullptr;
    }

    static void _dealloc_ProcessDiskUsageReport(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProcessDiskUsageReport_get_BytesReadCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReadCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_BytesWrittenCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesWrittenCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_OtherBytesCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OtherBytesCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_OtherOperationCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OtherOperationCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_ReadOperationCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReadOperationCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_WriteOperationCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WriteOperationCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProcessDiskUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessDiskUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessDiskUsageReport[] = {
        { "_from", (PyCFunction)_from_ProcessDiskUsageReport, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ProcessDiskUsageReport[] = {
        { const_cast<char*>("bytes_read_count"), (getter)ProcessDiskUsageReport_get_BytesReadCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("bytes_written_count"), (getter)ProcessDiskUsageReport_get_BytesWrittenCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("other_bytes_count"), (getter)ProcessDiskUsageReport_get_OtherBytesCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("other_operation_count"), (getter)ProcessDiskUsageReport_get_OtherOperationCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("read_operation_count"), (getter)ProcessDiskUsageReport_get_ReadOperationCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("write_operation_count"), (getter)ProcessDiskUsageReport_get_WriteOperationCount, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ProcessDiskUsageReport[] = 
    {
        { Py_tp_new, _new_ProcessDiskUsageReport },
        { Py_tp_dealloc, _dealloc_ProcessDiskUsageReport },
        { Py_tp_methods, _methods_ProcessDiskUsageReport },
        { Py_tp_getset, _getset_ProcessDiskUsageReport },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProcessDiskUsageReport =
    {
        "_winrt_Windows_System_Diagnostics.ProcessDiskUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessDiskUsageReport
    };

    // ----- ProcessMemoryUsage class --------------------
    constexpr const char* const _type_name_ProcessMemoryUsage = "ProcessMemoryUsage";

    static PyObject* _new_ProcessMemoryUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProcessMemoryUsage);
        return nullptr;
    }

    static void _dealloc_ProcessMemoryUsage(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProcessMemoryUsage_GetReport(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ProcessMemoryUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessMemoryUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessMemoryUsage[] = {
        { "get_report", (PyCFunction)ProcessMemoryUsage_GetReport, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ProcessMemoryUsage, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ProcessMemoryUsage[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ProcessMemoryUsage[] = 
    {
        { Py_tp_new, _new_ProcessMemoryUsage },
        { Py_tp_dealloc, _dealloc_ProcessMemoryUsage },
        { Py_tp_methods, _methods_ProcessMemoryUsage },
        { Py_tp_getset, _getset_ProcessMemoryUsage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProcessMemoryUsage =
    {
        "_winrt_Windows_System_Diagnostics.ProcessMemoryUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessMemoryUsage
    };

    // ----- ProcessMemoryUsageReport class --------------------
    constexpr const char* const _type_name_ProcessMemoryUsageReport = "ProcessMemoryUsageReport";

    static PyObject* _new_ProcessMemoryUsageReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProcessMemoryUsageReport);
        return nullptr;
    }

    static void _dealloc_ProcessMemoryUsageReport(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProcessMemoryUsageReport_get_NonPagedPoolSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NonPagedPoolSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PageFaultCount(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PageFaultCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PageFileSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PageFileSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PagedPoolSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PagedPoolSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakNonPagedPoolSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PeakNonPagedPoolSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakPageFileSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PeakPageFileSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakPagedPoolSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PeakPagedPoolSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakVirtualMemorySizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PeakVirtualMemorySizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakWorkingSetSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PeakWorkingSetSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PrivatePageCount(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrivatePageCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_VirtualMemorySizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VirtualMemorySizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_WorkingSetSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WorkingSetSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProcessMemoryUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessMemoryUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessMemoryUsageReport[] = {
        { "_from", (PyCFunction)_from_ProcessMemoryUsageReport, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ProcessMemoryUsageReport[] = {
        { const_cast<char*>("non_paged_pool_size_in_bytes"), (getter)ProcessMemoryUsageReport_get_NonPagedPoolSizeInBytes, nullptr, nullptr, nullptr },
        { const_cast<char*>("page_fault_count"), (getter)ProcessMemoryUsageReport_get_PageFaultCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("page_file_size_in_bytes"), (getter)ProcessMemoryUsageReport_get_PageFileSizeInBytes, nullptr, nullptr, nullptr },
        { const_cast<char*>("paged_pool_size_in_bytes"), (getter)ProcessMemoryUsageReport_get_PagedPoolSizeInBytes, nullptr, nullptr, nullptr },
        { const_cast<char*>("peak_non_paged_pool_size_in_bytes"), (getter)ProcessMemoryUsageReport_get_PeakNonPagedPoolSizeInBytes, nullptr, nullptr, nullptr },
        { const_cast<char*>("peak_page_file_size_in_bytes"), (getter)ProcessMemoryUsageReport_get_PeakPageFileSizeInBytes, nullptr, nullptr, nullptr },
        { const_cast<char*>("peak_paged_pool_size_in_bytes"), (getter)ProcessMemoryUsageReport_get_PeakPagedPoolSizeInBytes, nullptr, nullptr, nullptr },
        { const_cast<char*>("peak_virtual_memory_size_in_bytes"), (getter)ProcessMemoryUsageReport_get_PeakVirtualMemorySizeInBytes, nullptr, nullptr, nullptr },
        { const_cast<char*>("peak_working_set_size_in_bytes"), (getter)ProcessMemoryUsageReport_get_PeakWorkingSetSizeInBytes, nullptr, nullptr, nullptr },
        { const_cast<char*>("private_page_count"), (getter)ProcessMemoryUsageReport_get_PrivatePageCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("virtual_memory_size_in_bytes"), (getter)ProcessMemoryUsageReport_get_VirtualMemorySizeInBytes, nullptr, nullptr, nullptr },
        { const_cast<char*>("working_set_size_in_bytes"), (getter)ProcessMemoryUsageReport_get_WorkingSetSizeInBytes, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ProcessMemoryUsageReport[] = 
    {
        { Py_tp_new, _new_ProcessMemoryUsageReport },
        { Py_tp_dealloc, _dealloc_ProcessMemoryUsageReport },
        { Py_tp_methods, _methods_ProcessMemoryUsageReport },
        { Py_tp_getset, _getset_ProcessMemoryUsageReport },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProcessMemoryUsageReport =
    {
        "_winrt_Windows_System_Diagnostics.ProcessMemoryUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessMemoryUsageReport
    };

    // ----- SystemCpuUsage class --------------------
    constexpr const char* const _type_name_SystemCpuUsage = "SystemCpuUsage";

    static PyObject* _new_SystemCpuUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemCpuUsage);
        return nullptr;
    }

    static void _dealloc_SystemCpuUsage(py::wrapper::Windows::System::Diagnostics::SystemCpuUsage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemCpuUsage_GetReport(py::wrapper::Windows::System::Diagnostics::SystemCpuUsage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_SystemCpuUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemCpuUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemCpuUsage[] = {
        { "get_report", (PyCFunction)SystemCpuUsage_GetReport, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_SystemCpuUsage, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemCpuUsage[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemCpuUsage[] = 
    {
        { Py_tp_new, _new_SystemCpuUsage },
        { Py_tp_dealloc, _dealloc_SystemCpuUsage },
        { Py_tp_methods, _methods_SystemCpuUsage },
        { Py_tp_getset, _getset_SystemCpuUsage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemCpuUsage =
    {
        "_winrt_Windows_System_Diagnostics.SystemCpuUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemCpuUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemCpuUsage
    };

    // ----- SystemCpuUsageReport class --------------------
    constexpr const char* const _type_name_SystemCpuUsageReport = "SystemCpuUsageReport";

    static PyObject* _new_SystemCpuUsageReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemCpuUsageReport);
        return nullptr;
    }

    static void _dealloc_SystemCpuUsageReport(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemCpuUsageReport_get_IdleTime(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IdleTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemCpuUsageReport_get_KernelTime(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KernelTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemCpuUsageReport_get_UserTime(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemCpuUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemCpuUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemCpuUsageReport[] = {
        { "_from", (PyCFunction)_from_SystemCpuUsageReport, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemCpuUsageReport[] = {
        { const_cast<char*>("idle_time"), (getter)SystemCpuUsageReport_get_IdleTime, nullptr, nullptr, nullptr },
        { const_cast<char*>("kernel_time"), (getter)SystemCpuUsageReport_get_KernelTime, nullptr, nullptr, nullptr },
        { const_cast<char*>("user_time"), (getter)SystemCpuUsageReport_get_UserTime, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemCpuUsageReport[] = 
    {
        { Py_tp_new, _new_SystemCpuUsageReport },
        { Py_tp_dealloc, _dealloc_SystemCpuUsageReport },
        { Py_tp_methods, _methods_SystemCpuUsageReport },
        { Py_tp_getset, _getset_SystemCpuUsageReport },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemCpuUsageReport =
    {
        "_winrt_Windows_System_Diagnostics.SystemCpuUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemCpuUsageReport
    };

    // ----- SystemDiagnosticInfo class --------------------
    constexpr const char* const _type_name_SystemDiagnosticInfo = "SystemDiagnosticInfo";

    static PyObject* _new_SystemDiagnosticInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemDiagnosticInfo);
        return nullptr;
    }

    static void _dealloc_SystemDiagnosticInfo(py::wrapper::Windows::System::Diagnostics::SystemDiagnosticInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemDiagnosticInfo_GetForCurrentSystem(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::System::Diagnostics::SystemDiagnosticInfo::GetForCurrentSystem());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemDiagnosticInfo_IsArchitectureSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::ProcessorArchitecture>(args, 0);

                return py::convert(winrt::Windows::System::Diagnostics::SystemDiagnosticInfo::IsArchitectureSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemDiagnosticInfo_get_CpuUsage(py::wrapper::Windows::System::Diagnostics::SystemDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CpuUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDiagnosticInfo_get_MemoryUsage(py::wrapper::Windows::System::Diagnostics::SystemDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MemoryUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDiagnosticInfo_get_PreferredArchitecture(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::System::Diagnostics::SystemDiagnosticInfo::PreferredArchitecture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemDiagnosticInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemDiagnosticInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemDiagnosticInfo[] = {
        { "get_for_current_system", (PyCFunction)SystemDiagnosticInfo_GetForCurrentSystem, METH_VARARGS | METH_STATIC, nullptr },
        { "is_architecture_supported", (PyCFunction)SystemDiagnosticInfo_IsArchitectureSupported, METH_VARARGS | METH_STATIC, nullptr },
        { "get_preferred_architecture", (PyCFunction)SystemDiagnosticInfo_get_PreferredArchitecture, METH_NOARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_SystemDiagnosticInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemDiagnosticInfo[] = {
        { const_cast<char*>("cpu_usage"), (getter)SystemDiagnosticInfo_get_CpuUsage, nullptr, nullptr, nullptr },
        { const_cast<char*>("memory_usage"), (getter)SystemDiagnosticInfo_get_MemoryUsage, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemDiagnosticInfo[] = 
    {
        { Py_tp_new, _new_SystemDiagnosticInfo },
        { Py_tp_dealloc, _dealloc_SystemDiagnosticInfo },
        { Py_tp_methods, _methods_SystemDiagnosticInfo },
        { Py_tp_getset, _getset_SystemDiagnosticInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemDiagnosticInfo =
    {
        "_winrt_Windows_System_Diagnostics.SystemDiagnosticInfo",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemDiagnosticInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemDiagnosticInfo
    };

    // ----- SystemMemoryUsage class --------------------
    constexpr const char* const _type_name_SystemMemoryUsage = "SystemMemoryUsage";

    static PyObject* _new_SystemMemoryUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemMemoryUsage);
        return nullptr;
    }

    static void _dealloc_SystemMemoryUsage(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemMemoryUsage_GetReport(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_SystemMemoryUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemMemoryUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMemoryUsage[] = {
        { "get_report", (PyCFunction)SystemMemoryUsage_GetReport, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_SystemMemoryUsage, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemMemoryUsage[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemMemoryUsage[] = 
    {
        { Py_tp_new, _new_SystemMemoryUsage },
        { Py_tp_dealloc, _dealloc_SystemMemoryUsage },
        { Py_tp_methods, _methods_SystemMemoryUsage },
        { Py_tp_getset, _getset_SystemMemoryUsage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemMemoryUsage =
    {
        "_winrt_Windows_System_Diagnostics.SystemMemoryUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMemoryUsage
    };

    // ----- SystemMemoryUsageReport class --------------------
    constexpr const char* const _type_name_SystemMemoryUsageReport = "SystemMemoryUsageReport";

    static PyObject* _new_SystemMemoryUsageReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemMemoryUsageReport);
        return nullptr;
    }

    static void _dealloc_SystemMemoryUsageReport(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemMemoryUsageReport_get_AvailableSizeInBytes(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AvailableSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMemoryUsageReport_get_CommittedSizeInBytes(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CommittedSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMemoryUsageReport_get_TotalPhysicalSizeInBytes(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalPhysicalSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemMemoryUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemMemoryUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMemoryUsageReport[] = {
        { "_from", (PyCFunction)_from_SystemMemoryUsageReport, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemMemoryUsageReport[] = {
        { const_cast<char*>("available_size_in_bytes"), (getter)SystemMemoryUsageReport_get_AvailableSizeInBytes, nullptr, nullptr, nullptr },
        { const_cast<char*>("committed_size_in_bytes"), (getter)SystemMemoryUsageReport_get_CommittedSizeInBytes, nullptr, nullptr, nullptr },
        { const_cast<char*>("total_physical_size_in_bytes"), (getter)SystemMemoryUsageReport_get_TotalPhysicalSizeInBytes, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemMemoryUsageReport[] = 
    {
        { Py_tp_new, _new_SystemMemoryUsageReport },
        { Py_tp_dealloc, _dealloc_SystemMemoryUsageReport },
        { Py_tp_methods, _methods_SystemMemoryUsageReport },
        { Py_tp_getset, _getset_SystemMemoryUsageReport },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemMemoryUsageReport =
    {
        "_winrt_Windows_System_Diagnostics.SystemMemoryUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMemoryUsageReport
    };

    // ----- Windows.System.Diagnostics Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::System::Diagnostics::DiagnosticActionResult>::python_type = py::register_python_type(module, _type_name_DiagnosticActionResult, &_type_spec_DiagnosticActionResult, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::DiagnosticInvoker>::python_type = py::register_python_type(module, _type_name_DiagnosticInvoker, &_type_spec_DiagnosticInvoker, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::ProcessCpuUsage>::python_type = py::register_python_type(module, _type_name_ProcessCpuUsage, &_type_spec_ProcessCpuUsage, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::ProcessCpuUsageReport>::python_type = py::register_python_type(module, _type_name_ProcessCpuUsageReport, &_type_spec_ProcessCpuUsageReport, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo>::python_type = py::register_python_type(module, _type_name_ProcessDiagnosticInfo, &_type_spec_ProcessDiagnosticInfo, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::ProcessDiskUsage>::python_type = py::register_python_type(module, _type_name_ProcessDiskUsage, &_type_spec_ProcessDiskUsage, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::ProcessDiskUsageReport>::python_type = py::register_python_type(module, _type_name_ProcessDiskUsageReport, &_type_spec_ProcessDiskUsageReport, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::ProcessMemoryUsage>::python_type = py::register_python_type(module, _type_name_ProcessMemoryUsage, &_type_spec_ProcessMemoryUsage, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::ProcessMemoryUsageReport>::python_type = py::register_python_type(module, _type_name_ProcessMemoryUsageReport, &_type_spec_ProcessMemoryUsageReport, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::SystemCpuUsage>::python_type = py::register_python_type(module, _type_name_SystemCpuUsage, &_type_spec_SystemCpuUsage, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::SystemCpuUsageReport>::python_type = py::register_python_type(module, _type_name_SystemCpuUsageReport, &_type_spec_SystemCpuUsageReport, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::SystemDiagnosticInfo>::python_type = py::register_python_type(module, _type_name_SystemDiagnosticInfo, &_type_spec_SystemDiagnosticInfo, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::SystemMemoryUsage>::python_type = py::register_python_type(module, _type_name_SystemMemoryUsage, &_type_spec_SystemMemoryUsage, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::SystemMemoryUsageReport>::python_type = py::register_python_type(module, _type_name_SystemMemoryUsageReport, &_type_spec_SystemMemoryUsageReport, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.System.Diagnostics");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_System_Diagnostics",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::System::Diagnostics

PyMODINIT_FUNC
PyInit__winrt_Windows_System_Diagnostics (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::System::Diagnostics::module_def);
}
