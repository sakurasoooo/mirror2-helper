// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Foundation.Numerics.h"

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Numerics::float3x2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Numerics::float4x4>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Numerics::plane>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Numerics::quaternion>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Numerics::Rational>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Numerics::float2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Numerics::float3>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Numerics::float4>::python_type;

PyObject* py::converter<winrt::Windows::Foundation::Numerics::float3x2>::convert(winrt::Windows::Foundation::Numerics::float3x2 instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Foundation::Numerics::float3x2>());
}
winrt::Windows::Foundation::Numerics::float3x2 py::converter<winrt::Windows::Foundation::Numerics::float3x2>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Numerics::float3x2>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3x2>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Foundation::Numerics::float3x2 return_value{};

    PyObject* py_M11 = PyDict_GetItemString(obj, "m11");
    if (!py_M11) { throw winrt::hresult_invalid_argument(); }
    return_value.m11 = converter<float>::convert_to(py_M11);

    PyObject* py_M12 = PyDict_GetItemString(obj, "m12");
    if (!py_M12) { throw winrt::hresult_invalid_argument(); }
    return_value.m12 = converter<float>::convert_to(py_M12);

    PyObject* py_M21 = PyDict_GetItemString(obj, "m21");
    if (!py_M21) { throw winrt::hresult_invalid_argument(); }
    return_value.m21 = converter<float>::convert_to(py_M21);

    PyObject* py_M22 = PyDict_GetItemString(obj, "m22");
    if (!py_M22) { throw winrt::hresult_invalid_argument(); }
    return_value.m22 = converter<float>::convert_to(py_M22);

    PyObject* py_M31 = PyDict_GetItemString(obj, "m31");
    if (!py_M31) { throw winrt::hresult_invalid_argument(); }
    return_value.m31 = converter<float>::convert_to(py_M31);

    PyObject* py_M32 = PyDict_GetItemString(obj, "m32");
    if (!py_M32) { throw winrt::hresult_invalid_argument(); }
    return_value.m32 = converter<float>::convert_to(py_M32);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Foundation::Numerics::float4x4>::convert(winrt::Windows::Foundation::Numerics::float4x4 instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Foundation::Numerics::float4x4>());
}
winrt::Windows::Foundation::Numerics::float4x4 py::converter<winrt::Windows::Foundation::Numerics::float4x4>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Numerics::float4x4>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4x4>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Foundation::Numerics::float4x4 return_value{};

    PyObject* py_M11 = PyDict_GetItemString(obj, "m11");
    if (!py_M11) { throw winrt::hresult_invalid_argument(); }
    return_value.m11 = converter<float>::convert_to(py_M11);

    PyObject* py_M12 = PyDict_GetItemString(obj, "m12");
    if (!py_M12) { throw winrt::hresult_invalid_argument(); }
    return_value.m12 = converter<float>::convert_to(py_M12);

    PyObject* py_M13 = PyDict_GetItemString(obj, "m13");
    if (!py_M13) { throw winrt::hresult_invalid_argument(); }
    return_value.m13 = converter<float>::convert_to(py_M13);

    PyObject* py_M14 = PyDict_GetItemString(obj, "m14");
    if (!py_M14) { throw winrt::hresult_invalid_argument(); }
    return_value.m14 = converter<float>::convert_to(py_M14);

    PyObject* py_M21 = PyDict_GetItemString(obj, "m21");
    if (!py_M21) { throw winrt::hresult_invalid_argument(); }
    return_value.m21 = converter<float>::convert_to(py_M21);

    PyObject* py_M22 = PyDict_GetItemString(obj, "m22");
    if (!py_M22) { throw winrt::hresult_invalid_argument(); }
    return_value.m22 = converter<float>::convert_to(py_M22);

    PyObject* py_M23 = PyDict_GetItemString(obj, "m23");
    if (!py_M23) { throw winrt::hresult_invalid_argument(); }
    return_value.m23 = converter<float>::convert_to(py_M23);

    PyObject* py_M24 = PyDict_GetItemString(obj, "m24");
    if (!py_M24) { throw winrt::hresult_invalid_argument(); }
    return_value.m24 = converter<float>::convert_to(py_M24);

    PyObject* py_M31 = PyDict_GetItemString(obj, "m31");
    if (!py_M31) { throw winrt::hresult_invalid_argument(); }
    return_value.m31 = converter<float>::convert_to(py_M31);

    PyObject* py_M32 = PyDict_GetItemString(obj, "m32");
    if (!py_M32) { throw winrt::hresult_invalid_argument(); }
    return_value.m32 = converter<float>::convert_to(py_M32);

    PyObject* py_M33 = PyDict_GetItemString(obj, "m33");
    if (!py_M33) { throw winrt::hresult_invalid_argument(); }
    return_value.m33 = converter<float>::convert_to(py_M33);

    PyObject* py_M34 = PyDict_GetItemString(obj, "m34");
    if (!py_M34) { throw winrt::hresult_invalid_argument(); }
    return_value.m34 = converter<float>::convert_to(py_M34);

    PyObject* py_M41 = PyDict_GetItemString(obj, "m41");
    if (!py_M41) { throw winrt::hresult_invalid_argument(); }
    return_value.m41 = converter<float>::convert_to(py_M41);

    PyObject* py_M42 = PyDict_GetItemString(obj, "m42");
    if (!py_M42) { throw winrt::hresult_invalid_argument(); }
    return_value.m42 = converter<float>::convert_to(py_M42);

    PyObject* py_M43 = PyDict_GetItemString(obj, "m43");
    if (!py_M43) { throw winrt::hresult_invalid_argument(); }
    return_value.m43 = converter<float>::convert_to(py_M43);

    PyObject* py_M44 = PyDict_GetItemString(obj, "m44");
    if (!py_M44) { throw winrt::hresult_invalid_argument(); }
    return_value.m44 = converter<float>::convert_to(py_M44);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Foundation::Numerics::plane>::convert(winrt::Windows::Foundation::Numerics::plane instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Foundation::Numerics::plane>());
}
winrt::Windows::Foundation::Numerics::plane py::converter<winrt::Windows::Foundation::Numerics::plane>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Numerics::plane>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::plane>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Foundation::Numerics::plane return_value{};

    PyObject* py_Normal = PyDict_GetItemString(obj, "normal");
    if (!py_Normal) { throw winrt::hresult_invalid_argument(); }
    return_value.normal = converter<winrt::Windows::Foundation::Numerics::float3>::convert_to(py_Normal);

    PyObject* py_D = PyDict_GetItemString(obj, "d");
    if (!py_D) { throw winrt::hresult_invalid_argument(); }
    return_value.d = converter<float>::convert_to(py_D);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Foundation::Numerics::quaternion>::convert(winrt::Windows::Foundation::Numerics::quaternion instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Foundation::Numerics::quaternion>());
}
winrt::Windows::Foundation::Numerics::quaternion py::converter<winrt::Windows::Foundation::Numerics::quaternion>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Numerics::quaternion>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::quaternion>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Foundation::Numerics::quaternion return_value{};

    PyObject* py_X = PyDict_GetItemString(obj, "x");
    if (!py_X) { throw winrt::hresult_invalid_argument(); }
    return_value.x = converter<float>::convert_to(py_X);

    PyObject* py_Y = PyDict_GetItemString(obj, "y");
    if (!py_Y) { throw winrt::hresult_invalid_argument(); }
    return_value.y = converter<float>::convert_to(py_Y);

    PyObject* py_Z = PyDict_GetItemString(obj, "z");
    if (!py_Z) { throw winrt::hresult_invalid_argument(); }
    return_value.z = converter<float>::convert_to(py_Z);

    PyObject* py_W = PyDict_GetItemString(obj, "w");
    if (!py_W) { throw winrt::hresult_invalid_argument(); }
    return_value.w = converter<float>::convert_to(py_W);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Foundation::Numerics::Rational>::convert(winrt::Windows::Foundation::Numerics::Rational instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Foundation::Numerics::Rational>());
}
winrt::Windows::Foundation::Numerics::Rational py::converter<winrt::Windows::Foundation::Numerics::Rational>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Numerics::Rational>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::Rational>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Foundation::Numerics::Rational return_value{};

    PyObject* py_Numerator = PyDict_GetItemString(obj, "numerator");
    if (!py_Numerator) { throw winrt::hresult_invalid_argument(); }
    return_value.Numerator = converter<uint32_t>::convert_to(py_Numerator);

    PyObject* py_Denominator = PyDict_GetItemString(obj, "denominator");
    if (!py_Denominator) { throw winrt::hresult_invalid_argument(); }
    return_value.Denominator = converter<uint32_t>::convert_to(py_Denominator);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Foundation::Numerics::float2>::convert(winrt::Windows::Foundation::Numerics::float2 instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Foundation::Numerics::float2>());
}
winrt::Windows::Foundation::Numerics::float2 py::converter<winrt::Windows::Foundation::Numerics::float2>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Numerics::float2>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float2>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Foundation::Numerics::float2 return_value{};

    PyObject* py_X = PyDict_GetItemString(obj, "x");
    if (!py_X) { throw winrt::hresult_invalid_argument(); }
    return_value.x = converter<float>::convert_to(py_X);

    PyObject* py_Y = PyDict_GetItemString(obj, "y");
    if (!py_Y) { throw winrt::hresult_invalid_argument(); }
    return_value.y = converter<float>::convert_to(py_Y);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Foundation::Numerics::float3>::convert(winrt::Windows::Foundation::Numerics::float3 instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Foundation::Numerics::float3>());
}
winrt::Windows::Foundation::Numerics::float3 py::converter<winrt::Windows::Foundation::Numerics::float3>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Numerics::float3>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float3>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Foundation::Numerics::float3 return_value{};

    PyObject* py_X = PyDict_GetItemString(obj, "x");
    if (!py_X) { throw winrt::hresult_invalid_argument(); }
    return_value.x = converter<float>::convert_to(py_X);

    PyObject* py_Y = PyDict_GetItemString(obj, "y");
    if (!py_Y) { throw winrt::hresult_invalid_argument(); }
    return_value.y = converter<float>::convert_to(py_Y);

    PyObject* py_Z = PyDict_GetItemString(obj, "z");
    if (!py_Z) { throw winrt::hresult_invalid_argument(); }
    return_value.z = converter<float>::convert_to(py_Z);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Foundation::Numerics::float4>::convert(winrt::Windows::Foundation::Numerics::float4 instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Foundation::Numerics::float4>());
}
winrt::Windows::Foundation::Numerics::float4 py::converter<winrt::Windows::Foundation::Numerics::float4>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Foundation::Numerics::float4>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Foundation::Numerics::float4>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Foundation::Numerics::float4 return_value{};

    PyObject* py_X = PyDict_GetItemString(obj, "x");
    if (!py_X) { throw winrt::hresult_invalid_argument(); }
    return_value.x = converter<float>::convert_to(py_X);

    PyObject* py_Y = PyDict_GetItemString(obj, "y");
    if (!py_Y) { throw winrt::hresult_invalid_argument(); }
    return_value.y = converter<float>::convert_to(py_Y);

    PyObject* py_Z = PyDict_GetItemString(obj, "z");
    if (!py_Z) { throw winrt::hresult_invalid_argument(); }
    return_value.z = converter<float>::convert_to(py_Z);

    PyObject* py_W = PyDict_GetItemString(obj, "w");
    if (!py_W) { throw winrt::hresult_invalid_argument(); }
    return_value.w = converter<float>::convert_to(py_W);

    return return_value;
}

namespace py::cpp::Windows::Foundation::Numerics
{
    // ----- Matrix3x2 struct --------------------
    constexpr const char* const _type_name_Matrix3x2 = "Matrix3x2";

    PyObject* _new_Matrix3x2(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Foundation::Numerics::float3x2 return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        float _M11{};
        float _M12{};
        float _M21{};
        float _M22{};
        float _M31{};
        float _M32{};

        static const char* kwlist[] = {"m11", "m12", "m21", "m22", "m31", "m32", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ffffff", const_cast<char**>(kwlist), &_M11, &_M12, &_M21, &_M22, &_M31, &_M32))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Foundation::Numerics::float3x2 return_value{ _M11, _M12, _M21, _M22, _M31, _M32 };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Matrix3x2(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self)
    {
    }

    static PyObject* Matrix3x2_get_M11(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m11);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix3x2_set_M11(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m11 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix3x2_get_M12(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m12);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix3x2_set_M12(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m12 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix3x2_get_M21(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m21);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix3x2_set_M21(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m21 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix3x2_get_M22(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m22);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix3x2_set_M22(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m22 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix3x2_get_M31(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m31);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix3x2_set_M31(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m31 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix3x2_get_M32(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m32);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix3x2_set_M32(py::wrapper::Windows::Foundation::Numerics::Matrix3x2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m32 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Matrix3x2[] = {
        { const_cast<char*>("m11"), (getter)Matrix3x2_get_M11, (setter)Matrix3x2_set_M11, nullptr, nullptr },
        { const_cast<char*>("m12"), (getter)Matrix3x2_get_M12, (setter)Matrix3x2_set_M12, nullptr, nullptr },
        { const_cast<char*>("m21"), (getter)Matrix3x2_get_M21, (setter)Matrix3x2_set_M21, nullptr, nullptr },
        { const_cast<char*>("m22"), (getter)Matrix3x2_get_M22, (setter)Matrix3x2_set_M22, nullptr, nullptr },
        { const_cast<char*>("m31"), (getter)Matrix3x2_get_M31, (setter)Matrix3x2_set_M31, nullptr, nullptr },
        { const_cast<char*>("m32"), (getter)Matrix3x2_get_M32, (setter)Matrix3x2_set_M32, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Matrix3x2[] = 
    {
        { Py_tp_new, _new_Matrix3x2 },
        { Py_tp_dealloc, _dealloc_Matrix3x2 },
        { Py_tp_getset, _getset_Matrix3x2 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Matrix3x2 =
    {
        "_winrt_Windows_Foundation_Numerics.Matrix3x2",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Matrix3x2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Matrix3x2
    };

    // ----- Matrix4x4 struct --------------------
    constexpr const char* const _type_name_Matrix4x4 = "Matrix4x4";

    PyObject* _new_Matrix4x4(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Foundation::Numerics::float4x4 return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        float _M11{};
        float _M12{};
        float _M13{};
        float _M14{};
        float _M21{};
        float _M22{};
        float _M23{};
        float _M24{};
        float _M31{};
        float _M32{};
        float _M33{};
        float _M34{};
        float _M41{};
        float _M42{};
        float _M43{};
        float _M44{};

        static const char* kwlist[] = {"m11", "m12", "m13", "m14", "m21", "m22", "m23", "m24", "m31", "m32", "m33", "m34", "m41", "m42", "m43", "m44", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ffffffffffffffff", const_cast<char**>(kwlist), &_M11, &_M12, &_M13, &_M14, &_M21, &_M22, &_M23, &_M24, &_M31, &_M32, &_M33, &_M34, &_M41, &_M42, &_M43, &_M44))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Foundation::Numerics::float4x4 return_value{ _M11, _M12, _M13, _M14, _M21, _M22, _M23, _M24, _M31, _M32, _M33, _M34, _M41, _M42, _M43, _M44 };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Matrix4x4(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self)
    {
    }

    static PyObject* Matrix4x4_get_M11(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m11);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M11(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m11 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M12(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m12);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M12(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m12 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M13(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m13);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M13(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m13 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M14(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m14);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M14(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m14 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M21(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m21);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M21(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m21 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M22(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m22);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M22(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m22 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M23(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m23);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M23(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m23 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M24(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m24);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M24(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m24 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M31(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m31);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M31(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m31 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M32(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m32);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M32(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m32 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M33(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m33);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M33(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m33 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M34(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m34);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M34(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m34 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M41(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m41);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M41(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m41 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M42(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m42);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M42(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m42 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M43(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m43);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M43(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m43 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix4x4_get_M44(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.m44);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix4x4_set_M44(py::wrapper::Windows::Foundation::Numerics::Matrix4x4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.m44 = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Matrix4x4[] = {
        { const_cast<char*>("m11"), (getter)Matrix4x4_get_M11, (setter)Matrix4x4_set_M11, nullptr, nullptr },
        { const_cast<char*>("m12"), (getter)Matrix4x4_get_M12, (setter)Matrix4x4_set_M12, nullptr, nullptr },
        { const_cast<char*>("m13"), (getter)Matrix4x4_get_M13, (setter)Matrix4x4_set_M13, nullptr, nullptr },
        { const_cast<char*>("m14"), (getter)Matrix4x4_get_M14, (setter)Matrix4x4_set_M14, nullptr, nullptr },
        { const_cast<char*>("m21"), (getter)Matrix4x4_get_M21, (setter)Matrix4x4_set_M21, nullptr, nullptr },
        { const_cast<char*>("m22"), (getter)Matrix4x4_get_M22, (setter)Matrix4x4_set_M22, nullptr, nullptr },
        { const_cast<char*>("m23"), (getter)Matrix4x4_get_M23, (setter)Matrix4x4_set_M23, nullptr, nullptr },
        { const_cast<char*>("m24"), (getter)Matrix4x4_get_M24, (setter)Matrix4x4_set_M24, nullptr, nullptr },
        { const_cast<char*>("m31"), (getter)Matrix4x4_get_M31, (setter)Matrix4x4_set_M31, nullptr, nullptr },
        { const_cast<char*>("m32"), (getter)Matrix4x4_get_M32, (setter)Matrix4x4_set_M32, nullptr, nullptr },
        { const_cast<char*>("m33"), (getter)Matrix4x4_get_M33, (setter)Matrix4x4_set_M33, nullptr, nullptr },
        { const_cast<char*>("m34"), (getter)Matrix4x4_get_M34, (setter)Matrix4x4_set_M34, nullptr, nullptr },
        { const_cast<char*>("m41"), (getter)Matrix4x4_get_M41, (setter)Matrix4x4_set_M41, nullptr, nullptr },
        { const_cast<char*>("m42"), (getter)Matrix4x4_get_M42, (setter)Matrix4x4_set_M42, nullptr, nullptr },
        { const_cast<char*>("m43"), (getter)Matrix4x4_get_M43, (setter)Matrix4x4_set_M43, nullptr, nullptr },
        { const_cast<char*>("m44"), (getter)Matrix4x4_get_M44, (setter)Matrix4x4_set_M44, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Matrix4x4[] = 
    {
        { Py_tp_new, _new_Matrix4x4 },
        { Py_tp_dealloc, _dealloc_Matrix4x4 },
        { Py_tp_getset, _getset_Matrix4x4 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Matrix4x4 =
    {
        "_winrt_Windows_Foundation_Numerics.Matrix4x4",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Matrix4x4),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Matrix4x4
    };

    // ----- Plane struct --------------------
    constexpr const char* const _type_name_Plane = "Plane";

    PyObject* _new_Plane(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Foundation::Numerics::plane return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Foundation::Numerics::plane>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        PyObject* _Normal{};
        float _D{};

        static const char* kwlist[] = {"normal", "d", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "Of", const_cast<char**>(kwlist), &_Normal, &_D))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Foundation::Numerics::plane return_value{ py::converter<winrt::Windows::Foundation::Numerics::float3>::convert_to(_Normal), _D };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Plane(py::wrapper::Windows::Foundation::Numerics::Plane* self)
    {
    }

    static PyObject* Plane_get_Normal(py::wrapper::Windows::Foundation::Numerics::Plane* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.normal);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Plane_set_Normal(py::wrapper::Windows::Foundation::Numerics::Plane* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.normal = py::converter<winrt::Windows::Foundation::Numerics::float3>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Plane_get_D(py::wrapper::Windows::Foundation::Numerics::Plane* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.d);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Plane_set_D(py::wrapper::Windows::Foundation::Numerics::Plane* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.d = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Plane[] = {
        { const_cast<char*>("normal"), (getter)Plane_get_Normal, (setter)Plane_set_Normal, nullptr, nullptr },
        { const_cast<char*>("d"), (getter)Plane_get_D, (setter)Plane_set_D, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Plane[] = 
    {
        { Py_tp_new, _new_Plane },
        { Py_tp_dealloc, _dealloc_Plane },
        { Py_tp_getset, _getset_Plane },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Plane =
    {
        "_winrt_Windows_Foundation_Numerics.Plane",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Plane),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Plane
    };

    // ----- Quaternion struct --------------------
    constexpr const char* const _type_name_Quaternion = "Quaternion";

    PyObject* _new_Quaternion(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Foundation::Numerics::quaternion return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        float _X{};
        float _Y{};
        float _Z{};
        float _W{};

        static const char* kwlist[] = {"x", "y", "z", "w", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ffff", const_cast<char**>(kwlist), &_X, &_Y, &_Z, &_W))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Foundation::Numerics::quaternion return_value{ _X, _Y, _Z, _W };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Quaternion(py::wrapper::Windows::Foundation::Numerics::Quaternion* self)
    {
    }

    static PyObject* Quaternion_get_X(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.x);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Quaternion_set_X(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.x = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Quaternion_get_Y(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Quaternion_set_Y(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.y = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Quaternion_get_Z(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.z);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Quaternion_set_Z(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.z = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Quaternion_get_W(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.w);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Quaternion_set_W(py::wrapper::Windows::Foundation::Numerics::Quaternion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.w = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Quaternion[] = {
        { const_cast<char*>("x"), (getter)Quaternion_get_X, (setter)Quaternion_set_X, nullptr, nullptr },
        { const_cast<char*>("y"), (getter)Quaternion_get_Y, (setter)Quaternion_set_Y, nullptr, nullptr },
        { const_cast<char*>("z"), (getter)Quaternion_get_Z, (setter)Quaternion_set_Z, nullptr, nullptr },
        { const_cast<char*>("w"), (getter)Quaternion_get_W, (setter)Quaternion_set_W, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Quaternion[] = 
    {
        { Py_tp_new, _new_Quaternion },
        { Py_tp_dealloc, _dealloc_Quaternion },
        { Py_tp_getset, _getset_Quaternion },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Quaternion =
    {
        "_winrt_Windows_Foundation_Numerics.Quaternion",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Quaternion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Quaternion
    };

    // ----- Rational struct --------------------
    constexpr const char* const _type_name_Rational = "Rational";

    PyObject* _new_Rational(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Foundation::Numerics::Rational return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Foundation::Numerics::Rational>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint32_t _Numerator{};
        uint32_t _Denominator{};

        static const char* kwlist[] = {"numerator", "denominator", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "II", const_cast<char**>(kwlist), &_Numerator, &_Denominator))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Foundation::Numerics::Rational return_value{ _Numerator, _Denominator };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Rational(py::wrapper::Windows::Foundation::Numerics::Rational* self)
    {
    }

    static PyObject* Rational_get_Numerator(py::wrapper::Windows::Foundation::Numerics::Rational* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Numerator);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Rational_set_Numerator(py::wrapper::Windows::Foundation::Numerics::Rational* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Numerator = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Rational_get_Denominator(py::wrapper::Windows::Foundation::Numerics::Rational* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Denominator);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Rational_set_Denominator(py::wrapper::Windows::Foundation::Numerics::Rational* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Denominator = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Rational[] = {
        { const_cast<char*>("numerator"), (getter)Rational_get_Numerator, (setter)Rational_set_Numerator, nullptr, nullptr },
        { const_cast<char*>("denominator"), (getter)Rational_get_Denominator, (setter)Rational_set_Denominator, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Rational[] = 
    {
        { Py_tp_new, _new_Rational },
        { Py_tp_dealloc, _dealloc_Rational },
        { Py_tp_getset, _getset_Rational },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Rational =
    {
        "_winrt_Windows_Foundation_Numerics.Rational",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Rational),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Rational
    };

    // ----- Vector2 struct --------------------
    constexpr const char* const _type_name_Vector2 = "Vector2";

    PyObject* _new_Vector2(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Foundation::Numerics::float2 return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        float _X{};
        float _Y{};

        static const char* kwlist[] = {"x", "y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ff", const_cast<char**>(kwlist), &_X, &_Y))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Foundation::Numerics::float2 return_value{ _X, _Y };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Vector2(py::wrapper::Windows::Foundation::Numerics::Vector2* self)
    {
    }

    static PyObject* Vector2_get_X(py::wrapper::Windows::Foundation::Numerics::Vector2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.x);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector2_set_X(py::wrapper::Windows::Foundation::Numerics::Vector2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.x = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Vector2_get_Y(py::wrapper::Windows::Foundation::Numerics::Vector2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector2_set_Y(py::wrapper::Windows::Foundation::Numerics::Vector2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.y = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Vector2[] = {
        { const_cast<char*>("x"), (getter)Vector2_get_X, (setter)Vector2_set_X, nullptr, nullptr },
        { const_cast<char*>("y"), (getter)Vector2_get_Y, (setter)Vector2_set_Y, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Vector2[] = 
    {
        { Py_tp_new, _new_Vector2 },
        { Py_tp_dealloc, _dealloc_Vector2 },
        { Py_tp_getset, _getset_Vector2 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Vector2 =
    {
        "_winrt_Windows_Foundation_Numerics.Vector2",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Vector2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Vector2
    };

    // ----- Vector3 struct --------------------
    constexpr const char* const _type_name_Vector3 = "Vector3";

    PyObject* _new_Vector3(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Foundation::Numerics::float3 return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        float _X{};
        float _Y{};
        float _Z{};

        static const char* kwlist[] = {"x", "y", "z", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "fff", const_cast<char**>(kwlist), &_X, &_Y, &_Z))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Foundation::Numerics::float3 return_value{ _X, _Y, _Z };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Vector3(py::wrapper::Windows::Foundation::Numerics::Vector3* self)
    {
    }

    static PyObject* Vector3_get_X(py::wrapper::Windows::Foundation::Numerics::Vector3* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.x);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector3_set_X(py::wrapper::Windows::Foundation::Numerics::Vector3* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.x = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Vector3_get_Y(py::wrapper::Windows::Foundation::Numerics::Vector3* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector3_set_Y(py::wrapper::Windows::Foundation::Numerics::Vector3* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.y = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Vector3_get_Z(py::wrapper::Windows::Foundation::Numerics::Vector3* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.z);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector3_set_Z(py::wrapper::Windows::Foundation::Numerics::Vector3* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.z = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Vector3[] = {
        { const_cast<char*>("x"), (getter)Vector3_get_X, (setter)Vector3_set_X, nullptr, nullptr },
        { const_cast<char*>("y"), (getter)Vector3_get_Y, (setter)Vector3_set_Y, nullptr, nullptr },
        { const_cast<char*>("z"), (getter)Vector3_get_Z, (setter)Vector3_set_Z, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Vector3[] = 
    {
        { Py_tp_new, _new_Vector3 },
        { Py_tp_dealloc, _dealloc_Vector3 },
        { Py_tp_getset, _getset_Vector3 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Vector3 =
    {
        "_winrt_Windows_Foundation_Numerics.Vector3",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Vector3),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Vector3
    };

    // ----- Vector4 struct --------------------
    constexpr const char* const _type_name_Vector4 = "Vector4";

    PyObject* _new_Vector4(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Foundation::Numerics::float4 return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        float _X{};
        float _Y{};
        float _Z{};
        float _W{};

        static const char* kwlist[] = {"x", "y", "z", "w", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ffff", const_cast<char**>(kwlist), &_X, &_Y, &_Z, &_W))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Foundation::Numerics::float4 return_value{ _X, _Y, _Z, _W };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Vector4(py::wrapper::Windows::Foundation::Numerics::Vector4* self)
    {
    }

    static PyObject* Vector4_get_X(py::wrapper::Windows::Foundation::Numerics::Vector4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.x);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector4_set_X(py::wrapper::Windows::Foundation::Numerics::Vector4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.x = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Vector4_get_Y(py::wrapper::Windows::Foundation::Numerics::Vector4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector4_set_Y(py::wrapper::Windows::Foundation::Numerics::Vector4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.y = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Vector4_get_Z(py::wrapper::Windows::Foundation::Numerics::Vector4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.z);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector4_set_Z(py::wrapper::Windows::Foundation::Numerics::Vector4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.z = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Vector4_get_W(py::wrapper::Windows::Foundation::Numerics::Vector4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.w);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Vector4_set_W(py::wrapper::Windows::Foundation::Numerics::Vector4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.w = py::converter<float>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Vector4[] = {
        { const_cast<char*>("x"), (getter)Vector4_get_X, (setter)Vector4_set_X, nullptr, nullptr },
        { const_cast<char*>("y"), (getter)Vector4_get_Y, (setter)Vector4_set_Y, nullptr, nullptr },
        { const_cast<char*>("z"), (getter)Vector4_get_Z, (setter)Vector4_set_Z, nullptr, nullptr },
        { const_cast<char*>("w"), (getter)Vector4_get_W, (setter)Vector4_set_W, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_Vector4[] = 
    {
        { Py_tp_new, _new_Vector4 },
        { Py_tp_dealloc, _dealloc_Vector4 },
        { Py_tp_getset, _getset_Vector4 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Vector4 =
    {
        "_winrt_Windows_Foundation_Numerics.Vector4",
        sizeof(py::wrapper::Windows::Foundation::Numerics::Vector4),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Vector4
    };

    // ----- Windows.Foundation.Numerics Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Foundation::Numerics::float3x2>::python_type = py::register_python_type(module, _type_name_Matrix3x2, &_type_spec_Matrix3x2, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Numerics::float4x4>::python_type = py::register_python_type(module, _type_name_Matrix4x4, &_type_spec_Matrix4x4, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Numerics::plane>::python_type = py::register_python_type(module, _type_name_Plane, &_type_spec_Plane, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Numerics::quaternion>::python_type = py::register_python_type(module, _type_name_Quaternion, &_type_spec_Quaternion, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Numerics::Rational>::python_type = py::register_python_type(module, _type_name_Rational, &_type_spec_Rational, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Numerics::float2>::python_type = py::register_python_type(module, _type_name_Vector2, &_type_spec_Vector2, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Numerics::float3>::python_type = py::register_python_type(module, _type_name_Vector3, &_type_spec_Vector3, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Numerics::float4>::python_type = py::register_python_type(module, _type_name_Vector4, &_type_spec_Vector4, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Foundation.Numerics");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Foundation_Numerics",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Foundation::Numerics

PyMODINIT_FUNC
PyInit__winrt_Windows_Foundation_Numerics (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Foundation::Numerics::module_def);
}
