// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Devices.Usb.h"

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbBulkInEndpointDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbBulkInPipe>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbBulkOutPipe>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbConfigurationDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbControlRequestType>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbDevice>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbDeviceClass>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbDeviceClasses>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbDeviceDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbEndpointDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterface>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterfaceDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterfaceSetting>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptInEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptInPipe>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptOutPipe>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbSetupPacket>::python_type;

namespace py::cpp::Windows::Devices::Usb
{
    // ----- UsbBulkInEndpointDescriptor class --------------------
    constexpr const char* const _type_name_UsbBulkInEndpointDescriptor = "UsbBulkInEndpointDescriptor";

    static PyObject* _new_UsbBulkInEndpointDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbBulkInEndpointDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbBulkInEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbBulkInEndpointDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbBulkInEndpointDescriptor_get_EndpointNumber(py::wrapper::Windows::Devices::Usb::UsbBulkInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndpointNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkInEndpointDescriptor_get_MaxPacketSize(py::wrapper::Windows::Devices::Usb::UsbBulkInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPacketSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkInEndpointDescriptor_get_Pipe(py::wrapper::Windows::Devices::Usb::UsbBulkInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pipe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbBulkInEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbBulkInEndpointDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbBulkInEndpointDescriptor[] = {
        { "_from", (PyCFunction)_from_UsbBulkInEndpointDescriptor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbBulkInEndpointDescriptor[] = {
        { const_cast<char*>("endpoint_number"), (getter)UsbBulkInEndpointDescriptor_get_EndpointNumber, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_packet_size"), (getter)UsbBulkInEndpointDescriptor_get_MaxPacketSize, nullptr, nullptr, nullptr },
        { const_cast<char*>("pipe"), (getter)UsbBulkInEndpointDescriptor_get_Pipe, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbBulkInEndpointDescriptor[] = 
    {
        { Py_tp_new, _new_UsbBulkInEndpointDescriptor },
        { Py_tp_dealloc, _dealloc_UsbBulkInEndpointDescriptor },
        { Py_tp_methods, _methods_UsbBulkInEndpointDescriptor },
        { Py_tp_getset, _getset_UsbBulkInEndpointDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbBulkInEndpointDescriptor =
    {
        "_winrt_Windows_Devices_Usb.UsbBulkInEndpointDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbBulkInEndpointDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbBulkInEndpointDescriptor
    };

    // ----- UsbBulkInPipe class --------------------
    constexpr const char* const _type_name_UsbBulkInPipe = "UsbBulkInPipe";

    static PyObject* _new_UsbBulkInPipe(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbBulkInPipe);
        return nullptr;
    }

    static void _dealloc_UsbBulkInPipe(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbBulkInPipe_ClearStallAsync(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClearStallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbBulkInPipe_FlushBuffer(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.FlushBuffer();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbBulkInPipe_get_ReadOptions(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReadOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbBulkInPipe_put_ReadOptions(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbReadOptions>(arg);

            self->obj.ReadOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbBulkInPipe_get_EndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkInPipe_get_InputStream(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkInPipe_get_MaxTransferSizeBytes(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxTransferSizeBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbBulkInPipe(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbBulkInPipe>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbBulkInPipe[] = {
        { "clear_stall_async", (PyCFunction)UsbBulkInPipe_ClearStallAsync, METH_VARARGS, nullptr },
        { "flush_buffer", (PyCFunction)UsbBulkInPipe_FlushBuffer, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_UsbBulkInPipe, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbBulkInPipe[] = {
        { const_cast<char*>("read_options"), (getter)UsbBulkInPipe_get_ReadOptions, (setter)UsbBulkInPipe_put_ReadOptions, nullptr, nullptr },
        { const_cast<char*>("endpoint_descriptor"), (getter)UsbBulkInPipe_get_EndpointDescriptor, nullptr, nullptr, nullptr },
        { const_cast<char*>("input_stream"), (getter)UsbBulkInPipe_get_InputStream, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_transfer_size_bytes"), (getter)UsbBulkInPipe_get_MaxTransferSizeBytes, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbBulkInPipe[] = 
    {
        { Py_tp_new, _new_UsbBulkInPipe },
        { Py_tp_dealloc, _dealloc_UsbBulkInPipe },
        { Py_tp_methods, _methods_UsbBulkInPipe },
        { Py_tp_getset, _getset_UsbBulkInPipe },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbBulkInPipe =
    {
        "_winrt_Windows_Devices_Usb.UsbBulkInPipe",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbBulkInPipe
    };

    // ----- UsbBulkOutEndpointDescriptor class --------------------
    constexpr const char* const _type_name_UsbBulkOutEndpointDescriptor = "UsbBulkOutEndpointDescriptor";

    static PyObject* _new_UsbBulkOutEndpointDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbBulkOutEndpointDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbBulkOutEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbBulkOutEndpointDescriptor_get_EndpointNumber(py::wrapper::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndpointNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkOutEndpointDescriptor_get_MaxPacketSize(py::wrapper::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPacketSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkOutEndpointDescriptor_get_Pipe(py::wrapper::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pipe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbBulkOutEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbBulkOutEndpointDescriptor[] = {
        { "_from", (PyCFunction)_from_UsbBulkOutEndpointDescriptor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbBulkOutEndpointDescriptor[] = {
        { const_cast<char*>("endpoint_number"), (getter)UsbBulkOutEndpointDescriptor_get_EndpointNumber, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_packet_size"), (getter)UsbBulkOutEndpointDescriptor_get_MaxPacketSize, nullptr, nullptr, nullptr },
        { const_cast<char*>("pipe"), (getter)UsbBulkOutEndpointDescriptor_get_Pipe, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbBulkOutEndpointDescriptor[] = 
    {
        { Py_tp_new, _new_UsbBulkOutEndpointDescriptor },
        { Py_tp_dealloc, _dealloc_UsbBulkOutEndpointDescriptor },
        { Py_tp_methods, _methods_UsbBulkOutEndpointDescriptor },
        { Py_tp_getset, _getset_UsbBulkOutEndpointDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbBulkOutEndpointDescriptor =
    {
        "_winrt_Windows_Devices_Usb.UsbBulkOutEndpointDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbBulkOutEndpointDescriptor
    };

    // ----- UsbBulkOutPipe class --------------------
    constexpr const char* const _type_name_UsbBulkOutPipe = "UsbBulkOutPipe";

    static PyObject* _new_UsbBulkOutPipe(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbBulkOutPipe);
        return nullptr;
    }

    static void _dealloc_UsbBulkOutPipe(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbBulkOutPipe_ClearStallAsync(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClearStallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbBulkOutPipe_get_WriteOptions(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WriteOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbBulkOutPipe_put_WriteOptions(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbWriteOptions>(arg);

            self->obj.WriteOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbBulkOutPipe_get_EndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkOutPipe_get_OutputStream(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbBulkOutPipe(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbBulkOutPipe>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbBulkOutPipe[] = {
        { "clear_stall_async", (PyCFunction)UsbBulkOutPipe_ClearStallAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_UsbBulkOutPipe, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbBulkOutPipe[] = {
        { const_cast<char*>("write_options"), (getter)UsbBulkOutPipe_get_WriteOptions, (setter)UsbBulkOutPipe_put_WriteOptions, nullptr, nullptr },
        { const_cast<char*>("endpoint_descriptor"), (getter)UsbBulkOutPipe_get_EndpointDescriptor, nullptr, nullptr, nullptr },
        { const_cast<char*>("output_stream"), (getter)UsbBulkOutPipe_get_OutputStream, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbBulkOutPipe[] = 
    {
        { Py_tp_new, _new_UsbBulkOutPipe },
        { Py_tp_dealloc, _dealloc_UsbBulkOutPipe },
        { Py_tp_methods, _methods_UsbBulkOutPipe },
        { Py_tp_getset, _getset_UsbBulkOutPipe },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbBulkOutPipe =
    {
        "_winrt_Windows_Devices_Usb.UsbBulkOutPipe",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbBulkOutPipe
    };

    // ----- UsbConfiguration class --------------------
    constexpr const char* const _type_name_UsbConfiguration = "UsbConfiguration";

    static PyObject* _new_UsbConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbConfiguration);
        return nullptr;
    }

    static void _dealloc_UsbConfiguration(py::wrapper::Windows::Devices::Usb::UsbConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbConfiguration_get_ConfigurationDescriptor(py::wrapper::Windows::Devices::Usb::UsbConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConfigurationDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbConfiguration_get_Descriptors(py::wrapper::Windows::Devices::Usb::UsbConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Descriptors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbConfiguration_get_UsbInterfaces(py::wrapper::Windows::Devices::Usb::UsbConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UsbInterfaces());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbConfiguration[] = {
        { "_from", (PyCFunction)_from_UsbConfiguration, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbConfiguration[] = {
        { const_cast<char*>("configuration_descriptor"), (getter)UsbConfiguration_get_ConfigurationDescriptor, nullptr, nullptr, nullptr },
        { const_cast<char*>("descriptors"), (getter)UsbConfiguration_get_Descriptors, nullptr, nullptr, nullptr },
        { const_cast<char*>("usb_interfaces"), (getter)UsbConfiguration_get_UsbInterfaces, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbConfiguration[] = 
    {
        { Py_tp_new, _new_UsbConfiguration },
        { Py_tp_dealloc, _dealloc_UsbConfiguration },
        { Py_tp_methods, _methods_UsbConfiguration },
        { Py_tp_getset, _getset_UsbConfiguration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbConfiguration =
    {
        "_winrt_Windows_Devices_Usb.UsbConfiguration",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbConfiguration
    };

    // ----- UsbConfigurationDescriptor class --------------------
    constexpr const char* const _type_name_UsbConfigurationDescriptor = "UsbConfigurationDescriptor";

    static PyObject* _new_UsbConfigurationDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbConfigurationDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbConfigurationDescriptor(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbConfigurationDescriptor_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbConfigurationDescriptor::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbConfigurationDescriptor_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);
                winrt::Windows::Devices::Usb::UsbConfigurationDescriptor param1 { nullptr };

                auto return_value = winrt::Windows::Devices::Usb::UsbConfigurationDescriptor::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbConfigurationDescriptor_get_ConfigurationValue(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConfigurationValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbConfigurationDescriptor_get_MaxPowerMilliamps(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPowerMilliamps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbConfigurationDescriptor_get_RemoteWakeup(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteWakeup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbConfigurationDescriptor_get_SelfPowered(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SelfPowered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbConfigurationDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbConfigurationDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbConfigurationDescriptor[] = {
        { "parse", (PyCFunction)UsbConfigurationDescriptor_Parse, METH_VARARGS | METH_STATIC, nullptr },
        { "try_parse", (PyCFunction)UsbConfigurationDescriptor_TryParse, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_UsbConfigurationDescriptor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbConfigurationDescriptor[] = {
        { const_cast<char*>("configuration_value"), (getter)UsbConfigurationDescriptor_get_ConfigurationValue, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_power_milliamps"), (getter)UsbConfigurationDescriptor_get_MaxPowerMilliamps, nullptr, nullptr, nullptr },
        { const_cast<char*>("remote_wakeup"), (getter)UsbConfigurationDescriptor_get_RemoteWakeup, nullptr, nullptr, nullptr },
        { const_cast<char*>("self_powered"), (getter)UsbConfigurationDescriptor_get_SelfPowered, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbConfigurationDescriptor[] = 
    {
        { Py_tp_new, _new_UsbConfigurationDescriptor },
        { Py_tp_dealloc, _dealloc_UsbConfigurationDescriptor },
        { Py_tp_methods, _methods_UsbConfigurationDescriptor },
        { Py_tp_getset, _getset_UsbConfigurationDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbConfigurationDescriptor =
    {
        "_winrt_Windows_Devices_Usb.UsbConfigurationDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbConfigurationDescriptor
    };

    // ----- UsbControlRequestType class --------------------
    constexpr const char* const _type_name_UsbControlRequestType = "UsbControlRequestType";

    static PyObject* _new_UsbControlRequestType(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Usb::UsbControlRequestType instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UsbControlRequestType(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbControlRequestType_get_Recipient(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Recipient());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbControlRequestType_put_Recipient(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbControlRecipient>(arg);

            self->obj.Recipient(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbControlRequestType_get_Direction(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Direction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbControlRequestType_put_Direction(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbTransferDirection>(arg);

            self->obj.Direction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbControlRequestType_get_ControlTransferType(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ControlTransferType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbControlRequestType_put_ControlTransferType(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbControlTransferType>(arg);

            self->obj.ControlTransferType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbControlRequestType_get_AsByte(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AsByte());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbControlRequestType_put_AsByte(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.AsByte(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_UsbControlRequestType(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbControlRequestType>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbControlRequestType[] = {
        { "_from", (PyCFunction)_from_UsbControlRequestType, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbControlRequestType[] = {
        { const_cast<char*>("recipient"), (getter)UsbControlRequestType_get_Recipient, (setter)UsbControlRequestType_put_Recipient, nullptr, nullptr },
        { const_cast<char*>("direction"), (getter)UsbControlRequestType_get_Direction, (setter)UsbControlRequestType_put_Direction, nullptr, nullptr },
        { const_cast<char*>("control_transfer_type"), (getter)UsbControlRequestType_get_ControlTransferType, (setter)UsbControlRequestType_put_ControlTransferType, nullptr, nullptr },
        { const_cast<char*>("as_byte"), (getter)UsbControlRequestType_get_AsByte, (setter)UsbControlRequestType_put_AsByte, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbControlRequestType[] = 
    {
        { Py_tp_new, _new_UsbControlRequestType },
        { Py_tp_dealloc, _dealloc_UsbControlRequestType },
        { Py_tp_methods, _methods_UsbControlRequestType },
        { Py_tp_getset, _getset_UsbControlRequestType },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbControlRequestType =
    {
        "_winrt_Windows_Devices_Usb.UsbControlRequestType",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbControlRequestType),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbControlRequestType
    };

    // ----- UsbDescriptor class --------------------
    constexpr const char* const _type_name_UsbDescriptor = "UsbDescriptor";

    static PyObject* _new_UsbDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbDescriptor(py::wrapper::Windows::Devices::Usb::UsbDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbDescriptor_ReadDescriptorBuffer(py::wrapper::Windows::Devices::Usb::UsbDescriptor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.ReadDescriptorBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDescriptor_get_DescriptorType(py::wrapper::Windows::Devices::Usb::UsbDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DescriptorType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDescriptor_get_Length(py::wrapper::Windows::Devices::Usb::UsbDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbDescriptor[] = {
        { "read_descriptor_buffer", (PyCFunction)UsbDescriptor_ReadDescriptorBuffer, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_UsbDescriptor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbDescriptor[] = {
        { const_cast<char*>("descriptor_type"), (getter)UsbDescriptor_get_DescriptorType, nullptr, nullptr, nullptr },
        { const_cast<char*>("length"), (getter)UsbDescriptor_get_Length, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbDescriptor[] = 
    {
        { Py_tp_new, _new_UsbDescriptor },
        { Py_tp_dealloc, _dealloc_UsbDescriptor },
        { Py_tp_methods, _methods_UsbDescriptor },
        { Py_tp_getset, _getset_UsbDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbDescriptor =
    {
        "_winrt_Windows_Devices_Usb.UsbDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbDescriptor
    };

    // ----- UsbDevice class --------------------
    constexpr const char* const _type_name_UsbDevice = "UsbDevice";

    static PyObject* _new_UsbDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbDevice);
        return nullptr;
    }

    static void _dealloc_UsbDevice(py::wrapper::Windows::Devices::Usb::UsbDevice* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbDevice_Close(py::wrapper::Windows::Devices::Usb::UsbDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbDevice::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_GetDeviceClassSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDeviceClass>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbDevice::GetDeviceClassSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbDevice::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(winrt::Windows::Devices::Usb::UsbDevice::GetDeviceSelector(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                return py::convert(winrt::Windows::Devices::Usb::UsbDevice::GetDeviceSelector(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_SendControlInTransferAsync(py::wrapper::Windows::Devices::Usb::UsbDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbSetupPacket>(args, 0);

                return py::convert(self->obj.SendControlInTransferAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbSetupPacket>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(self->obj.SendControlInTransferAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_SendControlOutTransferAsync(py::wrapper::Windows::Devices::Usb::UsbDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbSetupPacket>(args, 0);

                return py::convert(self->obj.SendControlOutTransferAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbSetupPacket>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(self->obj.SendControlOutTransferAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_get_Configuration(py::wrapper::Windows::Devices::Usb::UsbDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDevice_get_DefaultInterface(py::wrapper::Windows::Devices::Usb::UsbDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DefaultInterface());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDevice_get_DeviceDescriptor(py::wrapper::Windows::Devices::Usb::UsbDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_UsbDevice(py::wrapper::Windows::Devices::Usb::UsbDevice* self) noexcept
    {
        Py_INCREF(self);
        return (PyObject*)self;
    }

    static PyObject* _exit_UsbDevice(py::wrapper::Windows::Devices::Usb::UsbDevice* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbDevice[] = {
        { "close", (PyCFunction)UsbDevice_Close, METH_VARARGS, nullptr },
        { "from_id_async", (PyCFunction)UsbDevice_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_class_selector", (PyCFunction)UsbDevice_GetDeviceClassSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)UsbDevice_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "send_control_in_transfer_async", (PyCFunction)UsbDevice_SendControlInTransferAsync, METH_VARARGS, nullptr },
        { "send_control_out_transfer_async", (PyCFunction)UsbDevice_SendControlOutTransferAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_UsbDevice, METH_O | METH_STATIC, nullptr },
        { "__enter__", (PyCFunction)_enter_UsbDevice, METH_NOARGS, nullptr },
        { "__exit__",  (PyCFunction)_exit_UsbDevice, METH_VARARGS, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbDevice[] = {
        { const_cast<char*>("configuration"), (getter)UsbDevice_get_Configuration, nullptr, nullptr, nullptr },
        { const_cast<char*>("default_interface"), (getter)UsbDevice_get_DefaultInterface, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_descriptor"), (getter)UsbDevice_get_DeviceDescriptor, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbDevice[] = 
    {
        { Py_tp_new, _new_UsbDevice },
        { Py_tp_dealloc, _dealloc_UsbDevice },
        { Py_tp_methods, _methods_UsbDevice },
        { Py_tp_getset, _getset_UsbDevice },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbDevice =
    {
        "_winrt_Windows_Devices_Usb.UsbDevice",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbDevice
    };

    // ----- UsbDeviceClass class --------------------
    constexpr const char* const _type_name_UsbDeviceClass = "UsbDeviceClass";

    static PyObject* _new_UsbDeviceClass(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Usb::UsbDeviceClass instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UsbDeviceClass(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbDeviceClass_get_SubclassCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SubclassCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbDeviceClass_put_SubclassCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint8_t>>(arg);

            self->obj.SubclassCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbDeviceClass_get_ProtocolCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtocolCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbDeviceClass_put_ProtocolCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint8_t>>(arg);

            self->obj.ProtocolCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbDeviceClass_get_ClassCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ClassCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbDeviceClass_put_ClassCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.ClassCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_UsbDeviceClass(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbDeviceClass>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbDeviceClass[] = {
        { "_from", (PyCFunction)_from_UsbDeviceClass, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbDeviceClass[] = {
        { const_cast<char*>("subclass_code"), (getter)UsbDeviceClass_get_SubclassCode, (setter)UsbDeviceClass_put_SubclassCode, nullptr, nullptr },
        { const_cast<char*>("protocol_code"), (getter)UsbDeviceClass_get_ProtocolCode, (setter)UsbDeviceClass_put_ProtocolCode, nullptr, nullptr },
        { const_cast<char*>("class_code"), (getter)UsbDeviceClass_get_ClassCode, (setter)UsbDeviceClass_put_ClassCode, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbDeviceClass[] = 
    {
        { Py_tp_new, _new_UsbDeviceClass },
        { Py_tp_dealloc, _dealloc_UsbDeviceClass },
        { Py_tp_methods, _methods_UsbDeviceClass },
        { Py_tp_getset, _getset_UsbDeviceClass },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbDeviceClass =
    {
        "_winrt_Windows_Devices_Usb.UsbDeviceClass",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbDeviceClass),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbDeviceClass
    };

    // ----- UsbDeviceClasses class --------------------
    constexpr const char* const _type_name_UsbDeviceClasses = "UsbDeviceClasses";

    static PyObject* _new_UsbDeviceClasses(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbDeviceClasses);
        return nullptr;
    }

    static void _dealloc_UsbDeviceClasses(py::wrapper::Windows::Devices::Usb::UsbDeviceClasses* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbDeviceClasses_get_ActiveSync(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::ActiveSync());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_CdcControl(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::CdcControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_DeviceFirmwareUpdate(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::DeviceFirmwareUpdate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_Irda(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::Irda());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_Measurement(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::Measurement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_PalmSync(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::PalmSync());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_PersonalHealthcare(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::PersonalHealthcare());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_Physical(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::Physical());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_VendorSpecific(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::VendorSpecific());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbDeviceClasses(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbDeviceClasses>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbDeviceClasses[] = {
        { "get_active_sync", (PyCFunction)UsbDeviceClasses_get_ActiveSync, METH_NOARGS | METH_STATIC, nullptr },
        { "get_cdc_control", (PyCFunction)UsbDeviceClasses_get_CdcControl, METH_NOARGS | METH_STATIC, nullptr },
        { "get_device_firmware_update", (PyCFunction)UsbDeviceClasses_get_DeviceFirmwareUpdate, METH_NOARGS | METH_STATIC, nullptr },
        { "get_irda", (PyCFunction)UsbDeviceClasses_get_Irda, METH_NOARGS | METH_STATIC, nullptr },
        { "get_measurement", (PyCFunction)UsbDeviceClasses_get_Measurement, METH_NOARGS | METH_STATIC, nullptr },
        { "get_palm_sync", (PyCFunction)UsbDeviceClasses_get_PalmSync, METH_NOARGS | METH_STATIC, nullptr },
        { "get_personal_healthcare", (PyCFunction)UsbDeviceClasses_get_PersonalHealthcare, METH_NOARGS | METH_STATIC, nullptr },
        { "get_physical", (PyCFunction)UsbDeviceClasses_get_Physical, METH_NOARGS | METH_STATIC, nullptr },
        { "get_vendor_specific", (PyCFunction)UsbDeviceClasses_get_VendorSpecific, METH_NOARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_UsbDeviceClasses, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbDeviceClasses[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbDeviceClasses[] = 
    {
        { Py_tp_new, _new_UsbDeviceClasses },
        { Py_tp_dealloc, _dealloc_UsbDeviceClasses },
        { Py_tp_methods, _methods_UsbDeviceClasses },
        { Py_tp_getset, _getset_UsbDeviceClasses },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbDeviceClasses =
    {
        "_winrt_Windows_Devices_Usb.UsbDeviceClasses",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbDeviceClasses),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbDeviceClasses
    };

    // ----- UsbDeviceDescriptor class --------------------
    constexpr const char* const _type_name_UsbDeviceDescriptor = "UsbDeviceDescriptor";

    static PyObject* _new_UsbDeviceDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbDeviceDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbDeviceDescriptor(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbDeviceDescriptor_get_BcdDeviceRevision(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BcdDeviceRevision());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceDescriptor_get_BcdUsb(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BcdUsb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceDescriptor_get_MaxPacketSize0(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPacketSize0());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceDescriptor_get_NumberOfConfigurations(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NumberOfConfigurations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceDescriptor_get_ProductId(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceDescriptor_get_VendorId(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbDeviceDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbDeviceDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbDeviceDescriptor[] = {
        { "_from", (PyCFunction)_from_UsbDeviceDescriptor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbDeviceDescriptor[] = {
        { const_cast<char*>("bcd_device_revision"), (getter)UsbDeviceDescriptor_get_BcdDeviceRevision, nullptr, nullptr, nullptr },
        { const_cast<char*>("bcd_usb"), (getter)UsbDeviceDescriptor_get_BcdUsb, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_packet_size0"), (getter)UsbDeviceDescriptor_get_MaxPacketSize0, nullptr, nullptr, nullptr },
        { const_cast<char*>("number_of_configurations"), (getter)UsbDeviceDescriptor_get_NumberOfConfigurations, nullptr, nullptr, nullptr },
        { const_cast<char*>("product_id"), (getter)UsbDeviceDescriptor_get_ProductId, nullptr, nullptr, nullptr },
        { const_cast<char*>("vendor_id"), (getter)UsbDeviceDescriptor_get_VendorId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbDeviceDescriptor[] = 
    {
        { Py_tp_new, _new_UsbDeviceDescriptor },
        { Py_tp_dealloc, _dealloc_UsbDeviceDescriptor },
        { Py_tp_methods, _methods_UsbDeviceDescriptor },
        { Py_tp_getset, _getset_UsbDeviceDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbDeviceDescriptor =
    {
        "_winrt_Windows_Devices_Usb.UsbDeviceDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbDeviceDescriptor
    };

    // ----- UsbEndpointDescriptor class --------------------
    constexpr const char* const _type_name_UsbEndpointDescriptor = "UsbEndpointDescriptor";

    static PyObject* _new_UsbEndpointDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbEndpointDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbEndpointDescriptor_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbEndpointDescriptor::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);
                winrt::Windows::Devices::Usb::UsbEndpointDescriptor param1 { nullptr };

                auto return_value = winrt::Windows::Devices::Usb::UsbEndpointDescriptor::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_AsBulkInEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AsBulkInEndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_AsBulkOutEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AsBulkOutEndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_AsInterruptInEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AsInterruptInEndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_AsInterruptOutEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AsInterruptOutEndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_Direction(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Direction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_EndpointNumber(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndpointNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_EndpointType(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndpointType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbEndpointDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbEndpointDescriptor[] = {
        { "parse", (PyCFunction)UsbEndpointDescriptor_Parse, METH_VARARGS | METH_STATIC, nullptr },
        { "try_parse", (PyCFunction)UsbEndpointDescriptor_TryParse, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_UsbEndpointDescriptor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbEndpointDescriptor[] = {
        { const_cast<char*>("as_bulk_in_endpoint_descriptor"), (getter)UsbEndpointDescriptor_get_AsBulkInEndpointDescriptor, nullptr, nullptr, nullptr },
        { const_cast<char*>("as_bulk_out_endpoint_descriptor"), (getter)UsbEndpointDescriptor_get_AsBulkOutEndpointDescriptor, nullptr, nullptr, nullptr },
        { const_cast<char*>("as_interrupt_in_endpoint_descriptor"), (getter)UsbEndpointDescriptor_get_AsInterruptInEndpointDescriptor, nullptr, nullptr, nullptr },
        { const_cast<char*>("as_interrupt_out_endpoint_descriptor"), (getter)UsbEndpointDescriptor_get_AsInterruptOutEndpointDescriptor, nullptr, nullptr, nullptr },
        { const_cast<char*>("direction"), (getter)UsbEndpointDescriptor_get_Direction, nullptr, nullptr, nullptr },
        { const_cast<char*>("endpoint_number"), (getter)UsbEndpointDescriptor_get_EndpointNumber, nullptr, nullptr, nullptr },
        { const_cast<char*>("endpoint_type"), (getter)UsbEndpointDescriptor_get_EndpointType, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbEndpointDescriptor[] = 
    {
        { Py_tp_new, _new_UsbEndpointDescriptor },
        { Py_tp_dealloc, _dealloc_UsbEndpointDescriptor },
        { Py_tp_methods, _methods_UsbEndpointDescriptor },
        { Py_tp_getset, _getset_UsbEndpointDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbEndpointDescriptor =
    {
        "_winrt_Windows_Devices_Usb.UsbEndpointDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbEndpointDescriptor
    };

    // ----- UsbInterface class --------------------
    constexpr const char* const _type_name_UsbInterface = "UsbInterface";

    static PyObject* _new_UsbInterface(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbInterface);
        return nullptr;
    }

    static void _dealloc_UsbInterface(py::wrapper::Windows::Devices::Usb::UsbInterface* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbInterface_get_BulkInPipes(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BulkInPipes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_BulkOutPipes(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BulkOutPipes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_Descriptors(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Descriptors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_InterfaceNumber(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterfaceNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_InterfaceSettings(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterfaceSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_InterruptInPipes(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterruptInPipes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_InterruptOutPipes(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterruptOutPipes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterface>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterface[] = {
        { "_from", (PyCFunction)_from_UsbInterface, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbInterface[] = {
        { const_cast<char*>("bulk_in_pipes"), (getter)UsbInterface_get_BulkInPipes, nullptr, nullptr, nullptr },
        { const_cast<char*>("bulk_out_pipes"), (getter)UsbInterface_get_BulkOutPipes, nullptr, nullptr, nullptr },
        { const_cast<char*>("descriptors"), (getter)UsbInterface_get_Descriptors, nullptr, nullptr, nullptr },
        { const_cast<char*>("interface_number"), (getter)UsbInterface_get_InterfaceNumber, nullptr, nullptr, nullptr },
        { const_cast<char*>("interface_settings"), (getter)UsbInterface_get_InterfaceSettings, nullptr, nullptr, nullptr },
        { const_cast<char*>("interrupt_in_pipes"), (getter)UsbInterface_get_InterruptInPipes, nullptr, nullptr, nullptr },
        { const_cast<char*>("interrupt_out_pipes"), (getter)UsbInterface_get_InterruptOutPipes, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbInterface[] = 
    {
        { Py_tp_new, _new_UsbInterface },
        { Py_tp_dealloc, _dealloc_UsbInterface },
        { Py_tp_methods, _methods_UsbInterface },
        { Py_tp_getset, _getset_UsbInterface },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbInterface =
    {
        "_winrt_Windows_Devices_Usb.UsbInterface",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterface),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterface
    };

    // ----- UsbInterfaceDescriptor class --------------------
    constexpr const char* const _type_name_UsbInterfaceDescriptor = "UsbInterfaceDescriptor";

    static PyObject* _new_UsbInterfaceDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbInterfaceDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbInterfaceDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbInterfaceDescriptor_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbInterfaceDescriptor::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);
                winrt::Windows::Devices::Usb::UsbInterfaceDescriptor param1 { nullptr };

                auto return_value = winrt::Windows::Devices::Usb::UsbInterfaceDescriptor::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_get_AlternateSettingNumber(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlternateSettingNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_get_ClassCode(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ClassCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_get_InterfaceNumber(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterfaceNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_get_ProtocolCode(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtocolCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_get_SubclassCode(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SubclassCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterfaceDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterfaceDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterfaceDescriptor[] = {
        { "parse", (PyCFunction)UsbInterfaceDescriptor_Parse, METH_VARARGS | METH_STATIC, nullptr },
        { "try_parse", (PyCFunction)UsbInterfaceDescriptor_TryParse, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_UsbInterfaceDescriptor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbInterfaceDescriptor[] = {
        { const_cast<char*>("alternate_setting_number"), (getter)UsbInterfaceDescriptor_get_AlternateSettingNumber, nullptr, nullptr, nullptr },
        { const_cast<char*>("class_code"), (getter)UsbInterfaceDescriptor_get_ClassCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("interface_number"), (getter)UsbInterfaceDescriptor_get_InterfaceNumber, nullptr, nullptr, nullptr },
        { const_cast<char*>("protocol_code"), (getter)UsbInterfaceDescriptor_get_ProtocolCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("subclass_code"), (getter)UsbInterfaceDescriptor_get_SubclassCode, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbInterfaceDescriptor[] = 
    {
        { Py_tp_new, _new_UsbInterfaceDescriptor },
        { Py_tp_dealloc, _dealloc_UsbInterfaceDescriptor },
        { Py_tp_methods, _methods_UsbInterfaceDescriptor },
        { Py_tp_getset, _getset_UsbInterfaceDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbInterfaceDescriptor =
    {
        "_winrt_Windows_Devices_Usb.UsbInterfaceDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterfaceDescriptor
    };

    // ----- UsbInterfaceSetting class --------------------
    constexpr const char* const _type_name_UsbInterfaceSetting = "UsbInterfaceSetting";

    static PyObject* _new_UsbInterfaceSetting(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbInterfaceSetting);
        return nullptr;
    }

    static void _dealloc_UsbInterfaceSetting(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbInterfaceSetting_SelectSettingAsync(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.SelectSettingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_BulkInEndpoints(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BulkInEndpoints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_BulkOutEndpoints(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BulkOutEndpoints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_Descriptors(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Descriptors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_InterfaceDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterfaceDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_InterruptInEndpoints(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterruptInEndpoints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_InterruptOutEndpoints(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterruptOutEndpoints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_Selected(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Selected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterfaceSetting(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterfaceSetting>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterfaceSetting[] = {
        { "select_setting_async", (PyCFunction)UsbInterfaceSetting_SelectSettingAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_UsbInterfaceSetting, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbInterfaceSetting[] = {
        { const_cast<char*>("bulk_in_endpoints"), (getter)UsbInterfaceSetting_get_BulkInEndpoints, nullptr, nullptr, nullptr },
        { const_cast<char*>("bulk_out_endpoints"), (getter)UsbInterfaceSetting_get_BulkOutEndpoints, nullptr, nullptr, nullptr },
        { const_cast<char*>("descriptors"), (getter)UsbInterfaceSetting_get_Descriptors, nullptr, nullptr, nullptr },
        { const_cast<char*>("interface_descriptor"), (getter)UsbInterfaceSetting_get_InterfaceDescriptor, nullptr, nullptr, nullptr },
        { const_cast<char*>("interrupt_in_endpoints"), (getter)UsbInterfaceSetting_get_InterruptInEndpoints, nullptr, nullptr, nullptr },
        { const_cast<char*>("interrupt_out_endpoints"), (getter)UsbInterfaceSetting_get_InterruptOutEndpoints, nullptr, nullptr, nullptr },
        { const_cast<char*>("selected"), (getter)UsbInterfaceSetting_get_Selected, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbInterfaceSetting[] = 
    {
        { Py_tp_new, _new_UsbInterfaceSetting },
        { Py_tp_dealloc, _dealloc_UsbInterfaceSetting },
        { Py_tp_methods, _methods_UsbInterfaceSetting },
        { Py_tp_getset, _getset_UsbInterfaceSetting },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbInterfaceSetting =
    {
        "_winrt_Windows_Devices_Usb.UsbInterfaceSetting",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterfaceSetting
    };

    // ----- UsbInterruptInEndpointDescriptor class --------------------
    constexpr const char* const _type_name_UsbInterruptInEndpointDescriptor = "UsbInterruptInEndpointDescriptor";

    static PyObject* _new_UsbInterruptInEndpointDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbInterruptInEndpointDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbInterruptInEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbInterruptInEndpointDescriptor_get_EndpointNumber(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndpointNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInEndpointDescriptor_get_Interval(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Interval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInEndpointDescriptor_get_MaxPacketSize(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPacketSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInEndpointDescriptor_get_Pipe(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pipe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterruptInEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterruptInEndpointDescriptor[] = {
        { "_from", (PyCFunction)_from_UsbInterruptInEndpointDescriptor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbInterruptInEndpointDescriptor[] = {
        { const_cast<char*>("endpoint_number"), (getter)UsbInterruptInEndpointDescriptor_get_EndpointNumber, nullptr, nullptr, nullptr },
        { const_cast<char*>("interval"), (getter)UsbInterruptInEndpointDescriptor_get_Interval, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_packet_size"), (getter)UsbInterruptInEndpointDescriptor_get_MaxPacketSize, nullptr, nullptr, nullptr },
        { const_cast<char*>("pipe"), (getter)UsbInterruptInEndpointDescriptor_get_Pipe, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbInterruptInEndpointDescriptor[] = 
    {
        { Py_tp_new, _new_UsbInterruptInEndpointDescriptor },
        { Py_tp_dealloc, _dealloc_UsbInterruptInEndpointDescriptor },
        { Py_tp_methods, _methods_UsbInterruptInEndpointDescriptor },
        { Py_tp_getset, _getset_UsbInterruptInEndpointDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbInterruptInEndpointDescriptor =
    {
        "_winrt_Windows_Devices_Usb.UsbInterruptInEndpointDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterruptInEndpointDescriptor
    };

    // ----- UsbInterruptInEventArgs class --------------------
    constexpr const char* const _type_name_UsbInterruptInEventArgs = "UsbInterruptInEventArgs";

    static PyObject* _new_UsbInterruptInEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbInterruptInEventArgs);
        return nullptr;
    }

    static void _dealloc_UsbInterruptInEventArgs(py::wrapper::Windows::Devices::Usb::UsbInterruptInEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbInterruptInEventArgs_get_InterruptData(py::wrapper::Windows::Devices::Usb::UsbInterruptInEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterruptData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterruptInEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterruptInEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterruptInEventArgs[] = {
        { "_from", (PyCFunction)_from_UsbInterruptInEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbInterruptInEventArgs[] = {
        { const_cast<char*>("interrupt_data"), (getter)UsbInterruptInEventArgs_get_InterruptData, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbInterruptInEventArgs[] = 
    {
        { Py_tp_new, _new_UsbInterruptInEventArgs },
        { Py_tp_dealloc, _dealloc_UsbInterruptInEventArgs },
        { Py_tp_methods, _methods_UsbInterruptInEventArgs },
        { Py_tp_getset, _getset_UsbInterruptInEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbInterruptInEventArgs =
    {
        "_winrt_Windows_Devices_Usb.UsbInterruptInEventArgs",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterruptInEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterruptInEventArgs
    };

    // ----- UsbInterruptInPipe class --------------------
    constexpr const char* const _type_name_UsbInterruptInPipe = "UsbInterruptInPipe";

    static PyObject* _new_UsbInterruptInPipe(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbInterruptInPipe);
        return nullptr;
    }

    static void _dealloc_UsbInterruptInPipe(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbInterruptInPipe_ClearStallAsync(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClearStallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInPipe_get_EndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInPipe_add_DataReceived(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Usb::UsbInterruptInPipe, winrt::Windows::Devices::Usb::UsbInterruptInEventArgs>>(arg);

            return py::convert(self->obj.DataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInPipe_remove_DataReceived(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterruptInPipe(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterruptInPipe>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterruptInPipe[] = {
        { "clear_stall_async", (PyCFunction)UsbInterruptInPipe_ClearStallAsync, METH_VARARGS, nullptr },
        { "add_data_received", (PyCFunction)UsbInterruptInPipe_add_DataReceived, METH_O, nullptr },
        { "remove_data_received", (PyCFunction)UsbInterruptInPipe_remove_DataReceived, METH_O, nullptr },
        { "_from", (PyCFunction)_from_UsbInterruptInPipe, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbInterruptInPipe[] = {
        { const_cast<char*>("endpoint_descriptor"), (getter)UsbInterruptInPipe_get_EndpointDescriptor, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbInterruptInPipe[] = 
    {
        { Py_tp_new, _new_UsbInterruptInPipe },
        { Py_tp_dealloc, _dealloc_UsbInterruptInPipe },
        { Py_tp_methods, _methods_UsbInterruptInPipe },
        { Py_tp_getset, _getset_UsbInterruptInPipe },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbInterruptInPipe =
    {
        "_winrt_Windows_Devices_Usb.UsbInterruptInPipe",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterruptInPipe
    };

    // ----- UsbInterruptOutEndpointDescriptor class --------------------
    constexpr const char* const _type_name_UsbInterruptOutEndpointDescriptor = "UsbInterruptOutEndpointDescriptor";

    static PyObject* _new_UsbInterruptOutEndpointDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbInterruptOutEndpointDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbInterruptOutEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbInterruptOutEndpointDescriptor_get_EndpointNumber(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndpointNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptOutEndpointDescriptor_get_Interval(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Interval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptOutEndpointDescriptor_get_MaxPacketSize(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPacketSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptOutEndpointDescriptor_get_Pipe(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pipe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterruptOutEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterruptOutEndpointDescriptor[] = {
        { "_from", (PyCFunction)_from_UsbInterruptOutEndpointDescriptor, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbInterruptOutEndpointDescriptor[] = {
        { const_cast<char*>("endpoint_number"), (getter)UsbInterruptOutEndpointDescriptor_get_EndpointNumber, nullptr, nullptr, nullptr },
        { const_cast<char*>("interval"), (getter)UsbInterruptOutEndpointDescriptor_get_Interval, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_packet_size"), (getter)UsbInterruptOutEndpointDescriptor_get_MaxPacketSize, nullptr, nullptr, nullptr },
        { const_cast<char*>("pipe"), (getter)UsbInterruptOutEndpointDescriptor_get_Pipe, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbInterruptOutEndpointDescriptor[] = 
    {
        { Py_tp_new, _new_UsbInterruptOutEndpointDescriptor },
        { Py_tp_dealloc, _dealloc_UsbInterruptOutEndpointDescriptor },
        { Py_tp_methods, _methods_UsbInterruptOutEndpointDescriptor },
        { Py_tp_getset, _getset_UsbInterruptOutEndpointDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbInterruptOutEndpointDescriptor =
    {
        "_winrt_Windows_Devices_Usb.UsbInterruptOutEndpointDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterruptOutEndpointDescriptor
    };

    // ----- UsbInterruptOutPipe class --------------------
    constexpr const char* const _type_name_UsbInterruptOutPipe = "UsbInterruptOutPipe";

    static PyObject* _new_UsbInterruptOutPipe(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbInterruptOutPipe);
        return nullptr;
    }

    static void _dealloc_UsbInterruptOutPipe(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbInterruptOutPipe_ClearStallAsync(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClearStallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbInterruptOutPipe_get_WriteOptions(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WriteOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbInterruptOutPipe_put_WriteOptions(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbWriteOptions>(arg);

            self->obj.WriteOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbInterruptOutPipe_get_EndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptOutPipe_get_OutputStream(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterruptOutPipe(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterruptOutPipe>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterruptOutPipe[] = {
        { "clear_stall_async", (PyCFunction)UsbInterruptOutPipe_ClearStallAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_UsbInterruptOutPipe, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbInterruptOutPipe[] = {
        { const_cast<char*>("write_options"), (getter)UsbInterruptOutPipe_get_WriteOptions, (setter)UsbInterruptOutPipe_put_WriteOptions, nullptr, nullptr },
        { const_cast<char*>("endpoint_descriptor"), (getter)UsbInterruptOutPipe_get_EndpointDescriptor, nullptr, nullptr, nullptr },
        { const_cast<char*>("output_stream"), (getter)UsbInterruptOutPipe_get_OutputStream, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbInterruptOutPipe[] = 
    {
        { Py_tp_new, _new_UsbInterruptOutPipe },
        { Py_tp_dealloc, _dealloc_UsbInterruptOutPipe },
        { Py_tp_methods, _methods_UsbInterruptOutPipe },
        { Py_tp_getset, _getset_UsbInterruptOutPipe },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbInterruptOutPipe =
    {
        "_winrt_Windows_Devices_Usb.UsbInterruptOutPipe",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterruptOutPipe
    };

    // ----- UsbSetupPacket class --------------------
    constexpr const char* const _type_name_UsbSetupPacket = "UsbSetupPacket";

    static PyObject* _new_UsbSetupPacket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Devices::Usb::UsbSetupPacket instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Usb::UsbSetupPacket instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UsbSetupPacket(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbSetupPacket_get_Value(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbSetupPacket_put_Value(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbSetupPacket_get_RequestType(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbSetupPacket_put_RequestType(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbControlRequestType>(arg);

            self->obj.RequestType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbSetupPacket_get_Request(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbSetupPacket_put_Request(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.Request(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbSetupPacket_get_Length(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbSetupPacket_put_Length(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Length(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbSetupPacket_get_Index(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Index());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbSetupPacket_put_Index(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Index(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_UsbSetupPacket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbSetupPacket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbSetupPacket[] = {
        { "_from", (PyCFunction)_from_UsbSetupPacket, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UsbSetupPacket[] = {
        { const_cast<char*>("value"), (getter)UsbSetupPacket_get_Value, (setter)UsbSetupPacket_put_Value, nullptr, nullptr },
        { const_cast<char*>("request_type"), (getter)UsbSetupPacket_get_RequestType, (setter)UsbSetupPacket_put_RequestType, nullptr, nullptr },
        { const_cast<char*>("request"), (getter)UsbSetupPacket_get_Request, (setter)UsbSetupPacket_put_Request, nullptr, nullptr },
        { const_cast<char*>("length"), (getter)UsbSetupPacket_get_Length, (setter)UsbSetupPacket_put_Length, nullptr, nullptr },
        { const_cast<char*>("index"), (getter)UsbSetupPacket_get_Index, (setter)UsbSetupPacket_put_Index, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_UsbSetupPacket[] = 
    {
        { Py_tp_new, _new_UsbSetupPacket },
        { Py_tp_dealloc, _dealloc_UsbSetupPacket },
        { Py_tp_methods, _methods_UsbSetupPacket },
        { Py_tp_getset, _getset_UsbSetupPacket },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbSetupPacket =
    {
        "_winrt_Windows_Devices_Usb.UsbSetupPacket",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbSetupPacket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbSetupPacket
    };

    // ----- Windows.Devices.Usb Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Devices::Usb::UsbBulkInEndpointDescriptor>::python_type = py::register_python_type(module, _type_name_UsbBulkInEndpointDescriptor, &_type_spec_UsbBulkInEndpointDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbBulkInPipe>::python_type = py::register_python_type(module, _type_name_UsbBulkInPipe, &_type_spec_UsbBulkInPipe, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor>::python_type = py::register_python_type(module, _type_name_UsbBulkOutEndpointDescriptor, &_type_spec_UsbBulkOutEndpointDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbBulkOutPipe>::python_type = py::register_python_type(module, _type_name_UsbBulkOutPipe, &_type_spec_UsbBulkOutPipe, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbConfiguration>::python_type = py::register_python_type(module, _type_name_UsbConfiguration, &_type_spec_UsbConfiguration, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbConfigurationDescriptor>::python_type = py::register_python_type(module, _type_name_UsbConfigurationDescriptor, &_type_spec_UsbConfigurationDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbControlRequestType>::python_type = py::register_python_type(module, _type_name_UsbControlRequestType, &_type_spec_UsbControlRequestType, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbDescriptor>::python_type = py::register_python_type(module, _type_name_UsbDescriptor, &_type_spec_UsbDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbDevice>::python_type = py::register_python_type(module, _type_name_UsbDevice, &_type_spec_UsbDevice, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbDeviceClass>::python_type = py::register_python_type(module, _type_name_UsbDeviceClass, &_type_spec_UsbDeviceClass, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbDeviceClasses>::python_type = py::register_python_type(module, _type_name_UsbDeviceClasses, &_type_spec_UsbDeviceClasses, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbDeviceDescriptor>::python_type = py::register_python_type(module, _type_name_UsbDeviceDescriptor, &_type_spec_UsbDeviceDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbEndpointDescriptor>::python_type = py::register_python_type(module, _type_name_UsbEndpointDescriptor, &_type_spec_UsbEndpointDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbInterface>::python_type = py::register_python_type(module, _type_name_UsbInterface, &_type_spec_UsbInterface, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbInterfaceDescriptor>::python_type = py::register_python_type(module, _type_name_UsbInterfaceDescriptor, &_type_spec_UsbInterfaceDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbInterfaceSetting>::python_type = py::register_python_type(module, _type_name_UsbInterfaceSetting, &_type_spec_UsbInterfaceSetting, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor>::python_type = py::register_python_type(module, _type_name_UsbInterruptInEndpointDescriptor, &_type_spec_UsbInterruptInEndpointDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptInEventArgs>::python_type = py::register_python_type(module, _type_name_UsbInterruptInEventArgs, &_type_spec_UsbInterruptInEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptInPipe>::python_type = py::register_python_type(module, _type_name_UsbInterruptInPipe, &_type_spec_UsbInterruptInPipe, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor>::python_type = py::register_python_type(module, _type_name_UsbInterruptOutEndpointDescriptor, &_type_spec_UsbInterruptOutEndpointDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptOutPipe>::python_type = py::register_python_type(module, _type_name_UsbInterruptOutPipe, &_type_spec_UsbInterruptOutPipe, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbSetupPacket>::python_type = py::register_python_type(module, _type_name_UsbSetupPacket, &_type_spec_UsbSetupPacket, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Devices.Usb");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Devices_Usb",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Devices::Usb

PyMODINIT_FUNC
PyInit__winrt_Windows_Devices_Usb (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Devices::Usb::module_def);
}
