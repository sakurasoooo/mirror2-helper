// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.ApplicationModel.Background.h"

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::ActivitySensorTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::ApplicationTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::ApplicationTriggerDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::AppointmentStoreNotificationTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskBuilder>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundWorkCost>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::ChatMessageNotificationTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::ChatMessageReceivedNotificationTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::CommunicationBlockingAppSetAsActiveTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::ContactStoreNotificationTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::ContentPrefetchTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::ConversationalAgentTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::CustomSystemEventTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::DeviceServicingTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::DeviceUseTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::DeviceWatcherTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::EmailStoreNotificationTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::GattServiceProviderTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::GeovisitTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::LocationTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::MaintenanceTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::MediaProcessingTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::MobileBroadbandDeviceServiceNotificationTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::MobileBroadbandPcoDataChangeTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::MobileBroadbandPinLockStateChangeTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::MobileBroadbandRadioStateChangeTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::MobileBroadbandRegistrationStateChangeTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::NetworkOperatorDataUsageTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::NetworkOperatorHotspotAuthenticationTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::NetworkOperatorNotificationTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::PaymentAppCanMakePaymentTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::PhoneTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::PushNotificationTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::RcsEndUserMessageAvailableTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::RfcommConnectionTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::SecondaryAuthenticationFactorAuthenticationTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::SensorDataThresholdTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::SmartCardTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::SmsMessageReceivedTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::SocketActivityTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::StorageLibraryChangeTrackerTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::SystemCondition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::SystemTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::TetheringEntitlementCheckTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::TimeTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::ToastNotificationActionTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::ToastNotificationHistoryChangedTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::UserNotificationChangedTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundCondition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTask>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance4>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTrigger>::python_type;

namespace py::cpp::Windows::ApplicationModel::Background
{
    // ----- ActivitySensorTrigger class --------------------
    constexpr const char* const _type_name_ActivitySensorTrigger = "ActivitySensorTrigger";

    static PyObject* _new_ActivitySensorTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::ApplicationModel::Background::ActivitySensorTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ActivitySensorTrigger(py::wrapper::Windows::ApplicationModel::Background::ActivitySensorTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ActivitySensorTrigger_get_MinimumReportInterval(py::wrapper::Windows::ApplicationModel::Background::ActivitySensorTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinimumReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensorTrigger_get_ReportInterval(py::wrapper::Windows::ApplicationModel::Background::ActivitySensorTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensorTrigger_get_SubscribedActivities(py::wrapper::Windows::ApplicationModel::Background::ActivitySensorTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SubscribedActivities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivitySensorTrigger_get_SupportedActivities(py::wrapper::Windows::ApplicationModel::Background::ActivitySensorTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedActivities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ActivitySensorTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ActivitySensorTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivitySensorTrigger[] = {
        { "_from", (PyCFunction)_from_ActivitySensorTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ActivitySensorTrigger[] = {
        { const_cast<char*>("minimum_report_interval"), (getter)ActivitySensorTrigger_get_MinimumReportInterval, nullptr, nullptr, nullptr },
        { const_cast<char*>("report_interval"), (getter)ActivitySensorTrigger_get_ReportInterval, nullptr, nullptr, nullptr },
        { const_cast<char*>("subscribed_activities"), (getter)ActivitySensorTrigger_get_SubscribedActivities, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_activities"), (getter)ActivitySensorTrigger_get_SupportedActivities, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ActivitySensorTrigger[] = 
    {
        { Py_tp_new, _new_ActivitySensorTrigger },
        { Py_tp_dealloc, _dealloc_ActivitySensorTrigger },
        { Py_tp_methods, _methods_ActivitySensorTrigger },
        { Py_tp_getset, _getset_ActivitySensorTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ActivitySensorTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.ActivitySensorTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ActivitySensorTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivitySensorTrigger
    };

    // ----- ApplicationTrigger class --------------------
    constexpr const char* const _type_name_ApplicationTrigger = "ApplicationTrigger";

    static PyObject* _new_ApplicationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ApplicationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ApplicationTrigger(py::wrapper::Windows::ApplicationModel::Background::ApplicationTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ApplicationTrigger_RequestAsync(py::wrapper::Windows::ApplicationModel::Background::ApplicationTrigger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);

                return py::convert(self->obj.RequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ApplicationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ApplicationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationTrigger[] = {
        { "request_async", (PyCFunction)ApplicationTrigger_RequestAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ApplicationTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ApplicationTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ApplicationTrigger[] = 
    {
        { Py_tp_new, _new_ApplicationTrigger },
        { Py_tp_dealloc, _dealloc_ApplicationTrigger },
        { Py_tp_methods, _methods_ApplicationTrigger },
        { Py_tp_getset, _getset_ApplicationTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ApplicationTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.ApplicationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ApplicationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationTrigger
    };

    // ----- ApplicationTriggerDetails class --------------------
    constexpr const char* const _type_name_ApplicationTriggerDetails = "ApplicationTriggerDetails";

    static PyObject* _new_ApplicationTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ApplicationTriggerDetails);
        return nullptr;
    }

    static void _dealloc_ApplicationTriggerDetails(py::wrapper::Windows::ApplicationModel::Background::ApplicationTriggerDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ApplicationTriggerDetails_get_Arguments(py::wrapper::Windows::ApplicationModel::Background::ApplicationTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ApplicationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ApplicationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationTriggerDetails[] = {
        { "_from", (PyCFunction)_from_ApplicationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ApplicationTriggerDetails[] = {
        { const_cast<char*>("arguments"), (getter)ApplicationTriggerDetails_get_Arguments, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ApplicationTriggerDetails[] = 
    {
        { Py_tp_new, _new_ApplicationTriggerDetails },
        { Py_tp_dealloc, _dealloc_ApplicationTriggerDetails },
        { Py_tp_methods, _methods_ApplicationTriggerDetails },
        { Py_tp_getset, _getset_ApplicationTriggerDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ApplicationTriggerDetails =
    {
        "_winrt_Windows_ApplicationModel_Background.ApplicationTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ApplicationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationTriggerDetails
    };

    // ----- AppointmentStoreNotificationTrigger class --------------------
    constexpr const char* const _type_name_AppointmentStoreNotificationTrigger = "AppointmentStoreNotificationTrigger";

    static PyObject* _new_AppointmentStoreNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::AppointmentStoreNotificationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppointmentStoreNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::AppointmentStoreNotificationTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_AppointmentStoreNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::AppointmentStoreNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentStoreNotificationTrigger[] = {
        { "_from", (PyCFunction)_from_AppointmentStoreNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AppointmentStoreNotificationTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_AppointmentStoreNotificationTrigger[] = 
    {
        { Py_tp_new, _new_AppointmentStoreNotificationTrigger },
        { Py_tp_dealloc, _dealloc_AppointmentStoreNotificationTrigger },
        { Py_tp_methods, _methods_AppointmentStoreNotificationTrigger },
        { Py_tp_getset, _getset_AppointmentStoreNotificationTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppointmentStoreNotificationTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.AppointmentStoreNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::AppointmentStoreNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentStoreNotificationTrigger
    };

    // ----- BackgroundExecutionManager class --------------------
    constexpr const char* const _type_name_BackgroundExecutionManager = "BackgroundExecutionManager";

    static PyObject* _new_BackgroundExecutionManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BackgroundExecutionManager);
        return nullptr;
    }

    static PyObject* BackgroundExecutionManager_GetAccessStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::GetAccessStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::GetAccessStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundExecutionManager_GetAccessStatusForModernStandby(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::GetAccessStatusForModernStandby());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::GetAccessStatusForModernStandby(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundExecutionManager_RemoveAccess(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::RemoveAccess();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::RemoveAccess(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundExecutionManager_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::RequestAccessAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundExecutionManager_RequestAccessKindAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundAccessRequestKind>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::RequestAccessKindAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundExecutionManager_RequestAccessKindForModernStandbyAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundAccessRequestKind>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager::RequestAccessKindForModernStandbyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundExecutionManager[] = {
        { "get_access_status", (PyCFunction)BackgroundExecutionManager_GetAccessStatus, METH_VARARGS | METH_STATIC, nullptr },
        { "get_access_status_for_modern_standby", (PyCFunction)BackgroundExecutionManager_GetAccessStatusForModernStandby, METH_VARARGS | METH_STATIC, nullptr },
        { "remove_access", (PyCFunction)BackgroundExecutionManager_RemoveAccess, METH_VARARGS | METH_STATIC, nullptr },
        { "request_access_async", (PyCFunction)BackgroundExecutionManager_RequestAccessAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "request_access_kind_async", (PyCFunction)BackgroundExecutionManager_RequestAccessKindAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "request_access_kind_for_modern_standby_async", (PyCFunction)BackgroundExecutionManager_RequestAccessKindForModernStandbyAsync, METH_VARARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BackgroundExecutionManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_BackgroundExecutionManager[] = 
    {
        { Py_tp_new, _new_BackgroundExecutionManager },
        { Py_tp_methods, _methods_BackgroundExecutionManager },
        { Py_tp_getset, _getset_BackgroundExecutionManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BackgroundExecutionManager =
    {
        "_winrt_Windows_ApplicationModel_Background.BackgroundExecutionManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundExecutionManager
    };

    // ----- BackgroundTaskBuilder class --------------------
    constexpr const char* const _type_name_BackgroundTaskBuilder = "BackgroundTaskBuilder";

    static PyObject* _new_BackgroundTaskBuilder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::BackgroundTaskBuilder instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundTaskBuilder(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BackgroundTaskBuilder_AddCondition(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::IBackgroundCondition>(args, 0);

                self->obj.AddCondition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskBuilder_Register(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Register());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskBuilder_SetTaskEntryPointClsid(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.SetTaskEntryPointClsid(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskBuilder_SetTrigger(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::IBackgroundTrigger>(args, 0);

                self->obj.SetTrigger(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskBuilder_get_TaskEntryPoint(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TaskEntryPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTaskBuilder_put_TaskEntryPoint(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TaskEntryPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundTaskBuilder_get_Name(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTaskBuilder_put_Name(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundTaskBuilder_get_CancelOnConditionLoss(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CancelOnConditionLoss());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTaskBuilder_put_CancelOnConditionLoss(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CancelOnConditionLoss(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundTaskBuilder_get_IsNetworkRequested(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsNetworkRequested());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTaskBuilder_put_IsNetworkRequested(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsNetworkRequested(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundTaskBuilder_get_TaskGroup(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TaskGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTaskBuilder_put_TaskGroup(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup>(arg);

            self->obj.TaskGroup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_BackgroundTaskBuilder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BackgroundTaskBuilder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTaskBuilder[] = {
        { "add_condition", (PyCFunction)BackgroundTaskBuilder_AddCondition, METH_VARARGS, nullptr },
        { "register", (PyCFunction)BackgroundTaskBuilder_Register, METH_VARARGS, nullptr },
        { "set_task_entry_point_clsid", (PyCFunction)BackgroundTaskBuilder_SetTaskEntryPointClsid, METH_VARARGS, nullptr },
        { "set_trigger", (PyCFunction)BackgroundTaskBuilder_SetTrigger, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_BackgroundTaskBuilder, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BackgroundTaskBuilder[] = {
        { const_cast<char*>("task_entry_point"), (getter)BackgroundTaskBuilder_get_TaskEntryPoint, (setter)BackgroundTaskBuilder_put_TaskEntryPoint, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)BackgroundTaskBuilder_get_Name, (setter)BackgroundTaskBuilder_put_Name, nullptr, nullptr },
        { const_cast<char*>("cancel_on_condition_loss"), (getter)BackgroundTaskBuilder_get_CancelOnConditionLoss, (setter)BackgroundTaskBuilder_put_CancelOnConditionLoss, nullptr, nullptr },
        { const_cast<char*>("is_network_requested"), (getter)BackgroundTaskBuilder_get_IsNetworkRequested, (setter)BackgroundTaskBuilder_put_IsNetworkRequested, nullptr, nullptr },
        { const_cast<char*>("task_group"), (getter)BackgroundTaskBuilder_get_TaskGroup, (setter)BackgroundTaskBuilder_put_TaskGroup, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BackgroundTaskBuilder[] = 
    {
        { Py_tp_new, _new_BackgroundTaskBuilder },
        { Py_tp_dealloc, _dealloc_BackgroundTaskBuilder },
        { Py_tp_methods, _methods_BackgroundTaskBuilder },
        { Py_tp_getset, _getset_BackgroundTaskBuilder },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BackgroundTaskBuilder =
    {
        "_winrt_Windows_ApplicationModel_Background.BackgroundTaskBuilder",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskBuilder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTaskBuilder
    };

    // ----- BackgroundTaskCompletedEventArgs class --------------------
    constexpr const char* const _type_name_BackgroundTaskCompletedEventArgs = "BackgroundTaskCompletedEventArgs";

    static PyObject* _new_BackgroundTaskCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BackgroundTaskCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_BackgroundTaskCompletedEventArgs(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BackgroundTaskCompletedEventArgs_CheckResult(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.CheckResult();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskCompletedEventArgs_get_InstanceId(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BackgroundTaskCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTaskCompletedEventArgs[] = {
        { "check_result", (PyCFunction)BackgroundTaskCompletedEventArgs_CheckResult, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_BackgroundTaskCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BackgroundTaskCompletedEventArgs[] = {
        { const_cast<char*>("instance_id"), (getter)BackgroundTaskCompletedEventArgs_get_InstanceId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BackgroundTaskCompletedEventArgs[] = 
    {
        { Py_tp_new, _new_BackgroundTaskCompletedEventArgs },
        { Py_tp_dealloc, _dealloc_BackgroundTaskCompletedEventArgs },
        { Py_tp_methods, _methods_BackgroundTaskCompletedEventArgs },
        { Py_tp_getset, _getset_BackgroundTaskCompletedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BackgroundTaskCompletedEventArgs =
    {
        "_winrt_Windows_ApplicationModel_Background.BackgroundTaskCompletedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTaskCompletedEventArgs
    };

    // ----- BackgroundTaskDeferral class --------------------
    constexpr const char* const _type_name_BackgroundTaskDeferral = "BackgroundTaskDeferral";

    static PyObject* _new_BackgroundTaskDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BackgroundTaskDeferral);
        return nullptr;
    }

    static void _dealloc_BackgroundTaskDeferral(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BackgroundTaskDeferral_Complete(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_BackgroundTaskDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BackgroundTaskDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTaskDeferral[] = {
        { "complete", (PyCFunction)BackgroundTaskDeferral_Complete, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_BackgroundTaskDeferral, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BackgroundTaskDeferral[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_BackgroundTaskDeferral[] = 
    {
        { Py_tp_new, _new_BackgroundTaskDeferral },
        { Py_tp_dealloc, _dealloc_BackgroundTaskDeferral },
        { Py_tp_methods, _methods_BackgroundTaskDeferral },
        { Py_tp_getset, _getset_BackgroundTaskDeferral },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BackgroundTaskDeferral =
    {
        "_winrt_Windows_ApplicationModel_Background.BackgroundTaskDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTaskDeferral
    };

    // ----- BackgroundTaskProgressEventArgs class --------------------
    constexpr const char* const _type_name_BackgroundTaskProgressEventArgs = "BackgroundTaskProgressEventArgs";

    static PyObject* _new_BackgroundTaskProgressEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BackgroundTaskProgressEventArgs);
        return nullptr;
    }

    static void _dealloc_BackgroundTaskProgressEventArgs(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BackgroundTaskProgressEventArgs_get_InstanceId(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskProgressEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BackgroundTaskProgressEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTaskProgressEventArgs[] = {
        { "_from", (PyCFunction)_from_BackgroundTaskProgressEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BackgroundTaskProgressEventArgs[] = {
        { const_cast<char*>("instance_id"), (getter)BackgroundTaskProgressEventArgs_get_InstanceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("progress"), (getter)BackgroundTaskProgressEventArgs_get_Progress, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BackgroundTaskProgressEventArgs[] = 
    {
        { Py_tp_new, _new_BackgroundTaskProgressEventArgs },
        { Py_tp_dealloc, _dealloc_BackgroundTaskProgressEventArgs },
        { Py_tp_methods, _methods_BackgroundTaskProgressEventArgs },
        { Py_tp_getset, _getset_BackgroundTaskProgressEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BackgroundTaskProgressEventArgs =
    {
        "_winrt_Windows_ApplicationModel_Background.BackgroundTaskProgressEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTaskProgressEventArgs
    };

    // ----- BackgroundTaskRegistration class --------------------
    constexpr const char* const _type_name_BackgroundTaskRegistration = "BackgroundTaskRegistration";

    static PyObject* _new_BackgroundTaskRegistration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BackgroundTaskRegistration);
        return nullptr;
    }

    static void _dealloc_BackgroundTaskRegistration(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BackgroundTaskRegistration_GetTaskGroup(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistration::GetTaskGroup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_Unregister(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.Unregister(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_get_Name(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_get_TaskId(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_get_Trigger(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Trigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_get_TaskGroup(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TaskGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_get_AllTasks(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistration::AllTasks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_get_AllTaskGroups(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistration::AllTaskGroups());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_add_Completed(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventHandler>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_remove_Completed(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_add_Progress(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventHandler>(arg);

            return py::convert(self->obj.Progress(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistration_remove_Progress(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Progress(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BackgroundTaskRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTaskRegistration[] = {
        { "get_task_group", (PyCFunction)BackgroundTaskRegistration_GetTaskGroup, METH_VARARGS | METH_STATIC, nullptr },
        { "unregister", (PyCFunction)BackgroundTaskRegistration_Unregister, METH_VARARGS, nullptr },
        { "get_all_tasks", (PyCFunction)BackgroundTaskRegistration_get_AllTasks, METH_NOARGS | METH_STATIC, nullptr },
        { "get_all_task_groups", (PyCFunction)BackgroundTaskRegistration_get_AllTaskGroups, METH_NOARGS | METH_STATIC, nullptr },
        { "add_completed", (PyCFunction)BackgroundTaskRegistration_add_Completed, METH_O, nullptr },
        { "remove_completed", (PyCFunction)BackgroundTaskRegistration_remove_Completed, METH_O, nullptr },
        { "add_progress", (PyCFunction)BackgroundTaskRegistration_add_Progress, METH_O, nullptr },
        { "remove_progress", (PyCFunction)BackgroundTaskRegistration_remove_Progress, METH_O, nullptr },
        { "_from", (PyCFunction)_from_BackgroundTaskRegistration, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BackgroundTaskRegistration[] = {
        { const_cast<char*>("name"), (getter)BackgroundTaskRegistration_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("task_id"), (getter)BackgroundTaskRegistration_get_TaskId, nullptr, nullptr, nullptr },
        { const_cast<char*>("trigger"), (getter)BackgroundTaskRegistration_get_Trigger, nullptr, nullptr, nullptr },
        { const_cast<char*>("task_group"), (getter)BackgroundTaskRegistration_get_TaskGroup, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BackgroundTaskRegistration[] = 
    {
        { Py_tp_new, _new_BackgroundTaskRegistration },
        { Py_tp_dealloc, _dealloc_BackgroundTaskRegistration },
        { Py_tp_methods, _methods_BackgroundTaskRegistration },
        { Py_tp_getset, _getset_BackgroundTaskRegistration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BackgroundTaskRegistration =
    {
        "_winrt_Windows_ApplicationModel_Background.BackgroundTaskRegistration",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTaskRegistration
    };

    // ----- BackgroundTaskRegistrationGroup class --------------------
    constexpr const char* const _type_name_BackgroundTaskRegistrationGroup = "BackgroundTaskRegistrationGroup";

    static PyObject* _new_BackgroundTaskRegistrationGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundTaskRegistrationGroup(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BackgroundTaskRegistrationGroup_get_AllTasks(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllTasks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistrationGroup_get_Id(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistrationGroup_get_Name(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistrationGroup_add_BackgroundActivated(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup, winrt::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs>>(arg);

            return py::convert(self->obj.BackgroundActivated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTaskRegistrationGroup_remove_BackgroundActivated(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BackgroundActivated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BackgroundTaskRegistrationGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTaskRegistrationGroup[] = {
        { "add_background_activated", (PyCFunction)BackgroundTaskRegistrationGroup_add_BackgroundActivated, METH_O, nullptr },
        { "remove_background_activated", (PyCFunction)BackgroundTaskRegistrationGroup_remove_BackgroundActivated, METH_O, nullptr },
        { "_from", (PyCFunction)_from_BackgroundTaskRegistrationGroup, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BackgroundTaskRegistrationGroup[] = {
        { const_cast<char*>("all_tasks"), (getter)BackgroundTaskRegistrationGroup_get_AllTasks, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)BackgroundTaskRegistrationGroup_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)BackgroundTaskRegistrationGroup_get_Name, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BackgroundTaskRegistrationGroup[] = 
    {
        { Py_tp_new, _new_BackgroundTaskRegistrationGroup },
        { Py_tp_dealloc, _dealloc_BackgroundTaskRegistrationGroup },
        { Py_tp_methods, _methods_BackgroundTaskRegistrationGroup },
        { Py_tp_getset, _getset_BackgroundTaskRegistrationGroup },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BackgroundTaskRegistrationGroup =
    {
        "_winrt_Windows_ApplicationModel_Background.BackgroundTaskRegistrationGroup",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTaskRegistrationGroup
    };

    // ----- BackgroundWorkCost class --------------------
    constexpr const char* const _type_name_BackgroundWorkCost = "BackgroundWorkCost";

    static PyObject* _new_BackgroundWorkCost(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BackgroundWorkCost);
        return nullptr;
    }

    static PyObject* BackgroundWorkCost_get_CurrentBackgroundWorkCost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Background::BackgroundWorkCost::CurrentBackgroundWorkCost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundWorkCost[] = {
        { "get_current_background_work_cost", (PyCFunction)BackgroundWorkCost_get_CurrentBackgroundWorkCost, METH_NOARGS | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BackgroundWorkCost[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_BackgroundWorkCost[] = 
    {
        { Py_tp_new, _new_BackgroundWorkCost },
        { Py_tp_methods, _methods_BackgroundWorkCost },
        { Py_tp_getset, _getset_BackgroundWorkCost },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BackgroundWorkCost =
    {
        "_winrt_Windows_ApplicationModel_Background.BackgroundWorkCost",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundWorkCost
    };

    // ----- BluetoothLEAdvertisementPublisherTrigger class --------------------
    constexpr const char* const _type_name_BluetoothLEAdvertisementPublisherTrigger = "BluetoothLEAdvertisementPublisherTrigger";

    static PyObject* _new_BluetoothLEAdvertisementPublisherTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BluetoothLEAdvertisementPublisherTrigger(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BluetoothLEAdvertisementPublisherTrigger_get_Advertisement(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Advertisement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisherTrigger_get_UseExtendedFormat(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UseExtendedFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementPublisherTrigger_put_UseExtendedFormat(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.UseExtendedFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisherTrigger_get_PreferredTransmitPowerLevelInDBm(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreferredTransmitPowerLevelInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementPublisherTrigger_put_PreferredTransmitPowerLevelInDBm(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int16_t>>(arg);

            self->obj.PreferredTransmitPowerLevelInDBm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisherTrigger_get_IsAnonymous(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAnonymous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementPublisherTrigger_put_IsAnonymous(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAnonymous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementPublisherTrigger_get_IncludeTransmitPowerLevel(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IncludeTransmitPowerLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementPublisherTrigger_put_IncludeTransmitPowerLevel(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeTransmitPowerLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_BluetoothLEAdvertisementPublisherTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAdvertisementPublisherTrigger[] = {
        { "_from", (PyCFunction)_from_BluetoothLEAdvertisementPublisherTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BluetoothLEAdvertisementPublisherTrigger[] = {
        { const_cast<char*>("advertisement"), (getter)BluetoothLEAdvertisementPublisherTrigger_get_Advertisement, nullptr, nullptr, nullptr },
        { const_cast<char*>("use_extended_format"), (getter)BluetoothLEAdvertisementPublisherTrigger_get_UseExtendedFormat, (setter)BluetoothLEAdvertisementPublisherTrigger_put_UseExtendedFormat, nullptr, nullptr },
        { const_cast<char*>("preferred_transmit_power_level_in_d_bm"), (getter)BluetoothLEAdvertisementPublisherTrigger_get_PreferredTransmitPowerLevelInDBm, (setter)BluetoothLEAdvertisementPublisherTrigger_put_PreferredTransmitPowerLevelInDBm, nullptr, nullptr },
        { const_cast<char*>("is_anonymous"), (getter)BluetoothLEAdvertisementPublisherTrigger_get_IsAnonymous, (setter)BluetoothLEAdvertisementPublisherTrigger_put_IsAnonymous, nullptr, nullptr },
        { const_cast<char*>("include_transmit_power_level"), (getter)BluetoothLEAdvertisementPublisherTrigger_get_IncludeTransmitPowerLevel, (setter)BluetoothLEAdvertisementPublisherTrigger_put_IncludeTransmitPowerLevel, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BluetoothLEAdvertisementPublisherTrigger[] = 
    {
        { Py_tp_new, _new_BluetoothLEAdvertisementPublisherTrigger },
        { Py_tp_dealloc, _dealloc_BluetoothLEAdvertisementPublisherTrigger },
        { Py_tp_methods, _methods_BluetoothLEAdvertisementPublisherTrigger },
        { Py_tp_getset, _getset_BluetoothLEAdvertisementPublisherTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BluetoothLEAdvertisementPublisherTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.BluetoothLEAdvertisementPublisherTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAdvertisementPublisherTrigger
    };

    // ----- BluetoothLEAdvertisementWatcherTrigger class --------------------
    constexpr const char* const _type_name_BluetoothLEAdvertisementWatcherTrigger = "BluetoothLEAdvertisementWatcherTrigger";

    static PyObject* _new_BluetoothLEAdvertisementWatcherTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BluetoothLEAdvertisementWatcherTrigger(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BluetoothLEAdvertisementWatcherTrigger_get_SignalStrengthFilter(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignalStrengthFilter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementWatcherTrigger_put_SignalStrengthFilter(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter>(arg);

            self->obj.SignalStrengthFilter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcherTrigger_get_AdvertisementFilter(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdvertisementFilter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementWatcherTrigger_put_AdvertisementFilter(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::Advertisement::BluetoothLEAdvertisementFilter>(arg);

            self->obj.AdvertisementFilter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcherTrigger_get_MaxOutOfRangeTimeout(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxOutOfRangeTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcherTrigger_get_MaxSamplingInterval(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxSamplingInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcherTrigger_get_MinOutOfRangeTimeout(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinOutOfRangeTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcherTrigger_get_MinSamplingInterval(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinSamplingInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAdvertisementWatcherTrigger_get_AllowExtendedAdvertisements(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowExtendedAdvertisements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothLEAdvertisementWatcherTrigger_put_AllowExtendedAdvertisements(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowExtendedAdvertisements(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_BluetoothLEAdvertisementWatcherTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAdvertisementWatcherTrigger[] = {
        { "_from", (PyCFunction)_from_BluetoothLEAdvertisementWatcherTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_BluetoothLEAdvertisementWatcherTrigger[] = {
        { const_cast<char*>("signal_strength_filter"), (getter)BluetoothLEAdvertisementWatcherTrigger_get_SignalStrengthFilter, (setter)BluetoothLEAdvertisementWatcherTrigger_put_SignalStrengthFilter, nullptr, nullptr },
        { const_cast<char*>("advertisement_filter"), (getter)BluetoothLEAdvertisementWatcherTrigger_get_AdvertisementFilter, (setter)BluetoothLEAdvertisementWatcherTrigger_put_AdvertisementFilter, nullptr, nullptr },
        { const_cast<char*>("max_out_of_range_timeout"), (getter)BluetoothLEAdvertisementWatcherTrigger_get_MaxOutOfRangeTimeout, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_sampling_interval"), (getter)BluetoothLEAdvertisementWatcherTrigger_get_MaxSamplingInterval, nullptr, nullptr, nullptr },
        { const_cast<char*>("min_out_of_range_timeout"), (getter)BluetoothLEAdvertisementWatcherTrigger_get_MinOutOfRangeTimeout, nullptr, nullptr, nullptr },
        { const_cast<char*>("min_sampling_interval"), (getter)BluetoothLEAdvertisementWatcherTrigger_get_MinSamplingInterval, nullptr, nullptr, nullptr },
        { const_cast<char*>("allow_extended_advertisements"), (getter)BluetoothLEAdvertisementWatcherTrigger_get_AllowExtendedAdvertisements, (setter)BluetoothLEAdvertisementWatcherTrigger_put_AllowExtendedAdvertisements, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_BluetoothLEAdvertisementWatcherTrigger[] = 
    {
        { Py_tp_new, _new_BluetoothLEAdvertisementWatcherTrigger },
        { Py_tp_dealloc, _dealloc_BluetoothLEAdvertisementWatcherTrigger },
        { Py_tp_methods, _methods_BluetoothLEAdvertisementWatcherTrigger },
        { Py_tp_getset, _getset_BluetoothLEAdvertisementWatcherTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BluetoothLEAdvertisementWatcherTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.BluetoothLEAdvertisementWatcherTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAdvertisementWatcherTrigger
    };

    // ----- CachedFileUpdaterTrigger class --------------------
    constexpr const char* const _type_name_CachedFileUpdaterTrigger = "CachedFileUpdaterTrigger";

    static PyObject* _new_CachedFileUpdaterTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CachedFileUpdaterTrigger(py::wrapper::Windows::ApplicationModel::Background::CachedFileUpdaterTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_CachedFileUpdaterTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileUpdaterTrigger[] = {
        { "_from", (PyCFunction)_from_CachedFileUpdaterTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CachedFileUpdaterTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_CachedFileUpdaterTrigger[] = 
    {
        { Py_tp_new, _new_CachedFileUpdaterTrigger },
        { Py_tp_dealloc, _dealloc_CachedFileUpdaterTrigger },
        { Py_tp_methods, _methods_CachedFileUpdaterTrigger },
        { Py_tp_getset, _getset_CachedFileUpdaterTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CachedFileUpdaterTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.CachedFileUpdaterTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::CachedFileUpdaterTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileUpdaterTrigger
    };

    // ----- CachedFileUpdaterTriggerDetails class --------------------
    constexpr const char* const _type_name_CachedFileUpdaterTriggerDetails = "CachedFileUpdaterTriggerDetails";

    static PyObject* _new_CachedFileUpdaterTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CachedFileUpdaterTriggerDetails);
        return nullptr;
    }

    static void _dealloc_CachedFileUpdaterTriggerDetails(py::wrapper::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CachedFileUpdaterTriggerDetails_get_CanRequestUserInput(py::wrapper::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanRequestUserInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterTriggerDetails_get_UpdateRequest(py::wrapper::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateRequest());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterTriggerDetails_get_UpdateTarget(py::wrapper::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CachedFileUpdaterTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileUpdaterTriggerDetails[] = {
        { "_from", (PyCFunction)_from_CachedFileUpdaterTriggerDetails, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CachedFileUpdaterTriggerDetails[] = {
        { const_cast<char*>("can_request_user_input"), (getter)CachedFileUpdaterTriggerDetails_get_CanRequestUserInput, nullptr, nullptr, nullptr },
        { const_cast<char*>("update_request"), (getter)CachedFileUpdaterTriggerDetails_get_UpdateRequest, nullptr, nullptr, nullptr },
        { const_cast<char*>("update_target"), (getter)CachedFileUpdaterTriggerDetails_get_UpdateTarget, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CachedFileUpdaterTriggerDetails[] = 
    {
        { Py_tp_new, _new_CachedFileUpdaterTriggerDetails },
        { Py_tp_dealloc, _dealloc_CachedFileUpdaterTriggerDetails },
        { Py_tp_methods, _methods_CachedFileUpdaterTriggerDetails },
        { Py_tp_getset, _getset_CachedFileUpdaterTriggerDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CachedFileUpdaterTriggerDetails =
    {
        "_winrt_Windows_ApplicationModel_Background.CachedFileUpdaterTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileUpdaterTriggerDetails
    };

    // ----- ChatMessageNotificationTrigger class --------------------
    constexpr const char* const _type_name_ChatMessageNotificationTrigger = "ChatMessageNotificationTrigger";

    static PyObject* _new_ChatMessageNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ChatMessageNotificationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatMessageNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::ChatMessageNotificationTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ChatMessageNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ChatMessageNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageNotificationTrigger[] = {
        { "_from", (PyCFunction)_from_ChatMessageNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatMessageNotificationTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatMessageNotificationTrigger[] = 
    {
        { Py_tp_new, _new_ChatMessageNotificationTrigger },
        { Py_tp_dealloc, _dealloc_ChatMessageNotificationTrigger },
        { Py_tp_methods, _methods_ChatMessageNotificationTrigger },
        { Py_tp_getset, _getset_ChatMessageNotificationTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatMessageNotificationTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.ChatMessageNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ChatMessageNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageNotificationTrigger
    };

    // ----- ChatMessageReceivedNotificationTrigger class --------------------
    constexpr const char* const _type_name_ChatMessageReceivedNotificationTrigger = "ChatMessageReceivedNotificationTrigger";

    static PyObject* _new_ChatMessageReceivedNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ChatMessageReceivedNotificationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatMessageReceivedNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::ChatMessageReceivedNotificationTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ChatMessageReceivedNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ChatMessageReceivedNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageReceivedNotificationTrigger[] = {
        { "_from", (PyCFunction)_from_ChatMessageReceivedNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ChatMessageReceivedNotificationTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ChatMessageReceivedNotificationTrigger[] = 
    {
        { Py_tp_new, _new_ChatMessageReceivedNotificationTrigger },
        { Py_tp_dealloc, _dealloc_ChatMessageReceivedNotificationTrigger },
        { Py_tp_methods, _methods_ChatMessageReceivedNotificationTrigger },
        { Py_tp_getset, _getset_ChatMessageReceivedNotificationTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ChatMessageReceivedNotificationTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.ChatMessageReceivedNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ChatMessageReceivedNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageReceivedNotificationTrigger
    };

    // ----- CommunicationBlockingAppSetAsActiveTrigger class --------------------
    constexpr const char* const _type_name_CommunicationBlockingAppSetAsActiveTrigger = "CommunicationBlockingAppSetAsActiveTrigger";

    static PyObject* _new_CommunicationBlockingAppSetAsActiveTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::CommunicationBlockingAppSetAsActiveTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CommunicationBlockingAppSetAsActiveTrigger(py::wrapper::Windows::ApplicationModel::Background::CommunicationBlockingAppSetAsActiveTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_CommunicationBlockingAppSetAsActiveTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::CommunicationBlockingAppSetAsActiveTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommunicationBlockingAppSetAsActiveTrigger[] = {
        { "_from", (PyCFunction)_from_CommunicationBlockingAppSetAsActiveTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CommunicationBlockingAppSetAsActiveTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_CommunicationBlockingAppSetAsActiveTrigger[] = 
    {
        { Py_tp_new, _new_CommunicationBlockingAppSetAsActiveTrigger },
        { Py_tp_dealloc, _dealloc_CommunicationBlockingAppSetAsActiveTrigger },
        { Py_tp_methods, _methods_CommunicationBlockingAppSetAsActiveTrigger },
        { Py_tp_getset, _getset_CommunicationBlockingAppSetAsActiveTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CommunicationBlockingAppSetAsActiveTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.CommunicationBlockingAppSetAsActiveTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::CommunicationBlockingAppSetAsActiveTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommunicationBlockingAppSetAsActiveTrigger
    };

    // ----- ContactStoreNotificationTrigger class --------------------
    constexpr const char* const _type_name_ContactStoreNotificationTrigger = "ContactStoreNotificationTrigger";

    static PyObject* _new_ContactStoreNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ContactStoreNotificationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactStoreNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::ContactStoreNotificationTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ContactStoreNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ContactStoreNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactStoreNotificationTrigger[] = {
        { "_from", (PyCFunction)_from_ContactStoreNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContactStoreNotificationTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ContactStoreNotificationTrigger[] = 
    {
        { Py_tp_new, _new_ContactStoreNotificationTrigger },
        { Py_tp_dealloc, _dealloc_ContactStoreNotificationTrigger },
        { Py_tp_methods, _methods_ContactStoreNotificationTrigger },
        { Py_tp_getset, _getset_ContactStoreNotificationTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContactStoreNotificationTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.ContactStoreNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ContactStoreNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactStoreNotificationTrigger
    };

    // ----- ContentPrefetchTrigger class --------------------
    constexpr const char* const _type_name_ContentPrefetchTrigger = "ContentPrefetchTrigger";

    static PyObject* _new_ContentPrefetchTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                winrt::Windows::ApplicationModel::Background::ContentPrefetchTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ContentPrefetchTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContentPrefetchTrigger(py::wrapper::Windows::ApplicationModel::Background::ContentPrefetchTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContentPrefetchTrigger_get_WaitInterval(py::wrapper::Windows::ApplicationModel::Background::ContentPrefetchTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WaitInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContentPrefetchTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ContentPrefetchTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentPrefetchTrigger[] = {
        { "_from", (PyCFunction)_from_ContentPrefetchTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ContentPrefetchTrigger[] = {
        { const_cast<char*>("wait_interval"), (getter)ContentPrefetchTrigger_get_WaitInterval, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ContentPrefetchTrigger[] = 
    {
        { Py_tp_new, _new_ContentPrefetchTrigger },
        { Py_tp_dealloc, _dealloc_ContentPrefetchTrigger },
        { Py_tp_methods, _methods_ContentPrefetchTrigger },
        { Py_tp_getset, _getset_ContentPrefetchTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ContentPrefetchTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.ContentPrefetchTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ContentPrefetchTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentPrefetchTrigger
    };

    // ----- ConversationalAgentTrigger class --------------------
    constexpr const char* const _type_name_ConversationalAgentTrigger = "ConversationalAgentTrigger";

    static PyObject* _new_ConversationalAgentTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ConversationalAgentTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ConversationalAgentTrigger(py::wrapper::Windows::ApplicationModel::Background::ConversationalAgentTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ConversationalAgentTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ConversationalAgentTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentTrigger[] = {
        { "_from", (PyCFunction)_from_ConversationalAgentTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ConversationalAgentTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ConversationalAgentTrigger[] = 
    {
        { Py_tp_new, _new_ConversationalAgentTrigger },
        { Py_tp_dealloc, _dealloc_ConversationalAgentTrigger },
        { Py_tp_methods, _methods_ConversationalAgentTrigger },
        { Py_tp_getset, _getset_ConversationalAgentTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConversationalAgentTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.ConversationalAgentTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ConversationalAgentTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentTrigger
    };

    // ----- CustomSystemEventTrigger class --------------------
    constexpr const char* const _type_name_CustomSystemEventTrigger = "CustomSystemEventTrigger";

    static PyObject* _new_CustomSystemEventTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Background::CustomSystemEventTriggerRecurrence>(args, 1);

                winrt::Windows::ApplicationModel::Background::CustomSystemEventTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CustomSystemEventTrigger(py::wrapper::Windows::ApplicationModel::Background::CustomSystemEventTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CustomSystemEventTrigger_get_Recurrence(py::wrapper::Windows::ApplicationModel::Background::CustomSystemEventTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Recurrence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CustomSystemEventTrigger_get_TriggerId(py::wrapper::Windows::ApplicationModel::Background::CustomSystemEventTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TriggerId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CustomSystemEventTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::CustomSystemEventTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CustomSystemEventTrigger[] = {
        { "_from", (PyCFunction)_from_CustomSystemEventTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CustomSystemEventTrigger[] = {
        { const_cast<char*>("recurrence"), (getter)CustomSystemEventTrigger_get_Recurrence, nullptr, nullptr, nullptr },
        { const_cast<char*>("trigger_id"), (getter)CustomSystemEventTrigger_get_TriggerId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CustomSystemEventTrigger[] = 
    {
        { Py_tp_new, _new_CustomSystemEventTrigger },
        { Py_tp_dealloc, _dealloc_CustomSystemEventTrigger },
        { Py_tp_methods, _methods_CustomSystemEventTrigger },
        { Py_tp_getset, _getset_CustomSystemEventTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CustomSystemEventTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.CustomSystemEventTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::CustomSystemEventTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CustomSystemEventTrigger
    };

    // ----- DeviceConnectionChangeTrigger class --------------------
    constexpr const char* const _type_name_DeviceConnectionChangeTrigger = "DeviceConnectionChangeTrigger";

    static PyObject* _new_DeviceConnectionChangeTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DeviceConnectionChangeTrigger);
        return nullptr;
    }

    static void _dealloc_DeviceConnectionChangeTrigger(py::wrapper::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeviceConnectionChangeTrigger_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DeviceConnectionChangeTrigger_get_MaintainConnection(py::wrapper::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaintainConnection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeviceConnectionChangeTrigger_put_MaintainConnection(py::wrapper::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.MaintainConnection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeviceConnectionChangeTrigger_get_CanMaintainConnection(py::wrapper::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanMaintainConnection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceConnectionChangeTrigger_get_DeviceId(py::wrapper::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DeviceConnectionChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceConnectionChangeTrigger[] = {
        { "from_id_async", (PyCFunction)DeviceConnectionChangeTrigger_FromIdAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_DeviceConnectionChangeTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeviceConnectionChangeTrigger[] = {
        { const_cast<char*>("maintain_connection"), (getter)DeviceConnectionChangeTrigger_get_MaintainConnection, (setter)DeviceConnectionChangeTrigger_put_MaintainConnection, nullptr, nullptr },
        { const_cast<char*>("can_maintain_connection"), (getter)DeviceConnectionChangeTrigger_get_CanMaintainConnection, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)DeviceConnectionChangeTrigger_get_DeviceId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DeviceConnectionChangeTrigger[] = 
    {
        { Py_tp_new, _new_DeviceConnectionChangeTrigger },
        { Py_tp_dealloc, _dealloc_DeviceConnectionChangeTrigger },
        { Py_tp_methods, _methods_DeviceConnectionChangeTrigger },
        { Py_tp_getset, _getset_DeviceConnectionChangeTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeviceConnectionChangeTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.DeviceConnectionChangeTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceConnectionChangeTrigger
    };

    // ----- DeviceManufacturerNotificationTrigger class --------------------
    constexpr const char* const _type_name_DeviceManufacturerNotificationTrigger = "DeviceManufacturerNotificationTrigger";

    static PyObject* _new_DeviceManufacturerNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DeviceManufacturerNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeviceManufacturerNotificationTrigger_get_OneShot(py::wrapper::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OneShot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceManufacturerNotificationTrigger_get_TriggerQualifier(py::wrapper::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TriggerQualifier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DeviceManufacturerNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceManufacturerNotificationTrigger[] = {
        { "_from", (PyCFunction)_from_DeviceManufacturerNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeviceManufacturerNotificationTrigger[] = {
        { const_cast<char*>("one_shot"), (getter)DeviceManufacturerNotificationTrigger_get_OneShot, nullptr, nullptr, nullptr },
        { const_cast<char*>("trigger_qualifier"), (getter)DeviceManufacturerNotificationTrigger_get_TriggerQualifier, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DeviceManufacturerNotificationTrigger[] = 
    {
        { Py_tp_new, _new_DeviceManufacturerNotificationTrigger },
        { Py_tp_dealloc, _dealloc_DeviceManufacturerNotificationTrigger },
        { Py_tp_methods, _methods_DeviceManufacturerNotificationTrigger },
        { Py_tp_getset, _getset_DeviceManufacturerNotificationTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeviceManufacturerNotificationTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.DeviceManufacturerNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceManufacturerNotificationTrigger
    };

    // ----- DeviceServicingTrigger class --------------------
    constexpr const char* const _type_name_DeviceServicingTrigger = "DeviceServicingTrigger";

    static PyObject* _new_DeviceServicingTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::DeviceServicingTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DeviceServicingTrigger(py::wrapper::Windows::ApplicationModel::Background::DeviceServicingTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeviceServicingTrigger_RequestAsync(py::wrapper::Windows::ApplicationModel::Background::DeviceServicingTrigger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(self->obj.RequestAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.RequestAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_DeviceServicingTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::DeviceServicingTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceServicingTrigger[] = {
        { "request_async", (PyCFunction)DeviceServicingTrigger_RequestAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DeviceServicingTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeviceServicingTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_DeviceServicingTrigger[] = 
    {
        { Py_tp_new, _new_DeviceServicingTrigger },
        { Py_tp_dealloc, _dealloc_DeviceServicingTrigger },
        { Py_tp_methods, _methods_DeviceServicingTrigger },
        { Py_tp_getset, _getset_DeviceServicingTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeviceServicingTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.DeviceServicingTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::DeviceServicingTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceServicingTrigger
    };

    // ----- DeviceUseTrigger class --------------------
    constexpr const char* const _type_name_DeviceUseTrigger = "DeviceUseTrigger";

    static PyObject* _new_DeviceUseTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::DeviceUseTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DeviceUseTrigger(py::wrapper::Windows::ApplicationModel::Background::DeviceUseTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeviceUseTrigger_RequestAsync(py::wrapper::Windows::ApplicationModel::Background::DeviceUseTrigger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.RequestAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_DeviceUseTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::DeviceUseTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceUseTrigger[] = {
        { "request_async", (PyCFunction)DeviceUseTrigger_RequestAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DeviceUseTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeviceUseTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_DeviceUseTrigger[] = 
    {
        { Py_tp_new, _new_DeviceUseTrigger },
        { Py_tp_dealloc, _dealloc_DeviceUseTrigger },
        { Py_tp_methods, _methods_DeviceUseTrigger },
        { Py_tp_getset, _getset_DeviceUseTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeviceUseTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.DeviceUseTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::DeviceUseTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceUseTrigger
    };

    // ----- DeviceWatcherTrigger class --------------------
    constexpr const char* const _type_name_DeviceWatcherTrigger = "DeviceWatcherTrigger";

    static PyObject* _new_DeviceWatcherTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DeviceWatcherTrigger);
        return nullptr;
    }

    static void _dealloc_DeviceWatcherTrigger(py::wrapper::Windows::ApplicationModel::Background::DeviceWatcherTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_DeviceWatcherTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::DeviceWatcherTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceWatcherTrigger[] = {
        { "_from", (PyCFunction)_from_DeviceWatcherTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DeviceWatcherTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_DeviceWatcherTrigger[] = 
    {
        { Py_tp_new, _new_DeviceWatcherTrigger },
        { Py_tp_dealloc, _dealloc_DeviceWatcherTrigger },
        { Py_tp_methods, _methods_DeviceWatcherTrigger },
        { Py_tp_getset, _getset_DeviceWatcherTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeviceWatcherTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.DeviceWatcherTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::DeviceWatcherTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceWatcherTrigger
    };

    // ----- EmailStoreNotificationTrigger class --------------------
    constexpr const char* const _type_name_EmailStoreNotificationTrigger = "EmailStoreNotificationTrigger";

    static PyObject* _new_EmailStoreNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::EmailStoreNotificationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailStoreNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::EmailStoreNotificationTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_EmailStoreNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::EmailStoreNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailStoreNotificationTrigger[] = {
        { "_from", (PyCFunction)_from_EmailStoreNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_EmailStoreNotificationTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_EmailStoreNotificationTrigger[] = 
    {
        { Py_tp_new, _new_EmailStoreNotificationTrigger },
        { Py_tp_dealloc, _dealloc_EmailStoreNotificationTrigger },
        { Py_tp_methods, _methods_EmailStoreNotificationTrigger },
        { Py_tp_getset, _getset_EmailStoreNotificationTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EmailStoreNotificationTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.EmailStoreNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::EmailStoreNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailStoreNotificationTrigger
    };

    // ----- GattCharacteristicNotificationTrigger class --------------------
    constexpr const char* const _type_name_GattCharacteristicNotificationTrigger = "GattCharacteristicNotificationTrigger";

    static PyObject* _new_GattCharacteristicNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::Background::BluetoothEventTriggeringMode>(args, 1);

                winrt::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattCharacteristic>(args, 0);

                winrt::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GattCharacteristicNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GattCharacteristicNotificationTrigger_get_Characteristic(py::wrapper::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Characteristic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattCharacteristicNotificationTrigger_get_EventTriggeringMode(py::wrapper::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EventTriggeringMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GattCharacteristicNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattCharacteristicNotificationTrigger[] = {
        { "_from", (PyCFunction)_from_GattCharacteristicNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GattCharacteristicNotificationTrigger[] = {
        { const_cast<char*>("characteristic"), (getter)GattCharacteristicNotificationTrigger_get_Characteristic, nullptr, nullptr, nullptr },
        { const_cast<char*>("event_triggering_mode"), (getter)GattCharacteristicNotificationTrigger_get_EventTriggeringMode, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GattCharacteristicNotificationTrigger[] = 
    {
        { Py_tp_new, _new_GattCharacteristicNotificationTrigger },
        { Py_tp_dealloc, _dealloc_GattCharacteristicNotificationTrigger },
        { Py_tp_methods, _methods_GattCharacteristicNotificationTrigger },
        { Py_tp_getset, _getset_GattCharacteristicNotificationTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GattCharacteristicNotificationTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.GattCharacteristicNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattCharacteristicNotificationTrigger
    };

    // ----- GattServiceProviderTrigger class --------------------
    constexpr const char* const _type_name_GattServiceProviderTrigger = "GattServiceProviderTrigger";

    static PyObject* _new_GattServiceProviderTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GattServiceProviderTrigger);
        return nullptr;
    }

    static void _dealloc_GattServiceProviderTrigger(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GattServiceProviderTrigger_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Background::GattServiceProviderTrigger::CreateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GattServiceProviderTrigger_get_AdvertisingParameters(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdvertisingParameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GattServiceProviderTrigger_put_AdvertisingParameters(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::GenericAttributeProfile::GattServiceProviderAdvertisingParameters>(arg);

            self->obj.AdvertisingParameters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GattServiceProviderTrigger_get_Service(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Service());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceProviderTrigger_get_TriggerId(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TriggerId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GattServiceProviderTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::GattServiceProviderTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattServiceProviderTrigger[] = {
        { "create_async", (PyCFunction)GattServiceProviderTrigger_CreateAsync, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_GattServiceProviderTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GattServiceProviderTrigger[] = {
        { const_cast<char*>("advertising_parameters"), (getter)GattServiceProviderTrigger_get_AdvertisingParameters, (setter)GattServiceProviderTrigger_put_AdvertisingParameters, nullptr, nullptr },
        { const_cast<char*>("service"), (getter)GattServiceProviderTrigger_get_Service, nullptr, nullptr, nullptr },
        { const_cast<char*>("trigger_id"), (getter)GattServiceProviderTrigger_get_TriggerId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GattServiceProviderTrigger[] = 
    {
        { Py_tp_new, _new_GattServiceProviderTrigger },
        { Py_tp_dealloc, _dealloc_GattServiceProviderTrigger },
        { Py_tp_methods, _methods_GattServiceProviderTrigger },
        { Py_tp_getset, _getset_GattServiceProviderTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GattServiceProviderTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.GattServiceProviderTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattServiceProviderTrigger
    };

    // ----- GattServiceProviderTriggerResult class --------------------
    constexpr const char* const _type_name_GattServiceProviderTriggerResult = "GattServiceProviderTriggerResult";

    static PyObject* _new_GattServiceProviderTriggerResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GattServiceProviderTriggerResult);
        return nullptr;
    }

    static void _dealloc_GattServiceProviderTriggerResult(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GattServiceProviderTriggerResult_get_Error(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GattServiceProviderTriggerResult_get_Trigger(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Trigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GattServiceProviderTriggerResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GattServiceProviderTriggerResult[] = {
        { "_from", (PyCFunction)_from_GattServiceProviderTriggerResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GattServiceProviderTriggerResult[] = {
        { const_cast<char*>("error"), (getter)GattServiceProviderTriggerResult_get_Error, nullptr, nullptr, nullptr },
        { const_cast<char*>("trigger"), (getter)GattServiceProviderTriggerResult_get_Trigger, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GattServiceProviderTriggerResult[] = 
    {
        { Py_tp_new, _new_GattServiceProviderTriggerResult },
        { Py_tp_dealloc, _dealloc_GattServiceProviderTriggerResult },
        { Py_tp_methods, _methods_GattServiceProviderTriggerResult },
        { Py_tp_getset, _getset_GattServiceProviderTriggerResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GattServiceProviderTriggerResult =
    {
        "_winrt_Windows_ApplicationModel_Background.GattServiceProviderTriggerResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GattServiceProviderTriggerResult
    };

    // ----- GeovisitTrigger class --------------------
    constexpr const char* const _type_name_GeovisitTrigger = "GeovisitTrigger";

    static PyObject* _new_GeovisitTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::GeovisitTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GeovisitTrigger(py::wrapper::Windows::ApplicationModel::Background::GeovisitTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GeovisitTrigger_get_MonitoringScope(py::wrapper::Windows::ApplicationModel::Background::GeovisitTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MonitoringScope());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GeovisitTrigger_put_MonitoringScope(py::wrapper::Windows::ApplicationModel::Background::GeovisitTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::VisitMonitoringScope>(arg);

            self->obj.MonitoringScope(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_GeovisitTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::GeovisitTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GeovisitTrigger[] = {
        { "_from", (PyCFunction)_from_GeovisitTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_GeovisitTrigger[] = {
        { const_cast<char*>("monitoring_scope"), (getter)GeovisitTrigger_get_MonitoringScope, (setter)GeovisitTrigger_put_MonitoringScope, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_GeovisitTrigger[] = 
    {
        { Py_tp_new, _new_GeovisitTrigger },
        { Py_tp_dealloc, _dealloc_GeovisitTrigger },
        { Py_tp_methods, _methods_GeovisitTrigger },
        { Py_tp_getset, _getset_GeovisitTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GeovisitTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.GeovisitTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::GeovisitTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeovisitTrigger
    };

    // ----- LocationTrigger class --------------------
    constexpr const char* const _type_name_LocationTrigger = "LocationTrigger";

    static PyObject* _new_LocationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::LocationTriggerType>(args, 0);

                winrt::Windows::ApplicationModel::Background::LocationTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LocationTrigger(py::wrapper::Windows::ApplicationModel::Background::LocationTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LocationTrigger_get_TriggerType(py::wrapper::Windows::ApplicationModel::Background::LocationTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TriggerType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LocationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::LocationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LocationTrigger[] = {
        { "_from", (PyCFunction)_from_LocationTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LocationTrigger[] = {
        { const_cast<char*>("trigger_type"), (getter)LocationTrigger_get_TriggerType, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LocationTrigger[] = 
    {
        { Py_tp_new, _new_LocationTrigger },
        { Py_tp_dealloc, _dealloc_LocationTrigger },
        { Py_tp_methods, _methods_LocationTrigger },
        { Py_tp_getset, _getset_LocationTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LocationTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.LocationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::LocationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LocationTrigger
    };

    // ----- MaintenanceTrigger class --------------------
    constexpr const char* const _type_name_MaintenanceTrigger = "MaintenanceTrigger";

    static PyObject* _new_MaintenanceTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::ApplicationModel::Background::MaintenanceTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MaintenanceTrigger(py::wrapper::Windows::ApplicationModel::Background::MaintenanceTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MaintenanceTrigger_get_FreshnessTime(py::wrapper::Windows::ApplicationModel::Background::MaintenanceTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FreshnessTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MaintenanceTrigger_get_OneShot(py::wrapper::Windows::ApplicationModel::Background::MaintenanceTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OneShot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MaintenanceTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::MaintenanceTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MaintenanceTrigger[] = {
        { "_from", (PyCFunction)_from_MaintenanceTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MaintenanceTrigger[] = {
        { const_cast<char*>("freshness_time"), (getter)MaintenanceTrigger_get_FreshnessTime, nullptr, nullptr, nullptr },
        { const_cast<char*>("one_shot"), (getter)MaintenanceTrigger_get_OneShot, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MaintenanceTrigger[] = 
    {
        { Py_tp_new, _new_MaintenanceTrigger },
        { Py_tp_dealloc, _dealloc_MaintenanceTrigger },
        { Py_tp_methods, _methods_MaintenanceTrigger },
        { Py_tp_getset, _getset_MaintenanceTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MaintenanceTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.MaintenanceTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::MaintenanceTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MaintenanceTrigger
    };

    // ----- MediaProcessingTrigger class --------------------
    constexpr const char* const _type_name_MediaProcessingTrigger = "MediaProcessingTrigger";

    static PyObject* _new_MediaProcessingTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::MediaProcessingTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaProcessingTrigger(py::wrapper::Windows::ApplicationModel::Background::MediaProcessingTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaProcessingTrigger_RequestAsync(py::wrapper::Windows::ApplicationModel::Background::MediaProcessingTrigger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::ValueSet>(args, 0);

                return py::convert(self->obj.RequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_MediaProcessingTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::MediaProcessingTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaProcessingTrigger[] = {
        { "request_async", (PyCFunction)MediaProcessingTrigger_RequestAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaProcessingTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaProcessingTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaProcessingTrigger[] = 
    {
        { Py_tp_new, _new_MediaProcessingTrigger },
        { Py_tp_dealloc, _dealloc_MediaProcessingTrigger },
        { Py_tp_methods, _methods_MediaProcessingTrigger },
        { Py_tp_getset, _getset_MediaProcessingTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaProcessingTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.MediaProcessingTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::MediaProcessingTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaProcessingTrigger
    };

    // ----- MobileBroadbandDeviceServiceNotificationTrigger class --------------------
    constexpr const char* const _type_name_MobileBroadbandDeviceServiceNotificationTrigger = "MobileBroadbandDeviceServiceNotificationTrigger";

    static PyObject* _new_MobileBroadbandDeviceServiceNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::MobileBroadbandDeviceServiceNotificationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandDeviceServiceNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandDeviceServiceNotificationTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_MobileBroadbandDeviceServiceNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::MobileBroadbandDeviceServiceNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceServiceNotificationTrigger[] = {
        { "_from", (PyCFunction)_from_MobileBroadbandDeviceServiceNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceServiceNotificationTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceServiceNotificationTrigger[] = 
    {
        { Py_tp_new, _new_MobileBroadbandDeviceServiceNotificationTrigger },
        { Py_tp_dealloc, _dealloc_MobileBroadbandDeviceServiceNotificationTrigger },
        { Py_tp_methods, _methods_MobileBroadbandDeviceServiceNotificationTrigger },
        { Py_tp_getset, _getset_MobileBroadbandDeviceServiceNotificationTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MobileBroadbandDeviceServiceNotificationTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.MobileBroadbandDeviceServiceNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandDeviceServiceNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceServiceNotificationTrigger
    };

    // ----- MobileBroadbandPcoDataChangeTrigger class --------------------
    constexpr const char* const _type_name_MobileBroadbandPcoDataChangeTrigger = "MobileBroadbandPcoDataChangeTrigger";

    static PyObject* _new_MobileBroadbandPcoDataChangeTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::MobileBroadbandPcoDataChangeTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandPcoDataChangeTrigger(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandPcoDataChangeTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_MobileBroadbandPcoDataChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::MobileBroadbandPcoDataChangeTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPcoDataChangeTrigger[] = {
        { "_from", (PyCFunction)_from_MobileBroadbandPcoDataChangeTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MobileBroadbandPcoDataChangeTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_MobileBroadbandPcoDataChangeTrigger[] = 
    {
        { Py_tp_new, _new_MobileBroadbandPcoDataChangeTrigger },
        { Py_tp_dealloc, _dealloc_MobileBroadbandPcoDataChangeTrigger },
        { Py_tp_methods, _methods_MobileBroadbandPcoDataChangeTrigger },
        { Py_tp_getset, _getset_MobileBroadbandPcoDataChangeTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MobileBroadbandPcoDataChangeTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.MobileBroadbandPcoDataChangeTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandPcoDataChangeTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPcoDataChangeTrigger
    };

    // ----- MobileBroadbandPinLockStateChangeTrigger class --------------------
    constexpr const char* const _type_name_MobileBroadbandPinLockStateChangeTrigger = "MobileBroadbandPinLockStateChangeTrigger";

    static PyObject* _new_MobileBroadbandPinLockStateChangeTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::MobileBroadbandPinLockStateChangeTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandPinLockStateChangeTrigger(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandPinLockStateChangeTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_MobileBroadbandPinLockStateChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::MobileBroadbandPinLockStateChangeTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPinLockStateChangeTrigger[] = {
        { "_from", (PyCFunction)_from_MobileBroadbandPinLockStateChangeTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MobileBroadbandPinLockStateChangeTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_MobileBroadbandPinLockStateChangeTrigger[] = 
    {
        { Py_tp_new, _new_MobileBroadbandPinLockStateChangeTrigger },
        { Py_tp_dealloc, _dealloc_MobileBroadbandPinLockStateChangeTrigger },
        { Py_tp_methods, _methods_MobileBroadbandPinLockStateChangeTrigger },
        { Py_tp_getset, _getset_MobileBroadbandPinLockStateChangeTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MobileBroadbandPinLockStateChangeTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.MobileBroadbandPinLockStateChangeTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandPinLockStateChangeTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPinLockStateChangeTrigger
    };

    // ----- MobileBroadbandRadioStateChangeTrigger class --------------------
    constexpr const char* const _type_name_MobileBroadbandRadioStateChangeTrigger = "MobileBroadbandRadioStateChangeTrigger";

    static PyObject* _new_MobileBroadbandRadioStateChangeTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::MobileBroadbandRadioStateChangeTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandRadioStateChangeTrigger(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandRadioStateChangeTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_MobileBroadbandRadioStateChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::MobileBroadbandRadioStateChangeTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandRadioStateChangeTrigger[] = {
        { "_from", (PyCFunction)_from_MobileBroadbandRadioStateChangeTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MobileBroadbandRadioStateChangeTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_MobileBroadbandRadioStateChangeTrigger[] = 
    {
        { Py_tp_new, _new_MobileBroadbandRadioStateChangeTrigger },
        { Py_tp_dealloc, _dealloc_MobileBroadbandRadioStateChangeTrigger },
        { Py_tp_methods, _methods_MobileBroadbandRadioStateChangeTrigger },
        { Py_tp_getset, _getset_MobileBroadbandRadioStateChangeTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MobileBroadbandRadioStateChangeTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.MobileBroadbandRadioStateChangeTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandRadioStateChangeTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandRadioStateChangeTrigger
    };

    // ----- MobileBroadbandRegistrationStateChangeTrigger class --------------------
    constexpr const char* const _type_name_MobileBroadbandRegistrationStateChangeTrigger = "MobileBroadbandRegistrationStateChangeTrigger";

    static PyObject* _new_MobileBroadbandRegistrationStateChangeTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::MobileBroadbandRegistrationStateChangeTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandRegistrationStateChangeTrigger(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandRegistrationStateChangeTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_MobileBroadbandRegistrationStateChangeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::MobileBroadbandRegistrationStateChangeTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandRegistrationStateChangeTrigger[] = {
        { "_from", (PyCFunction)_from_MobileBroadbandRegistrationStateChangeTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MobileBroadbandRegistrationStateChangeTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_MobileBroadbandRegistrationStateChangeTrigger[] = 
    {
        { Py_tp_new, _new_MobileBroadbandRegistrationStateChangeTrigger },
        { Py_tp_dealloc, _dealloc_MobileBroadbandRegistrationStateChangeTrigger },
        { Py_tp_methods, _methods_MobileBroadbandRegistrationStateChangeTrigger },
        { Py_tp_getset, _getset_MobileBroadbandRegistrationStateChangeTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MobileBroadbandRegistrationStateChangeTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.MobileBroadbandRegistrationStateChangeTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::MobileBroadbandRegistrationStateChangeTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandRegistrationStateChangeTrigger
    };

    // ----- NetworkOperatorDataUsageTrigger class --------------------
    constexpr const char* const _type_name_NetworkOperatorDataUsageTrigger = "NetworkOperatorDataUsageTrigger";

    static PyObject* _new_NetworkOperatorDataUsageTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::NetworkOperatorDataUsageTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NetworkOperatorDataUsageTrigger(py::wrapper::Windows::ApplicationModel::Background::NetworkOperatorDataUsageTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_NetworkOperatorDataUsageTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::NetworkOperatorDataUsageTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorDataUsageTrigger[] = {
        { "_from", (PyCFunction)_from_NetworkOperatorDataUsageTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_NetworkOperatorDataUsageTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_NetworkOperatorDataUsageTrigger[] = 
    {
        { Py_tp_new, _new_NetworkOperatorDataUsageTrigger },
        { Py_tp_dealloc, _dealloc_NetworkOperatorDataUsageTrigger },
        { Py_tp_methods, _methods_NetworkOperatorDataUsageTrigger },
        { Py_tp_getset, _getset_NetworkOperatorDataUsageTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NetworkOperatorDataUsageTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.NetworkOperatorDataUsageTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::NetworkOperatorDataUsageTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorDataUsageTrigger
    };

    // ----- NetworkOperatorHotspotAuthenticationTrigger class --------------------
    constexpr const char* const _type_name_NetworkOperatorHotspotAuthenticationTrigger = "NetworkOperatorHotspotAuthenticationTrigger";

    static PyObject* _new_NetworkOperatorHotspotAuthenticationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::NetworkOperatorHotspotAuthenticationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NetworkOperatorHotspotAuthenticationTrigger(py::wrapper::Windows::ApplicationModel::Background::NetworkOperatorHotspotAuthenticationTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_NetworkOperatorHotspotAuthenticationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::NetworkOperatorHotspotAuthenticationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorHotspotAuthenticationTrigger[] = {
        { "_from", (PyCFunction)_from_NetworkOperatorHotspotAuthenticationTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_NetworkOperatorHotspotAuthenticationTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_NetworkOperatorHotspotAuthenticationTrigger[] = 
    {
        { Py_tp_new, _new_NetworkOperatorHotspotAuthenticationTrigger },
        { Py_tp_dealloc, _dealloc_NetworkOperatorHotspotAuthenticationTrigger },
        { Py_tp_methods, _methods_NetworkOperatorHotspotAuthenticationTrigger },
        { Py_tp_getset, _getset_NetworkOperatorHotspotAuthenticationTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NetworkOperatorHotspotAuthenticationTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.NetworkOperatorHotspotAuthenticationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::NetworkOperatorHotspotAuthenticationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorHotspotAuthenticationTrigger
    };

    // ----- NetworkOperatorNotificationTrigger class --------------------
    constexpr const char* const _type_name_NetworkOperatorNotificationTrigger = "NetworkOperatorNotificationTrigger";

    static PyObject* _new_NetworkOperatorNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Background::NetworkOperatorNotificationTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NetworkOperatorNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::NetworkOperatorNotificationTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* NetworkOperatorNotificationTrigger_get_NetworkAccountId(py::wrapper::Windows::ApplicationModel::Background::NetworkOperatorNotificationTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NetworkOperatorNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::NetworkOperatorNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorNotificationTrigger[] = {
        { "_from", (PyCFunction)_from_NetworkOperatorNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_NetworkOperatorNotificationTrigger[] = {
        { const_cast<char*>("network_account_id"), (getter)NetworkOperatorNotificationTrigger_get_NetworkAccountId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_NetworkOperatorNotificationTrigger[] = 
    {
        { Py_tp_new, _new_NetworkOperatorNotificationTrigger },
        { Py_tp_dealloc, _dealloc_NetworkOperatorNotificationTrigger },
        { Py_tp_methods, _methods_NetworkOperatorNotificationTrigger },
        { Py_tp_getset, _getset_NetworkOperatorNotificationTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NetworkOperatorNotificationTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.NetworkOperatorNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::NetworkOperatorNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorNotificationTrigger
    };

    // ----- PaymentAppCanMakePaymentTrigger class --------------------
    constexpr const char* const _type_name_PaymentAppCanMakePaymentTrigger = "PaymentAppCanMakePaymentTrigger";

    static PyObject* _new_PaymentAppCanMakePaymentTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::PaymentAppCanMakePaymentTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PaymentAppCanMakePaymentTrigger(py::wrapper::Windows::ApplicationModel::Background::PaymentAppCanMakePaymentTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_PaymentAppCanMakePaymentTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::PaymentAppCanMakePaymentTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PaymentAppCanMakePaymentTrigger[] = {
        { "_from", (PyCFunction)_from_PaymentAppCanMakePaymentTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PaymentAppCanMakePaymentTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PaymentAppCanMakePaymentTrigger[] = 
    {
        { Py_tp_new, _new_PaymentAppCanMakePaymentTrigger },
        { Py_tp_dealloc, _dealloc_PaymentAppCanMakePaymentTrigger },
        { Py_tp_methods, _methods_PaymentAppCanMakePaymentTrigger },
        { Py_tp_getset, _getset_PaymentAppCanMakePaymentTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PaymentAppCanMakePaymentTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.PaymentAppCanMakePaymentTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::PaymentAppCanMakePaymentTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PaymentAppCanMakePaymentTrigger
    };

    // ----- PhoneTrigger class --------------------
    constexpr const char* const _type_name_PhoneTrigger = "PhoneTrigger";

    static PyObject* _new_PhoneTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::Background::PhoneTriggerType>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::ApplicationModel::Background::PhoneTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PhoneTrigger(py::wrapper::Windows::ApplicationModel::Background::PhoneTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneTrigger_get_OneShot(py::wrapper::Windows::ApplicationModel::Background::PhoneTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OneShot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneTrigger_get_TriggerType(py::wrapper::Windows::ApplicationModel::Background::PhoneTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TriggerType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::PhoneTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneTrigger[] = {
        { "_from", (PyCFunction)_from_PhoneTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhoneTrigger[] = {
        { const_cast<char*>("one_shot"), (getter)PhoneTrigger_get_OneShot, nullptr, nullptr, nullptr },
        { const_cast<char*>("trigger_type"), (getter)PhoneTrigger_get_TriggerType, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PhoneTrigger[] = 
    {
        { Py_tp_new, _new_PhoneTrigger },
        { Py_tp_dealloc, _dealloc_PhoneTrigger },
        { Py_tp_methods, _methods_PhoneTrigger },
        { Py_tp_getset, _getset_PhoneTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.PhoneTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::PhoneTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneTrigger
    };

    // ----- PushNotificationTrigger class --------------------
    constexpr const char* const _type_name_PushNotificationTrigger = "PushNotificationTrigger";

    static PyObject* _new_PushNotificationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Background::PushNotificationTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::PushNotificationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PushNotificationTrigger(py::wrapper::Windows::ApplicationModel::Background::PushNotificationTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_PushNotificationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::PushNotificationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PushNotificationTrigger[] = {
        { "_from", (PyCFunction)_from_PushNotificationTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PushNotificationTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_PushNotificationTrigger[] = 
    {
        { Py_tp_new, _new_PushNotificationTrigger },
        { Py_tp_dealloc, _dealloc_PushNotificationTrigger },
        { Py_tp_methods, _methods_PushNotificationTrigger },
        { Py_tp_getset, _getset_PushNotificationTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PushNotificationTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.PushNotificationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::PushNotificationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PushNotificationTrigger
    };

    // ----- RcsEndUserMessageAvailableTrigger class --------------------
    constexpr const char* const _type_name_RcsEndUserMessageAvailableTrigger = "RcsEndUserMessageAvailableTrigger";

    static PyObject* _new_RcsEndUserMessageAvailableTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::RcsEndUserMessageAvailableTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RcsEndUserMessageAvailableTrigger(py::wrapper::Windows::ApplicationModel::Background::RcsEndUserMessageAvailableTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_RcsEndUserMessageAvailableTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::RcsEndUserMessageAvailableTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessageAvailableTrigger[] = {
        { "_from", (PyCFunction)_from_RcsEndUserMessageAvailableTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RcsEndUserMessageAvailableTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_RcsEndUserMessageAvailableTrigger[] = 
    {
        { Py_tp_new, _new_RcsEndUserMessageAvailableTrigger },
        { Py_tp_dealloc, _dealloc_RcsEndUserMessageAvailableTrigger },
        { Py_tp_methods, _methods_RcsEndUserMessageAvailableTrigger },
        { Py_tp_getset, _getset_RcsEndUserMessageAvailableTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RcsEndUserMessageAvailableTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.RcsEndUserMessageAvailableTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::RcsEndUserMessageAvailableTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessageAvailableTrigger
    };

    // ----- RfcommConnectionTrigger class --------------------
    constexpr const char* const _type_name_RfcommConnectionTrigger = "RfcommConnectionTrigger";

    static PyObject* _new_RfcommConnectionTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::RfcommConnectionTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RfcommConnectionTrigger(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RfcommConnectionTrigger_get_RemoteHostName(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteHostName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RfcommConnectionTrigger_put_RemoteHostName(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(arg);

            self->obj.RemoteHostName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RfcommConnectionTrigger_get_ProtectionLevel(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RfcommConnectionTrigger_put_ProtectionLevel(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(arg);

            self->obj.ProtectionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RfcommConnectionTrigger_get_AllowMultipleConnections(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowMultipleConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RfcommConnectionTrigger_put_AllowMultipleConnections(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowMultipleConnections(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RfcommConnectionTrigger_get_InboundConnection(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundConnection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RfcommConnectionTrigger_get_OutboundConnection(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundConnection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RfcommConnectionTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::RfcommConnectionTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RfcommConnectionTrigger[] = {
        { "_from", (PyCFunction)_from_RfcommConnectionTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RfcommConnectionTrigger[] = {
        { const_cast<char*>("remote_host_name"), (getter)RfcommConnectionTrigger_get_RemoteHostName, (setter)RfcommConnectionTrigger_put_RemoteHostName, nullptr, nullptr },
        { const_cast<char*>("protection_level"), (getter)RfcommConnectionTrigger_get_ProtectionLevel, (setter)RfcommConnectionTrigger_put_ProtectionLevel, nullptr, nullptr },
        { const_cast<char*>("allow_multiple_connections"), (getter)RfcommConnectionTrigger_get_AllowMultipleConnections, (setter)RfcommConnectionTrigger_put_AllowMultipleConnections, nullptr, nullptr },
        { const_cast<char*>("inbound_connection"), (getter)RfcommConnectionTrigger_get_InboundConnection, nullptr, nullptr, nullptr },
        { const_cast<char*>("outbound_connection"), (getter)RfcommConnectionTrigger_get_OutboundConnection, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RfcommConnectionTrigger[] = 
    {
        { Py_tp_new, _new_RfcommConnectionTrigger },
        { Py_tp_dealloc, _dealloc_RfcommConnectionTrigger },
        { Py_tp_methods, _methods_RfcommConnectionTrigger },
        { Py_tp_getset, _getset_RfcommConnectionTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RfcommConnectionTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.RfcommConnectionTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::RfcommConnectionTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RfcommConnectionTrigger
    };

    // ----- SecondaryAuthenticationFactorAuthenticationTrigger class --------------------
    constexpr const char* const _type_name_SecondaryAuthenticationFactorAuthenticationTrigger = "SecondaryAuthenticationFactorAuthenticationTrigger";

    static PyObject* _new_SecondaryAuthenticationFactorAuthenticationTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::SecondaryAuthenticationFactorAuthenticationTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SecondaryAuthenticationFactorAuthenticationTrigger(py::wrapper::Windows::ApplicationModel::Background::SecondaryAuthenticationFactorAuthenticationTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_SecondaryAuthenticationFactorAuthenticationTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::SecondaryAuthenticationFactorAuthenticationTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SecondaryAuthenticationFactorAuthenticationTrigger[] = {
        { "_from", (PyCFunction)_from_SecondaryAuthenticationFactorAuthenticationTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SecondaryAuthenticationFactorAuthenticationTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_SecondaryAuthenticationFactorAuthenticationTrigger[] = 
    {
        { Py_tp_new, _new_SecondaryAuthenticationFactorAuthenticationTrigger },
        { Py_tp_dealloc, _dealloc_SecondaryAuthenticationFactorAuthenticationTrigger },
        { Py_tp_methods, _methods_SecondaryAuthenticationFactorAuthenticationTrigger },
        { Py_tp_getset, _getset_SecondaryAuthenticationFactorAuthenticationTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SecondaryAuthenticationFactorAuthenticationTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.SecondaryAuthenticationFactorAuthenticationTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::SecondaryAuthenticationFactorAuthenticationTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SecondaryAuthenticationFactorAuthenticationTrigger
    };

    // ----- SensorDataThresholdTrigger class --------------------
    constexpr const char* const _type_name_SensorDataThresholdTrigger = "SensorDataThresholdTrigger";

    static PyObject* _new_SensorDataThresholdTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sensors::ISensorDataThreshold>(args, 0);

                winrt::Windows::ApplicationModel::Background::SensorDataThresholdTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SensorDataThresholdTrigger(py::wrapper::Windows::ApplicationModel::Background::SensorDataThresholdTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_SensorDataThresholdTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::SensorDataThresholdTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SensorDataThresholdTrigger[] = {
        { "_from", (PyCFunction)_from_SensorDataThresholdTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SensorDataThresholdTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_SensorDataThresholdTrigger[] = 
    {
        { Py_tp_new, _new_SensorDataThresholdTrigger },
        { Py_tp_dealloc, _dealloc_SensorDataThresholdTrigger },
        { Py_tp_methods, _methods_SensorDataThresholdTrigger },
        { Py_tp_getset, _getset_SensorDataThresholdTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SensorDataThresholdTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.SensorDataThresholdTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::SensorDataThresholdTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SensorDataThresholdTrigger
    };

    // ----- SmartCardTrigger class --------------------
    constexpr const char* const _type_name_SmartCardTrigger = "SmartCardTrigger";

    static PyObject* _new_SmartCardTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::SmartCards::SmartCardTriggerType>(args, 0);

                winrt::Windows::ApplicationModel::Background::SmartCardTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmartCardTrigger(py::wrapper::Windows::ApplicationModel::Background::SmartCardTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmartCardTrigger_get_TriggerType(py::wrapper::Windows::ApplicationModel::Background::SmartCardTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TriggerType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmartCardTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::SmartCardTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartCardTrigger[] = {
        { "_from", (PyCFunction)_from_SmartCardTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SmartCardTrigger[] = {
        { const_cast<char*>("trigger_type"), (getter)SmartCardTrigger_get_TriggerType, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SmartCardTrigger[] = 
    {
        { Py_tp_new, _new_SmartCardTrigger },
        { Py_tp_dealloc, _dealloc_SmartCardTrigger },
        { Py_tp_methods, _methods_SmartCardTrigger },
        { Py_tp_getset, _getset_SmartCardTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SmartCardTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.SmartCardTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::SmartCardTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartCardTrigger
    };

    // ----- SmsMessageReceivedTrigger class --------------------
    constexpr const char* const _type_name_SmsMessageReceivedTrigger = "SmsMessageReceivedTrigger";

    static PyObject* _new_SmsMessageReceivedTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsFilterRules>(args, 0);

                winrt::Windows::ApplicationModel::Background::SmsMessageReceivedTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsMessageReceivedTrigger(py::wrapper::Windows::ApplicationModel::Background::SmsMessageReceivedTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_SmsMessageReceivedTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::SmsMessageReceivedTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsMessageReceivedTrigger[] = {
        { "_from", (PyCFunction)_from_SmsMessageReceivedTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SmsMessageReceivedTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_SmsMessageReceivedTrigger[] = 
    {
        { Py_tp_new, _new_SmsMessageReceivedTrigger },
        { Py_tp_dealloc, _dealloc_SmsMessageReceivedTrigger },
        { Py_tp_methods, _methods_SmsMessageReceivedTrigger },
        { Py_tp_getset, _getset_SmsMessageReceivedTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SmsMessageReceivedTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.SmsMessageReceivedTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::SmsMessageReceivedTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsMessageReceivedTrigger
    };

    // ----- SocketActivityTrigger class --------------------
    constexpr const char* const _type_name_SocketActivityTrigger = "SocketActivityTrigger";

    static PyObject* _new_SocketActivityTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::SocketActivityTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SocketActivityTrigger(py::wrapper::Windows::ApplicationModel::Background::SocketActivityTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SocketActivityTrigger_get_IsWakeFromLowPowerSupported(py::wrapper::Windows::ApplicationModel::Background::SocketActivityTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWakeFromLowPowerSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SocketActivityTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::SocketActivityTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SocketActivityTrigger[] = {
        { "_from", (PyCFunction)_from_SocketActivityTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SocketActivityTrigger[] = {
        { const_cast<char*>("is_wake_from_low_power_supported"), (getter)SocketActivityTrigger_get_IsWakeFromLowPowerSupported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SocketActivityTrigger[] = 
    {
        { Py_tp_new, _new_SocketActivityTrigger },
        { Py_tp_dealloc, _dealloc_SocketActivityTrigger },
        { Py_tp_methods, _methods_SocketActivityTrigger },
        { Py_tp_getset, _getset_SocketActivityTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SocketActivityTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.SocketActivityTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::SocketActivityTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SocketActivityTrigger
    };

    // ----- StorageLibraryChangeTrackerTrigger class --------------------
    constexpr const char* const _type_name_StorageLibraryChangeTrackerTrigger = "StorageLibraryChangeTrackerTrigger";

    static PyObject* _new_StorageLibraryChangeTrackerTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageLibraryChangeTracker>(args, 0);

                winrt::Windows::ApplicationModel::Background::StorageLibraryChangeTrackerTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageLibraryChangeTrackerTrigger(py::wrapper::Windows::ApplicationModel::Background::StorageLibraryChangeTrackerTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_StorageLibraryChangeTrackerTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::StorageLibraryChangeTrackerTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryChangeTrackerTrigger[] = {
        { "_from", (PyCFunction)_from_StorageLibraryChangeTrackerTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageLibraryChangeTrackerTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageLibraryChangeTrackerTrigger[] = 
    {
        { Py_tp_new, _new_StorageLibraryChangeTrackerTrigger },
        { Py_tp_dealloc, _dealloc_StorageLibraryChangeTrackerTrigger },
        { Py_tp_methods, _methods_StorageLibraryChangeTrackerTrigger },
        { Py_tp_getset, _getset_StorageLibraryChangeTrackerTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageLibraryChangeTrackerTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.StorageLibraryChangeTrackerTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::StorageLibraryChangeTrackerTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryChangeTrackerTrigger
    };

    // ----- StorageLibraryContentChangedTrigger class --------------------
    constexpr const char* const _type_name_StorageLibraryContentChangedTrigger = "StorageLibraryContentChangedTrigger";

    static PyObject* _new_StorageLibraryContentChangedTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageLibraryContentChangedTrigger);
        return nullptr;
    }

    static void _dealloc_StorageLibraryContentChangedTrigger(py::wrapper::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageLibraryContentChangedTrigger_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageLibrary>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryContentChangedTrigger_CreateFromLibraries(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::StorageLibrary>>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger::CreateFromLibraries(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_StorageLibraryContentChangedTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryContentChangedTrigger[] = {
        { "create", (PyCFunction)StorageLibraryContentChangedTrigger_Create, METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_libraries", (PyCFunction)StorageLibraryContentChangedTrigger_CreateFromLibraries, METH_VARARGS | METH_STATIC, nullptr },
        { "_from", (PyCFunction)_from_StorageLibraryContentChangedTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_StorageLibraryContentChangedTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_StorageLibraryContentChangedTrigger[] = 
    {
        { Py_tp_new, _new_StorageLibraryContentChangedTrigger },
        { Py_tp_dealloc, _dealloc_StorageLibraryContentChangedTrigger },
        { Py_tp_methods, _methods_StorageLibraryContentChangedTrigger },
        { Py_tp_getset, _getset_StorageLibraryContentChangedTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageLibraryContentChangedTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.StorageLibraryContentChangedTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryContentChangedTrigger
    };

    // ----- SystemCondition class --------------------
    constexpr const char* const _type_name_SystemCondition = "SystemCondition";

    static PyObject* _new_SystemCondition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::SystemConditionType>(args, 0);

                winrt::Windows::ApplicationModel::Background::SystemCondition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SystemCondition(py::wrapper::Windows::ApplicationModel::Background::SystemCondition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemCondition_get_ConditionType(py::wrapper::Windows::ApplicationModel::Background::SystemCondition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConditionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemCondition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::SystemCondition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemCondition[] = {
        { "_from", (PyCFunction)_from_SystemCondition, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemCondition[] = {
        { const_cast<char*>("condition_type"), (getter)SystemCondition_get_ConditionType, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemCondition[] = 
    {
        { Py_tp_new, _new_SystemCondition },
        { Py_tp_dealloc, _dealloc_SystemCondition },
        { Py_tp_methods, _methods_SystemCondition },
        { Py_tp_getset, _getset_SystemCondition },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemCondition =
    {
        "_winrt_Windows_ApplicationModel_Background.SystemCondition",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::SystemCondition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemCondition
    };

    // ----- SystemTrigger class --------------------
    constexpr const char* const _type_name_SystemTrigger = "SystemTrigger";

    static PyObject* _new_SystemTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::SystemTriggerType>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::ApplicationModel::Background::SystemTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SystemTrigger(py::wrapper::Windows::ApplicationModel::Background::SystemTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemTrigger_get_OneShot(py::wrapper::Windows::ApplicationModel::Background::SystemTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OneShot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemTrigger_get_TriggerType(py::wrapper::Windows::ApplicationModel::Background::SystemTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TriggerType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::SystemTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemTrigger[] = {
        { "_from", (PyCFunction)_from_SystemTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SystemTrigger[] = {
        { const_cast<char*>("one_shot"), (getter)SystemTrigger_get_OneShot, nullptr, nullptr, nullptr },
        { const_cast<char*>("trigger_type"), (getter)SystemTrigger_get_TriggerType, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SystemTrigger[] = 
    {
        { Py_tp_new, _new_SystemTrigger },
        { Py_tp_dealloc, _dealloc_SystemTrigger },
        { Py_tp_methods, _methods_SystemTrigger },
        { Py_tp_getset, _getset_SystemTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.SystemTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::SystemTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemTrigger
    };

    // ----- TetheringEntitlementCheckTrigger class --------------------
    constexpr const char* const _type_name_TetheringEntitlementCheckTrigger = "TetheringEntitlementCheckTrigger";

    static PyObject* _new_TetheringEntitlementCheckTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::TetheringEntitlementCheckTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TetheringEntitlementCheckTrigger(py::wrapper::Windows::ApplicationModel::Background::TetheringEntitlementCheckTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_TetheringEntitlementCheckTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::TetheringEntitlementCheckTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TetheringEntitlementCheckTrigger[] = {
        { "_from", (PyCFunction)_from_TetheringEntitlementCheckTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TetheringEntitlementCheckTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_TetheringEntitlementCheckTrigger[] = 
    {
        { Py_tp_new, _new_TetheringEntitlementCheckTrigger },
        { Py_tp_dealloc, _dealloc_TetheringEntitlementCheckTrigger },
        { Py_tp_methods, _methods_TetheringEntitlementCheckTrigger },
        { Py_tp_getset, _getset_TetheringEntitlementCheckTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TetheringEntitlementCheckTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.TetheringEntitlementCheckTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::TetheringEntitlementCheckTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TetheringEntitlementCheckTrigger
    };

    // ----- TimeTrigger class --------------------
    constexpr const char* const _type_name_TimeTrigger = "TimeTrigger";

    static PyObject* _new_TimeTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::ApplicationModel::Background::TimeTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimeTrigger(py::wrapper::Windows::ApplicationModel::Background::TimeTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimeTrigger_get_FreshnessTime(py::wrapper::Windows::ApplicationModel::Background::TimeTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FreshnessTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimeTrigger_get_OneShot(py::wrapper::Windows::ApplicationModel::Background::TimeTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OneShot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimeTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::TimeTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimeTrigger[] = {
        { "_from", (PyCFunction)_from_TimeTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TimeTrigger[] = {
        { const_cast<char*>("freshness_time"), (getter)TimeTrigger_get_FreshnessTime, nullptr, nullptr, nullptr },
        { const_cast<char*>("one_shot"), (getter)TimeTrigger_get_OneShot, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TimeTrigger[] = 
    {
        { Py_tp_new, _new_TimeTrigger },
        { Py_tp_dealloc, _dealloc_TimeTrigger },
        { Py_tp_methods, _methods_TimeTrigger },
        { Py_tp_getset, _getset_TimeTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TimeTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.TimeTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::TimeTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimeTrigger
    };

    // ----- ToastNotificationActionTrigger class --------------------
    constexpr const char* const _type_name_ToastNotificationActionTrigger = "ToastNotificationActionTrigger";

    static PyObject* _new_ToastNotificationActionTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Background::ToastNotificationActionTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ToastNotificationActionTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToastNotificationActionTrigger(py::wrapper::Windows::ApplicationModel::Background::ToastNotificationActionTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ToastNotificationActionTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ToastNotificationActionTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationActionTrigger[] = {
        { "_from", (PyCFunction)_from_ToastNotificationActionTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ToastNotificationActionTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ToastNotificationActionTrigger[] = 
    {
        { Py_tp_new, _new_ToastNotificationActionTrigger },
        { Py_tp_dealloc, _dealloc_ToastNotificationActionTrigger },
        { Py_tp_methods, _methods_ToastNotificationActionTrigger },
        { Py_tp_getset, _getset_ToastNotificationActionTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ToastNotificationActionTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.ToastNotificationActionTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ToastNotificationActionTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationActionTrigger
    };

    // ----- ToastNotificationHistoryChangedTrigger class --------------------
    constexpr const char* const _type_name_ToastNotificationHistoryChangedTrigger = "ToastNotificationHistoryChangedTrigger";

    static PyObject* _new_ToastNotificationHistoryChangedTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Background::ToastNotificationHistoryChangedTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Background::ToastNotificationHistoryChangedTrigger instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToastNotificationHistoryChangedTrigger(py::wrapper::Windows::ApplicationModel::Background::ToastNotificationHistoryChangedTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ToastNotificationHistoryChangedTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::ToastNotificationHistoryChangedTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationHistoryChangedTrigger[] = {
        { "_from", (PyCFunction)_from_ToastNotificationHistoryChangedTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ToastNotificationHistoryChangedTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_ToastNotificationHistoryChangedTrigger[] = 
    {
        { Py_tp_new, _new_ToastNotificationHistoryChangedTrigger },
        { Py_tp_dealloc, _dealloc_ToastNotificationHistoryChangedTrigger },
        { Py_tp_methods, _methods_ToastNotificationHistoryChangedTrigger },
        { Py_tp_getset, _getset_ToastNotificationHistoryChangedTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ToastNotificationHistoryChangedTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.ToastNotificationHistoryChangedTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::ToastNotificationHistoryChangedTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationHistoryChangedTrigger
    };

    // ----- UserNotificationChangedTrigger class --------------------
    constexpr const char* const _type_name_UserNotificationChangedTrigger = "UserNotificationChangedTrigger";

    static PyObject* _new_UserNotificationChangedTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationKinds>(args, 0);

                winrt::Windows::ApplicationModel::Background::UserNotificationChangedTrigger instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UserNotificationChangedTrigger(py::wrapper::Windows::ApplicationModel::Background::UserNotificationChangedTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_UserNotificationChangedTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::UserNotificationChangedTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserNotificationChangedTrigger[] = {
        { "_from", (PyCFunction)_from_UserNotificationChangedTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_UserNotificationChangedTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_UserNotificationChangedTrigger[] = 
    {
        { Py_tp_new, _new_UserNotificationChangedTrigger },
        { Py_tp_dealloc, _dealloc_UserNotificationChangedTrigger },
        { Py_tp_methods, _methods_UserNotificationChangedTrigger },
        { Py_tp_getset, _getset_UserNotificationChangedTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UserNotificationChangedTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.UserNotificationChangedTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::UserNotificationChangedTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserNotificationChangedTrigger
    };

    // ----- IBackgroundCondition interface --------------------
    constexpr const char* const _type_name_IBackgroundCondition = "IBackgroundCondition";

    static PyObject* _new_IBackgroundCondition(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IBackgroundCondition);
        return nullptr;
    }

    static void _dealloc_IBackgroundCondition(py::wrapper::Windows::ApplicationModel::Background::IBackgroundCondition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_IBackgroundCondition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundCondition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundCondition[] = {
        { "_from", (PyCFunction)_from_IBackgroundCondition, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IBackgroundCondition[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IBackgroundCondition[] = 
    {
        { Py_tp_new, _new_IBackgroundCondition },
        { Py_tp_dealloc, _dealloc_IBackgroundCondition },
        { Py_tp_methods, _methods_IBackgroundCondition },
        { Py_tp_getset, _getset_IBackgroundCondition },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IBackgroundCondition =
    {
        "_winrt_Windows_ApplicationModel_Background.IBackgroundCondition",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundCondition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundCondition
    };

    // ----- IBackgroundTask interface --------------------
    constexpr const char* const _type_name_IBackgroundTask = "IBackgroundTask";

    static PyObject* _new_IBackgroundTask(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IBackgroundTask);
        return nullptr;
    }

    static void _dealloc_IBackgroundTask(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTask* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IBackgroundTask_Run(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTask* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance>(args, 0);

                self->obj.Run(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IBackgroundTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTask>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTask[] = {
        { "run", (PyCFunction)IBackgroundTask_Run, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IBackgroundTask, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IBackgroundTask[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IBackgroundTask[] = 
    {
        { Py_tp_new, _new_IBackgroundTask },
        { Py_tp_dealloc, _dealloc_IBackgroundTask },
        { Py_tp_methods, _methods_IBackgroundTask },
        { Py_tp_getset, _getset_IBackgroundTask },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IBackgroundTask =
    {
        "_winrt_Windows_ApplicationModel_Background.IBackgroundTask",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTask),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTask
    };

    // ----- IBackgroundTaskInstance interface --------------------
    constexpr const char* const _type_name_IBackgroundTaskInstance = "IBackgroundTaskInstance";

    static PyObject* _new_IBackgroundTaskInstance(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IBackgroundTaskInstance);
        return nullptr;
    }

    static void _dealloc_IBackgroundTaskInstance(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IBackgroundTaskInstance_GetDeferral(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance_get_InstanceId(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance_get_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTaskInstance_put_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Progress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTaskInstance_get_SuspendedCount(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuspendedCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance_get_Task(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Task());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance_get_TriggerDetails(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TriggerDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance_add_Canceled(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCanceledEventHandler>(arg);

            return py::convert(self->obj.Canceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance_remove_Canceled(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Canceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IBackgroundTaskInstance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTaskInstance[] = {
        { "get_deferral", (PyCFunction)IBackgroundTaskInstance_GetDeferral, METH_VARARGS, nullptr },
        { "add_canceled", (PyCFunction)IBackgroundTaskInstance_add_Canceled, METH_O, nullptr },
        { "remove_canceled", (PyCFunction)IBackgroundTaskInstance_remove_Canceled, METH_O, nullptr },
        { "_from", (PyCFunction)_from_IBackgroundTaskInstance, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IBackgroundTaskInstance[] = {
        { const_cast<char*>("instance_id"), (getter)IBackgroundTaskInstance_get_InstanceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("progress"), (getter)IBackgroundTaskInstance_get_Progress, (setter)IBackgroundTaskInstance_put_Progress, nullptr, nullptr },
        { const_cast<char*>("suspended_count"), (getter)IBackgroundTaskInstance_get_SuspendedCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("task"), (getter)IBackgroundTaskInstance_get_Task, nullptr, nullptr, nullptr },
        { const_cast<char*>("trigger_details"), (getter)IBackgroundTaskInstance_get_TriggerDetails, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IBackgroundTaskInstance[] = 
    {
        { Py_tp_new, _new_IBackgroundTaskInstance },
        { Py_tp_dealloc, _dealloc_IBackgroundTaskInstance },
        { Py_tp_methods, _methods_IBackgroundTaskInstance },
        { Py_tp_getset, _getset_IBackgroundTaskInstance },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IBackgroundTaskInstance =
    {
        "_winrt_Windows_ApplicationModel_Background.IBackgroundTaskInstance",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTaskInstance
    };

    // ----- IBackgroundTaskInstance2 interface --------------------
    constexpr const char* const _type_name_IBackgroundTaskInstance2 = "IBackgroundTaskInstance2";

    static PyObject* _new_IBackgroundTaskInstance2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IBackgroundTaskInstance2);
        return nullptr;
    }

    static void _dealloc_IBackgroundTaskInstance2(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IBackgroundTaskInstance2_GetDeferral(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance2_GetThrottleCount(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskThrottleCounter>(args, 0);

                return py::convert(self->obj.GetThrottleCount(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance2_get_InstanceId(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance2_get_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTaskInstance2_put_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Progress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTaskInstance2_get_SuspendedCount(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuspendedCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance2_get_Task(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Task());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance2_get_TriggerDetails(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TriggerDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance2_add_Canceled(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCanceledEventHandler>(arg);

            return py::convert(self->obj.Canceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance2_remove_Canceled(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Canceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IBackgroundTaskInstance2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTaskInstance2[] = {
        { "get_throttle_count", (PyCFunction)IBackgroundTaskInstance2_GetThrottleCount, METH_VARARGS, nullptr },
        { "get_deferral", (PyCFunction)IBackgroundTaskInstance2_GetDeferral, METH_VARARGS, nullptr },
        { "add_canceled", (PyCFunction)IBackgroundTaskInstance2_add_Canceled, METH_O, nullptr },
        { "remove_canceled", (PyCFunction)IBackgroundTaskInstance2_remove_Canceled, METH_O, nullptr },
        { "_from", (PyCFunction)_from_IBackgroundTaskInstance2, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IBackgroundTaskInstance2[] = {
        { const_cast<char*>("instance_id"), (getter)IBackgroundTaskInstance2_get_InstanceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("progress"), (getter)IBackgroundTaskInstance2_get_Progress, (setter)IBackgroundTaskInstance2_put_Progress, nullptr, nullptr },
        { const_cast<char*>("suspended_count"), (getter)IBackgroundTaskInstance2_get_SuspendedCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("task"), (getter)IBackgroundTaskInstance2_get_Task, nullptr, nullptr, nullptr },
        { const_cast<char*>("trigger_details"), (getter)IBackgroundTaskInstance2_get_TriggerDetails, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IBackgroundTaskInstance2[] = 
    {
        { Py_tp_new, _new_IBackgroundTaskInstance2 },
        { Py_tp_dealloc, _dealloc_IBackgroundTaskInstance2 },
        { Py_tp_methods, _methods_IBackgroundTaskInstance2 },
        { Py_tp_getset, _getset_IBackgroundTaskInstance2 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IBackgroundTaskInstance2 =
    {
        "_winrt_Windows_ApplicationModel_Background.IBackgroundTaskInstance2",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTaskInstance2
    };

    // ----- IBackgroundTaskInstance4 interface --------------------
    constexpr const char* const _type_name_IBackgroundTaskInstance4 = "IBackgroundTaskInstance4";

    static PyObject* _new_IBackgroundTaskInstance4(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IBackgroundTaskInstance4);
        return nullptr;
    }

    static void _dealloc_IBackgroundTaskInstance4(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IBackgroundTaskInstance4_GetDeferral(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance4_get_User(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance4_get_InstanceId(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance4_get_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTaskInstance4_put_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Progress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTaskInstance4_get_SuspendedCount(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuspendedCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance4_get_Task(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Task());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance4_get_TriggerDetails(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TriggerDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance4_add_Canceled(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCanceledEventHandler>(arg);

            return py::convert(self->obj.Canceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskInstance4_remove_Canceled(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Canceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IBackgroundTaskInstance4(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance4>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTaskInstance4[] = {
        { "get_deferral", (PyCFunction)IBackgroundTaskInstance4_GetDeferral, METH_VARARGS, nullptr },
        { "add_canceled", (PyCFunction)IBackgroundTaskInstance4_add_Canceled, METH_O, nullptr },
        { "remove_canceled", (PyCFunction)IBackgroundTaskInstance4_remove_Canceled, METH_O, nullptr },
        { "_from", (PyCFunction)_from_IBackgroundTaskInstance4, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IBackgroundTaskInstance4[] = {
        { const_cast<char*>("user"), (getter)IBackgroundTaskInstance4_get_User, nullptr, nullptr, nullptr },
        { const_cast<char*>("instance_id"), (getter)IBackgroundTaskInstance4_get_InstanceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("progress"), (getter)IBackgroundTaskInstance4_get_Progress, (setter)IBackgroundTaskInstance4_put_Progress, nullptr, nullptr },
        { const_cast<char*>("suspended_count"), (getter)IBackgroundTaskInstance4_get_SuspendedCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("task"), (getter)IBackgroundTaskInstance4_get_Task, nullptr, nullptr, nullptr },
        { const_cast<char*>("trigger_details"), (getter)IBackgroundTaskInstance4_get_TriggerDetails, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IBackgroundTaskInstance4[] = 
    {
        { Py_tp_new, _new_IBackgroundTaskInstance4 },
        { Py_tp_dealloc, _dealloc_IBackgroundTaskInstance4 },
        { Py_tp_methods, _methods_IBackgroundTaskInstance4 },
        { Py_tp_getset, _getset_IBackgroundTaskInstance4 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IBackgroundTaskInstance4 =
    {
        "_winrt_Windows_ApplicationModel_Background.IBackgroundTaskInstance4",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskInstance4),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTaskInstance4
    };

    // ----- IBackgroundTaskRegistration interface --------------------
    constexpr const char* const _type_name_IBackgroundTaskRegistration = "IBackgroundTaskRegistration";

    static PyObject* _new_IBackgroundTaskRegistration(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IBackgroundTaskRegistration);
        return nullptr;
    }

    static void _dealloc_IBackgroundTaskRegistration(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IBackgroundTaskRegistration_Unregister(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.Unregister(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration_get_Name(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration_get_TaskId(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration_add_Completed(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventHandler>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration_remove_Completed(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration_add_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventHandler>(arg);

            return py::convert(self->obj.Progress(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration_remove_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Progress(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IBackgroundTaskRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTaskRegistration[] = {
        { "unregister", (PyCFunction)IBackgroundTaskRegistration_Unregister, METH_VARARGS, nullptr },
        { "add_completed", (PyCFunction)IBackgroundTaskRegistration_add_Completed, METH_O, nullptr },
        { "remove_completed", (PyCFunction)IBackgroundTaskRegistration_remove_Completed, METH_O, nullptr },
        { "add_progress", (PyCFunction)IBackgroundTaskRegistration_add_Progress, METH_O, nullptr },
        { "remove_progress", (PyCFunction)IBackgroundTaskRegistration_remove_Progress, METH_O, nullptr },
        { "_from", (PyCFunction)_from_IBackgroundTaskRegistration, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IBackgroundTaskRegistration[] = {
        { const_cast<char*>("name"), (getter)IBackgroundTaskRegistration_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("task_id"), (getter)IBackgroundTaskRegistration_get_TaskId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IBackgroundTaskRegistration[] = 
    {
        { Py_tp_new, _new_IBackgroundTaskRegistration },
        { Py_tp_dealloc, _dealloc_IBackgroundTaskRegistration },
        { Py_tp_methods, _methods_IBackgroundTaskRegistration },
        { Py_tp_getset, _getset_IBackgroundTaskRegistration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IBackgroundTaskRegistration =
    {
        "_winrt_Windows_ApplicationModel_Background.IBackgroundTaskRegistration",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTaskRegistration
    };

    // ----- IBackgroundTaskRegistration2 interface --------------------
    constexpr const char* const _type_name_IBackgroundTaskRegistration2 = "IBackgroundTaskRegistration2";

    static PyObject* _new_IBackgroundTaskRegistration2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IBackgroundTaskRegistration2);
        return nullptr;
    }

    static void _dealloc_IBackgroundTaskRegistration2(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IBackgroundTaskRegistration2_Unregister(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.Unregister(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration2_get_Trigger(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Trigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration2_get_Name(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration2_get_TaskId(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration2_add_Completed(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventHandler>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration2_remove_Completed(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration2_add_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventHandler>(arg);

            return py::convert(self->obj.Progress(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration2_remove_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Progress(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IBackgroundTaskRegistration2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTaskRegistration2[] = {
        { "unregister", (PyCFunction)IBackgroundTaskRegistration2_Unregister, METH_VARARGS, nullptr },
        { "add_completed", (PyCFunction)IBackgroundTaskRegistration2_add_Completed, METH_O, nullptr },
        { "remove_completed", (PyCFunction)IBackgroundTaskRegistration2_remove_Completed, METH_O, nullptr },
        { "add_progress", (PyCFunction)IBackgroundTaskRegistration2_add_Progress, METH_O, nullptr },
        { "remove_progress", (PyCFunction)IBackgroundTaskRegistration2_remove_Progress, METH_O, nullptr },
        { "_from", (PyCFunction)_from_IBackgroundTaskRegistration2, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IBackgroundTaskRegistration2[] = {
        { const_cast<char*>("trigger"), (getter)IBackgroundTaskRegistration2_get_Trigger, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)IBackgroundTaskRegistration2_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("task_id"), (getter)IBackgroundTaskRegistration2_get_TaskId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IBackgroundTaskRegistration2[] = 
    {
        { Py_tp_new, _new_IBackgroundTaskRegistration2 },
        { Py_tp_dealloc, _dealloc_IBackgroundTaskRegistration2 },
        { Py_tp_methods, _methods_IBackgroundTaskRegistration2 },
        { Py_tp_getset, _getset_IBackgroundTaskRegistration2 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IBackgroundTaskRegistration2 =
    {
        "_winrt_Windows_ApplicationModel_Background.IBackgroundTaskRegistration2",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTaskRegistration2
    };

    // ----- IBackgroundTaskRegistration3 interface --------------------
    constexpr const char* const _type_name_IBackgroundTaskRegistration3 = "IBackgroundTaskRegistration3";

    static PyObject* _new_IBackgroundTaskRegistration3(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IBackgroundTaskRegistration3);
        return nullptr;
    }

    static void _dealloc_IBackgroundTaskRegistration3(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IBackgroundTaskRegistration3_Unregister(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.Unregister(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration3_get_TaskGroup(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TaskGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration3_get_Name(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration3_get_TaskId(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration3_add_Completed(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventHandler>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration3_remove_Completed(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration3_add_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventHandler>(arg);

            return py::convert(self->obj.Progress(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTaskRegistration3_remove_Progress(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Progress(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IBackgroundTaskRegistration3(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTaskRegistration3[] = {
        { "unregister", (PyCFunction)IBackgroundTaskRegistration3_Unregister, METH_VARARGS, nullptr },
        { "add_completed", (PyCFunction)IBackgroundTaskRegistration3_add_Completed, METH_O, nullptr },
        { "remove_completed", (PyCFunction)IBackgroundTaskRegistration3_remove_Completed, METH_O, nullptr },
        { "add_progress", (PyCFunction)IBackgroundTaskRegistration3_add_Progress, METH_O, nullptr },
        { "remove_progress", (PyCFunction)IBackgroundTaskRegistration3_remove_Progress, METH_O, nullptr },
        { "_from", (PyCFunction)_from_IBackgroundTaskRegistration3, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IBackgroundTaskRegistration3[] = {
        { const_cast<char*>("task_group"), (getter)IBackgroundTaskRegistration3_get_TaskGroup, nullptr, nullptr, nullptr },
        { const_cast<char*>("name"), (getter)IBackgroundTaskRegistration3_get_Name, nullptr, nullptr, nullptr },
        { const_cast<char*>("task_id"), (getter)IBackgroundTaskRegistration3_get_TaskId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IBackgroundTaskRegistration3[] = 
    {
        { Py_tp_new, _new_IBackgroundTaskRegistration3 },
        { Py_tp_dealloc, _dealloc_IBackgroundTaskRegistration3 },
        { Py_tp_methods, _methods_IBackgroundTaskRegistration3 },
        { Py_tp_getset, _getset_IBackgroundTaskRegistration3 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IBackgroundTaskRegistration3 =
    {
        "_winrt_Windows_ApplicationModel_Background.IBackgroundTaskRegistration3",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTaskRegistration3
    };

    // ----- IBackgroundTrigger interface --------------------
    constexpr const char* const _type_name_IBackgroundTrigger = "IBackgroundTrigger";

    static PyObject* _new_IBackgroundTrigger(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IBackgroundTrigger);
        return nullptr;
    }

    static void _dealloc_IBackgroundTrigger(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_IBackgroundTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Background::IBackgroundTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTrigger[] = {
        { "_from", (PyCFunction)_from_IBackgroundTrigger, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IBackgroundTrigger[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IBackgroundTrigger[] = 
    {
        { Py_tp_new, _new_IBackgroundTrigger },
        { Py_tp_dealloc, _dealloc_IBackgroundTrigger },
        { Py_tp_methods, _methods_IBackgroundTrigger },
        { Py_tp_getset, _getset_IBackgroundTrigger },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IBackgroundTrigger =
    {
        "_winrt_Windows_ApplicationModel_Background.IBackgroundTrigger",
        sizeof(py::wrapper::Windows::ApplicationModel::Background::IBackgroundTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTrigger
    };

    // ----- Windows.ApplicationModel.Background Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::ApplicationModel::Background::ActivitySensorTrigger>::python_type = py::register_python_type(module, _type_name_ActivitySensorTrigger, &_type_spec_ActivitySensorTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::ApplicationTrigger>::python_type = py::register_python_type(module, _type_name_ApplicationTrigger, &_type_spec_ApplicationTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::ApplicationTriggerDetails>::python_type = py::register_python_type(module, _type_name_ApplicationTriggerDetails, &_type_spec_ApplicationTriggerDetails, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::AppointmentStoreNotificationTrigger>::python_type = py::register_python_type(module, _type_name_AppointmentStoreNotificationTrigger, &_type_spec_AppointmentStoreNotificationTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundExecutionManager>::python_type = py::register_python_type(module, _type_name_BackgroundExecutionManager, &_type_spec_BackgroundExecutionManager, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskBuilder>::python_type = py::register_python_type(module, _type_name_BackgroundTaskBuilder, &_type_spec_BackgroundTaskBuilder, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskCompletedEventArgs>::python_type = py::register_python_type(module, _type_name_BackgroundTaskCompletedEventArgs, &_type_spec_BackgroundTaskCompletedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskDeferral>::python_type = py::register_python_type(module, _type_name_BackgroundTaskDeferral, &_type_spec_BackgroundTaskDeferral, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskProgressEventArgs>::python_type = py::register_python_type(module, _type_name_BackgroundTaskProgressEventArgs, &_type_spec_BackgroundTaskProgressEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistration>::python_type = py::register_python_type(module, _type_name_BackgroundTaskRegistration, &_type_spec_BackgroundTaskRegistration, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundTaskRegistrationGroup>::python_type = py::register_python_type(module, _type_name_BackgroundTaskRegistrationGroup, &_type_spec_BackgroundTaskRegistrationGroup, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::BackgroundWorkCost>::python_type = py::register_python_type(module, _type_name_BackgroundWorkCost, &_type_spec_BackgroundWorkCost, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementPublisherTrigger>::python_type = py::register_python_type(module, _type_name_BluetoothLEAdvertisementPublisherTrigger, &_type_spec_BluetoothLEAdvertisementPublisherTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::BluetoothLEAdvertisementWatcherTrigger>::python_type = py::register_python_type(module, _type_name_BluetoothLEAdvertisementWatcherTrigger, &_type_spec_BluetoothLEAdvertisementWatcherTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTrigger>::python_type = py::register_python_type(module, _type_name_CachedFileUpdaterTrigger, &_type_spec_CachedFileUpdaterTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::CachedFileUpdaterTriggerDetails>::python_type = py::register_python_type(module, _type_name_CachedFileUpdaterTriggerDetails, &_type_spec_CachedFileUpdaterTriggerDetails, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::ChatMessageNotificationTrigger>::python_type = py::register_python_type(module, _type_name_ChatMessageNotificationTrigger, &_type_spec_ChatMessageNotificationTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::ChatMessageReceivedNotificationTrigger>::python_type = py::register_python_type(module, _type_name_ChatMessageReceivedNotificationTrigger, &_type_spec_ChatMessageReceivedNotificationTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::CommunicationBlockingAppSetAsActiveTrigger>::python_type = py::register_python_type(module, _type_name_CommunicationBlockingAppSetAsActiveTrigger, &_type_spec_CommunicationBlockingAppSetAsActiveTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::ContactStoreNotificationTrigger>::python_type = py::register_python_type(module, _type_name_ContactStoreNotificationTrigger, &_type_spec_ContactStoreNotificationTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::ContentPrefetchTrigger>::python_type = py::register_python_type(module, _type_name_ContentPrefetchTrigger, &_type_spec_ContentPrefetchTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::ConversationalAgentTrigger>::python_type = py::register_python_type(module, _type_name_ConversationalAgentTrigger, &_type_spec_ConversationalAgentTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::CustomSystemEventTrigger>::python_type = py::register_python_type(module, _type_name_CustomSystemEventTrigger, &_type_spec_CustomSystemEventTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::DeviceConnectionChangeTrigger>::python_type = py::register_python_type(module, _type_name_DeviceConnectionChangeTrigger, &_type_spec_DeviceConnectionChangeTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::DeviceManufacturerNotificationTrigger>::python_type = py::register_python_type(module, _type_name_DeviceManufacturerNotificationTrigger, &_type_spec_DeviceManufacturerNotificationTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::DeviceServicingTrigger>::python_type = py::register_python_type(module, _type_name_DeviceServicingTrigger, &_type_spec_DeviceServicingTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::DeviceUseTrigger>::python_type = py::register_python_type(module, _type_name_DeviceUseTrigger, &_type_spec_DeviceUseTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::DeviceWatcherTrigger>::python_type = py::register_python_type(module, _type_name_DeviceWatcherTrigger, &_type_spec_DeviceWatcherTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::EmailStoreNotificationTrigger>::python_type = py::register_python_type(module, _type_name_EmailStoreNotificationTrigger, &_type_spec_EmailStoreNotificationTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::GattCharacteristicNotificationTrigger>::python_type = py::register_python_type(module, _type_name_GattCharacteristicNotificationTrigger, &_type_spec_GattCharacteristicNotificationTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::GattServiceProviderTrigger>::python_type = py::register_python_type(module, _type_name_GattServiceProviderTrigger, &_type_spec_GattServiceProviderTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::GattServiceProviderTriggerResult>::python_type = py::register_python_type(module, _type_name_GattServiceProviderTriggerResult, &_type_spec_GattServiceProviderTriggerResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::GeovisitTrigger>::python_type = py::register_python_type(module, _type_name_GeovisitTrigger, &_type_spec_GeovisitTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::LocationTrigger>::python_type = py::register_python_type(module, _type_name_LocationTrigger, &_type_spec_LocationTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::MaintenanceTrigger>::python_type = py::register_python_type(module, _type_name_MaintenanceTrigger, &_type_spec_MaintenanceTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::MediaProcessingTrigger>::python_type = py::register_python_type(module, _type_name_MediaProcessingTrigger, &_type_spec_MediaProcessingTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::MobileBroadbandDeviceServiceNotificationTrigger>::python_type = py::register_python_type(module, _type_name_MobileBroadbandDeviceServiceNotificationTrigger, &_type_spec_MobileBroadbandDeviceServiceNotificationTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::MobileBroadbandPcoDataChangeTrigger>::python_type = py::register_python_type(module, _type_name_MobileBroadbandPcoDataChangeTrigger, &_type_spec_MobileBroadbandPcoDataChangeTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::MobileBroadbandPinLockStateChangeTrigger>::python_type = py::register_python_type(module, _type_name_MobileBroadbandPinLockStateChangeTrigger, &_type_spec_MobileBroadbandPinLockStateChangeTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::MobileBroadbandRadioStateChangeTrigger>::python_type = py::register_python_type(module, _type_name_MobileBroadbandRadioStateChangeTrigger, &_type_spec_MobileBroadbandRadioStateChangeTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::MobileBroadbandRegistrationStateChangeTrigger>::python_type = py::register_python_type(module, _type_name_MobileBroadbandRegistrationStateChangeTrigger, &_type_spec_MobileBroadbandRegistrationStateChangeTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::NetworkOperatorDataUsageTrigger>::python_type = py::register_python_type(module, _type_name_NetworkOperatorDataUsageTrigger, &_type_spec_NetworkOperatorDataUsageTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::NetworkOperatorHotspotAuthenticationTrigger>::python_type = py::register_python_type(module, _type_name_NetworkOperatorHotspotAuthenticationTrigger, &_type_spec_NetworkOperatorHotspotAuthenticationTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::NetworkOperatorNotificationTrigger>::python_type = py::register_python_type(module, _type_name_NetworkOperatorNotificationTrigger, &_type_spec_NetworkOperatorNotificationTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::PaymentAppCanMakePaymentTrigger>::python_type = py::register_python_type(module, _type_name_PaymentAppCanMakePaymentTrigger, &_type_spec_PaymentAppCanMakePaymentTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::PhoneTrigger>::python_type = py::register_python_type(module, _type_name_PhoneTrigger, &_type_spec_PhoneTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::PushNotificationTrigger>::python_type = py::register_python_type(module, _type_name_PushNotificationTrigger, &_type_spec_PushNotificationTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::RcsEndUserMessageAvailableTrigger>::python_type = py::register_python_type(module, _type_name_RcsEndUserMessageAvailableTrigger, &_type_spec_RcsEndUserMessageAvailableTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::RfcommConnectionTrigger>::python_type = py::register_python_type(module, _type_name_RfcommConnectionTrigger, &_type_spec_RfcommConnectionTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::SecondaryAuthenticationFactorAuthenticationTrigger>::python_type = py::register_python_type(module, _type_name_SecondaryAuthenticationFactorAuthenticationTrigger, &_type_spec_SecondaryAuthenticationFactorAuthenticationTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::SensorDataThresholdTrigger>::python_type = py::register_python_type(module, _type_name_SensorDataThresholdTrigger, &_type_spec_SensorDataThresholdTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::SmartCardTrigger>::python_type = py::register_python_type(module, _type_name_SmartCardTrigger, &_type_spec_SmartCardTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::SmsMessageReceivedTrigger>::python_type = py::register_python_type(module, _type_name_SmsMessageReceivedTrigger, &_type_spec_SmsMessageReceivedTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::SocketActivityTrigger>::python_type = py::register_python_type(module, _type_name_SocketActivityTrigger, &_type_spec_SocketActivityTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::StorageLibraryChangeTrackerTrigger>::python_type = py::register_python_type(module, _type_name_StorageLibraryChangeTrackerTrigger, &_type_spec_StorageLibraryChangeTrackerTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::StorageLibraryContentChangedTrigger>::python_type = py::register_python_type(module, _type_name_StorageLibraryContentChangedTrigger, &_type_spec_StorageLibraryContentChangedTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::SystemCondition>::python_type = py::register_python_type(module, _type_name_SystemCondition, &_type_spec_SystemCondition, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::SystemTrigger>::python_type = py::register_python_type(module, _type_name_SystemTrigger, &_type_spec_SystemTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::TetheringEntitlementCheckTrigger>::python_type = py::register_python_type(module, _type_name_TetheringEntitlementCheckTrigger, &_type_spec_TetheringEntitlementCheckTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::TimeTrigger>::python_type = py::register_python_type(module, _type_name_TimeTrigger, &_type_spec_TimeTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::ToastNotificationActionTrigger>::python_type = py::register_python_type(module, _type_name_ToastNotificationActionTrigger, &_type_spec_ToastNotificationActionTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::ToastNotificationHistoryChangedTrigger>::python_type = py::register_python_type(module, _type_name_ToastNotificationHistoryChangedTrigger, &_type_spec_ToastNotificationHistoryChangedTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::UserNotificationChangedTrigger>::python_type = py::register_python_type(module, _type_name_UserNotificationChangedTrigger, &_type_spec_UserNotificationChangedTrigger, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundCondition>::python_type = py::register_python_type(module, _type_name_IBackgroundCondition, &_type_spec_IBackgroundCondition, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTask>::python_type = py::register_python_type(module, _type_name_IBackgroundTask, &_type_spec_IBackgroundTask, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance>::python_type = py::register_python_type(module, _type_name_IBackgroundTaskInstance, &_type_spec_IBackgroundTaskInstance, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance2>::python_type = py::register_python_type(module, _type_name_IBackgroundTaskInstance2, &_type_spec_IBackgroundTaskInstance2, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance4>::python_type = py::register_python_type(module, _type_name_IBackgroundTaskInstance4, &_type_spec_IBackgroundTaskInstance4, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration>::python_type = py::register_python_type(module, _type_name_IBackgroundTaskRegistration, &_type_spec_IBackgroundTaskRegistration, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration2>::python_type = py::register_python_type(module, _type_name_IBackgroundTaskRegistration2, &_type_spec_IBackgroundTaskRegistration2, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTaskRegistration3>::python_type = py::register_python_type(module, _type_name_IBackgroundTaskRegistration3, &_type_spec_IBackgroundTaskRegistration3, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Background::IBackgroundTrigger>::python_type = py::register_python_type(module, _type_name_IBackgroundTrigger, &_type_spec_IBackgroundTrigger, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.Background");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_ApplicationModel_Background",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::ApplicationModel::Background

PyMODINIT_FUNC
PyInit__winrt_Windows_ApplicationModel_Background (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::ApplicationModel::Background::module_def);
}
