// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Media.Devices.h"

PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::AdvancedPhotoCaptureSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::AdvancedPhotoControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::AudioDeviceController>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::AudioDeviceModule>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::AudioDeviceModulesManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::CameraOcclusionInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::CameraOcclusionState>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::DigitalWindowBounds>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::DigitalWindowCapability>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::DigitalWindowControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::ExposureCompensationControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::ExposureControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::ExposurePriorityVideoControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::FlashControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::FocusControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::FocusSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::HdrVideoControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::InfraredTorchControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::IsoSpeedControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::LowLagPhotoControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::LowLagPhotoSequenceControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::MediaDevice>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::MediaDeviceControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::MediaDeviceControlCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::ModuleCommandResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::OpticalImageStabilizationControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::PanelBasedOptimizationControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::PhotoConfirmationControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::RegionOfInterest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::RegionsOfInterestControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::SceneModeControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::TorchControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::VideoDeviceController>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::VideoTemporalDenoisingControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::WhiteBalanceControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::ZoomControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::ZoomSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::IMediaDeviceController>::python_type;

namespace py::cpp::Windows::Media::Devices
{
    // ----- AdvancedPhotoCaptureSettings class --------------------
    constexpr const char* const _type_name_AdvancedPhotoCaptureSettings = "AdvancedPhotoCaptureSettings";

    static PyObject* _new_AdvancedPhotoCaptureSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Devices::AdvancedPhotoCaptureSettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AdvancedPhotoCaptureSettings(py::wrapper::Windows::Media::Devices::AdvancedPhotoCaptureSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdvancedPhotoCaptureSettings_get_Mode(py::wrapper::Windows::Media::Devices::AdvancedPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdvancedPhotoCaptureSettings_put_Mode(py::wrapper::Windows::Media::Devices::AdvancedPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::AdvancedPhotoMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AdvancedPhotoCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::AdvancedPhotoCaptureSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdvancedPhotoCaptureSettings[] = {
        { "_from", (PyCFunction)_from_AdvancedPhotoCaptureSettings, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AdvancedPhotoCaptureSettings[] = {
        { const_cast<char*>("mode"), (getter)AdvancedPhotoCaptureSettings_get_Mode, (setter)AdvancedPhotoCaptureSettings_put_Mode, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AdvancedPhotoCaptureSettings[] = 
    {
        { Py_tp_new, _new_AdvancedPhotoCaptureSettings },
        { Py_tp_dealloc, _dealloc_AdvancedPhotoCaptureSettings },
        { Py_tp_methods, _methods_AdvancedPhotoCaptureSettings },
        { Py_tp_getset, _getset_AdvancedPhotoCaptureSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AdvancedPhotoCaptureSettings =
    {
        "_winrt_Windows_Media_Devices.AdvancedPhotoCaptureSettings",
        sizeof(py::wrapper::Windows::Media::Devices::AdvancedPhotoCaptureSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdvancedPhotoCaptureSettings
    };

    // ----- AdvancedPhotoControl class --------------------
    constexpr const char* const _type_name_AdvancedPhotoControl = "AdvancedPhotoControl";

    static PyObject* _new_AdvancedPhotoControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AdvancedPhotoControl);
        return nullptr;
    }

    static void _dealloc_AdvancedPhotoControl(py::wrapper::Windows::Media::Devices::AdvancedPhotoControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdvancedPhotoControl_Configure(py::wrapper::Windows::Media::Devices::AdvancedPhotoControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::AdvancedPhotoCaptureSettings>(args, 0);

                self->obj.Configure(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoControl_get_Mode(py::wrapper::Windows::Media::Devices::AdvancedPhotoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoControl_get_Supported(py::wrapper::Windows::Media::Devices::AdvancedPhotoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::AdvancedPhotoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AdvancedPhotoControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::AdvancedPhotoControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdvancedPhotoControl[] = {
        { "configure", (PyCFunction)AdvancedPhotoControl_Configure, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AdvancedPhotoControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AdvancedPhotoControl[] = {
        { const_cast<char*>("mode"), (getter)AdvancedPhotoControl_get_Mode, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)AdvancedPhotoControl_get_Supported, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_modes"), (getter)AdvancedPhotoControl_get_SupportedModes, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AdvancedPhotoControl[] = 
    {
        { Py_tp_new, _new_AdvancedPhotoControl },
        { Py_tp_dealloc, _dealloc_AdvancedPhotoControl },
        { Py_tp_methods, _methods_AdvancedPhotoControl },
        { Py_tp_getset, _getset_AdvancedPhotoControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AdvancedPhotoControl =
    {
        "_winrt_Windows_Media_Devices.AdvancedPhotoControl",
        sizeof(py::wrapper::Windows::Media::Devices::AdvancedPhotoControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdvancedPhotoControl
    };

    // ----- AudioDeviceController class --------------------
    constexpr const char* const _type_name_AudioDeviceController = "AudioDeviceController";

    static PyObject* _new_AudioDeviceController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioDeviceController);
        return nullptr;
    }

    static void _dealloc_AudioDeviceController(py::wrapper::Windows::Media::Devices::AudioDeviceController* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioDeviceController_GetAvailableMediaStreamProperties(py::wrapper::Windows::Media::Devices::AudioDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.GetAvailableMediaStreamProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceController_GetMediaStreamProperties(py::wrapper::Windows::Media::Devices::AudioDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.GetMediaStreamProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceController_SetMediaStreamPropertiesAsync(py::wrapper::Windows::Media::Devices::AudioDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 1);

                return py::convert(self->obj.SetMediaStreamPropertiesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceController_get_VolumePercent(py::wrapper::Windows::Media::Devices::AudioDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VolumePercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceController_put_VolumePercent(py::wrapper::Windows::Media::Devices::AudioDeviceController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.VolumePercent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceController_get_Muted(py::wrapper::Windows::Media::Devices::AudioDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Muted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceController_put_Muted(py::wrapper::Windows::Media::Devices::AudioDeviceController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Muted(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AudioDeviceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::AudioDeviceController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceController[] = {
        { "get_available_media_stream_properties", (PyCFunction)AudioDeviceController_GetAvailableMediaStreamProperties, METH_VARARGS, nullptr },
        { "get_media_stream_properties", (PyCFunction)AudioDeviceController_GetMediaStreamProperties, METH_VARARGS, nullptr },
        { "set_media_stream_properties_async", (PyCFunction)AudioDeviceController_SetMediaStreamPropertiesAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AudioDeviceController, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioDeviceController[] = {
        { const_cast<char*>("volume_percent"), (getter)AudioDeviceController_get_VolumePercent, (setter)AudioDeviceController_put_VolumePercent, nullptr, nullptr },
        { const_cast<char*>("muted"), (getter)AudioDeviceController_get_Muted, (setter)AudioDeviceController_put_Muted, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioDeviceController[] = 
    {
        { Py_tp_new, _new_AudioDeviceController },
        { Py_tp_dealloc, _dealloc_AudioDeviceController },
        { Py_tp_methods, _methods_AudioDeviceController },
        { Py_tp_getset, _getset_AudioDeviceController },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioDeviceController =
    {
        "_winrt_Windows_Media_Devices.AudioDeviceController",
        sizeof(py::wrapper::Windows::Media::Devices::AudioDeviceController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceController
    };

    // ----- AudioDeviceModule class --------------------
    constexpr const char* const _type_name_AudioDeviceModule = "AudioDeviceModule";

    static PyObject* _new_AudioDeviceModule(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioDeviceModule);
        return nullptr;
    }

    static void _dealloc_AudioDeviceModule(py::wrapper::Windows::Media::Devices::AudioDeviceModule* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioDeviceModule_SendCommandAsync(py::wrapper::Windows::Media::Devices::AudioDeviceModule* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.SendCommandAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModule_get_ClassId(py::wrapper::Windows::Media::Devices::AudioDeviceModule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModule_get_DisplayName(py::wrapper::Windows::Media::Devices::AudioDeviceModule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModule_get_InstanceId(py::wrapper::Windows::Media::Devices::AudioDeviceModule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModule_get_MajorVersion(py::wrapper::Windows::Media::Devices::AudioDeviceModule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MajorVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModule_get_MinorVersion(py::wrapper::Windows::Media::Devices::AudioDeviceModule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinorVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioDeviceModule(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::AudioDeviceModule>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceModule[] = {
        { "send_command_async", (PyCFunction)AudioDeviceModule_SendCommandAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_AudioDeviceModule, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioDeviceModule[] = {
        { const_cast<char*>("class_id"), (getter)AudioDeviceModule_get_ClassId, nullptr, nullptr, nullptr },
        { const_cast<char*>("display_name"), (getter)AudioDeviceModule_get_DisplayName, nullptr, nullptr, nullptr },
        { const_cast<char*>("instance_id"), (getter)AudioDeviceModule_get_InstanceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("major_version"), (getter)AudioDeviceModule_get_MajorVersion, nullptr, nullptr, nullptr },
        { const_cast<char*>("minor_version"), (getter)AudioDeviceModule_get_MinorVersion, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioDeviceModule[] = 
    {
        { Py_tp_new, _new_AudioDeviceModule },
        { Py_tp_dealloc, _dealloc_AudioDeviceModule },
        { Py_tp_methods, _methods_AudioDeviceModule },
        { Py_tp_getset, _getset_AudioDeviceModule },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioDeviceModule =
    {
        "_winrt_Windows_Media_Devices.AudioDeviceModule",
        sizeof(py::wrapper::Windows::Media::Devices::AudioDeviceModule),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceModule
    };

    // ----- AudioDeviceModuleNotificationEventArgs class --------------------
    constexpr const char* const _type_name_AudioDeviceModuleNotificationEventArgs = "AudioDeviceModuleNotificationEventArgs";

    static PyObject* _new_AudioDeviceModuleNotificationEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioDeviceModuleNotificationEventArgs);
        return nullptr;
    }

    static void _dealloc_AudioDeviceModuleNotificationEventArgs(py::wrapper::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioDeviceModuleNotificationEventArgs_get_Module(py::wrapper::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Module());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModuleNotificationEventArgs_get_NotificationData(py::wrapper::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NotificationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioDeviceModuleNotificationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceModuleNotificationEventArgs[] = {
        { "_from", (PyCFunction)_from_AudioDeviceModuleNotificationEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioDeviceModuleNotificationEventArgs[] = {
        { const_cast<char*>("module"), (getter)AudioDeviceModuleNotificationEventArgs_get_Module, nullptr, nullptr, nullptr },
        { const_cast<char*>("notification_data"), (getter)AudioDeviceModuleNotificationEventArgs_get_NotificationData, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioDeviceModuleNotificationEventArgs[] = 
    {
        { Py_tp_new, _new_AudioDeviceModuleNotificationEventArgs },
        { Py_tp_dealloc, _dealloc_AudioDeviceModuleNotificationEventArgs },
        { Py_tp_methods, _methods_AudioDeviceModuleNotificationEventArgs },
        { Py_tp_getset, _getset_AudioDeviceModuleNotificationEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioDeviceModuleNotificationEventArgs =
    {
        "_winrt_Windows_Media_Devices.AudioDeviceModuleNotificationEventArgs",
        sizeof(py::wrapper::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceModuleNotificationEventArgs
    };

    // ----- AudioDeviceModulesManager class --------------------
    constexpr const char* const _type_name_AudioDeviceModulesManager = "AudioDeviceModulesManager";

    static PyObject* _new_AudioDeviceModulesManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Media::Devices::AudioDeviceModulesManager instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioDeviceModulesManager(py::wrapper::Windows::Media::Devices::AudioDeviceModulesManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioDeviceModulesManager_FindAll(py::wrapper::Windows::Media::Devices::AudioDeviceModulesManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindAll());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModulesManager_FindAllById(py::wrapper::Windows::Media::Devices::AudioDeviceModulesManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindAllById(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModulesManager_add_ModuleNotificationReceived(py::wrapper::Windows::Media::Devices::AudioDeviceModulesManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Devices::AudioDeviceModulesManager, winrt::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs>>(arg);

            return py::convert(self->obj.ModuleNotificationReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModulesManager_remove_ModuleNotificationReceived(py::wrapper::Windows::Media::Devices::AudioDeviceModulesManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ModuleNotificationReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioDeviceModulesManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::AudioDeviceModulesManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceModulesManager[] = {
        { "find_all", (PyCFunction)AudioDeviceModulesManager_FindAll, METH_VARARGS, nullptr },
        { "find_all_by_id", (PyCFunction)AudioDeviceModulesManager_FindAllById, METH_VARARGS, nullptr },
        { "add_module_notification_received", (PyCFunction)AudioDeviceModulesManager_add_ModuleNotificationReceived, METH_O, nullptr },
        { "remove_module_notification_received", (PyCFunction)AudioDeviceModulesManager_remove_ModuleNotificationReceived, METH_O, nullptr },
        { "_from", (PyCFunction)_from_AudioDeviceModulesManager, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_AudioDeviceModulesManager[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_AudioDeviceModulesManager[] = 
    {
        { Py_tp_new, _new_AudioDeviceModulesManager },
        { Py_tp_dealloc, _dealloc_AudioDeviceModulesManager },
        { Py_tp_methods, _methods_AudioDeviceModulesManager },
        { Py_tp_getset, _getset_AudioDeviceModulesManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioDeviceModulesManager =
    {
        "_winrt_Windows_Media_Devices.AudioDeviceModulesManager",
        sizeof(py::wrapper::Windows::Media::Devices::AudioDeviceModulesManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceModulesManager
    };

    // ----- CameraOcclusionInfo class --------------------
    constexpr const char* const _type_name_CameraOcclusionInfo = "CameraOcclusionInfo";

    static PyObject* _new_CameraOcclusionInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CameraOcclusionInfo);
        return nullptr;
    }

    static void _dealloc_CameraOcclusionInfo(py::wrapper::Windows::Media::Devices::CameraOcclusionInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CameraOcclusionInfo_GetState(py::wrapper::Windows::Media::Devices::CameraOcclusionInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetState());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraOcclusionInfo_IsOcclusionKindSupported(py::wrapper::Windows::Media::Devices::CameraOcclusionInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::CameraOcclusionKind>(args, 0);

                return py::convert(self->obj.IsOcclusionKindSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraOcclusionInfo_add_StateChanged(py::wrapper::Windows::Media::Devices::CameraOcclusionInfo* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Devices::CameraOcclusionInfo, winrt::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraOcclusionInfo_remove_StateChanged(py::wrapper::Windows::Media::Devices::CameraOcclusionInfo* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CameraOcclusionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::CameraOcclusionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraOcclusionInfo[] = {
        { "get_state", (PyCFunction)CameraOcclusionInfo_GetState, METH_VARARGS, nullptr },
        { "is_occlusion_kind_supported", (PyCFunction)CameraOcclusionInfo_IsOcclusionKindSupported, METH_VARARGS, nullptr },
        { "add_state_changed", (PyCFunction)CameraOcclusionInfo_add_StateChanged, METH_O, nullptr },
        { "remove_state_changed", (PyCFunction)CameraOcclusionInfo_remove_StateChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_CameraOcclusionInfo, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CameraOcclusionInfo[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_CameraOcclusionInfo[] = 
    {
        { Py_tp_new, _new_CameraOcclusionInfo },
        { Py_tp_dealloc, _dealloc_CameraOcclusionInfo },
        { Py_tp_methods, _methods_CameraOcclusionInfo },
        { Py_tp_getset, _getset_CameraOcclusionInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CameraOcclusionInfo =
    {
        "_winrt_Windows_Media_Devices.CameraOcclusionInfo",
        sizeof(py::wrapper::Windows::Media::Devices::CameraOcclusionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraOcclusionInfo
    };

    // ----- CameraOcclusionState class --------------------
    constexpr const char* const _type_name_CameraOcclusionState = "CameraOcclusionState";

    static PyObject* _new_CameraOcclusionState(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CameraOcclusionState);
        return nullptr;
    }

    static void _dealloc_CameraOcclusionState(py::wrapper::Windows::Media::Devices::CameraOcclusionState* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CameraOcclusionState_IsOcclusionKind(py::wrapper::Windows::Media::Devices::CameraOcclusionState* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::CameraOcclusionKind>(args, 0);

                return py::convert(self->obj.IsOcclusionKind(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraOcclusionState_get_IsOccluded(py::wrapper::Windows::Media::Devices::CameraOcclusionState* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOccluded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CameraOcclusionState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::CameraOcclusionState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraOcclusionState[] = {
        { "is_occlusion_kind", (PyCFunction)CameraOcclusionState_IsOcclusionKind, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_CameraOcclusionState, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CameraOcclusionState[] = {
        { const_cast<char*>("is_occluded"), (getter)CameraOcclusionState_get_IsOccluded, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CameraOcclusionState[] = 
    {
        { Py_tp_new, _new_CameraOcclusionState },
        { Py_tp_dealloc, _dealloc_CameraOcclusionState },
        { Py_tp_methods, _methods_CameraOcclusionState },
        { Py_tp_getset, _getset_CameraOcclusionState },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CameraOcclusionState =
    {
        "_winrt_Windows_Media_Devices.CameraOcclusionState",
        sizeof(py::wrapper::Windows::Media::Devices::CameraOcclusionState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraOcclusionState
    };

    // ----- CameraOcclusionStateChangedEventArgs class --------------------
    constexpr const char* const _type_name_CameraOcclusionStateChangedEventArgs = "CameraOcclusionStateChangedEventArgs";

    static PyObject* _new_CameraOcclusionStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CameraOcclusionStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_CameraOcclusionStateChangedEventArgs(py::wrapper::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CameraOcclusionStateChangedEventArgs_get_State(py::wrapper::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CameraOcclusionStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraOcclusionStateChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_CameraOcclusionStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_CameraOcclusionStateChangedEventArgs[] = {
        { const_cast<char*>("state"), (getter)CameraOcclusionStateChangedEventArgs_get_State, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_CameraOcclusionStateChangedEventArgs[] = 
    {
        { Py_tp_new, _new_CameraOcclusionStateChangedEventArgs },
        { Py_tp_dealloc, _dealloc_CameraOcclusionStateChangedEventArgs },
        { Py_tp_methods, _methods_CameraOcclusionStateChangedEventArgs },
        { Py_tp_getset, _getset_CameraOcclusionStateChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CameraOcclusionStateChangedEventArgs =
    {
        "_winrt_Windows_Media_Devices.CameraOcclusionStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraOcclusionStateChangedEventArgs
    };

    // ----- DefaultAudioCaptureDeviceChangedEventArgs class --------------------
    constexpr const char* const _type_name_DefaultAudioCaptureDeviceChangedEventArgs = "DefaultAudioCaptureDeviceChangedEventArgs";

    static PyObject* _new_DefaultAudioCaptureDeviceChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DefaultAudioCaptureDeviceChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_DefaultAudioCaptureDeviceChangedEventArgs(py::wrapper::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DefaultAudioCaptureDeviceChangedEventArgs_get_Id(py::wrapper::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DefaultAudioCaptureDeviceChangedEventArgs_get_Role(py::wrapper::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Role());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DefaultAudioCaptureDeviceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DefaultAudioCaptureDeviceChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_DefaultAudioCaptureDeviceChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DefaultAudioCaptureDeviceChangedEventArgs[] = {
        { const_cast<char*>("id"), (getter)DefaultAudioCaptureDeviceChangedEventArgs_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("role"), (getter)DefaultAudioCaptureDeviceChangedEventArgs_get_Role, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DefaultAudioCaptureDeviceChangedEventArgs[] = 
    {
        { Py_tp_new, _new_DefaultAudioCaptureDeviceChangedEventArgs },
        { Py_tp_dealloc, _dealloc_DefaultAudioCaptureDeviceChangedEventArgs },
        { Py_tp_methods, _methods_DefaultAudioCaptureDeviceChangedEventArgs },
        { Py_tp_getset, _getset_DefaultAudioCaptureDeviceChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DefaultAudioCaptureDeviceChangedEventArgs =
    {
        "_winrt_Windows_Media_Devices.DefaultAudioCaptureDeviceChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DefaultAudioCaptureDeviceChangedEventArgs
    };

    // ----- DefaultAudioRenderDeviceChangedEventArgs class --------------------
    constexpr const char* const _type_name_DefaultAudioRenderDeviceChangedEventArgs = "DefaultAudioRenderDeviceChangedEventArgs";

    static PyObject* _new_DefaultAudioRenderDeviceChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DefaultAudioRenderDeviceChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_DefaultAudioRenderDeviceChangedEventArgs(py::wrapper::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DefaultAudioRenderDeviceChangedEventArgs_get_Id(py::wrapper::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DefaultAudioRenderDeviceChangedEventArgs_get_Role(py::wrapper::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Role());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DefaultAudioRenderDeviceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DefaultAudioRenderDeviceChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_DefaultAudioRenderDeviceChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DefaultAudioRenderDeviceChangedEventArgs[] = {
        { const_cast<char*>("id"), (getter)DefaultAudioRenderDeviceChangedEventArgs_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("role"), (getter)DefaultAudioRenderDeviceChangedEventArgs_get_Role, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DefaultAudioRenderDeviceChangedEventArgs[] = 
    {
        { Py_tp_new, _new_DefaultAudioRenderDeviceChangedEventArgs },
        { Py_tp_dealloc, _dealloc_DefaultAudioRenderDeviceChangedEventArgs },
        { Py_tp_methods, _methods_DefaultAudioRenderDeviceChangedEventArgs },
        { Py_tp_getset, _getset_DefaultAudioRenderDeviceChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DefaultAudioRenderDeviceChangedEventArgs =
    {
        "_winrt_Windows_Media_Devices.DefaultAudioRenderDeviceChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DefaultAudioRenderDeviceChangedEventArgs
    };

    // ----- DigitalWindowBounds class --------------------
    constexpr const char* const _type_name_DigitalWindowBounds = "DigitalWindowBounds";

    static PyObject* _new_DigitalWindowBounds(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Devices::DigitalWindowBounds instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DigitalWindowBounds(py::wrapper::Windows::Media::Devices::DigitalWindowBounds* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DigitalWindowBounds_get_Scale(py::wrapper::Windows::Media::Devices::DigitalWindowBounds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Scale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DigitalWindowBounds_put_Scale(py::wrapper::Windows::Media::Devices::DigitalWindowBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Scale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DigitalWindowBounds_get_NormalizedOriginTop(py::wrapper::Windows::Media::Devices::DigitalWindowBounds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NormalizedOriginTop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DigitalWindowBounds_put_NormalizedOriginTop(py::wrapper::Windows::Media::Devices::DigitalWindowBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.NormalizedOriginTop(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DigitalWindowBounds_get_NormalizedOriginLeft(py::wrapper::Windows::Media::Devices::DigitalWindowBounds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NormalizedOriginLeft());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DigitalWindowBounds_put_NormalizedOriginLeft(py::wrapper::Windows::Media::Devices::DigitalWindowBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.NormalizedOriginLeft(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_DigitalWindowBounds(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::DigitalWindowBounds>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DigitalWindowBounds[] = {
        { "_from", (PyCFunction)_from_DigitalWindowBounds, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DigitalWindowBounds[] = {
        { const_cast<char*>("scale"), (getter)DigitalWindowBounds_get_Scale, (setter)DigitalWindowBounds_put_Scale, nullptr, nullptr },
        { const_cast<char*>("normalized_origin_top"), (getter)DigitalWindowBounds_get_NormalizedOriginTop, (setter)DigitalWindowBounds_put_NormalizedOriginTop, nullptr, nullptr },
        { const_cast<char*>("normalized_origin_left"), (getter)DigitalWindowBounds_get_NormalizedOriginLeft, (setter)DigitalWindowBounds_put_NormalizedOriginLeft, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DigitalWindowBounds[] = 
    {
        { Py_tp_new, _new_DigitalWindowBounds },
        { Py_tp_dealloc, _dealloc_DigitalWindowBounds },
        { Py_tp_methods, _methods_DigitalWindowBounds },
        { Py_tp_getset, _getset_DigitalWindowBounds },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DigitalWindowBounds =
    {
        "_winrt_Windows_Media_Devices.DigitalWindowBounds",
        sizeof(py::wrapper::Windows::Media::Devices::DigitalWindowBounds),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DigitalWindowBounds
    };

    // ----- DigitalWindowCapability class --------------------
    constexpr const char* const _type_name_DigitalWindowCapability = "DigitalWindowCapability";

    static PyObject* _new_DigitalWindowCapability(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DigitalWindowCapability);
        return nullptr;
    }

    static void _dealloc_DigitalWindowCapability(py::wrapper::Windows::Media::Devices::DigitalWindowCapability* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DigitalWindowCapability_get_Height(py::wrapper::Windows::Media::Devices::DigitalWindowCapability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowCapability_get_MaxScaleValue(py::wrapper::Windows::Media::Devices::DigitalWindowCapability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxScaleValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowCapability_get_MinScaleValue(py::wrapper::Windows::Media::Devices::DigitalWindowCapability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinScaleValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowCapability_get_MinScaleValueWithoutUpsampling(py::wrapper::Windows::Media::Devices::DigitalWindowCapability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinScaleValueWithoutUpsampling());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowCapability_get_NormalizedFieldOfViewLimit(py::wrapper::Windows::Media::Devices::DigitalWindowCapability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NormalizedFieldOfViewLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowCapability_get_Width(py::wrapper::Windows::Media::Devices::DigitalWindowCapability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DigitalWindowCapability(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::DigitalWindowCapability>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DigitalWindowCapability[] = {
        { "_from", (PyCFunction)_from_DigitalWindowCapability, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DigitalWindowCapability[] = {
        { const_cast<char*>("height"), (getter)DigitalWindowCapability_get_Height, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_scale_value"), (getter)DigitalWindowCapability_get_MaxScaleValue, nullptr, nullptr, nullptr },
        { const_cast<char*>("min_scale_value"), (getter)DigitalWindowCapability_get_MinScaleValue, nullptr, nullptr, nullptr },
        { const_cast<char*>("min_scale_value_without_upsampling"), (getter)DigitalWindowCapability_get_MinScaleValueWithoutUpsampling, nullptr, nullptr, nullptr },
        { const_cast<char*>("normalized_field_of_view_limit"), (getter)DigitalWindowCapability_get_NormalizedFieldOfViewLimit, nullptr, nullptr, nullptr },
        { const_cast<char*>("width"), (getter)DigitalWindowCapability_get_Width, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DigitalWindowCapability[] = 
    {
        { Py_tp_new, _new_DigitalWindowCapability },
        { Py_tp_dealloc, _dealloc_DigitalWindowCapability },
        { Py_tp_methods, _methods_DigitalWindowCapability },
        { Py_tp_getset, _getset_DigitalWindowCapability },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DigitalWindowCapability =
    {
        "_winrt_Windows_Media_Devices.DigitalWindowCapability",
        sizeof(py::wrapper::Windows::Media::Devices::DigitalWindowCapability),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DigitalWindowCapability
    };

    // ----- DigitalWindowControl class --------------------
    constexpr const char* const _type_name_DigitalWindowControl = "DigitalWindowControl";

    static PyObject* _new_DigitalWindowControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DigitalWindowControl);
        return nullptr;
    }

    static void _dealloc_DigitalWindowControl(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DigitalWindowControl_Configure(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::DigitalWindowMode>(args, 0);

                self->obj.Configure(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::DigitalWindowMode>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Devices::DigitalWindowBounds>(args, 1);

                self->obj.Configure(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DigitalWindowControl_GetBounds(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetBounds());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DigitalWindowControl_GetCapabilityForSize(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.GetCapabilityForSize(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DigitalWindowControl_get_CurrentMode(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowControl_get_IsSupported(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowControl_get_SupportedCapabilities(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DigitalWindowControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::DigitalWindowControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DigitalWindowControl[] = {
        { "configure", (PyCFunction)DigitalWindowControl_Configure, METH_VARARGS, nullptr },
        { "get_bounds", (PyCFunction)DigitalWindowControl_GetBounds, METH_VARARGS, nullptr },
        { "get_capability_for_size", (PyCFunction)DigitalWindowControl_GetCapabilityForSize, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_DigitalWindowControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_DigitalWindowControl[] = {
        { const_cast<char*>("current_mode"), (getter)DigitalWindowControl_get_CurrentMode, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_supported"), (getter)DigitalWindowControl_get_IsSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_capabilities"), (getter)DigitalWindowControl_get_SupportedCapabilities, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_modes"), (getter)DigitalWindowControl_get_SupportedModes, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_DigitalWindowControl[] = 
    {
        { Py_tp_new, _new_DigitalWindowControl },
        { Py_tp_dealloc, _dealloc_DigitalWindowControl },
        { Py_tp_methods, _methods_DigitalWindowControl },
        { Py_tp_getset, _getset_DigitalWindowControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DigitalWindowControl =
    {
        "_winrt_Windows_Media_Devices.DigitalWindowControl",
        sizeof(py::wrapper::Windows::Media::Devices::DigitalWindowControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DigitalWindowControl
    };

    // ----- ExposureCompensationControl class --------------------
    constexpr const char* const _type_name_ExposureCompensationControl = "ExposureCompensationControl";

    static PyObject* _new_ExposureCompensationControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ExposureCompensationControl);
        return nullptr;
    }

    static void _dealloc_ExposureCompensationControl(py::wrapper::Windows::Media::Devices::ExposureCompensationControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ExposureCompensationControl_SetValueAsync(py::wrapper::Windows::Media::Devices::ExposureCompensationControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<float>(args, 0);

                return py::convert(self->obj.SetValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ExposureCompensationControl_get_Max(py::wrapper::Windows::Media::Devices::ExposureCompensationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureCompensationControl_get_Min(py::wrapper::Windows::Media::Devices::ExposureCompensationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureCompensationControl_get_Step(py::wrapper::Windows::Media::Devices::ExposureCompensationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureCompensationControl_get_Supported(py::wrapper::Windows::Media::Devices::ExposureCompensationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureCompensationControl_get_Value(py::wrapper::Windows::Media::Devices::ExposureCompensationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ExposureCompensationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::ExposureCompensationControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExposureCompensationControl[] = {
        { "set_value_async", (PyCFunction)ExposureCompensationControl_SetValueAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ExposureCompensationControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ExposureCompensationControl[] = {
        { const_cast<char*>("max"), (getter)ExposureCompensationControl_get_Max, nullptr, nullptr, nullptr },
        { const_cast<char*>("min"), (getter)ExposureCompensationControl_get_Min, nullptr, nullptr, nullptr },
        { const_cast<char*>("step"), (getter)ExposureCompensationControl_get_Step, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)ExposureCompensationControl_get_Supported, nullptr, nullptr, nullptr },
        { const_cast<char*>("value"), (getter)ExposureCompensationControl_get_Value, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ExposureCompensationControl[] = 
    {
        { Py_tp_new, _new_ExposureCompensationControl },
        { Py_tp_dealloc, _dealloc_ExposureCompensationControl },
        { Py_tp_methods, _methods_ExposureCompensationControl },
        { Py_tp_getset, _getset_ExposureCompensationControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ExposureCompensationControl =
    {
        "_winrt_Windows_Media_Devices.ExposureCompensationControl",
        sizeof(py::wrapper::Windows::Media::Devices::ExposureCompensationControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ExposureCompensationControl
    };

    // ----- ExposureControl class --------------------
    constexpr const char* const _type_name_ExposureControl = "ExposureControl";

    static PyObject* _new_ExposureControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ExposureControl);
        return nullptr;
    }

    static void _dealloc_ExposureControl(py::wrapper::Windows::Media::Devices::ExposureControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ExposureControl_SetAutoAsync(py::wrapper::Windows::Media::Devices::ExposureControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetAutoAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ExposureControl_SetValueAsync(py::wrapper::Windows::Media::Devices::ExposureControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(self->obj.SetValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ExposureControl_get_Auto(py::wrapper::Windows::Media::Devices::ExposureControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Auto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureControl_get_Max(py::wrapper::Windows::Media::Devices::ExposureControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureControl_get_Min(py::wrapper::Windows::Media::Devices::ExposureControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureControl_get_Step(py::wrapper::Windows::Media::Devices::ExposureControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureControl_get_Supported(py::wrapper::Windows::Media::Devices::ExposureControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureControl_get_Value(py::wrapper::Windows::Media::Devices::ExposureControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ExposureControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::ExposureControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExposureControl[] = {
        { "set_auto_async", (PyCFunction)ExposureControl_SetAutoAsync, METH_VARARGS, nullptr },
        { "set_value_async", (PyCFunction)ExposureControl_SetValueAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ExposureControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ExposureControl[] = {
        { const_cast<char*>("auto"), (getter)ExposureControl_get_Auto, nullptr, nullptr, nullptr },
        { const_cast<char*>("max"), (getter)ExposureControl_get_Max, nullptr, nullptr, nullptr },
        { const_cast<char*>("min"), (getter)ExposureControl_get_Min, nullptr, nullptr, nullptr },
        { const_cast<char*>("step"), (getter)ExposureControl_get_Step, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)ExposureControl_get_Supported, nullptr, nullptr, nullptr },
        { const_cast<char*>("value"), (getter)ExposureControl_get_Value, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ExposureControl[] = 
    {
        { Py_tp_new, _new_ExposureControl },
        { Py_tp_dealloc, _dealloc_ExposureControl },
        { Py_tp_methods, _methods_ExposureControl },
        { Py_tp_getset, _getset_ExposureControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ExposureControl =
    {
        "_winrt_Windows_Media_Devices.ExposureControl",
        sizeof(py::wrapper::Windows::Media::Devices::ExposureControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ExposureControl
    };

    // ----- ExposurePriorityVideoControl class --------------------
    constexpr const char* const _type_name_ExposurePriorityVideoControl = "ExposurePriorityVideoControl";

    static PyObject* _new_ExposurePriorityVideoControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ExposurePriorityVideoControl);
        return nullptr;
    }

    static void _dealloc_ExposurePriorityVideoControl(py::wrapper::Windows::Media::Devices::ExposurePriorityVideoControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ExposurePriorityVideoControl_get_Enabled(py::wrapper::Windows::Media::Devices::ExposurePriorityVideoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ExposurePriorityVideoControl_put_Enabled(py::wrapper::Windows::Media::Devices::ExposurePriorityVideoControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ExposurePriorityVideoControl_get_Supported(py::wrapper::Windows::Media::Devices::ExposurePriorityVideoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ExposurePriorityVideoControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::ExposurePriorityVideoControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExposurePriorityVideoControl[] = {
        { "_from", (PyCFunction)_from_ExposurePriorityVideoControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ExposurePriorityVideoControl[] = {
        { const_cast<char*>("enabled"), (getter)ExposurePriorityVideoControl_get_Enabled, (setter)ExposurePriorityVideoControl_put_Enabled, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)ExposurePriorityVideoControl_get_Supported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ExposurePriorityVideoControl[] = 
    {
        { Py_tp_new, _new_ExposurePriorityVideoControl },
        { Py_tp_dealloc, _dealloc_ExposurePriorityVideoControl },
        { Py_tp_methods, _methods_ExposurePriorityVideoControl },
        { Py_tp_getset, _getset_ExposurePriorityVideoControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ExposurePriorityVideoControl =
    {
        "_winrt_Windows_Media_Devices.ExposurePriorityVideoControl",
        sizeof(py::wrapper::Windows::Media::Devices::ExposurePriorityVideoControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ExposurePriorityVideoControl
    };

    // ----- FlashControl class --------------------
    constexpr const char* const _type_name_FlashControl = "FlashControl";

    static PyObject* _new_FlashControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FlashControl);
        return nullptr;
    }

    static void _dealloc_FlashControl(py::wrapper::Windows::Media::Devices::FlashControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FlashControl_get_RedEyeReduction(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RedEyeReduction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlashControl_put_RedEyeReduction(py::wrapper::Windows::Media::Devices::FlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RedEyeReduction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlashControl_get_PowerPercent(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlashControl_put_PowerPercent(py::wrapper::Windows::Media::Devices::FlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.PowerPercent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlashControl_get_Enabled(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlashControl_put_Enabled(py::wrapper::Windows::Media::Devices::FlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlashControl_get_Auto(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Auto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlashControl_put_Auto(py::wrapper::Windows::Media::Devices::FlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Auto(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlashControl_get_PowerSupported(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlashControl_get_RedEyeReductionSupported(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RedEyeReductionSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlashControl_get_Supported(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlashControl_get_AssistantLightEnabled(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AssistantLightEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlashControl_put_AssistantLightEnabled(py::wrapper::Windows::Media::Devices::FlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AssistantLightEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlashControl_get_AssistantLightSupported(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AssistantLightSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FlashControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::FlashControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlashControl[] = {
        { "_from", (PyCFunction)_from_FlashControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FlashControl[] = {
        { const_cast<char*>("red_eye_reduction"), (getter)FlashControl_get_RedEyeReduction, (setter)FlashControl_put_RedEyeReduction, nullptr, nullptr },
        { const_cast<char*>("power_percent"), (getter)FlashControl_get_PowerPercent, (setter)FlashControl_put_PowerPercent, nullptr, nullptr },
        { const_cast<char*>("enabled"), (getter)FlashControl_get_Enabled, (setter)FlashControl_put_Enabled, nullptr, nullptr },
        { const_cast<char*>("auto"), (getter)FlashControl_get_Auto, (setter)FlashControl_put_Auto, nullptr, nullptr },
        { const_cast<char*>("power_supported"), (getter)FlashControl_get_PowerSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("red_eye_reduction_supported"), (getter)FlashControl_get_RedEyeReductionSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)FlashControl_get_Supported, nullptr, nullptr, nullptr },
        { const_cast<char*>("assistant_light_enabled"), (getter)FlashControl_get_AssistantLightEnabled, (setter)FlashControl_put_AssistantLightEnabled, nullptr, nullptr },
        { const_cast<char*>("assistant_light_supported"), (getter)FlashControl_get_AssistantLightSupported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FlashControl[] = 
    {
        { Py_tp_new, _new_FlashControl },
        { Py_tp_dealloc, _dealloc_FlashControl },
        { Py_tp_methods, _methods_FlashControl },
        { Py_tp_getset, _getset_FlashControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FlashControl =
    {
        "_winrt_Windows_Media_Devices.FlashControl",
        sizeof(py::wrapper::Windows::Media::Devices::FlashControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlashControl
    };

    // ----- FocusControl class --------------------
    constexpr const char* const _type_name_FocusControl = "FocusControl";

    static PyObject* _new_FocusControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FocusControl);
        return nullptr;
    }

    static void _dealloc_FocusControl(py::wrapper::Windows::Media::Devices::FocusControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FocusControl_Configure(py::wrapper::Windows::Media::Devices::FocusControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::FocusSettings>(args, 0);

                self->obj.Configure(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusControl_FocusAsync(py::wrapper::Windows::Media::Devices::FocusControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FocusAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusControl_LockAsync(py::wrapper::Windows::Media::Devices::FocusControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.LockAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusControl_SetPresetAsync(py::wrapper::Windows::Media::Devices::FocusControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::FocusPreset>(args, 0);

                return py::convert(self->obj.SetPresetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::FocusPreset>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.SetPresetAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusControl_SetValueAsync(py::wrapper::Windows::Media::Devices::FocusControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.SetValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusControl_UnlockAsync(py::wrapper::Windows::Media::Devices::FocusControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.UnlockAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_Max(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_Min(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_Preset(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Preset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_Step(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_Supported(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_SupportedPresets(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedPresets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_Value(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_FocusChangedSupported(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FocusChangedSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_FocusState(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FocusState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_Mode(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_SupportedFocusDistances(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedFocusDistances());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_SupportedFocusModes(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedFocusModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_SupportedFocusRanges(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedFocusRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_WaitForFocusSupported(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WaitForFocusSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FocusControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::FocusControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusControl[] = {
        { "configure", (PyCFunction)FocusControl_Configure, METH_VARARGS, nullptr },
        { "focus_async", (PyCFunction)FocusControl_FocusAsync, METH_VARARGS, nullptr },
        { "lock_async", (PyCFunction)FocusControl_LockAsync, METH_VARARGS, nullptr },
        { "set_preset_async", (PyCFunction)FocusControl_SetPresetAsync, METH_VARARGS, nullptr },
        { "set_value_async", (PyCFunction)FocusControl_SetValueAsync, METH_VARARGS, nullptr },
        { "unlock_async", (PyCFunction)FocusControl_UnlockAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_FocusControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FocusControl[] = {
        { const_cast<char*>("max"), (getter)FocusControl_get_Max, nullptr, nullptr, nullptr },
        { const_cast<char*>("min"), (getter)FocusControl_get_Min, nullptr, nullptr, nullptr },
        { const_cast<char*>("preset"), (getter)FocusControl_get_Preset, nullptr, nullptr, nullptr },
        { const_cast<char*>("step"), (getter)FocusControl_get_Step, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)FocusControl_get_Supported, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_presets"), (getter)FocusControl_get_SupportedPresets, nullptr, nullptr, nullptr },
        { const_cast<char*>("value"), (getter)FocusControl_get_Value, nullptr, nullptr, nullptr },
        { const_cast<char*>("focus_changed_supported"), (getter)FocusControl_get_FocusChangedSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("focus_state"), (getter)FocusControl_get_FocusState, nullptr, nullptr, nullptr },
        { const_cast<char*>("mode"), (getter)FocusControl_get_Mode, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_focus_distances"), (getter)FocusControl_get_SupportedFocusDistances, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_focus_modes"), (getter)FocusControl_get_SupportedFocusModes, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_focus_ranges"), (getter)FocusControl_get_SupportedFocusRanges, nullptr, nullptr, nullptr },
        { const_cast<char*>("wait_for_focus_supported"), (getter)FocusControl_get_WaitForFocusSupported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FocusControl[] = 
    {
        { Py_tp_new, _new_FocusControl },
        { Py_tp_dealloc, _dealloc_FocusControl },
        { Py_tp_methods, _methods_FocusControl },
        { Py_tp_getset, _getset_FocusControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FocusControl =
    {
        "_winrt_Windows_Media_Devices.FocusControl",
        sizeof(py::wrapper::Windows::Media::Devices::FocusControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusControl
    };

    // ----- FocusSettings class --------------------
    constexpr const char* const _type_name_FocusSettings = "FocusSettings";

    static PyObject* _new_FocusSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Devices::FocusSettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FocusSettings(py::wrapper::Windows::Media::Devices::FocusSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FocusSettings_get_WaitForFocus(py::wrapper::Windows::Media::Devices::FocusSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WaitForFocus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FocusSettings_put_WaitForFocus(py::wrapper::Windows::Media::Devices::FocusSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.WaitForFocus(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FocusSettings_get_Value(py::wrapper::Windows::Media::Devices::FocusSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FocusSettings_put_Value(py::wrapper::Windows::Media::Devices::FocusSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FocusSettings_get_Mode(py::wrapper::Windows::Media::Devices::FocusSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FocusSettings_put_Mode(py::wrapper::Windows::Media::Devices::FocusSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::FocusMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FocusSettings_get_Distance(py::wrapper::Windows::Media::Devices::FocusSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Distance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FocusSettings_put_Distance(py::wrapper::Windows::Media::Devices::FocusSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Media::Devices::ManualFocusDistance>>(arg);

            self->obj.Distance(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FocusSettings_get_DisableDriverFallback(py::wrapper::Windows::Media::Devices::FocusSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisableDriverFallback());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FocusSettings_put_DisableDriverFallback(py::wrapper::Windows::Media::Devices::FocusSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DisableDriverFallback(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FocusSettings_get_AutoFocusRange(py::wrapper::Windows::Media::Devices::FocusSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoFocusRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FocusSettings_put_AutoFocusRange(py::wrapper::Windows::Media::Devices::FocusSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::AutoFocusRange>(arg);

            self->obj.AutoFocusRange(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_FocusSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::FocusSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusSettings[] = {
        { "_from", (PyCFunction)_from_FocusSettings, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_FocusSettings[] = {
        { const_cast<char*>("wait_for_focus"), (getter)FocusSettings_get_WaitForFocus, (setter)FocusSettings_put_WaitForFocus, nullptr, nullptr },
        { const_cast<char*>("value"), (getter)FocusSettings_get_Value, (setter)FocusSettings_put_Value, nullptr, nullptr },
        { const_cast<char*>("mode"), (getter)FocusSettings_get_Mode, (setter)FocusSettings_put_Mode, nullptr, nullptr },
        { const_cast<char*>("distance"), (getter)FocusSettings_get_Distance, (setter)FocusSettings_put_Distance, nullptr, nullptr },
        { const_cast<char*>("disable_driver_fallback"), (getter)FocusSettings_get_DisableDriverFallback, (setter)FocusSettings_put_DisableDriverFallback, nullptr, nullptr },
        { const_cast<char*>("auto_focus_range"), (getter)FocusSettings_get_AutoFocusRange, (setter)FocusSettings_put_AutoFocusRange, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_FocusSettings[] = 
    {
        { Py_tp_new, _new_FocusSettings },
        { Py_tp_dealloc, _dealloc_FocusSettings },
        { Py_tp_methods, _methods_FocusSettings },
        { Py_tp_getset, _getset_FocusSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FocusSettings =
    {
        "_winrt_Windows_Media_Devices.FocusSettings",
        sizeof(py::wrapper::Windows::Media::Devices::FocusSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusSettings
    };

    // ----- HdrVideoControl class --------------------
    constexpr const char* const _type_name_HdrVideoControl = "HdrVideoControl";

    static PyObject* _new_HdrVideoControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HdrVideoControl);
        return nullptr;
    }

    static void _dealloc_HdrVideoControl(py::wrapper::Windows::Media::Devices::HdrVideoControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HdrVideoControl_get_Mode(py::wrapper::Windows::Media::Devices::HdrVideoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HdrVideoControl_put_Mode(py::wrapper::Windows::Media::Devices::HdrVideoControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::HdrVideoMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HdrVideoControl_get_Supported(py::wrapper::Windows::Media::Devices::HdrVideoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HdrVideoControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::HdrVideoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HdrVideoControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::HdrVideoControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HdrVideoControl[] = {
        { "_from", (PyCFunction)_from_HdrVideoControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_HdrVideoControl[] = {
        { const_cast<char*>("mode"), (getter)HdrVideoControl_get_Mode, (setter)HdrVideoControl_put_Mode, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)HdrVideoControl_get_Supported, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_modes"), (getter)HdrVideoControl_get_SupportedModes, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_HdrVideoControl[] = 
    {
        { Py_tp_new, _new_HdrVideoControl },
        { Py_tp_dealloc, _dealloc_HdrVideoControl },
        { Py_tp_methods, _methods_HdrVideoControl },
        { Py_tp_getset, _getset_HdrVideoControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HdrVideoControl =
    {
        "_winrt_Windows_Media_Devices.HdrVideoControl",
        sizeof(py::wrapper::Windows::Media::Devices::HdrVideoControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HdrVideoControl
    };

    // ----- InfraredTorchControl class --------------------
    constexpr const char* const _type_name_InfraredTorchControl = "InfraredTorchControl";

    static PyObject* _new_InfraredTorchControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InfraredTorchControl);
        return nullptr;
    }

    static void _dealloc_InfraredTorchControl(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InfraredTorchControl_get_Power(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Power());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfraredTorchControl_put_Power(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Power(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfraredTorchControl_get_CurrentMode(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfraredTorchControl_put_CurrentMode(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::InfraredTorchMode>(arg);

            self->obj.CurrentMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfraredTorchControl_get_IsSupported(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfraredTorchControl_get_MaxPower(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPower());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfraredTorchControl_get_MinPower(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinPower());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfraredTorchControl_get_PowerStep(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerStep());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfraredTorchControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InfraredTorchControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::InfraredTorchControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InfraredTorchControl[] = {
        { "_from", (PyCFunction)_from_InfraredTorchControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_InfraredTorchControl[] = {
        { const_cast<char*>("power"), (getter)InfraredTorchControl_get_Power, (setter)InfraredTorchControl_put_Power, nullptr, nullptr },
        { const_cast<char*>("current_mode"), (getter)InfraredTorchControl_get_CurrentMode, (setter)InfraredTorchControl_put_CurrentMode, nullptr, nullptr },
        { const_cast<char*>("is_supported"), (getter)InfraredTorchControl_get_IsSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_power"), (getter)InfraredTorchControl_get_MaxPower, nullptr, nullptr, nullptr },
        { const_cast<char*>("min_power"), (getter)InfraredTorchControl_get_MinPower, nullptr, nullptr, nullptr },
        { const_cast<char*>("power_step"), (getter)InfraredTorchControl_get_PowerStep, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_modes"), (getter)InfraredTorchControl_get_SupportedModes, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_InfraredTorchControl[] = 
    {
        { Py_tp_new, _new_InfraredTorchControl },
        { Py_tp_dealloc, _dealloc_InfraredTorchControl },
        { Py_tp_methods, _methods_InfraredTorchControl },
        { Py_tp_getset, _getset_InfraredTorchControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InfraredTorchControl =
    {
        "_winrt_Windows_Media_Devices.InfraredTorchControl",
        sizeof(py::wrapper::Windows::Media::Devices::InfraredTorchControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InfraredTorchControl
    };

    // ----- IsoSpeedControl class --------------------
    constexpr const char* const _type_name_IsoSpeedControl = "IsoSpeedControl";

    static PyObject* _new_IsoSpeedControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_IsoSpeedControl);
        return nullptr;
    }

    static void _dealloc_IsoSpeedControl(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IsoSpeedControl_SetAutoAsync(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.SetAutoAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_SetPresetAsync(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::IsoSpeedPreset>(args, 0);

                return py::convert(self->obj.SetPresetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_SetValueAsync(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.SetValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_Preset(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Preset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_Supported(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_SupportedPresets(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedPresets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_Auto(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Auto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_Max(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_Min(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_Step(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_Value(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IsoSpeedControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::IsoSpeedControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsoSpeedControl[] = {
        { "set_auto_async", (PyCFunction)IsoSpeedControl_SetAutoAsync, METH_VARARGS, nullptr },
        { "set_preset_async", (PyCFunction)IsoSpeedControl_SetPresetAsync, METH_VARARGS, nullptr },
        { "set_value_async", (PyCFunction)IsoSpeedControl_SetValueAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IsoSpeedControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IsoSpeedControl[] = {
        { const_cast<char*>("preset"), (getter)IsoSpeedControl_get_Preset, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)IsoSpeedControl_get_Supported, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_presets"), (getter)IsoSpeedControl_get_SupportedPresets, nullptr, nullptr, nullptr },
        { const_cast<char*>("auto"), (getter)IsoSpeedControl_get_Auto, nullptr, nullptr, nullptr },
        { const_cast<char*>("max"), (getter)IsoSpeedControl_get_Max, nullptr, nullptr, nullptr },
        { const_cast<char*>("min"), (getter)IsoSpeedControl_get_Min, nullptr, nullptr, nullptr },
        { const_cast<char*>("step"), (getter)IsoSpeedControl_get_Step, nullptr, nullptr, nullptr },
        { const_cast<char*>("value"), (getter)IsoSpeedControl_get_Value, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IsoSpeedControl[] = 
    {
        { Py_tp_new, _new_IsoSpeedControl },
        { Py_tp_dealloc, _dealloc_IsoSpeedControl },
        { Py_tp_methods, _methods_IsoSpeedControl },
        { Py_tp_getset, _getset_IsoSpeedControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IsoSpeedControl =
    {
        "_winrt_Windows_Media_Devices.IsoSpeedControl",
        sizeof(py::wrapper::Windows::Media::Devices::IsoSpeedControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsoSpeedControl
    };

    // ----- LowLagPhotoControl class --------------------
    constexpr const char* const _type_name_LowLagPhotoControl = "LowLagPhotoControl";

    static PyObject* _new_LowLagPhotoControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LowLagPhotoControl);
        return nullptr;
    }

    static void _dealloc_LowLagPhotoControl(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LowLagPhotoControl_GetCurrentFrameRate(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentFrameRate());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoControl_GetHighestConcurrentFrameRate(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 0);

                return py::convert(self->obj.GetHighestConcurrentFrameRate(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoControl_get_ThumbnailFormat(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ThumbnailFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoControl_put_ThumbnailFormat(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaThumbnailFormat>(arg);

            self->obj.ThumbnailFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoControl_get_ThumbnailEnabled(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ThumbnailEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoControl_put_ThumbnailEnabled(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ThumbnailEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoControl_get_DesiredThumbnailSize(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredThumbnailSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoControl_put_DesiredThumbnailSize(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DesiredThumbnailSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoControl_get_HardwareAcceleratedThumbnailSupported(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareAcceleratedThumbnailSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LowLagPhotoControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::LowLagPhotoControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLagPhotoControl[] = {
        { "get_current_frame_rate", (PyCFunction)LowLagPhotoControl_GetCurrentFrameRate, METH_VARARGS, nullptr },
        { "get_highest_concurrent_frame_rate", (PyCFunction)LowLagPhotoControl_GetHighestConcurrentFrameRate, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_LowLagPhotoControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LowLagPhotoControl[] = {
        { const_cast<char*>("thumbnail_format"), (getter)LowLagPhotoControl_get_ThumbnailFormat, (setter)LowLagPhotoControl_put_ThumbnailFormat, nullptr, nullptr },
        { const_cast<char*>("thumbnail_enabled"), (getter)LowLagPhotoControl_get_ThumbnailEnabled, (setter)LowLagPhotoControl_put_ThumbnailEnabled, nullptr, nullptr },
        { const_cast<char*>("desired_thumbnail_size"), (getter)LowLagPhotoControl_get_DesiredThumbnailSize, (setter)LowLagPhotoControl_put_DesiredThumbnailSize, nullptr, nullptr },
        { const_cast<char*>("hardware_accelerated_thumbnail_supported"), (getter)LowLagPhotoControl_get_HardwareAcceleratedThumbnailSupported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LowLagPhotoControl[] = 
    {
        { Py_tp_new, _new_LowLagPhotoControl },
        { Py_tp_dealloc, _dealloc_LowLagPhotoControl },
        { Py_tp_methods, _methods_LowLagPhotoControl },
        { Py_tp_getset, _getset_LowLagPhotoControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LowLagPhotoControl =
    {
        "_winrt_Windows_Media_Devices.LowLagPhotoControl",
        sizeof(py::wrapper::Windows::Media::Devices::LowLagPhotoControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLagPhotoControl
    };

    // ----- LowLagPhotoSequenceControl class --------------------
    constexpr const char* const _type_name_LowLagPhotoSequenceControl = "LowLagPhotoSequenceControl";

    static PyObject* _new_LowLagPhotoSequenceControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LowLagPhotoSequenceControl);
        return nullptr;
    }

    static void _dealloc_LowLagPhotoSequenceControl(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LowLagPhotoSequenceControl_GetCurrentFrameRate(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentFrameRate());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_GetHighestConcurrentFrameRate(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 0);

                return py::convert(self->obj.GetHighestConcurrentFrameRate(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_ThumbnailFormat(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ThumbnailFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoSequenceControl_put_ThumbnailFormat(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaThumbnailFormat>(arg);

            self->obj.ThumbnailFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_ThumbnailEnabled(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ThumbnailEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoSequenceControl_put_ThumbnailEnabled(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ThumbnailEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_PhotosPerSecondLimit(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhotosPerSecondLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoSequenceControl_put_PhotosPerSecondLimit(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.PhotosPerSecondLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_PastPhotoLimit(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PastPhotoLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoSequenceControl_put_PastPhotoLimit(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.PastPhotoLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_DesiredThumbnailSize(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredThumbnailSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoSequenceControl_put_DesiredThumbnailSize(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DesiredThumbnailSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_HardwareAcceleratedThumbnailSupported(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareAcceleratedThumbnailSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_MaxPastPhotos(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPastPhotos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_MaxPhotosPerSecond(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPhotosPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_Supported(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LowLagPhotoSequenceControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::LowLagPhotoSequenceControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLagPhotoSequenceControl[] = {
        { "get_current_frame_rate", (PyCFunction)LowLagPhotoSequenceControl_GetCurrentFrameRate, METH_VARARGS, nullptr },
        { "get_highest_concurrent_frame_rate", (PyCFunction)LowLagPhotoSequenceControl_GetHighestConcurrentFrameRate, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_LowLagPhotoSequenceControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_LowLagPhotoSequenceControl[] = {
        { const_cast<char*>("thumbnail_format"), (getter)LowLagPhotoSequenceControl_get_ThumbnailFormat, (setter)LowLagPhotoSequenceControl_put_ThumbnailFormat, nullptr, nullptr },
        { const_cast<char*>("thumbnail_enabled"), (getter)LowLagPhotoSequenceControl_get_ThumbnailEnabled, (setter)LowLagPhotoSequenceControl_put_ThumbnailEnabled, nullptr, nullptr },
        { const_cast<char*>("photos_per_second_limit"), (getter)LowLagPhotoSequenceControl_get_PhotosPerSecondLimit, (setter)LowLagPhotoSequenceControl_put_PhotosPerSecondLimit, nullptr, nullptr },
        { const_cast<char*>("past_photo_limit"), (getter)LowLagPhotoSequenceControl_get_PastPhotoLimit, (setter)LowLagPhotoSequenceControl_put_PastPhotoLimit, nullptr, nullptr },
        { const_cast<char*>("desired_thumbnail_size"), (getter)LowLagPhotoSequenceControl_get_DesiredThumbnailSize, (setter)LowLagPhotoSequenceControl_put_DesiredThumbnailSize, nullptr, nullptr },
        { const_cast<char*>("hardware_accelerated_thumbnail_supported"), (getter)LowLagPhotoSequenceControl_get_HardwareAcceleratedThumbnailSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_past_photos"), (getter)LowLagPhotoSequenceControl_get_MaxPastPhotos, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_photos_per_second"), (getter)LowLagPhotoSequenceControl_get_MaxPhotosPerSecond, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)LowLagPhotoSequenceControl_get_Supported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_LowLagPhotoSequenceControl[] = 
    {
        { Py_tp_new, _new_LowLagPhotoSequenceControl },
        { Py_tp_dealloc, _dealloc_LowLagPhotoSequenceControl },
        { Py_tp_methods, _methods_LowLagPhotoSequenceControl },
        { Py_tp_getset, _getset_LowLagPhotoSequenceControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LowLagPhotoSequenceControl =
    {
        "_winrt_Windows_Media_Devices.LowLagPhotoSequenceControl",
        sizeof(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLagPhotoSequenceControl
    };

    // ----- MediaDevice class --------------------
    constexpr const char* const _type_name_MediaDevice = "MediaDevice";

    static PyObject* _new_MediaDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaDevice);
        return nullptr;
    }

    static PyObject* MediaDevice_GetAudioCaptureSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::Devices::MediaDevice::GetAudioCaptureSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDevice_GetAudioRenderSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::Devices::MediaDevice::GetAudioRenderSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDevice_GetDefaultAudioCaptureId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::AudioDeviceRole>(args, 0);

                return py::convert(winrt::Windows::Media::Devices::MediaDevice::GetDefaultAudioCaptureId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDevice_GetDefaultAudioRenderId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::AudioDeviceRole>(args, 0);

                return py::convert(winrt::Windows::Media::Devices::MediaDevice::GetDefaultAudioRenderId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDevice_GetVideoCaptureSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::Devices::MediaDevice::GetVideoCaptureSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDevice_add_DefaultAudioCaptureDeviceChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs>>(arg);

            return py::convert(winrt::Windows::Media::Devices::MediaDevice::DefaultAudioCaptureDeviceChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDevice_remove_DefaultAudioCaptureDeviceChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::Devices::MediaDevice::DefaultAudioCaptureDeviceChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDevice_add_DefaultAudioRenderDeviceChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs>>(arg);

            return py::convert(winrt::Windows::Media::Devices::MediaDevice::DefaultAudioRenderDeviceChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDevice_remove_DefaultAudioRenderDeviceChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::Devices::MediaDevice::DefaultAudioRenderDeviceChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaDevice[] = {
        { "get_audio_capture_selector", (PyCFunction)MediaDevice_GetAudioCaptureSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "get_audio_render_selector", (PyCFunction)MediaDevice_GetAudioRenderSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_audio_capture_id", (PyCFunction)MediaDevice_GetDefaultAudioCaptureId, METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_audio_render_id", (PyCFunction)MediaDevice_GetDefaultAudioRenderId, METH_VARARGS | METH_STATIC, nullptr },
        { "get_video_capture_selector", (PyCFunction)MediaDevice_GetVideoCaptureSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "add_default_audio_capture_device_changed", (PyCFunction)MediaDevice_add_DefaultAudioCaptureDeviceChanged, METH_O | METH_STATIC, nullptr },
        { "remove_default_audio_capture_device_changed", (PyCFunction)MediaDevice_remove_DefaultAudioCaptureDeviceChanged, METH_O | METH_STATIC, nullptr },
        { "add_default_audio_render_device_changed", (PyCFunction)MediaDevice_add_DefaultAudioRenderDeviceChanged, METH_O | METH_STATIC, nullptr },
        { "remove_default_audio_render_device_changed", (PyCFunction)MediaDevice_remove_DefaultAudioRenderDeviceChanged, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaDevice[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaDevice[] = 
    {
        { Py_tp_new, _new_MediaDevice },
        { Py_tp_methods, _methods_MediaDevice },
        { Py_tp_getset, _getset_MediaDevice },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaDevice =
    {
        "_winrt_Windows_Media_Devices.MediaDevice",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaDevice
    };

    // ----- MediaDeviceControl class --------------------
    constexpr const char* const _type_name_MediaDeviceControl = "MediaDeviceControl";

    static PyObject* _new_MediaDeviceControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaDeviceControl);
        return nullptr;
    }

    static void _dealloc_MediaDeviceControl(py::wrapper::Windows::Media::Devices::MediaDeviceControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaDeviceControl_TryGetAuto(py::wrapper::Windows::Media::Devices::MediaDeviceControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                bool param0 {  };

                auto return_value = self->obj.TryGetAuto(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControl_TryGetValue(py::wrapper::Windows::Media::Devices::MediaDeviceControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                double param0 {  };

                auto return_value = self->obj.TryGetValue(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControl_TrySetAuto(py::wrapper::Windows::Media::Devices::MediaDeviceControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.TrySetAuto(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControl_TrySetValue(py::wrapper::Windows::Media::Devices::MediaDeviceControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControl_get_Capabilities(py::wrapper::Windows::Media::Devices::MediaDeviceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaDeviceControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::MediaDeviceControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaDeviceControl[] = {
        { "try_get_auto", (PyCFunction)MediaDeviceControl_TryGetAuto, METH_VARARGS, nullptr },
        { "try_get_value", (PyCFunction)MediaDeviceControl_TryGetValue, METH_VARARGS, nullptr },
        { "try_set_auto", (PyCFunction)MediaDeviceControl_TrySetAuto, METH_VARARGS, nullptr },
        { "try_set_value", (PyCFunction)MediaDeviceControl_TrySetValue, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_MediaDeviceControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaDeviceControl[] = {
        { const_cast<char*>("capabilities"), (getter)MediaDeviceControl_get_Capabilities, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaDeviceControl[] = 
    {
        { Py_tp_new, _new_MediaDeviceControl },
        { Py_tp_dealloc, _dealloc_MediaDeviceControl },
        { Py_tp_methods, _methods_MediaDeviceControl },
        { Py_tp_getset, _getset_MediaDeviceControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaDeviceControl =
    {
        "_winrt_Windows_Media_Devices.MediaDeviceControl",
        sizeof(py::wrapper::Windows::Media::Devices::MediaDeviceControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaDeviceControl
    };

    // ----- MediaDeviceControlCapabilities class --------------------
    constexpr const char* const _type_name_MediaDeviceControlCapabilities = "MediaDeviceControlCapabilities";

    static PyObject* _new_MediaDeviceControlCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaDeviceControlCapabilities);
        return nullptr;
    }

    static void _dealloc_MediaDeviceControlCapabilities(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaDeviceControlCapabilities_get_AutoModeSupported(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoModeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControlCapabilities_get_Default(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Default());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControlCapabilities_get_Max(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControlCapabilities_get_Min(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControlCapabilities_get_Step(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControlCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaDeviceControlCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::MediaDeviceControlCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaDeviceControlCapabilities[] = {
        { "_from", (PyCFunction)_from_MediaDeviceControlCapabilities, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_MediaDeviceControlCapabilities[] = {
        { const_cast<char*>("auto_mode_supported"), (getter)MediaDeviceControlCapabilities_get_AutoModeSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("default"), (getter)MediaDeviceControlCapabilities_get_Default, nullptr, nullptr, nullptr },
        { const_cast<char*>("max"), (getter)MediaDeviceControlCapabilities_get_Max, nullptr, nullptr, nullptr },
        { const_cast<char*>("min"), (getter)MediaDeviceControlCapabilities_get_Min, nullptr, nullptr, nullptr },
        { const_cast<char*>("step"), (getter)MediaDeviceControlCapabilities_get_Step, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)MediaDeviceControlCapabilities_get_Supported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_MediaDeviceControlCapabilities[] = 
    {
        { Py_tp_new, _new_MediaDeviceControlCapabilities },
        { Py_tp_dealloc, _dealloc_MediaDeviceControlCapabilities },
        { Py_tp_methods, _methods_MediaDeviceControlCapabilities },
        { Py_tp_getset, _getset_MediaDeviceControlCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaDeviceControlCapabilities =
    {
        "_winrt_Windows_Media_Devices.MediaDeviceControlCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaDeviceControlCapabilities
    };

    // ----- ModuleCommandResult class --------------------
    constexpr const char* const _type_name_ModuleCommandResult = "ModuleCommandResult";

    static PyObject* _new_ModuleCommandResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ModuleCommandResult);
        return nullptr;
    }

    static void _dealloc_ModuleCommandResult(py::wrapper::Windows::Media::Devices::ModuleCommandResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ModuleCommandResult_get_Result(py::wrapper::Windows::Media::Devices::ModuleCommandResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ModuleCommandResult_get_Status(py::wrapper::Windows::Media::Devices::ModuleCommandResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ModuleCommandResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::ModuleCommandResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ModuleCommandResult[] = {
        { "_from", (PyCFunction)_from_ModuleCommandResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ModuleCommandResult[] = {
        { const_cast<char*>("result"), (getter)ModuleCommandResult_get_Result, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)ModuleCommandResult_get_Status, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ModuleCommandResult[] = 
    {
        { Py_tp_new, _new_ModuleCommandResult },
        { Py_tp_dealloc, _dealloc_ModuleCommandResult },
        { Py_tp_methods, _methods_ModuleCommandResult },
        { Py_tp_getset, _getset_ModuleCommandResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ModuleCommandResult =
    {
        "_winrt_Windows_Media_Devices.ModuleCommandResult",
        sizeof(py::wrapper::Windows::Media::Devices::ModuleCommandResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ModuleCommandResult
    };

    // ----- OpticalImageStabilizationControl class --------------------
    constexpr const char* const _type_name_OpticalImageStabilizationControl = "OpticalImageStabilizationControl";

    static PyObject* _new_OpticalImageStabilizationControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_OpticalImageStabilizationControl);
        return nullptr;
    }

    static void _dealloc_OpticalImageStabilizationControl(py::wrapper::Windows::Media::Devices::OpticalImageStabilizationControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* OpticalImageStabilizationControl_get_Mode(py::wrapper::Windows::Media::Devices::OpticalImageStabilizationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OpticalImageStabilizationControl_put_Mode(py::wrapper::Windows::Media::Devices::OpticalImageStabilizationControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::OpticalImageStabilizationMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OpticalImageStabilizationControl_get_Supported(py::wrapper::Windows::Media::Devices::OpticalImageStabilizationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OpticalImageStabilizationControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::OpticalImageStabilizationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_OpticalImageStabilizationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::OpticalImageStabilizationControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OpticalImageStabilizationControl[] = {
        { "_from", (PyCFunction)_from_OpticalImageStabilizationControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_OpticalImageStabilizationControl[] = {
        { const_cast<char*>("mode"), (getter)OpticalImageStabilizationControl_get_Mode, (setter)OpticalImageStabilizationControl_put_Mode, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)OpticalImageStabilizationControl_get_Supported, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_modes"), (getter)OpticalImageStabilizationControl_get_SupportedModes, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_OpticalImageStabilizationControl[] = 
    {
        { Py_tp_new, _new_OpticalImageStabilizationControl },
        { Py_tp_dealloc, _dealloc_OpticalImageStabilizationControl },
        { Py_tp_methods, _methods_OpticalImageStabilizationControl },
        { Py_tp_getset, _getset_OpticalImageStabilizationControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_OpticalImageStabilizationControl =
    {
        "_winrt_Windows_Media_Devices.OpticalImageStabilizationControl",
        sizeof(py::wrapper::Windows::Media::Devices::OpticalImageStabilizationControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OpticalImageStabilizationControl
    };

    // ----- PanelBasedOptimizationControl class --------------------
    constexpr const char* const _type_name_PanelBasedOptimizationControl = "PanelBasedOptimizationControl";

    static PyObject* _new_PanelBasedOptimizationControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PanelBasedOptimizationControl);
        return nullptr;
    }

    static void _dealloc_PanelBasedOptimizationControl(py::wrapper::Windows::Media::Devices::PanelBasedOptimizationControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PanelBasedOptimizationControl_get_Panel(py::wrapper::Windows::Media::Devices::PanelBasedOptimizationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Panel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PanelBasedOptimizationControl_put_Panel(py::wrapper::Windows::Media::Devices::PanelBasedOptimizationControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::Panel>(arg);

            self->obj.Panel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PanelBasedOptimizationControl_get_IsSupported(py::wrapper::Windows::Media::Devices::PanelBasedOptimizationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PanelBasedOptimizationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::PanelBasedOptimizationControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PanelBasedOptimizationControl[] = {
        { "_from", (PyCFunction)_from_PanelBasedOptimizationControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PanelBasedOptimizationControl[] = {
        { const_cast<char*>("panel"), (getter)PanelBasedOptimizationControl_get_Panel, (setter)PanelBasedOptimizationControl_put_Panel, nullptr, nullptr },
        { const_cast<char*>("is_supported"), (getter)PanelBasedOptimizationControl_get_IsSupported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PanelBasedOptimizationControl[] = 
    {
        { Py_tp_new, _new_PanelBasedOptimizationControl },
        { Py_tp_dealloc, _dealloc_PanelBasedOptimizationControl },
        { Py_tp_methods, _methods_PanelBasedOptimizationControl },
        { Py_tp_getset, _getset_PanelBasedOptimizationControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PanelBasedOptimizationControl =
    {
        "_winrt_Windows_Media_Devices.PanelBasedOptimizationControl",
        sizeof(py::wrapper::Windows::Media::Devices::PanelBasedOptimizationControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PanelBasedOptimizationControl
    };

    // ----- PhotoConfirmationControl class --------------------
    constexpr const char* const _type_name_PhotoConfirmationControl = "PhotoConfirmationControl";

    static PyObject* _new_PhotoConfirmationControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhotoConfirmationControl);
        return nullptr;
    }

    static void _dealloc_PhotoConfirmationControl(py::wrapper::Windows::Media::Devices::PhotoConfirmationControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhotoConfirmationControl_get_PixelFormat(py::wrapper::Windows::Media::Devices::PhotoConfirmationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoConfirmationControl_put_PixelFormat(py::wrapper::Windows::Media::Devices::PhotoConfirmationControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaPixelFormat>(arg);

            self->obj.PixelFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoConfirmationControl_get_Enabled(py::wrapper::Windows::Media::Devices::PhotoConfirmationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoConfirmationControl_put_Enabled(py::wrapper::Windows::Media::Devices::PhotoConfirmationControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoConfirmationControl_get_Supported(py::wrapper::Windows::Media::Devices::PhotoConfirmationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhotoConfirmationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::PhotoConfirmationControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoConfirmationControl[] = {
        { "_from", (PyCFunction)_from_PhotoConfirmationControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_PhotoConfirmationControl[] = {
        { const_cast<char*>("pixel_format"), (getter)PhotoConfirmationControl_get_PixelFormat, (setter)PhotoConfirmationControl_put_PixelFormat, nullptr, nullptr },
        { const_cast<char*>("enabled"), (getter)PhotoConfirmationControl_get_Enabled, (setter)PhotoConfirmationControl_put_Enabled, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)PhotoConfirmationControl_get_Supported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_PhotoConfirmationControl[] = 
    {
        { Py_tp_new, _new_PhotoConfirmationControl },
        { Py_tp_dealloc, _dealloc_PhotoConfirmationControl },
        { Py_tp_methods, _methods_PhotoConfirmationControl },
        { Py_tp_getset, _getset_PhotoConfirmationControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhotoConfirmationControl =
    {
        "_winrt_Windows_Media_Devices.PhotoConfirmationControl",
        sizeof(py::wrapper::Windows::Media::Devices::PhotoConfirmationControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoConfirmationControl
    };

    // ----- RegionOfInterest class --------------------
    constexpr const char* const _type_name_RegionOfInterest = "RegionOfInterest";

    static PyObject* _new_RegionOfInterest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Devices::RegionOfInterest instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RegionOfInterest(py::wrapper::Windows::Media::Devices::RegionOfInterest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RegionOfInterest_get_Bounds(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegionOfInterest_put_Bounds(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.Bounds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegionOfInterest_get_AutoWhiteBalanceEnabled(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoWhiteBalanceEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegionOfInterest_put_AutoWhiteBalanceEnabled(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoWhiteBalanceEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegionOfInterest_get_AutoFocusEnabled(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoFocusEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegionOfInterest_put_AutoFocusEnabled(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoFocusEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegionOfInterest_get_AutoExposureEnabled(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoExposureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegionOfInterest_put_AutoExposureEnabled(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoExposureEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegionOfInterest_get_Weight(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Weight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegionOfInterest_put_Weight(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Weight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegionOfInterest_get_Type(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegionOfInterest_put_Type(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::RegionOfInterestType>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegionOfInterest_get_BoundsNormalized(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BoundsNormalized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegionOfInterest_put_BoundsNormalized(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.BoundsNormalized(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_RegionOfInterest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::RegionOfInterest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RegionOfInterest[] = {
        { "_from", (PyCFunction)_from_RegionOfInterest, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RegionOfInterest[] = {
        { const_cast<char*>("bounds"), (getter)RegionOfInterest_get_Bounds, (setter)RegionOfInterest_put_Bounds, nullptr, nullptr },
        { const_cast<char*>("auto_white_balance_enabled"), (getter)RegionOfInterest_get_AutoWhiteBalanceEnabled, (setter)RegionOfInterest_put_AutoWhiteBalanceEnabled, nullptr, nullptr },
        { const_cast<char*>("auto_focus_enabled"), (getter)RegionOfInterest_get_AutoFocusEnabled, (setter)RegionOfInterest_put_AutoFocusEnabled, nullptr, nullptr },
        { const_cast<char*>("auto_exposure_enabled"), (getter)RegionOfInterest_get_AutoExposureEnabled, (setter)RegionOfInterest_put_AutoExposureEnabled, nullptr, nullptr },
        { const_cast<char*>("weight"), (getter)RegionOfInterest_get_Weight, (setter)RegionOfInterest_put_Weight, nullptr, nullptr },
        { const_cast<char*>("type"), (getter)RegionOfInterest_get_Type, (setter)RegionOfInterest_put_Type, nullptr, nullptr },
        { const_cast<char*>("bounds_normalized"), (getter)RegionOfInterest_get_BoundsNormalized, (setter)RegionOfInterest_put_BoundsNormalized, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RegionOfInterest[] = 
    {
        { Py_tp_new, _new_RegionOfInterest },
        { Py_tp_dealloc, _dealloc_RegionOfInterest },
        { Py_tp_methods, _methods_RegionOfInterest },
        { Py_tp_getset, _getset_RegionOfInterest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RegionOfInterest =
    {
        "_winrt_Windows_Media_Devices.RegionOfInterest",
        sizeof(py::wrapper::Windows::Media::Devices::RegionOfInterest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RegionOfInterest
    };

    // ----- RegionsOfInterestControl class --------------------
    constexpr const char* const _type_name_RegionsOfInterestControl = "RegionsOfInterestControl";

    static PyObject* _new_RegionsOfInterestControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RegionsOfInterestControl);
        return nullptr;
    }

    static void _dealloc_RegionsOfInterestControl(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RegionsOfInterestControl_ClearRegionsAsync(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClearRegionsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RegionsOfInterestControl_SetRegionsAsync(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Devices::RegionOfInterest>>(args, 0);

                return py::convert(self->obj.SetRegionsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Devices::RegionOfInterest>>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.SetRegionsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RegionsOfInterestControl_get_AutoExposureSupported(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoExposureSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RegionsOfInterestControl_get_AutoFocusSupported(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoFocusSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RegionsOfInterestControl_get_AutoWhiteBalanceSupported(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoWhiteBalanceSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RegionsOfInterestControl_get_MaxRegions(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxRegions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RegionsOfInterestControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::RegionsOfInterestControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RegionsOfInterestControl[] = {
        { "clear_regions_async", (PyCFunction)RegionsOfInterestControl_ClearRegionsAsync, METH_VARARGS, nullptr },
        { "set_regions_async", (PyCFunction)RegionsOfInterestControl_SetRegionsAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_RegionsOfInterestControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_RegionsOfInterestControl[] = {
        { const_cast<char*>("auto_exposure_supported"), (getter)RegionsOfInterestControl_get_AutoExposureSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("auto_focus_supported"), (getter)RegionsOfInterestControl_get_AutoFocusSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("auto_white_balance_supported"), (getter)RegionsOfInterestControl_get_AutoWhiteBalanceSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("max_regions"), (getter)RegionsOfInterestControl_get_MaxRegions, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_RegionsOfInterestControl[] = 
    {
        { Py_tp_new, _new_RegionsOfInterestControl },
        { Py_tp_dealloc, _dealloc_RegionsOfInterestControl },
        { Py_tp_methods, _methods_RegionsOfInterestControl },
        { Py_tp_getset, _getset_RegionsOfInterestControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RegionsOfInterestControl =
    {
        "_winrt_Windows_Media_Devices.RegionsOfInterestControl",
        sizeof(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RegionsOfInterestControl
    };

    // ----- SceneModeControl class --------------------
    constexpr const char* const _type_name_SceneModeControl = "SceneModeControl";

    static PyObject* _new_SceneModeControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SceneModeControl);
        return nullptr;
    }

    static void _dealloc_SceneModeControl(py::wrapper::Windows::Media::Devices::SceneModeControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SceneModeControl_SetValueAsync(py::wrapper::Windows::Media::Devices::SceneModeControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::CaptureSceneMode>(args, 0);

                return py::convert(self->obj.SetValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneModeControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::SceneModeControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneModeControl_get_Value(py::wrapper::Windows::Media::Devices::SceneModeControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SceneModeControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::SceneModeControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneModeControl[] = {
        { "set_value_async", (PyCFunction)SceneModeControl_SetValueAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_SceneModeControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SceneModeControl[] = {
        { const_cast<char*>("supported_modes"), (getter)SceneModeControl_get_SupportedModes, nullptr, nullptr, nullptr },
        { const_cast<char*>("value"), (getter)SceneModeControl_get_Value, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SceneModeControl[] = 
    {
        { Py_tp_new, _new_SceneModeControl },
        { Py_tp_dealloc, _dealloc_SceneModeControl },
        { Py_tp_methods, _methods_SceneModeControl },
        { Py_tp_getset, _getset_SceneModeControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SceneModeControl =
    {
        "_winrt_Windows_Media_Devices.SceneModeControl",
        sizeof(py::wrapper::Windows::Media::Devices::SceneModeControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneModeControl
    };

    // ----- TorchControl class --------------------
    constexpr const char* const _type_name_TorchControl = "TorchControl";

    static PyObject* _new_TorchControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TorchControl);
        return nullptr;
    }

    static void _dealloc_TorchControl(py::wrapper::Windows::Media::Devices::TorchControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TorchControl_get_PowerPercent(py::wrapper::Windows::Media::Devices::TorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TorchControl_put_PowerPercent(py::wrapper::Windows::Media::Devices::TorchControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.PowerPercent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TorchControl_get_Enabled(py::wrapper::Windows::Media::Devices::TorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TorchControl_put_Enabled(py::wrapper::Windows::Media::Devices::TorchControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TorchControl_get_PowerSupported(py::wrapper::Windows::Media::Devices::TorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TorchControl_get_Supported(py::wrapper::Windows::Media::Devices::TorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TorchControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::TorchControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TorchControl[] = {
        { "_from", (PyCFunction)_from_TorchControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_TorchControl[] = {
        { const_cast<char*>("power_percent"), (getter)TorchControl_get_PowerPercent, (setter)TorchControl_put_PowerPercent, nullptr, nullptr },
        { const_cast<char*>("enabled"), (getter)TorchControl_get_Enabled, (setter)TorchControl_put_Enabled, nullptr, nullptr },
        { const_cast<char*>("power_supported"), (getter)TorchControl_get_PowerSupported, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)TorchControl_get_Supported, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_TorchControl[] = 
    {
        { Py_tp_new, _new_TorchControl },
        { Py_tp_dealloc, _dealloc_TorchControl },
        { Py_tp_methods, _methods_TorchControl },
        { Py_tp_getset, _getset_TorchControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TorchControl =
    {
        "_winrt_Windows_Media_Devices.TorchControl",
        sizeof(py::wrapper::Windows::Media::Devices::TorchControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TorchControl
    };

    // ----- VideoDeviceController class --------------------
    constexpr const char* const _type_name_VideoDeviceController = "VideoDeviceController";

    static PyObject* _new_VideoDeviceController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VideoDeviceController);
        return nullptr;
    }

    static void _dealloc_VideoDeviceController(py::wrapper::Windows::Media::Devices::VideoDeviceController* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoDeviceController_GetAvailableMediaStreamProperties(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.GetAvailableMediaStreamProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_GetDeviceProperty(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetDeviceProperty(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_GetDevicePropertyByExtendedId(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(args, 1);

                return py::convert(self->obj.GetDevicePropertyByExtendedId(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_GetDevicePropertyById(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(args, 1);

                return py::convert(self->obj.GetDevicePropertyById(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_GetMediaStreamProperties(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.GetMediaStreamProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_SetDeviceProperty(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetDeviceProperty(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_SetDevicePropertyByExtendedId(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                return py::convert(self->obj.SetDevicePropertyByExtendedId(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_SetDevicePropertyById(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.SetDevicePropertyById(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_SetMediaStreamPropertiesAsync(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 1);

                return py::convert(self->obj.SetMediaStreamPropertiesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_TryGetPowerlineFrequency(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Capture::PowerlineFrequency param0 {  };

                auto return_value = self->obj.TryGetPowerlineFrequency(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_TrySetPowerlineFrequency(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::PowerlineFrequency>(args, 0);

                return py::convert(self->obj.TrySetPowerlineFrequency(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_CameraOcclusionInfo(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CameraOcclusionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_PrimaryUse(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrimaryUse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoDeviceController_put_PrimaryUse(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::CaptureUse>(arg);

            self->obj.PrimaryUse(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoDeviceController_get_FocusControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FocusControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_IsoSpeedControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsoSpeedControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_LowLagPhoto(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LowLagPhoto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_WhiteBalanceControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WhiteBalanceControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_TorchControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TorchControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_SceneModeControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SceneModeControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_RegionsOfInterestControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RegionsOfInterestControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_FlashControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FlashControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_LowLagPhotoSequence(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LowLagPhotoSequence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_ExposureCompensationControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExposureCompensationControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_ExposureControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExposureControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_ZoomControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZoomControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_PhotoConfirmationControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhotoConfirmationControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_VariablePhotoSequenceController(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VariablePhotoSequenceController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_DesiredOptimization(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredOptimization());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoDeviceController_put_DesiredOptimization(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::MediaCaptureOptimization>(arg);

            self->obj.DesiredOptimization(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoDeviceController_get_AdvancedPhotoControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdvancedPhotoControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_ExposurePriorityVideoControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExposurePriorityVideoControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_HdrVideoControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HdrVideoControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_OpticalImageStabilizationControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OpticalImageStabilizationControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Id(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_VideoTemporalDenoisingControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoTemporalDenoisingControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_InfraredTorchControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InfraredTorchControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_PanelBasedOptimizationControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PanelBasedOptimizationControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_DigitalWindowControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DigitalWindowControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Hue(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Hue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Zoom(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Zoom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Contrast(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_WhiteBalance(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WhiteBalance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_BacklightCompensation(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BacklightCompensation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Brightness(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Brightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Exposure(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Exposure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Tilt(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tilt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Roll(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Roll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Pan(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pan());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Focus(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Focus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoDeviceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::VideoDeviceController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoDeviceController[] = {
        { "get_available_media_stream_properties", (PyCFunction)VideoDeviceController_GetAvailableMediaStreamProperties, METH_VARARGS, nullptr },
        { "get_device_property", (PyCFunction)VideoDeviceController_GetDeviceProperty, METH_VARARGS, nullptr },
        { "get_device_property_by_extended_id", (PyCFunction)VideoDeviceController_GetDevicePropertyByExtendedId, METH_VARARGS, nullptr },
        { "get_device_property_by_id", (PyCFunction)VideoDeviceController_GetDevicePropertyById, METH_VARARGS, nullptr },
        { "get_media_stream_properties", (PyCFunction)VideoDeviceController_GetMediaStreamProperties, METH_VARARGS, nullptr },
        { "set_device_property", (PyCFunction)VideoDeviceController_SetDeviceProperty, METH_VARARGS, nullptr },
        { "set_device_property_by_extended_id", (PyCFunction)VideoDeviceController_SetDevicePropertyByExtendedId, METH_VARARGS, nullptr },
        { "set_device_property_by_id", (PyCFunction)VideoDeviceController_SetDevicePropertyById, METH_VARARGS, nullptr },
        { "set_media_stream_properties_async", (PyCFunction)VideoDeviceController_SetMediaStreamPropertiesAsync, METH_VARARGS, nullptr },
        { "try_get_powerline_frequency", (PyCFunction)VideoDeviceController_TryGetPowerlineFrequency, METH_VARARGS, nullptr },
        { "try_set_powerline_frequency", (PyCFunction)VideoDeviceController_TrySetPowerlineFrequency, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_VideoDeviceController, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VideoDeviceController[] = {
        { const_cast<char*>("camera_occlusion_info"), (getter)VideoDeviceController_get_CameraOcclusionInfo, nullptr, nullptr, nullptr },
        { const_cast<char*>("primary_use"), (getter)VideoDeviceController_get_PrimaryUse, (setter)VideoDeviceController_put_PrimaryUse, nullptr, nullptr },
        { const_cast<char*>("focus_control"), (getter)VideoDeviceController_get_FocusControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("iso_speed_control"), (getter)VideoDeviceController_get_IsoSpeedControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("low_lag_photo"), (getter)VideoDeviceController_get_LowLagPhoto, nullptr, nullptr, nullptr },
        { const_cast<char*>("white_balance_control"), (getter)VideoDeviceController_get_WhiteBalanceControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("torch_control"), (getter)VideoDeviceController_get_TorchControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("scene_mode_control"), (getter)VideoDeviceController_get_SceneModeControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("regions_of_interest_control"), (getter)VideoDeviceController_get_RegionsOfInterestControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("flash_control"), (getter)VideoDeviceController_get_FlashControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("low_lag_photo_sequence"), (getter)VideoDeviceController_get_LowLagPhotoSequence, nullptr, nullptr, nullptr },
        { const_cast<char*>("exposure_compensation_control"), (getter)VideoDeviceController_get_ExposureCompensationControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("exposure_control"), (getter)VideoDeviceController_get_ExposureControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("zoom_control"), (getter)VideoDeviceController_get_ZoomControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("photo_confirmation_control"), (getter)VideoDeviceController_get_PhotoConfirmationControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("variable_photo_sequence_controller"), (getter)VideoDeviceController_get_VariablePhotoSequenceController, nullptr, nullptr, nullptr },
        { const_cast<char*>("desired_optimization"), (getter)VideoDeviceController_get_DesiredOptimization, (setter)VideoDeviceController_put_DesiredOptimization, nullptr, nullptr },
        { const_cast<char*>("advanced_photo_control"), (getter)VideoDeviceController_get_AdvancedPhotoControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("exposure_priority_video_control"), (getter)VideoDeviceController_get_ExposurePriorityVideoControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("hdr_video_control"), (getter)VideoDeviceController_get_HdrVideoControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("optical_image_stabilization_control"), (getter)VideoDeviceController_get_OpticalImageStabilizationControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("id"), (getter)VideoDeviceController_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("video_temporal_denoising_control"), (getter)VideoDeviceController_get_VideoTemporalDenoisingControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("infrared_torch_control"), (getter)VideoDeviceController_get_InfraredTorchControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("panel_based_optimization_control"), (getter)VideoDeviceController_get_PanelBasedOptimizationControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("digital_window_control"), (getter)VideoDeviceController_get_DigitalWindowControl, nullptr, nullptr, nullptr },
        { const_cast<char*>("hue"), (getter)VideoDeviceController_get_Hue, nullptr, nullptr, nullptr },
        { const_cast<char*>("zoom"), (getter)VideoDeviceController_get_Zoom, nullptr, nullptr, nullptr },
        { const_cast<char*>("contrast"), (getter)VideoDeviceController_get_Contrast, nullptr, nullptr, nullptr },
        { const_cast<char*>("white_balance"), (getter)VideoDeviceController_get_WhiteBalance, nullptr, nullptr, nullptr },
        { const_cast<char*>("backlight_compensation"), (getter)VideoDeviceController_get_BacklightCompensation, nullptr, nullptr, nullptr },
        { const_cast<char*>("brightness"), (getter)VideoDeviceController_get_Brightness, nullptr, nullptr, nullptr },
        { const_cast<char*>("exposure"), (getter)VideoDeviceController_get_Exposure, nullptr, nullptr, nullptr },
        { const_cast<char*>("tilt"), (getter)VideoDeviceController_get_Tilt, nullptr, nullptr, nullptr },
        { const_cast<char*>("roll"), (getter)VideoDeviceController_get_Roll, nullptr, nullptr, nullptr },
        { const_cast<char*>("pan"), (getter)VideoDeviceController_get_Pan, nullptr, nullptr, nullptr },
        { const_cast<char*>("focus"), (getter)VideoDeviceController_get_Focus, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VideoDeviceController[] = 
    {
        { Py_tp_new, _new_VideoDeviceController },
        { Py_tp_dealloc, _dealloc_VideoDeviceController },
        { Py_tp_methods, _methods_VideoDeviceController },
        { Py_tp_getset, _getset_VideoDeviceController },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoDeviceController =
    {
        "_winrt_Windows_Media_Devices.VideoDeviceController",
        sizeof(py::wrapper::Windows::Media::Devices::VideoDeviceController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoDeviceController
    };

    // ----- VideoDeviceControllerGetDevicePropertyResult class --------------------
    constexpr const char* const _type_name_VideoDeviceControllerGetDevicePropertyResult = "VideoDeviceControllerGetDevicePropertyResult";

    static PyObject* _new_VideoDeviceControllerGetDevicePropertyResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VideoDeviceControllerGetDevicePropertyResult);
        return nullptr;
    }

    static void _dealloc_VideoDeviceControllerGetDevicePropertyResult(py::wrapper::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoDeviceControllerGetDevicePropertyResult_get_Status(py::wrapper::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceControllerGetDevicePropertyResult_get_Value(py::wrapper::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoDeviceControllerGetDevicePropertyResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoDeviceControllerGetDevicePropertyResult[] = {
        { "_from", (PyCFunction)_from_VideoDeviceControllerGetDevicePropertyResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VideoDeviceControllerGetDevicePropertyResult[] = {
        { const_cast<char*>("status"), (getter)VideoDeviceControllerGetDevicePropertyResult_get_Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("value"), (getter)VideoDeviceControllerGetDevicePropertyResult_get_Value, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VideoDeviceControllerGetDevicePropertyResult[] = 
    {
        { Py_tp_new, _new_VideoDeviceControllerGetDevicePropertyResult },
        { Py_tp_dealloc, _dealloc_VideoDeviceControllerGetDevicePropertyResult },
        { Py_tp_methods, _methods_VideoDeviceControllerGetDevicePropertyResult },
        { Py_tp_getset, _getset_VideoDeviceControllerGetDevicePropertyResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoDeviceControllerGetDevicePropertyResult =
    {
        "_winrt_Windows_Media_Devices.VideoDeviceControllerGetDevicePropertyResult",
        sizeof(py::wrapper::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoDeviceControllerGetDevicePropertyResult
    };

    // ----- VideoTemporalDenoisingControl class --------------------
    constexpr const char* const _type_name_VideoTemporalDenoisingControl = "VideoTemporalDenoisingControl";

    static PyObject* _new_VideoTemporalDenoisingControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VideoTemporalDenoisingControl);
        return nullptr;
    }

    static void _dealloc_VideoTemporalDenoisingControl(py::wrapper::Windows::Media::Devices::VideoTemporalDenoisingControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoTemporalDenoisingControl_get_Mode(py::wrapper::Windows::Media::Devices::VideoTemporalDenoisingControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTemporalDenoisingControl_put_Mode(py::wrapper::Windows::Media::Devices::VideoTemporalDenoisingControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::VideoTemporalDenoisingMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTemporalDenoisingControl_get_Supported(py::wrapper::Windows::Media::Devices::VideoTemporalDenoisingControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTemporalDenoisingControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::VideoTemporalDenoisingControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoTemporalDenoisingControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::VideoTemporalDenoisingControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTemporalDenoisingControl[] = {
        { "_from", (PyCFunction)_from_VideoTemporalDenoisingControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_VideoTemporalDenoisingControl[] = {
        { const_cast<char*>("mode"), (getter)VideoTemporalDenoisingControl_get_Mode, (setter)VideoTemporalDenoisingControl_put_Mode, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)VideoTemporalDenoisingControl_get_Supported, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_modes"), (getter)VideoTemporalDenoisingControl_get_SupportedModes, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_VideoTemporalDenoisingControl[] = 
    {
        { Py_tp_new, _new_VideoTemporalDenoisingControl },
        { Py_tp_dealloc, _dealloc_VideoTemporalDenoisingControl },
        { Py_tp_methods, _methods_VideoTemporalDenoisingControl },
        { Py_tp_getset, _getset_VideoTemporalDenoisingControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoTemporalDenoisingControl =
    {
        "_winrt_Windows_Media_Devices.VideoTemporalDenoisingControl",
        sizeof(py::wrapper::Windows::Media::Devices::VideoTemporalDenoisingControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTemporalDenoisingControl
    };

    // ----- WhiteBalanceControl class --------------------
    constexpr const char* const _type_name_WhiteBalanceControl = "WhiteBalanceControl";

    static PyObject* _new_WhiteBalanceControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_WhiteBalanceControl);
        return nullptr;
    }

    static void _dealloc_WhiteBalanceControl(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* WhiteBalanceControl_SetPresetAsync(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::ColorTemperaturePreset>(args, 0);

                return py::convert(self->obj.SetPresetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WhiteBalanceControl_SetValueAsync(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.SetValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WhiteBalanceControl_get_Max(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WhiteBalanceControl_get_Min(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WhiteBalanceControl_get_Preset(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Preset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WhiteBalanceControl_get_Step(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WhiteBalanceControl_get_Supported(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WhiteBalanceControl_get_Value(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_WhiteBalanceControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::WhiteBalanceControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WhiteBalanceControl[] = {
        { "set_preset_async", (PyCFunction)WhiteBalanceControl_SetPresetAsync, METH_VARARGS, nullptr },
        { "set_value_async", (PyCFunction)WhiteBalanceControl_SetValueAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_WhiteBalanceControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_WhiteBalanceControl[] = {
        { const_cast<char*>("max"), (getter)WhiteBalanceControl_get_Max, nullptr, nullptr, nullptr },
        { const_cast<char*>("min"), (getter)WhiteBalanceControl_get_Min, nullptr, nullptr, nullptr },
        { const_cast<char*>("preset"), (getter)WhiteBalanceControl_get_Preset, nullptr, nullptr, nullptr },
        { const_cast<char*>("step"), (getter)WhiteBalanceControl_get_Step, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)WhiteBalanceControl_get_Supported, nullptr, nullptr, nullptr },
        { const_cast<char*>("value"), (getter)WhiteBalanceControl_get_Value, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_WhiteBalanceControl[] = 
    {
        { Py_tp_new, _new_WhiteBalanceControl },
        { Py_tp_dealloc, _dealloc_WhiteBalanceControl },
        { Py_tp_methods, _methods_WhiteBalanceControl },
        { Py_tp_getset, _getset_WhiteBalanceControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_WhiteBalanceControl =
    {
        "_winrt_Windows_Media_Devices.WhiteBalanceControl",
        sizeof(py::wrapper::Windows::Media::Devices::WhiteBalanceControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WhiteBalanceControl
    };

    // ----- ZoomControl class --------------------
    constexpr const char* const _type_name_ZoomControl = "ZoomControl";

    static PyObject* _new_ZoomControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ZoomControl);
        return nullptr;
    }

    static void _dealloc_ZoomControl(py::wrapper::Windows::Media::Devices::ZoomControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ZoomControl_Configure(py::wrapper::Windows::Media::Devices::ZoomControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::ZoomSettings>(args, 0);

                self->obj.Configure(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ZoomControl_get_Value(py::wrapper::Windows::Media::Devices::ZoomControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ZoomControl_put_Value(py::wrapper::Windows::Media::Devices::ZoomControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ZoomControl_get_Max(py::wrapper::Windows::Media::Devices::ZoomControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ZoomControl_get_Min(py::wrapper::Windows::Media::Devices::ZoomControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ZoomControl_get_Step(py::wrapper::Windows::Media::Devices::ZoomControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ZoomControl_get_Supported(py::wrapper::Windows::Media::Devices::ZoomControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ZoomControl_get_Mode(py::wrapper::Windows::Media::Devices::ZoomControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ZoomControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::ZoomControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ZoomControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::ZoomControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ZoomControl[] = {
        { "configure", (PyCFunction)ZoomControl_Configure, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_ZoomControl, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ZoomControl[] = {
        { const_cast<char*>("value"), (getter)ZoomControl_get_Value, (setter)ZoomControl_put_Value, nullptr, nullptr },
        { const_cast<char*>("max"), (getter)ZoomControl_get_Max, nullptr, nullptr, nullptr },
        { const_cast<char*>("min"), (getter)ZoomControl_get_Min, nullptr, nullptr, nullptr },
        { const_cast<char*>("step"), (getter)ZoomControl_get_Step, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported"), (getter)ZoomControl_get_Supported, nullptr, nullptr, nullptr },
        { const_cast<char*>("mode"), (getter)ZoomControl_get_Mode, nullptr, nullptr, nullptr },
        { const_cast<char*>("supported_modes"), (getter)ZoomControl_get_SupportedModes, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ZoomControl[] = 
    {
        { Py_tp_new, _new_ZoomControl },
        { Py_tp_dealloc, _dealloc_ZoomControl },
        { Py_tp_methods, _methods_ZoomControl },
        { Py_tp_getset, _getset_ZoomControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ZoomControl =
    {
        "_winrt_Windows_Media_Devices.ZoomControl",
        sizeof(py::wrapper::Windows::Media::Devices::ZoomControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ZoomControl
    };

    // ----- ZoomSettings class --------------------
    constexpr const char* const _type_name_ZoomSettings = "ZoomSettings";

    static PyObject* _new_ZoomSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Devices::ZoomSettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ZoomSettings(py::wrapper::Windows::Media::Devices::ZoomSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ZoomSettings_get_Value(py::wrapper::Windows::Media::Devices::ZoomSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ZoomSettings_put_Value(py::wrapper::Windows::Media::Devices::ZoomSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ZoomSettings_get_Mode(py::wrapper::Windows::Media::Devices::ZoomSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ZoomSettings_put_Mode(py::wrapper::Windows::Media::Devices::ZoomSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::ZoomTransitionMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ZoomSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::ZoomSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ZoomSettings[] = {
        { "_from", (PyCFunction)_from_ZoomSettings, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ZoomSettings[] = {
        { const_cast<char*>("value"), (getter)ZoomSettings_get_Value, (setter)ZoomSettings_put_Value, nullptr, nullptr },
        { const_cast<char*>("mode"), (getter)ZoomSettings_get_Mode, (setter)ZoomSettings_put_Mode, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ZoomSettings[] = 
    {
        { Py_tp_new, _new_ZoomSettings },
        { Py_tp_dealloc, _dealloc_ZoomSettings },
        { Py_tp_methods, _methods_ZoomSettings },
        { Py_tp_getset, _getset_ZoomSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ZoomSettings =
    {
        "_winrt_Windows_Media_Devices.ZoomSettings",
        sizeof(py::wrapper::Windows::Media::Devices::ZoomSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ZoomSettings
    };

    // ----- IDefaultAudioDeviceChangedEventArgs interface --------------------
    constexpr const char* const _type_name_IDefaultAudioDeviceChangedEventArgs = "IDefaultAudioDeviceChangedEventArgs";

    static PyObject* _new_IDefaultAudioDeviceChangedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IDefaultAudioDeviceChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_IDefaultAudioDeviceChangedEventArgs(py::wrapper::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IDefaultAudioDeviceChangedEventArgs_get_Id(py::wrapper::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDefaultAudioDeviceChangedEventArgs_get_Role(py::wrapper::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Role());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IDefaultAudioDeviceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDefaultAudioDeviceChangedEventArgs[] = {
        { "_from", (PyCFunction)_from_IDefaultAudioDeviceChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IDefaultAudioDeviceChangedEventArgs[] = {
        { const_cast<char*>("id"), (getter)IDefaultAudioDeviceChangedEventArgs_get_Id, nullptr, nullptr, nullptr },
        { const_cast<char*>("role"), (getter)IDefaultAudioDeviceChangedEventArgs_get_Role, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_IDefaultAudioDeviceChangedEventArgs[] = 
    {
        { Py_tp_new, _new_IDefaultAudioDeviceChangedEventArgs },
        { Py_tp_dealloc, _dealloc_IDefaultAudioDeviceChangedEventArgs },
        { Py_tp_methods, _methods_IDefaultAudioDeviceChangedEventArgs },
        { Py_tp_getset, _getset_IDefaultAudioDeviceChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IDefaultAudioDeviceChangedEventArgs =
    {
        "_winrt_Windows_Media_Devices.IDefaultAudioDeviceChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDefaultAudioDeviceChangedEventArgs
    };

    // ----- IMediaDeviceController interface --------------------
    constexpr const char* const _type_name_IMediaDeviceController = "IMediaDeviceController";

    static PyObject* _new_IMediaDeviceController(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IMediaDeviceController);
        return nullptr;
    }

    static void _dealloc_IMediaDeviceController(py::wrapper::Windows::Media::Devices::IMediaDeviceController* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IMediaDeviceController_GetAvailableMediaStreamProperties(py::wrapper::Windows::Media::Devices::IMediaDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.GetAvailableMediaStreamProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMediaDeviceController_GetMediaStreamProperties(py::wrapper::Windows::Media::Devices::IMediaDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.GetMediaStreamProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMediaDeviceController_SetMediaStreamPropertiesAsync(py::wrapper::Windows::Media::Devices::IMediaDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 1);

                return py::convert(self->obj.SetMediaStreamPropertiesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IMediaDeviceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::IMediaDeviceController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaDeviceController[] = {
        { "get_available_media_stream_properties", (PyCFunction)IMediaDeviceController_GetAvailableMediaStreamProperties, METH_VARARGS, nullptr },
        { "get_media_stream_properties", (PyCFunction)IMediaDeviceController_GetMediaStreamProperties, METH_VARARGS, nullptr },
        { "set_media_stream_properties_async", (PyCFunction)IMediaDeviceController_SetMediaStreamPropertiesAsync, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_IMediaDeviceController, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_IMediaDeviceController[] = {
        { nullptr }
    };

    static PyType_Slot _type_slots_IMediaDeviceController[] = 
    {
        { Py_tp_new, _new_IMediaDeviceController },
        { Py_tp_dealloc, _dealloc_IMediaDeviceController },
        { Py_tp_methods, _methods_IMediaDeviceController },
        { Py_tp_getset, _getset_IMediaDeviceController },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IMediaDeviceController =
    {
        "_winrt_Windows_Media_Devices.IMediaDeviceController",
        sizeof(py::wrapper::Windows::Media::Devices::IMediaDeviceController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaDeviceController
    };

    // ----- Windows.Media.Devices Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Media::Devices::AdvancedPhotoCaptureSettings>::python_type = py::register_python_type(module, _type_name_AdvancedPhotoCaptureSettings, &_type_spec_AdvancedPhotoCaptureSettings, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::AdvancedPhotoControl>::python_type = py::register_python_type(module, _type_name_AdvancedPhotoControl, &_type_spec_AdvancedPhotoControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::AudioDeviceController>::python_type = py::register_python_type(module, _type_name_AudioDeviceController, &_type_spec_AudioDeviceController, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::AudioDeviceModule>::python_type = py::register_python_type(module, _type_name_AudioDeviceModule, &_type_spec_AudioDeviceModule, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs>::python_type = py::register_python_type(module, _type_name_AudioDeviceModuleNotificationEventArgs, &_type_spec_AudioDeviceModuleNotificationEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::AudioDeviceModulesManager>::python_type = py::register_python_type(module, _type_name_AudioDeviceModulesManager, &_type_spec_AudioDeviceModulesManager, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::CameraOcclusionInfo>::python_type = py::register_python_type(module, _type_name_CameraOcclusionInfo, &_type_spec_CameraOcclusionInfo, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::CameraOcclusionState>::python_type = py::register_python_type(module, _type_name_CameraOcclusionState, &_type_spec_CameraOcclusionState, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs>::python_type = py::register_python_type(module, _type_name_CameraOcclusionStateChangedEventArgs, &_type_spec_CameraOcclusionStateChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs>::python_type = py::register_python_type(module, _type_name_DefaultAudioCaptureDeviceChangedEventArgs, &_type_spec_DefaultAudioCaptureDeviceChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs>::python_type = py::register_python_type(module, _type_name_DefaultAudioRenderDeviceChangedEventArgs, &_type_spec_DefaultAudioRenderDeviceChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::DigitalWindowBounds>::python_type = py::register_python_type(module, _type_name_DigitalWindowBounds, &_type_spec_DigitalWindowBounds, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::DigitalWindowCapability>::python_type = py::register_python_type(module, _type_name_DigitalWindowCapability, &_type_spec_DigitalWindowCapability, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::DigitalWindowControl>::python_type = py::register_python_type(module, _type_name_DigitalWindowControl, &_type_spec_DigitalWindowControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::ExposureCompensationControl>::python_type = py::register_python_type(module, _type_name_ExposureCompensationControl, &_type_spec_ExposureCompensationControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::ExposureControl>::python_type = py::register_python_type(module, _type_name_ExposureControl, &_type_spec_ExposureControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::ExposurePriorityVideoControl>::python_type = py::register_python_type(module, _type_name_ExposurePriorityVideoControl, &_type_spec_ExposurePriorityVideoControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::FlashControl>::python_type = py::register_python_type(module, _type_name_FlashControl, &_type_spec_FlashControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::FocusControl>::python_type = py::register_python_type(module, _type_name_FocusControl, &_type_spec_FocusControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::FocusSettings>::python_type = py::register_python_type(module, _type_name_FocusSettings, &_type_spec_FocusSettings, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::HdrVideoControl>::python_type = py::register_python_type(module, _type_name_HdrVideoControl, &_type_spec_HdrVideoControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::InfraredTorchControl>::python_type = py::register_python_type(module, _type_name_InfraredTorchControl, &_type_spec_InfraredTorchControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::IsoSpeedControl>::python_type = py::register_python_type(module, _type_name_IsoSpeedControl, &_type_spec_IsoSpeedControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::LowLagPhotoControl>::python_type = py::register_python_type(module, _type_name_LowLagPhotoControl, &_type_spec_LowLagPhotoControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::LowLagPhotoSequenceControl>::python_type = py::register_python_type(module, _type_name_LowLagPhotoSequenceControl, &_type_spec_LowLagPhotoSequenceControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::MediaDevice>::python_type = py::register_python_type(module, _type_name_MediaDevice, &_type_spec_MediaDevice, nullptr);
            py::winrt_type<winrt::Windows::Media::Devices::MediaDeviceControl>::python_type = py::register_python_type(module, _type_name_MediaDeviceControl, &_type_spec_MediaDeviceControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::MediaDeviceControlCapabilities>::python_type = py::register_python_type(module, _type_name_MediaDeviceControlCapabilities, &_type_spec_MediaDeviceControlCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::ModuleCommandResult>::python_type = py::register_python_type(module, _type_name_ModuleCommandResult, &_type_spec_ModuleCommandResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::OpticalImageStabilizationControl>::python_type = py::register_python_type(module, _type_name_OpticalImageStabilizationControl, &_type_spec_OpticalImageStabilizationControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::PanelBasedOptimizationControl>::python_type = py::register_python_type(module, _type_name_PanelBasedOptimizationControl, &_type_spec_PanelBasedOptimizationControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::PhotoConfirmationControl>::python_type = py::register_python_type(module, _type_name_PhotoConfirmationControl, &_type_spec_PhotoConfirmationControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::RegionOfInterest>::python_type = py::register_python_type(module, _type_name_RegionOfInterest, &_type_spec_RegionOfInterest, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::RegionsOfInterestControl>::python_type = py::register_python_type(module, _type_name_RegionsOfInterestControl, &_type_spec_RegionsOfInterestControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::SceneModeControl>::python_type = py::register_python_type(module, _type_name_SceneModeControl, &_type_spec_SceneModeControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::TorchControl>::python_type = py::register_python_type(module, _type_name_TorchControl, &_type_spec_TorchControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::VideoDeviceController>::python_type = py::register_python_type(module, _type_name_VideoDeviceController, &_type_spec_VideoDeviceController, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult>::python_type = py::register_python_type(module, _type_name_VideoDeviceControllerGetDevicePropertyResult, &_type_spec_VideoDeviceControllerGetDevicePropertyResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::VideoTemporalDenoisingControl>::python_type = py::register_python_type(module, _type_name_VideoTemporalDenoisingControl, &_type_spec_VideoTemporalDenoisingControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::WhiteBalanceControl>::python_type = py::register_python_type(module, _type_name_WhiteBalanceControl, &_type_spec_WhiteBalanceControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::ZoomControl>::python_type = py::register_python_type(module, _type_name_ZoomControl, &_type_spec_ZoomControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::ZoomSettings>::python_type = py::register_python_type(module, _type_name_ZoomSettings, &_type_spec_ZoomSettings, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs>::python_type = py::register_python_type(module, _type_name_IDefaultAudioDeviceChangedEventArgs, &_type_spec_IDefaultAudioDeviceChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::IMediaDeviceController>::python_type = py::register_python_type(module, _type_name_IMediaDeviceController, &_type_spec_IMediaDeviceController, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Media.Devices");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Media_Devices",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Media::Devices

PyMODINIT_FUNC
PyInit__winrt_Windows_Media_Devices (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Media::Devices::module_def);
}
