// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.2.3.4

#include "pybase.h"
#include "py.Windows.Devices.Sms.h"

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsAppMessage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsBroadcastMessage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsDevice2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsFilterRule>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsFilterRules>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsMessageRegistration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsSendMessageResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsStatusMessage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsTextMessage2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsVoicemailMessage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsWapMessage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::ISmsMessageBase>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsEncodedLength>::python_type;

PyObject* py::converter<winrt::Windows::Devices::Sms::SmsEncodedLength>::convert(winrt::Windows::Devices::Sms::SmsEncodedLength instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Devices::Sms::SmsEncodedLength>());
}
winrt::Windows::Devices::Sms::SmsEncodedLength py::converter<winrt::Windows::Devices::Sms::SmsEncodedLength>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Devices::Sms::SmsEncodedLength>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Devices::Sms::SmsEncodedLength>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Devices::Sms::SmsEncodedLength return_value{};

    PyObject* py_SegmentCount = PyDict_GetItemString(obj, "segment_count");
    if (!py_SegmentCount) { throw winrt::hresult_invalid_argument(); }
    return_value.SegmentCount = converter<uint32_t>::convert_to(py_SegmentCount);

    PyObject* py_CharacterCountLastSegment = PyDict_GetItemString(obj, "character_count_last_segment");
    if (!py_CharacterCountLastSegment) { throw winrt::hresult_invalid_argument(); }
    return_value.CharacterCountLastSegment = converter<uint32_t>::convert_to(py_CharacterCountLastSegment);

    PyObject* py_CharactersPerSegment = PyDict_GetItemString(obj, "characters_per_segment");
    if (!py_CharactersPerSegment) { throw winrt::hresult_invalid_argument(); }
    return_value.CharactersPerSegment = converter<uint32_t>::convert_to(py_CharactersPerSegment);

    PyObject* py_ByteCountLastSegment = PyDict_GetItemString(obj, "byte_count_last_segment");
    if (!py_ByteCountLastSegment) { throw winrt::hresult_invalid_argument(); }
    return_value.ByteCountLastSegment = converter<uint32_t>::convert_to(py_ByteCountLastSegment);

    PyObject* py_BytesPerSegment = PyDict_GetItemString(obj, "bytes_per_segment");
    if (!py_BytesPerSegment) { throw winrt::hresult_invalid_argument(); }
    return_value.BytesPerSegment = converter<uint32_t>::convert_to(py_BytesPerSegment);

    return return_value;
}

namespace py::cpp::Windows::Devices::Sms
{
    // ----- SmsAppMessage class --------------------
    constexpr const char* const _type_name_SmsAppMessage = "SmsAppMessage";

    static PyObject* _new_SmsAppMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Sms::SmsAppMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsAppMessage(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsAppMessage_get_ProtocolId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtocolId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_ProtocolId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ProtocolId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_PortNumber(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PortNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_PortNumber(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.PortNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_IsDeliveryNotificationEnabled(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDeliveryNotificationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_IsDeliveryNotificationEnabled(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDeliveryNotificationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_RetryAttemptCount(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RetryAttemptCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_RetryAttemptCount(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.RetryAttemptCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_Encoding(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Encoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_Encoding(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsEncoding>(arg);

            self->obj.Encoding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_Body(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_Body(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Body(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_CallbackNumber(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CallbackNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_CallbackNumber(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CallbackNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_BinaryBody(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BinaryBody());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_BinaryBody(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.BinaryBody(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_To(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.To(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_TeleserviceId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TeleserviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_TeleserviceId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.TeleserviceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_From(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsAppMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsAppMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsAppMessage[] = {
        { "_from", (PyCFunction)_from_SmsAppMessage, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SmsAppMessage[] = {
        { const_cast<char*>("protocol_id"), (getter)SmsAppMessage_get_ProtocolId, (setter)SmsAppMessage_put_ProtocolId, nullptr, nullptr },
        { const_cast<char*>("port_number"), (getter)SmsAppMessage_get_PortNumber, (setter)SmsAppMessage_put_PortNumber, nullptr, nullptr },
        { const_cast<char*>("is_delivery_notification_enabled"), (getter)SmsAppMessage_get_IsDeliveryNotificationEnabled, (setter)SmsAppMessage_put_IsDeliveryNotificationEnabled, nullptr, nullptr },
        { const_cast<char*>("retry_attempt_count"), (getter)SmsAppMessage_get_RetryAttemptCount, (setter)SmsAppMessage_put_RetryAttemptCount, nullptr, nullptr },
        { const_cast<char*>("encoding"), (getter)SmsAppMessage_get_Encoding, (setter)SmsAppMessage_put_Encoding, nullptr, nullptr },
        { const_cast<char*>("body"), (getter)SmsAppMessage_get_Body, (setter)SmsAppMessage_put_Body, nullptr, nullptr },
        { const_cast<char*>("callback_number"), (getter)SmsAppMessage_get_CallbackNumber, (setter)SmsAppMessage_put_CallbackNumber, nullptr, nullptr },
        { const_cast<char*>("binary_body"), (getter)SmsAppMessage_get_BinaryBody, (setter)SmsAppMessage_put_BinaryBody, nullptr, nullptr },
        { const_cast<char*>("to"), (getter)SmsAppMessage_get_To, (setter)SmsAppMessage_put_To, nullptr, nullptr },
        { const_cast<char*>("teleservice_id"), (getter)SmsAppMessage_get_TeleserviceId, (setter)SmsAppMessage_put_TeleserviceId, nullptr, nullptr },
        { const_cast<char*>("from"), (getter)SmsAppMessage_get_From, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)SmsAppMessage_get_Timestamp, nullptr, nullptr, nullptr },
        { const_cast<char*>("cellular_class"), (getter)SmsAppMessage_get_CellularClass, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)SmsAppMessage_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("message_class"), (getter)SmsAppMessage_get_MessageClass, nullptr, nullptr, nullptr },
        { const_cast<char*>("message_type"), (getter)SmsAppMessage_get_MessageType, nullptr, nullptr, nullptr },
        { const_cast<char*>("sim_icc_id"), (getter)SmsAppMessage_get_SimIccId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SmsAppMessage[] = 
    {
        { Py_tp_new, _new_SmsAppMessage },
        { Py_tp_dealloc, _dealloc_SmsAppMessage },
        { Py_tp_methods, _methods_SmsAppMessage },
        { Py_tp_getset, _getset_SmsAppMessage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SmsAppMessage =
    {
        "_winrt_Windows_Devices_Sms.SmsAppMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsAppMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsAppMessage
    };

    // ----- SmsBroadcastMessage class --------------------
    constexpr const char* const _type_name_SmsBroadcastMessage = "SmsBroadcastMessage";

    static PyObject* _new_SmsBroadcastMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SmsBroadcastMessage);
        return nullptr;
    }

    static void _dealloc_SmsBroadcastMessage(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsBroadcastMessage_get_Body(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_BroadcastType(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BroadcastType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_Channel(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_GeographicalScope(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.GeographicalScope());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_IsEmergencyAlert(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEmergencyAlert());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_IsUserPopupRequested(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUserPopupRequested());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_MessageCode(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_UpdateNumber(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsBroadcastMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsBroadcastMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsBroadcastMessage[] = {
        { "_from", (PyCFunction)_from_SmsBroadcastMessage, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SmsBroadcastMessage[] = {
        { const_cast<char*>("body"), (getter)SmsBroadcastMessage_get_Body, nullptr, nullptr, nullptr },
        { const_cast<char*>("broadcast_type"), (getter)SmsBroadcastMessage_get_BroadcastType, nullptr, nullptr, nullptr },
        { const_cast<char*>("channel"), (getter)SmsBroadcastMessage_get_Channel, nullptr, nullptr, nullptr },
        { const_cast<char*>("geographical_scope"), (getter)SmsBroadcastMessage_get_GeographicalScope, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_emergency_alert"), (getter)SmsBroadcastMessage_get_IsEmergencyAlert, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_user_popup_requested"), (getter)SmsBroadcastMessage_get_IsUserPopupRequested, nullptr, nullptr, nullptr },
        { const_cast<char*>("message_code"), (getter)SmsBroadcastMessage_get_MessageCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)SmsBroadcastMessage_get_Timestamp, nullptr, nullptr, nullptr },
        { const_cast<char*>("to"), (getter)SmsBroadcastMessage_get_To, nullptr, nullptr, nullptr },
        { const_cast<char*>("update_number"), (getter)SmsBroadcastMessage_get_UpdateNumber, nullptr, nullptr, nullptr },
        { const_cast<char*>("cellular_class"), (getter)SmsBroadcastMessage_get_CellularClass, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)SmsBroadcastMessage_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("message_class"), (getter)SmsBroadcastMessage_get_MessageClass, nullptr, nullptr, nullptr },
        { const_cast<char*>("message_type"), (getter)SmsBroadcastMessage_get_MessageType, nullptr, nullptr, nullptr },
        { const_cast<char*>("sim_icc_id"), (getter)SmsBroadcastMessage_get_SimIccId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SmsBroadcastMessage[] = 
    {
        { Py_tp_new, _new_SmsBroadcastMessage },
        { Py_tp_dealloc, _dealloc_SmsBroadcastMessage },
        { Py_tp_methods, _methods_SmsBroadcastMessage },
        { Py_tp_getset, _getset_SmsBroadcastMessage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SmsBroadcastMessage =
    {
        "_winrt_Windows_Devices_Sms.SmsBroadcastMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsBroadcastMessage
    };

    // ----- SmsDevice2 class --------------------
    constexpr const char* const _type_name_SmsDevice2 = "SmsDevice2";

    static PyObject* _new_SmsDevice2(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SmsDevice2);
        return nullptr;
    }

    static void _dealloc_SmsDevice2(py::wrapper::Windows::Devices::Sms::SmsDevice2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsDevice2_CalculateLength(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::ISmsMessageBase>(args, 0);

                return py::convert(self->obj.CalculateLength(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sms::SmsDevice2::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_FromParentId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sms::SmsDevice2::FromParentId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sms::SmsDevice2::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sms::SmsDevice2::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_SendMessageAndGetResultAsync(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::ISmsMessageBase>(args, 0);

                return py::convert(self->obj.SendMessageAndGetResultAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_get_SmscAddress(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SmscAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsDevice2_put_SmscAddress(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SmscAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsDevice2_get_AccountPhoneNumber(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccountPhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_get_DeviceStatus(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_get_ParentDeviceId(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ParentDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_add_DeviceStatusChanged(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sms::SmsDevice2, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.DeviceStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_remove_DeviceStatusChanged(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DeviceStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsDevice2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsDevice2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsDevice2[] = {
        { "calculate_length", (PyCFunction)SmsDevice2_CalculateLength, METH_VARARGS, nullptr },
        { "from_id", (PyCFunction)SmsDevice2_FromId, METH_VARARGS | METH_STATIC, nullptr },
        { "from_parent_id", (PyCFunction)SmsDevice2_FromParentId, METH_VARARGS | METH_STATIC, nullptr },
        { "get_default", (PyCFunction)SmsDevice2_GetDefault, METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", (PyCFunction)SmsDevice2_GetDeviceSelector, METH_VARARGS | METH_STATIC, nullptr },
        { "send_message_and_get_result_async", (PyCFunction)SmsDevice2_SendMessageAndGetResultAsync, METH_VARARGS, nullptr },
        { "add_device_status_changed", (PyCFunction)SmsDevice2_add_DeviceStatusChanged, METH_O, nullptr },
        { "remove_device_status_changed", (PyCFunction)SmsDevice2_remove_DeviceStatusChanged, METH_O, nullptr },
        { "_from", (PyCFunction)_from_SmsDevice2, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SmsDevice2[] = {
        { const_cast<char*>("smsc_address"), (getter)SmsDevice2_get_SmscAddress, (setter)SmsDevice2_put_SmscAddress, nullptr, nullptr },
        { const_cast<char*>("account_phone_number"), (getter)SmsDevice2_get_AccountPhoneNumber, nullptr, nullptr, nullptr },
        { const_cast<char*>("cellular_class"), (getter)SmsDevice2_get_CellularClass, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)SmsDevice2_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_status"), (getter)SmsDevice2_get_DeviceStatus, nullptr, nullptr, nullptr },
        { const_cast<char*>("parent_device_id"), (getter)SmsDevice2_get_ParentDeviceId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SmsDevice2[] = 
    {
        { Py_tp_new, _new_SmsDevice2 },
        { Py_tp_dealloc, _dealloc_SmsDevice2 },
        { Py_tp_methods, _methods_SmsDevice2 },
        { Py_tp_getset, _getset_SmsDevice2 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SmsDevice2 =
    {
        "_winrt_Windows_Devices_Sms.SmsDevice2",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsDevice2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsDevice2
    };

    // ----- SmsFilterRule class --------------------
    constexpr const char* const _type_name_SmsFilterRule = "SmsFilterRule";

    static PyObject* _new_SmsFilterRule(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsMessageType>(args, 0);

                winrt::Windows::Devices::Sms::SmsFilterRule instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsFilterRule(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsFilterRule_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsFilterRule_put_CellularClass(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::CellularClass>(arg);

            self->obj.CellularClass(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsFilterRule_get_BroadcastChannels(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BroadcastChannels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_BroadcastTypes(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BroadcastTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_DeviceIds(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_ImsiPrefixes(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ImsiPrefixes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_PortNumbers(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PortNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_ProtocolIds(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtocolIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_SenderNumbers(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SenderNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_TeleserviceIds(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TeleserviceIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_TextMessagePrefixes(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TextMessagePrefixes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_WapApplicationIds(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WapApplicationIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_WapContentTypes(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WapContentTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsFilterRule(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsFilterRule>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsFilterRule[] = {
        { "_from", (PyCFunction)_from_SmsFilterRule, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SmsFilterRule[] = {
        { const_cast<char*>("cellular_class"), (getter)SmsFilterRule_get_CellularClass, (setter)SmsFilterRule_put_CellularClass, nullptr, nullptr },
        { const_cast<char*>("broadcast_channels"), (getter)SmsFilterRule_get_BroadcastChannels, nullptr, nullptr, nullptr },
        { const_cast<char*>("broadcast_types"), (getter)SmsFilterRule_get_BroadcastTypes, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_ids"), (getter)SmsFilterRule_get_DeviceIds, nullptr, nullptr, nullptr },
        { const_cast<char*>("imsi_prefixes"), (getter)SmsFilterRule_get_ImsiPrefixes, nullptr, nullptr, nullptr },
        { const_cast<char*>("message_type"), (getter)SmsFilterRule_get_MessageType, nullptr, nullptr, nullptr },
        { const_cast<char*>("port_numbers"), (getter)SmsFilterRule_get_PortNumbers, nullptr, nullptr, nullptr },
        { const_cast<char*>("protocol_ids"), (getter)SmsFilterRule_get_ProtocolIds, nullptr, nullptr, nullptr },
        { const_cast<char*>("sender_numbers"), (getter)SmsFilterRule_get_SenderNumbers, nullptr, nullptr, nullptr },
        { const_cast<char*>("teleservice_ids"), (getter)SmsFilterRule_get_TeleserviceIds, nullptr, nullptr, nullptr },
        { const_cast<char*>("text_message_prefixes"), (getter)SmsFilterRule_get_TextMessagePrefixes, nullptr, nullptr, nullptr },
        { const_cast<char*>("wap_application_ids"), (getter)SmsFilterRule_get_WapApplicationIds, nullptr, nullptr, nullptr },
        { const_cast<char*>("wap_content_types"), (getter)SmsFilterRule_get_WapContentTypes, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SmsFilterRule[] = 
    {
        { Py_tp_new, _new_SmsFilterRule },
        { Py_tp_dealloc, _dealloc_SmsFilterRule },
        { Py_tp_methods, _methods_SmsFilterRule },
        { Py_tp_getset, _getset_SmsFilterRule },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SmsFilterRule =
    {
        "_winrt_Windows_Devices_Sms.SmsFilterRule",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsFilterRule),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsFilterRule
    };

    // ----- SmsFilterRules class --------------------
    constexpr const char* const _type_name_SmsFilterRules = "SmsFilterRules";

    static PyObject* _new_SmsFilterRules(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsFilterActionType>(args, 0);

                winrt::Windows::Devices::Sms::SmsFilterRules instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsFilterRules(py::wrapper::Windows::Devices::Sms::SmsFilterRules* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsFilterRules_get_ActionType(py::wrapper::Windows::Devices::Sms::SmsFilterRules* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRules_get_Rules(py::wrapper::Windows::Devices::Sms::SmsFilterRules* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Rules());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsFilterRules(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsFilterRules>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsFilterRules[] = {
        { "_from", (PyCFunction)_from_SmsFilterRules, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SmsFilterRules[] = {
        { const_cast<char*>("action_type"), (getter)SmsFilterRules_get_ActionType, nullptr, nullptr, nullptr },
        { const_cast<char*>("rules"), (getter)SmsFilterRules_get_Rules, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SmsFilterRules[] = 
    {
        { Py_tp_new, _new_SmsFilterRules },
        { Py_tp_dealloc, _dealloc_SmsFilterRules },
        { Py_tp_methods, _methods_SmsFilterRules },
        { Py_tp_getset, _getset_SmsFilterRules },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SmsFilterRules =
    {
        "_winrt_Windows_Devices_Sms.SmsFilterRules",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsFilterRules),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsFilterRules
    };

    // ----- SmsMessageReceivedTriggerDetails class --------------------
    constexpr const char* const _type_name_SmsMessageReceivedTriggerDetails = "SmsMessageReceivedTriggerDetails";

    static PyObject* _new_SmsMessageReceivedTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SmsMessageReceivedTriggerDetails);
        return nullptr;
    }

    static void _dealloc_SmsMessageReceivedTriggerDetails(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsMessageReceivedTriggerDetails_Accept(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Accept();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_Drop(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Drop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_AppMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_BroadcastMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BroadcastMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_StatusMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StatusMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_TextMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TextMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_VoicemailMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VoicemailMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_WapMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WapMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsMessageReceivedTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsMessageReceivedTriggerDetails[] = {
        { "accept", (PyCFunction)SmsMessageReceivedTriggerDetails_Accept, METH_VARARGS, nullptr },
        { "drop", (PyCFunction)SmsMessageReceivedTriggerDetails_Drop, METH_VARARGS, nullptr },
        { "_from", (PyCFunction)_from_SmsMessageReceivedTriggerDetails, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SmsMessageReceivedTriggerDetails[] = {
        { const_cast<char*>("app_message"), (getter)SmsMessageReceivedTriggerDetails_get_AppMessage, nullptr, nullptr, nullptr },
        { const_cast<char*>("broadcast_message"), (getter)SmsMessageReceivedTriggerDetails_get_BroadcastMessage, nullptr, nullptr, nullptr },
        { const_cast<char*>("message_type"), (getter)SmsMessageReceivedTriggerDetails_get_MessageType, nullptr, nullptr, nullptr },
        { const_cast<char*>("status_message"), (getter)SmsMessageReceivedTriggerDetails_get_StatusMessage, nullptr, nullptr, nullptr },
        { const_cast<char*>("text_message"), (getter)SmsMessageReceivedTriggerDetails_get_TextMessage, nullptr, nullptr, nullptr },
        { const_cast<char*>("voicemail_message"), (getter)SmsMessageReceivedTriggerDetails_get_VoicemailMessage, nullptr, nullptr, nullptr },
        { const_cast<char*>("wap_message"), (getter)SmsMessageReceivedTriggerDetails_get_WapMessage, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SmsMessageReceivedTriggerDetails[] = 
    {
        { Py_tp_new, _new_SmsMessageReceivedTriggerDetails },
        { Py_tp_dealloc, _dealloc_SmsMessageReceivedTriggerDetails },
        { Py_tp_methods, _methods_SmsMessageReceivedTriggerDetails },
        { Py_tp_getset, _getset_SmsMessageReceivedTriggerDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SmsMessageReceivedTriggerDetails =
    {
        "_winrt_Windows_Devices_Sms.SmsMessageReceivedTriggerDetails",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsMessageReceivedTriggerDetails
    };

    // ----- SmsMessageRegistration class --------------------
    constexpr const char* const _type_name_SmsMessageRegistration = "SmsMessageRegistration";

    static PyObject* _new_SmsMessageRegistration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SmsMessageRegistration);
        return nullptr;
    }

    static void _dealloc_SmsMessageRegistration(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsMessageRegistration_Register(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Sms::SmsFilterRules>(args, 1);

                return py::convert(winrt::Windows::Devices::Sms::SmsMessageRegistration::Register(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsMessageRegistration_Unregister(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Unregister();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsMessageRegistration_get_Id(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageRegistration_get_AllRegistrations(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Sms::SmsMessageRegistration::AllRegistrations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageRegistration_add_MessageReceived(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sms::SmsMessageRegistration, winrt::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails>>(arg);

            return py::convert(self->obj.MessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageRegistration_remove_MessageReceived(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsMessageRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsMessageRegistration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsMessageRegistration[] = {
        { "register", (PyCFunction)SmsMessageRegistration_Register, METH_VARARGS | METH_STATIC, nullptr },
        { "unregister", (PyCFunction)SmsMessageRegistration_Unregister, METH_VARARGS, nullptr },
        { "get_all_registrations", (PyCFunction)SmsMessageRegistration_get_AllRegistrations, METH_NOARGS | METH_STATIC, nullptr },
        { "add_message_received", (PyCFunction)SmsMessageRegistration_add_MessageReceived, METH_O, nullptr },
        { "remove_message_received", (PyCFunction)SmsMessageRegistration_remove_MessageReceived, METH_O, nullptr },
        { "_from", (PyCFunction)_from_SmsMessageRegistration, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SmsMessageRegistration[] = {
        { const_cast<char*>("id"), (getter)SmsMessageRegistration_get_Id, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SmsMessageRegistration[] = 
    {
        { Py_tp_new, _new_SmsMessageRegistration },
        { Py_tp_dealloc, _dealloc_SmsMessageRegistration },
        { Py_tp_methods, _methods_SmsMessageRegistration },
        { Py_tp_getset, _getset_SmsMessageRegistration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SmsMessageRegistration =
    {
        "_winrt_Windows_Devices_Sms.SmsMessageRegistration",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsMessageRegistration
    };

    // ----- SmsSendMessageResult class --------------------
    constexpr const char* const _type_name_SmsSendMessageResult = "SmsSendMessageResult";

    static PyObject* _new_SmsSendMessageResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SmsSendMessageResult);
        return nullptr;
    }

    static void _dealloc_SmsSendMessageResult(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsSendMessageResult_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_IsErrorTransient(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsErrorTransient());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_IsSuccessful(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSuccessful());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_MessageReferenceNumbers(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageReferenceNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_ModemErrorCode(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ModemErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_NetworkCauseCode(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkCauseCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_TransportFailureCause(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportFailureCause());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsSendMessageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsSendMessageResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsSendMessageResult[] = {
        { "_from", (PyCFunction)_from_SmsSendMessageResult, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SmsSendMessageResult[] = {
        { const_cast<char*>("cellular_class"), (getter)SmsSendMessageResult_get_CellularClass, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_error_transient"), (getter)SmsSendMessageResult_get_IsErrorTransient, nullptr, nullptr, nullptr },
        { const_cast<char*>("is_successful"), (getter)SmsSendMessageResult_get_IsSuccessful, nullptr, nullptr, nullptr },
        { const_cast<char*>("message_reference_numbers"), (getter)SmsSendMessageResult_get_MessageReferenceNumbers, nullptr, nullptr, nullptr },
        { const_cast<char*>("modem_error_code"), (getter)SmsSendMessageResult_get_ModemErrorCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("network_cause_code"), (getter)SmsSendMessageResult_get_NetworkCauseCode, nullptr, nullptr, nullptr },
        { const_cast<char*>("transport_failure_cause"), (getter)SmsSendMessageResult_get_TransportFailureCause, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SmsSendMessageResult[] = 
    {
        { Py_tp_new, _new_SmsSendMessageResult },
        { Py_tp_dealloc, _dealloc_SmsSendMessageResult },
        { Py_tp_methods, _methods_SmsSendMessageResult },
        { Py_tp_getset, _getset_SmsSendMessageResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SmsSendMessageResult =
    {
        "_winrt_Windows_Devices_Sms.SmsSendMessageResult",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsSendMessageResult
    };

    // ----- SmsStatusMessage class --------------------
    constexpr const char* const _type_name_SmsStatusMessage = "SmsStatusMessage";

    static PyObject* _new_SmsStatusMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SmsStatusMessage);
        return nullptr;
    }

    static void _dealloc_SmsStatusMessage(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsStatusMessage_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_Status(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_Body(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_DischargeTime(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DischargeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_From(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_MessageReferenceNumber(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageReferenceNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_ServiceCenterTimestamp(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceCenterTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsStatusMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsStatusMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsStatusMessage[] = {
        { "_from", (PyCFunction)_from_SmsStatusMessage, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SmsStatusMessage[] = {
        { const_cast<char*>("cellular_class"), (getter)SmsStatusMessage_get_CellularClass, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)SmsStatusMessage_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("message_class"), (getter)SmsStatusMessage_get_MessageClass, nullptr, nullptr, nullptr },
        { const_cast<char*>("message_type"), (getter)SmsStatusMessage_get_MessageType, nullptr, nullptr, nullptr },
        { const_cast<char*>("sim_icc_id"), (getter)SmsStatusMessage_get_SimIccId, nullptr, nullptr, nullptr },
        { const_cast<char*>("status"), (getter)SmsStatusMessage_get_Status, nullptr, nullptr, nullptr },
        { const_cast<char*>("body"), (getter)SmsStatusMessage_get_Body, nullptr, nullptr, nullptr },
        { const_cast<char*>("discharge_time"), (getter)SmsStatusMessage_get_DischargeTime, nullptr, nullptr, nullptr },
        { const_cast<char*>("from"), (getter)SmsStatusMessage_get_From, nullptr, nullptr, nullptr },
        { const_cast<char*>("message_reference_number"), (getter)SmsStatusMessage_get_MessageReferenceNumber, nullptr, nullptr, nullptr },
        { const_cast<char*>("service_center_timestamp"), (getter)SmsStatusMessage_get_ServiceCenterTimestamp, nullptr, nullptr, nullptr },
        { const_cast<char*>("to"), (getter)SmsStatusMessage_get_To, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SmsStatusMessage[] = 
    {
        { Py_tp_new, _new_SmsStatusMessage },
        { Py_tp_dealloc, _dealloc_SmsStatusMessage },
        { Py_tp_methods, _methods_SmsStatusMessage },
        { Py_tp_getset, _getset_SmsStatusMessage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SmsStatusMessage =
    {
        "_winrt_Windows_Devices_Sms.SmsStatusMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsStatusMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsStatusMessage
    };

    // ----- SmsTextMessage2 class --------------------
    constexpr const char* const _type_name_SmsTextMessage2 = "SmsTextMessage2";

    static PyObject* _new_SmsTextMessage2(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Sms::SmsTextMessage2 instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsTextMessage2(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsTextMessage2_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_RetryAttemptCount(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RetryAttemptCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_RetryAttemptCount(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.RetryAttemptCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_To(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_To(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.To(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_IsDeliveryNotificationEnabled(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDeliveryNotificationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_IsDeliveryNotificationEnabled(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDeliveryNotificationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_Encoding(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Encoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_Encoding(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsEncoding>(arg);

            self->obj.Encoding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_CallbackNumber(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CallbackNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_CallbackNumber(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CallbackNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_Body(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_Body(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Body(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_ProtocolId(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtocolId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_From(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_TeleserviceId(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TeleserviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsTextMessage2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsTextMessage2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsTextMessage2[] = {
        { "_from", (PyCFunction)_from_SmsTextMessage2, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SmsTextMessage2[] = {
        { const_cast<char*>("message_type"), (getter)SmsTextMessage2_get_MessageType, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)SmsTextMessage2_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("cellular_class"), (getter)SmsTextMessage2_get_CellularClass, nullptr, nullptr, nullptr },
        { const_cast<char*>("message_class"), (getter)SmsTextMessage2_get_MessageClass, nullptr, nullptr, nullptr },
        { const_cast<char*>("sim_icc_id"), (getter)SmsTextMessage2_get_SimIccId, nullptr, nullptr, nullptr },
        { const_cast<char*>("retry_attempt_count"), (getter)SmsTextMessage2_get_RetryAttemptCount, (setter)SmsTextMessage2_put_RetryAttemptCount, nullptr, nullptr },
        { const_cast<char*>("to"), (getter)SmsTextMessage2_get_To, (setter)SmsTextMessage2_put_To, nullptr, nullptr },
        { const_cast<char*>("is_delivery_notification_enabled"), (getter)SmsTextMessage2_get_IsDeliveryNotificationEnabled, (setter)SmsTextMessage2_put_IsDeliveryNotificationEnabled, nullptr, nullptr },
        { const_cast<char*>("encoding"), (getter)SmsTextMessage2_get_Encoding, (setter)SmsTextMessage2_put_Encoding, nullptr, nullptr },
        { const_cast<char*>("callback_number"), (getter)SmsTextMessage2_get_CallbackNumber, (setter)SmsTextMessage2_put_CallbackNumber, nullptr, nullptr },
        { const_cast<char*>("body"), (getter)SmsTextMessage2_get_Body, (setter)SmsTextMessage2_put_Body, nullptr, nullptr },
        { const_cast<char*>("protocol_id"), (getter)SmsTextMessage2_get_ProtocolId, nullptr, nullptr, nullptr },
        { const_cast<char*>("from"), (getter)SmsTextMessage2_get_From, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)SmsTextMessage2_get_Timestamp, nullptr, nullptr, nullptr },
        { const_cast<char*>("teleservice_id"), (getter)SmsTextMessage2_get_TeleserviceId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SmsTextMessage2[] = 
    {
        { Py_tp_new, _new_SmsTextMessage2 },
        { Py_tp_dealloc, _dealloc_SmsTextMessage2 },
        { Py_tp_methods, _methods_SmsTextMessage2 },
        { Py_tp_getset, _getset_SmsTextMessage2 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SmsTextMessage2 =
    {
        "_winrt_Windows_Devices_Sms.SmsTextMessage2",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsTextMessage2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsTextMessage2
    };

    // ----- SmsVoicemailMessage class --------------------
    constexpr const char* const _type_name_SmsVoicemailMessage = "SmsVoicemailMessage";

    static PyObject* _new_SmsVoicemailMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SmsVoicemailMessage);
        return nullptr;
    }

    static void _dealloc_SmsVoicemailMessage(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsVoicemailMessage_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_Body(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_MessageCount(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsVoicemailMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsVoicemailMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsVoicemailMessage[] = {
        { "_from", (PyCFunction)_from_SmsVoicemailMessage, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SmsVoicemailMessage[] = {
        { const_cast<char*>("cellular_class"), (getter)SmsVoicemailMessage_get_CellularClass, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)SmsVoicemailMessage_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("message_class"), (getter)SmsVoicemailMessage_get_MessageClass, nullptr, nullptr, nullptr },
        { const_cast<char*>("message_type"), (getter)SmsVoicemailMessage_get_MessageType, nullptr, nullptr, nullptr },
        { const_cast<char*>("sim_icc_id"), (getter)SmsVoicemailMessage_get_SimIccId, nullptr, nullptr, nullptr },
        { const_cast<char*>("body"), (getter)SmsVoicemailMessage_get_Body, nullptr, nullptr, nullptr },
        { const_cast<char*>("message_count"), (getter)SmsVoicemailMessage_get_MessageCount, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)SmsVoicemailMessage_get_Timestamp, nullptr, nullptr, nullptr },
        { const_cast<char*>("to"), (getter)SmsVoicemailMessage_get_To, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SmsVoicemailMessage[] = 
    {
        { Py_tp_new, _new_SmsVoicemailMessage },
        { Py_tp_dealloc, _dealloc_SmsVoicemailMessage },
        { Py_tp_methods, _methods_SmsVoicemailMessage },
        { Py_tp_getset, _getset_SmsVoicemailMessage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SmsVoicemailMessage =
    {
        "_winrt_Windows_Devices_Sms.SmsVoicemailMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsVoicemailMessage
    };

    // ----- SmsWapMessage class --------------------
    constexpr const char* const _type_name_SmsWapMessage = "SmsWapMessage";

    static PyObject* _new_SmsWapMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SmsWapMessage);
        return nullptr;
    }

    static void _dealloc_SmsWapMessage(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsWapMessage_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_ApplicationId(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ApplicationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_BinaryBody(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BinaryBody());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_ContentType(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_From(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_Headers(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsWapMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsWapMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsWapMessage[] = {
        { "_from", (PyCFunction)_from_SmsWapMessage, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_SmsWapMessage[] = {
        { const_cast<char*>("cellular_class"), (getter)SmsWapMessage_get_CellularClass, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)SmsWapMessage_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("message_class"), (getter)SmsWapMessage_get_MessageClass, nullptr, nullptr, nullptr },
        { const_cast<char*>("message_type"), (getter)SmsWapMessage_get_MessageType, nullptr, nullptr, nullptr },
        { const_cast<char*>("sim_icc_id"), (getter)SmsWapMessage_get_SimIccId, nullptr, nullptr, nullptr },
        { const_cast<char*>("timestamp"), (getter)SmsWapMessage_get_Timestamp, nullptr, nullptr, nullptr },
        { const_cast<char*>("application_id"), (getter)SmsWapMessage_get_ApplicationId, nullptr, nullptr, nullptr },
        { const_cast<char*>("binary_body"), (getter)SmsWapMessage_get_BinaryBody, nullptr, nullptr, nullptr },
        { const_cast<char*>("content_type"), (getter)SmsWapMessage_get_ContentType, nullptr, nullptr, nullptr },
        { const_cast<char*>("from"), (getter)SmsWapMessage_get_From, nullptr, nullptr, nullptr },
        { const_cast<char*>("headers"), (getter)SmsWapMessage_get_Headers, nullptr, nullptr, nullptr },
        { const_cast<char*>("to"), (getter)SmsWapMessage_get_To, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SmsWapMessage[] = 
    {
        { Py_tp_new, _new_SmsWapMessage },
        { Py_tp_dealloc, _dealloc_SmsWapMessage },
        { Py_tp_methods, _methods_SmsWapMessage },
        { Py_tp_getset, _getset_SmsWapMessage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SmsWapMessage =
    {
        "_winrt_Windows_Devices_Sms.SmsWapMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsWapMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsWapMessage
    };

    // ----- ISmsMessageBase interface --------------------
    constexpr const char* const _type_name_ISmsMessageBase = "ISmsMessageBase";

    static PyObject* _new_ISmsMessageBase(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ISmsMessageBase);
        return nullptr;
    }

    static void _dealloc_ISmsMessageBase(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ISmsMessageBase_get_CellularClass(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsMessageBase_get_DeviceId(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsMessageBase_get_MessageClass(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsMessageBase_get_MessageType(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsMessageBase_get_SimIccId(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ISmsMessageBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::ISmsMessageBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISmsMessageBase[] = {
        { "_from", (PyCFunction)_from_ISmsMessageBase, METH_O | METH_STATIC, nullptr },
        { nullptr }
    };

    static PyGetSetDef _getset_ISmsMessageBase[] = {
        { const_cast<char*>("cellular_class"), (getter)ISmsMessageBase_get_CellularClass, nullptr, nullptr, nullptr },
        { const_cast<char*>("device_id"), (getter)ISmsMessageBase_get_DeviceId, nullptr, nullptr, nullptr },
        { const_cast<char*>("message_class"), (getter)ISmsMessageBase_get_MessageClass, nullptr, nullptr, nullptr },
        { const_cast<char*>("message_type"), (getter)ISmsMessageBase_get_MessageType, nullptr, nullptr, nullptr },
        { const_cast<char*>("sim_icc_id"), (getter)ISmsMessageBase_get_SimIccId, nullptr, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_ISmsMessageBase[] = 
    {
        { Py_tp_new, _new_ISmsMessageBase },
        { Py_tp_dealloc, _dealloc_ISmsMessageBase },
        { Py_tp_methods, _methods_ISmsMessageBase },
        { Py_tp_getset, _getset_ISmsMessageBase },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ISmsMessageBase =
    {
        "_winrt_Windows_Devices_Sms.ISmsMessageBase",
        sizeof(py::wrapper::Windows::Devices::Sms::ISmsMessageBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISmsMessageBase
    };

    // ----- SmsEncodedLength struct --------------------
    constexpr const char* const _type_name_SmsEncodedLength = "SmsEncodedLength";

    PyObject* _new_SmsEncodedLength(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Devices::Sms::SmsEncodedLength return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Devices::Sms::SmsEncodedLength>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint32_t _SegmentCount{};
        uint32_t _CharacterCountLastSegment{};
        uint32_t _CharactersPerSegment{};
        uint32_t _ByteCountLastSegment{};
        uint32_t _BytesPerSegment{};

        static const char* kwlist[] = {"segment_count", "character_count_last_segment", "characters_per_segment", "byte_count_last_segment", "bytes_per_segment", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIIII", const_cast<char**>(kwlist), &_SegmentCount, &_CharacterCountLastSegment, &_CharactersPerSegment, &_ByteCountLastSegment, &_BytesPerSegment))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Devices::Sms::SmsEncodedLength return_value{ _SegmentCount, _CharacterCountLastSegment, _CharactersPerSegment, _ByteCountLastSegment, _BytesPerSegment };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_SmsEncodedLength(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self)
    {
    }

    static PyObject* SmsEncodedLength_get_SegmentCount(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SegmentCount);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsEncodedLength_set_SegmentCount(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.SegmentCount = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsEncodedLength_get_CharacterCountLastSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharacterCountLastSegment);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsEncodedLength_set_CharacterCountLastSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.CharacterCountLastSegment = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsEncodedLength_get_CharactersPerSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharactersPerSegment);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsEncodedLength_set_CharactersPerSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.CharactersPerSegment = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsEncodedLength_get_ByteCountLastSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ByteCountLastSegment);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsEncodedLength_set_ByteCountLastSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.ByteCountLastSegment = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsEncodedLength_get_BytesPerSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesPerSegment);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsEncodedLength_set_BytesPerSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.BytesPerSegment = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_SmsEncodedLength[] = {
        { const_cast<char*>("segment_count"), (getter)SmsEncodedLength_get_SegmentCount, (setter)SmsEncodedLength_set_SegmentCount, nullptr, nullptr },
        { const_cast<char*>("character_count_last_segment"), (getter)SmsEncodedLength_get_CharacterCountLastSegment, (setter)SmsEncodedLength_set_CharacterCountLastSegment, nullptr, nullptr },
        { const_cast<char*>("characters_per_segment"), (getter)SmsEncodedLength_get_CharactersPerSegment, (setter)SmsEncodedLength_set_CharactersPerSegment, nullptr, nullptr },
        { const_cast<char*>("byte_count_last_segment"), (getter)SmsEncodedLength_get_ByteCountLastSegment, (setter)SmsEncodedLength_set_ByteCountLastSegment, nullptr, nullptr },
        { const_cast<char*>("bytes_per_segment"), (getter)SmsEncodedLength_get_BytesPerSegment, (setter)SmsEncodedLength_set_BytesPerSegment, nullptr, nullptr },
        { nullptr }
    };

    static PyType_Slot _type_slots_SmsEncodedLength[] = 
    {
        { Py_tp_new, _new_SmsEncodedLength },
        { Py_tp_dealloc, _dealloc_SmsEncodedLength },
        { Py_tp_getset, _getset_SmsEncodedLength },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SmsEncodedLength =
    {
        "_winrt_Windows_Devices_Sms.SmsEncodedLength",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsEncodedLength),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsEncodedLength
    };

    // ----- Windows.Devices.Sms Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };

            py::winrt_type<winrt::Windows::Devices::Sms::SmsAppMessage>::python_type = py::register_python_type(module, _type_name_SmsAppMessage, &_type_spec_SmsAppMessage, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsBroadcastMessage>::python_type = py::register_python_type(module, _type_name_SmsBroadcastMessage, &_type_spec_SmsBroadcastMessage, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsDevice2>::python_type = py::register_python_type(module, _type_name_SmsDevice2, &_type_spec_SmsDevice2, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsFilterRule>::python_type = py::register_python_type(module, _type_name_SmsFilterRule, &_type_spec_SmsFilterRule, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsFilterRules>::python_type = py::register_python_type(module, _type_name_SmsFilterRules, &_type_spec_SmsFilterRules, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails>::python_type = py::register_python_type(module, _type_name_SmsMessageReceivedTriggerDetails, &_type_spec_SmsMessageReceivedTriggerDetails, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsMessageRegistration>::python_type = py::register_python_type(module, _type_name_SmsMessageRegistration, &_type_spec_SmsMessageRegistration, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsSendMessageResult>::python_type = py::register_python_type(module, _type_name_SmsSendMessageResult, &_type_spec_SmsSendMessageResult, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsStatusMessage>::python_type = py::register_python_type(module, _type_name_SmsStatusMessage, &_type_spec_SmsStatusMessage, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsTextMessage2>::python_type = py::register_python_type(module, _type_name_SmsTextMessage2, &_type_spec_SmsTextMessage2, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsVoicemailMessage>::python_type = py::register_python_type(module, _type_name_SmsVoicemailMessage, &_type_spec_SmsVoicemailMessage, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsWapMessage>::python_type = py::register_python_type(module, _type_name_SmsWapMessage, &_type_spec_SmsWapMessage, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::ISmsMessageBase>::python_type = py::register_python_type(module, _type_name_ISmsMessageBase, &_type_spec_ISmsMessageBase, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsEncodedLength>::python_type = py::register_python_type(module, _type_name_SmsEncodedLength, &_type_spec_SmsEncodedLength, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {
        {Py_mod_exec, module_exec},
        {0, nullptr}
    };

    PyDoc_STRVAR(module_doc, "Windows.Devices.Sms");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_Windows_Devices_Sms",
        module_doc,
        0,
        nullptr,
        module_slots,
        nullptr,
        nullptr,
        nullptr
    };
} // py::cpp::Windows::Devices::Sms

PyMODINIT_FUNC
PyInit__winrt_Windows_Devices_Sms (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Devices::Sms::module_def);
}
